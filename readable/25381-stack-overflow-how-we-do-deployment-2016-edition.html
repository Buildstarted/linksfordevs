<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Stack Overflow: How We Do Deployment - 2016 Edition -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }
    </style>
</head>
<body>
    <div class="grid">
            <h1>Stack Overflow: How We Do Deployment - 2016 Edition</h1>
        
<div class="readable"><article class="post-content"> <blockquote> <p>This is #3 in a <a href="/blog/2016/02/03/stack-overflow-a-technical-deconstruction/">very long series of posts</a> on Stack Overflow&#x2019;s architecture.<br>
Previous post (#2): <a href="/blog/2016/03/29/stack-overflow-the-hardware-2016-edition/">Stack Overflow: The Hardware - 2016 Edition</a></p>
</blockquote> <p>We&#x2019;ve talked about <a href="/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/">Stack Overflow&#x2019;s architecture</a> and <a href="/blog/2016/03/29/stack-overflow-the-hardware-2016-edition/">the hardware behind it</a>. The next <a href="https://trello.com/b/0zgQjktX/blog-post-queue-for-stack-overflow-topics">most requested topic</a> was Deployment. How do we get code a developer (or some random stranger) writes into production? Let&#x2019;s break it down. Keep in mind that we&#x2019;re talking about deploying Stack Overflow for the example, but most of our projects follow almost an identical pattern to deploy a website or a service.</p> <p>I&#x2019;m going ahead and inserting a set of section links here because this post got a bit long with all of the bits that need an explanation:
</p> <h3 id="source">Source</h3>
<p>This is our starting point for this article. We have the Stack Overflow repository on a developer&#x2019;s machine. For the sake of discussing the process, let&#x2019;s say they added a column to a database table and the corresponding property to the C# object &#x2014; that way we can dig into how database migrations work along the way.</p> <h3 id="a-little-context">A Little Context</h3>
<p>We deploy roughly 25 times per day to development (our CI build) just for Stack Overflow Q&amp;A. Other projects also push many times. We deploy to production about 5-10 times on a typical day. A deploy from first push to full deploy is under 9 minutes (2:15 for dev, 2:40 for meta, and 3:20 for all sites). We have roughly 15 people pushing to the repository used in this post. The repo contains the code for these applications: <a href="https://stackoverflow.com/">Stack Overflow</a> (every single Q&amp;A site), <a href="https://stackexchange.com/">stackexchange.com</a> (root domain only), <a href="https://stacksnippets.net/">Stack Snippets</a> (for Stack Overflow JavaScript snippets), <a href="https://stackauth.com/">Stack Auth</a> (for OAuth), <a href="https://sstatic.net/">sstatic.net</a> (cookieless CDN domain), <a href="https://api.stackexchange.com/">Stack Exchange API v2</a>, <a href="https://mobile.stackexchange.com/">Stack Exchange Mobile</a> (iOS and Android API), Stack Server (Tag Engine and Elasticsearch indexing Windows service), and Socket Server (our WebSocket Windows service).</p> <h3 id="the-human-steps">The Human Steps</h3>
<p>When we&#x2019;re coding, if a database migration is involved then we have some extra steps. First, we check the chatroom (and confirm in the local repo) which SQL migration number is available next (we&#x2019;ll get to how this works). Each project with a database has their own migration folder and number. For this deploy, we&#x2019;re talking about the Q&amp;A migrations folder, which applies to all Q&amp;A databases. Here&#x2019;s what chat and the local repo look like before we get started:</p> <p><img src="/blog/content/SO-Deployment-Stars.png" alt="Chat Stars"></p> <p>And here&#x2019;s the local <code class="highlighter-rouge">%Repo%\StackOverflow.Migrations\</code> folder:
<img src="/blog/content/SO-Deployment-Migrations.png" alt="StackOverflow.Migrations"></p> <p>You can see both in chat and locally that 726 was the last migration number taken. So we&#x2019;ll issue a &#x201C;taking 727 - Putting JSON in SQL to see who it offends&#x201D; message in chat. This will claim the next migration so that we don&#x2019;t collide with someone else also doing a migration. We just type a chat message, a bot pins it. Fun fact: it also pins when I say &#x201C;taking web 2 offline&#x201D;, but we think it&#x2019;s funny and refuse to fix it. Here&#x2019;s our little Pinbot trolling:</p> <p><img src="/blog/content/SO-Deployment-Pinbot.png" alt="Oh Pinbot"></p> <p>Now let&#x2019;s add some code &#x2014; we&#x2019;ll keep it simple here:</p> <p>A <code class="highlighter-rouge">\StackOverflow\Models\User.cs</code> diff:</p> <figure class="highlight"> <pre><code class="language-diff"><span class="gi">+ public string PreferencesJson { get; set; }</span></code></pre>
</figure> <p>And our new <code class="highlighter-rouge">\StackOverflow.Migrations\727 - Putting JSON in SQL to see who it offends.sql</code>:</p> <figure class="highlight"> <pre><code class="language-sql"><span class="n">If</span> <span class="n">dbo</span><span class="p">.</span><span class="n">fnColumnExists</span><span class="p">(</span><span class="s1">&apos;Users&apos;</span><span class="p">,</span> <span class="s1">&apos;PreferencesJson&apos;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">Begin</span> <span class="k">Alter</span> <span class="k">Table</span> <span class="n">Users</span> <span class="k">Add</span> <span class="n">PreferencesJson</span> <span class="n">nvarchar</span><span class="p">(</span><span class="k">max</span><span class="p">);</span>
<span class="k">End</span></code></pre>
</figure> <p>We&#x2019;ve tested the migration works by running it against our local Q&amp;A database of choice in SSMS and that the code on top of it works. Before deploying though, we need to make sure it runs <em>as a migration</em>. For example, sometimes you may forget to put a <a href="https://msdn.microsoft.com/en-us/library/ms188037.aspx">GO</a> separating something that must be the first or only operation in a batch such as creating a view. So, we test it in the runner. To do this, we run the <code class="highlighter-rouge">migrate.local.bat</code> you see in the screenshot above. The contents are simple:</p> <figure class="highlight"> <pre><code class="language-bat">..\Build\Migrator-Fast --tier=local 
  --sites=&quot;Data Source=.;Initial Catalog=Sites.Database;Integrated Security=True&quot; %*
PAUSE</code></pre>
</figure> <p>Note: the migrator is a project, but we simply drop the .exe in the solutions using it, since that&#x2019;s the simplest and most portable thing that works.</p> <p>What does this migrator do? It hits our local copy of the <code class="highlighter-rouge">Sites</code> database. It contains a list of all the Q&amp;A sites that developer runs locally and the migrator uses that list to connect and run all migrations against all databases, in Parallel. Here&#x2019;s what a run looks like on a simple install with a single Q&amp;A database:</p> <p><img src="/blog/content/SO-Deployment-Migration-Log.png" alt="Migration Log"></p> <p>So far, so good. We have code and a migration that works and code that does&#x2026;some stuff (which isn&#x2019;t relevant to this process). Now it&#x2019;s time to take our little code baby and send it out into the world. It&#x2019;s time to fly little code, be <a href="https://youtu.be/LnlFDduJV8E?t=48s">freeeeee</a>! Okay now that we&#x2019;re excited, the typical process is:</p> <figure class="highlight"> <pre><code class="language-cmd">git add &lt;files&gt; (usually --all for small commits)
git commit -m &quot;Migration 727: Putting JSON in SQL to see who it offends&quot;
git pull --rebase
git push</code></pre>
</figure> <p>Note: we first check our team chatroom to see if anyone is in the middle of a deploy. Since our deployments are pretty quick, the chances of this aren&#x2019;t <em>that</em> big. But, given how often we deploy, collisions can and do happen. Then we yell at the designer responsible.
</p> <p>With respect to the Git commands above: if a command line works for you, use it. If a GUI works for you, use it. Use the best tooling for you and don&#x2019;t give a damn what anyone else thinks. The entire point of tooling from an ancient hammer to a modern Git install is to save time and effort of the user. Use whatever saves <em>you</em> the most time and effort. Unless it&#x2019;s Emacs, then consult a doctor immediately.</p> <h3 id="branches">Branches</h3>
<p>I didn&#x2019;t cover branches above because compared to many teams, we very rarely use them. Most commits are on <code class="highlighter-rouge">master</code>. Generally, we branch for only one of a few reasons:</p> <ul> <li>A developer is new, and early on we want code reviews</li> <li>A developer is working on a big (or risky) feature and wants a one-off code review</li> <li>Several developers are working on a big feature</li>
</ul> <p>Other than the (generally rare) cases above, almost all commits are directly to <code class="highlighter-rouge">master</code> and deployed soon after. We don&#x2019;t like a big build queue. This encourages us to make small to medium size commits often and deploy often. It&#x2019;s just how we choose to operate. I&#x2019;m not recommending it for most teams or any teams for that matter. <em>Do what works for you</em>. This is simply what works for us.</p> <p>When we do branch, merging back in is always a topic people are interested in. In the vast majority of cases, we&#x2019;ll squash when merging into master so that rolling back the changes is straightforward. We also keep the original branch around a few days (for anything major) to ensure we don&#x2019;t need to reference what that <em>specific</em> change was about. That being said, we&#x2019;re practical. If a squash presents a ton of developer time investment, then we just eat the merge history and go on with our lives.</p> <h3 id="git-on-premises">Git On-Premises</h3>
<p>Alright, so our code is sent to the server-side repo. Which repo? We&#x2019;re currently using <a href="https://about.gitlab.com/">Gitlab</a> for repositories. It&#x2019;s pretty much <a href="https://github.com/">GitHub</a>, hosted on-prem. If Gitlab pricing keeps getting crazier (note: I said &#x201C;crazier&#x201D;, not &#x201C;more expensive&#x201D;), we&#x2019;ll certainly re-evaluate <a href="https://enterprise.github.com/home">GitHub Enterprise</a> again.</p> <p>Why on-prem for Git hosting? For the sake of argument, let&#x2019;s say we used GitHub instead (we did evaluate this option). What&#x2019;s the difference? First, builds are slower. While GitHub&#x2019;s protocol implementation of Git is much faster, latency and bandwidth making the builds slower than pulling over 2x10Gb locally. But to be fair, GitHub is far faster than Gitlab at <em>most</em> operations (especially search and viewing large diffs).</p> <p>However, depending on GitHub (or any offsite third party) has a few critical downsides for us. The main downside is the dependency chain. We aren&#x2019;t just relying on GitHub servers to be online (their uptime is pretty good). We&#x2019;re relying on them to be online <em>and being able to get to them</em>. For that matter, we&#x2019;re also relying on all of our remote developers to be able to push code in the first place. That&#x2019;s a lot of switching, routing, fiber, and DDoS surface area in-between us and the bare essentials needed to build: <strong>code</strong>. We can drastically shorten that dependency chain by being on a local server. It also alleviates <em>most</em> security concerns we have with any sensitive code being on a third-party server. We have no inside knowledge of any GitHub security issues or anything like that, we&#x2019;re just extra careful with such things. Quite simply: if something doesn&#x2019;t need to leave your network, the best security involves it not leaving your network.</p> <p>All of that being said, our open source projects <a href="https://github.com/StackExchange/">are hosted on GitHub</a> and it works great. The critical ones are also mirrored internally on Gitlab for the same reasons as above. We have no issues with GitHub (they&#x2019;re awesome), only the dependency chain. For those unaware, even this website <a href="https://github.com/NickCraver/nickcraver.github.com">is running on GitHub pages</a>&#x2026;so if you see a typo in this post, <a href="https://github.com/NickCraver/nickcraver.github.com/pulls">submit a PR</a>.</p> <h3 id="the-build-system">The Build System</h3>
<p>Once the code is in the repo, the <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> build takes over. This is just a fancy term for a build kicked off by a commit. For builds, we use <a href="https://www.jetbrains.com/teamcity/">TeamCity</a>. The TeamCity server is actually on the same VM as Gitlab since neither is useful without the other and it makes TeamCity&#x2019;s polling for changes a fast and cheap operation. Fun fact: since Linux has no built-in DNS caching, most of the DNS queries are looking for&#x2026;itself. Oh wait, that&#x2019;s not a fun fact &#x2014; it&#x2019;s actually a pain in the ass.</p> <p>As you may have heard, we like to keep things really simple. We have extra compute capacity on our web tier, so&#x2026;we use it. Builds for all of the websites run on agents right on the web tier itself, this means we have 11 build agents local to each data center. There are a few additional Windows and Linux build agents (for puppet, rpms, and internal applications) on other VMs, but they&#x2019;re not relevant to this deploy process.</p> <p>Like most CI builds, we simply poll the Git repo on an interval to see if there are changes. This repo is heavy hit, so we poll for changes every 15 seconds. We don&#x2019;t like waiting. Waiting sucks. Once a change is detected, the build server instructs an agent to run a build.</p> <p>Since our repos are large (we include dependencies like NuGet packages, though <a href="https://github.com/NuGet/NuGetGallery/issues/3004">this is changing</a>), we use what TeamCity calls <a href="https://confluence.jetbrains.com/display/TCD9/VCS+Checkout+Mode">agent-side checkout</a>. This means the agent does the actual fetching of content directly from the repository, rather than the default of the web server doing the checkout and sending all of the source to the agent. On top of this, we&#x2019;re using <a href="https://confluence.jetbrains.com/display/TCD9/Git#Git-AgentSettings">Git mirrors</a>. Mirrors maintain a full repository (one per repo) on the agent. This means the very first time the agent builds a given repository, it&#x2019;s a full <code class="highlighter-rouge">git clone</code>. However, every time <em>after</em> that it&#x2019;s just a <code class="highlighter-rouge">git pull</code>. Without this optimization, we&#x2019;re talking about a <code class="highlighter-rouge">git clone --depth 1</code>, which grabs the current file state and no history &#x2014; just what we need for a build. With the very small delta we&#x2019;ve pushed above (like most commits) a <code class="highlighter-rouge">git pull</code> of <em>only</em> that delta will always beat the pants off grabbing all of files across the network. That first-build cost is a no-brainer tradeoff.</p> <p>As I said earlier, there are many projects in this repo (all connected), so we&#x2019;re really talking about several builds running each commit (5 total):</p> <p><img src="/blog/content/SO-Deployment-Dev-Builds.png" alt="Dev Builds"></p> <h3 id="whats-in-the-build">What&#x2019;s In The Build?</h3>
<p>Okay&#x2026;what&#x2019;s that build actually doing? Let&#x2019;s take a top level look and break it down. Here are the 9 build steps in our development/CI build:</p> <p><img src="/blog/content/SO-Deployment-Dev-Build-Steps.png" alt="Dev Build Steps"></p> <p>And here&#x2019;s what the log of the build we triggered above looks like (<a href="https://gist.github.com/NickCraver/d22d285e35ea6816bc4efe8e81ff152c#file-teamcity-dev-build-log-txt">you can see the full version in a gist here</a>):</p> <p><img src="/blog/content/SO-Deployment-Dev-Build-Log.png" alt="Dev Build Log"></p> <h4 id="steps-1--2-migrations">Steps 1 &amp; 2: Migrations</h4>
<p>The first 2 steps are migrations. In development, we automatically migrate the &#x201C;Sites&#x201D; database. This database is our central store that contains the master list of sites and other network-level items like the inbox. This same migration isn&#x2019;t automatic in production since &#x201C;should this run be before or after code is deployed?&#x201D; is a 50/50 question. The second step is what we ran locally, just against dev. In dev, it&#x2019;s acceptable to be down for a second, but that still shouldn&#x2019;t happen. In the Meta build, we migrate <strong>all</strong> production databases. This means Stack Overflow&#x2019;s database gets new SQL bits <em>minutes</em> before code. We order deploys appropriately.</p> <p>The important part here is <strong>databases are always migrated before code is deployed</strong>. Database migrations are a topic all in themselves and something people have expressed interest in, so I detail them a bit more <a href="#database-migrations">a little later in this post</a>.</p> <h4 id="step-3-finding-moonspeak-translation">Step 3: Finding Moonspeak (Translation)</h4>
<p>Due to the structure and limitations of the build process, we have to locate our Moonspeak tooling since we don&#x2019;t know the location for sure (it changes with each version due to the version being in the path). Okay, what&#x2019;s Moonspeak? Moonspeak is the <a href="https://meta.stackexchange.com/a/25529/135201">codename</a> for our localization tooling. Don&#x2019;t worry, <a href="https://trello.com/c/GdywwBgb/24-localization-moonspeak-translations">we&#x2019;ll cover it in-depth later</a>. The step itself is simple:</p> <figure class="highlight"> <pre><code class="language-powershell"><span class="nb">echo</span> <span class="s2">&quot;##teamcity[setParameter name=&apos;system.moonspeaktools&apos; value=&apos;</span><span class="k">$((</span><span class="nb">get-childitem</span> <span class="o">-</span>directory packages/StackExchange.MoonSpeak.2<span class="o">*)</span>.FullName<span class="o">)</span>\tools<span class="s1">&apos;]&quot;</span></code></pre>
</figure> <p>It&#x2019;s just grabbing a directory path and setting the <code class="highlighter-rouge">system.moonspeaktools</code> TeamCity variable to the result. If you&#x2019;re curious about all of the various ways to interact with TeamCity&#x2019;s build, <a href="https://confluence.jetbrains.com/display/TCD9/Build+Script+Interaction+with+TeamCity">there&#x2019;s an article here</a>.</p> <h4 id="step-4-translation-dump-javascript-edition">Step 4: Translation Dump (JavaScript Edition)</h4>
<p>In dev specifically, we run the dump of all of our need-to-be-translated strings in JavaScript for localization. Again the command is pretty simple:</p> <figure class="highlight"> <pre><code class="language-cmd">%system.moonspeaktools%\Jerome.exe extract 
  %system.translationsDumpPath%\artifact-%build.number%-js.{0}.txt en;pt-br;mn-mn;ja;es;ru
  &quot;.\StackOverflow\Content\Js\*.js;.\StackOverflow\Content\Js\PartialJS\**\*.js&quot;</code></pre>
</figure> <p>Phew, that was easy. I don&#x2019;t know why everyone hates localization. Just kidding, localization sucks here too. Now I don&#x2019;t want to dive too far into localization because that&#x2019;s a whole (very long) post on its own, but here are the translation basics:</p> <p>Strings are surrounded by <code class="highlighter-rouge">_s()</code> (regular string) or <code class="highlighter-rouge">_m()</code> (markdown) in code. We love <code class="highlighter-rouge">_s()</code> and <code class="highlighter-rouge">_m()</code>. It&#x2019;s almost identical for both JavaScript and C#. During the build, we extract these strings by analyzing the JavaScript (with <a href="https://www.nuget.org/packages/AjaxMin/">AjaxMin</a>) and C#/Razor (with a custom <a href="https://github.com/dotnet/roslyn">Roslyn</a>-based build). We take these strings and stick them in files to use for the translators, our community team, and ultimately back into the build later. There&#x2019;s obviously <em>way</em> more going on - but those are the relevant bits. It&#x2019;s worth noting here that we&#x2019;re excited about the proposed <a href="https://github.com/dotnet/roslyn/blob/features/source-generators/docs/features/generators.md">Source Generators</a> feature specced for a future Roslyn release. We hope in its final form we&#x2019;ll be able to re-write this portion of Moonspeak as a much simpler generator while still avoiding as many runtime allocations as possible.</p> <h4 id="step-5-msbuild">Step 5: MSBuild</h4>
<p>This is where most of the magic happens. It&#x2019;s a single step, but behind the scenes, we&#x2019;re doing unspeakable things to MSBuild that I&#x2019;m going to&#x2026;speak about, I guess. The full <code class="highlighter-rouge">.msbuild</code> file <a href="https://gist.github.com/NickCraver/b59ff38567b32936e2a3440e439d5d5c#file-build-msbuild">is in the earlier Gist</a>. The most relevant section is the description of crazy:</p> <figure class="highlight"> <pre><code class="language-md">THIS IS HOW WE ROLL: CompileWeb - ReplaceConfigs - - - - - - BuildViews - - - - - - - - - - - - - PrepareStaticContent <span class="se">\ </span>                                                           /|  
                    &apos;- BundleJavaScript - TranslateJsContent - CompileNode   - &apos;  
NOTE:  
since msbuild requires separate projects for parallel execution of targets, this build file is copied
2 times, the DefaultTargets of each copy is set to one of BuildViews, CompileNode or CompressJSContent. 
thus the absence of the DependesOnTarget=&quot;ReplaceConfigs&quot; on those _call_ targets</code></pre>
</figure> <p>While we maintain 1 copy of the file in the repo, during the build it actually forks into 2 parallel MSBuild processes. We simply copy the file, change the <code class="highlighter-rouge">DefaultTargets</code>, and kick it off in parallel <a href="https://gist.github.com/NickCraver/b59ff38567b32936e2a3440e439d5d5c#file-build-xml-L146">here</a>.</p> <p>The first process is building the ASP.NET MVC views with our custom Roslyn-based build in <a href="https://github.com/StackExchange/StackExchange.Precompilation">StackExchange.Precompilation</a>, <a href="https://stackoverflow.blog/2015/07/23/announcing-stackexchange-precompilation/">explained by Samo Prelog here</a>. It&#x2019;s not only building the views but also plugging in localized strings for each language via <code class="highlighter-rouge">switch</code> statements. There&#x2019;s a hint at how that works <a href="#localizationtranslations-moonspeak">a bit further down</a>. We wrote this process for localization, but it turns out controlling the speed and batching of the view builds allows us to be <em>much</em> faster than <code class="highlighter-rouge">aspnet_compiler</code> used to be. Rumor is performance has gotten better there lately, though.</p> <p>The second process is the <code class="highlighter-rouge">.less</code>, <code class="highlighter-rouge">.css</code>, and <code class="highlighter-rouge">.js</code> compilation and minification which involves a few components. First up are the <code class="highlighter-rouge">.jsbundle</code> files. They are simple files that look like this example:</p> <figure class="highlight"> <pre><code class="language-json"><span class="p">{</span><span class="w"> </span><span class="s2">&quot;items&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;full-anon.jsbundle&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;PartialJS</span><span class="se">\\</span><span class="s2">full</span><span class="se">\\</span><span class="s2">*.js&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;bounty.js&quot;</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre>
</figure> <p>These files are true to their name, they are simply concatenated bundles of files for use further on. This allows us to maintain JavaScript divided up nicely across many files but handle it as one file for the rest of the build. The same bundler code runs as an HTTP handler locally to combine on the fly for local development. This sharing allows us to mimic production as best we can.</p> <p>After bundling, we have regular old <code class="highlighter-rouge">.js</code> files with JavaScript in them. They have letters, numbers, and even some semicolons. They&#x2019;re delightful. After that, they go through the translator <em>of doom</em>. We think. No one really knows. It&#x2019;s black magic. Really what happens here isn&#x2019;t relevant, but we get a <code class="highlighter-rouge">full.en.js</code>, <code class="highlighter-rouge">full.ru.js</code>, <code class="highlighter-rouge">full.pt.js</code>, etc. with the appropriate translations plugged in. It&#x2019;s the same <code class="highlighter-rouge">&lt;filename&gt;.&lt;locale&gt;.js</code> pattern for every file. I&#x2019;ll do a deep-dive with Samo on <a href="https://trello.com/c/GdywwBgb/24-localization">the localization post</a> (go vote it up if you&#x2019;re curious).</p> <p>After JavaScript translation completes (10-12 seconds), we move on to the Node.js piece of the build. Note: node is not installed on the build servers; we have everything needed inside the repo. Why do we use Node.js? Because it&#x2019;s the native platform for <a href="http://lesscss.org/">Less.js</a> and <a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a>. Once upon a time we used <a href="http://www.dotlesscss.org/">dotLess</a>, but we got tired of maintaining the fork and went with a node build process for faster absorption of new versions.</p> <p>The <code class="highlighter-rouge">node-compile.js</code> is <a href="https://gist.github.com/NickCraver/b59ff38567b32936e2a3440e439d5d5c#file-node-compile-js">also in the Gist</a>. It&#x2019;s a simple forking script that sets up <code class="highlighter-rouge">n</code> node worker processes to handle the hundreds of files we have (due to having hundreds of sites) with the main thread dishing out work. Files that are identical (e.g. the beta sites) are calculated once then cached, so we don&#x2019;t do the same work a hundred times. It also does things like add cache breakers on our SVG URLs based on a hash of their contents. Since we also serve the CSS with a cache breaker at the application level, we have a cache-breaker that changes from bottom to top, properly cache-breaking at the client when anything changes. The script can probably be vastly improved (and I&#x2019;d welcome it), it was just the simplest thing that worked and met our requirements when it was written and hasn&#x2019;t needed to change much since.</p> <p>Note: a (totally unintentional) benefit of the cache-breaker calculation has been that we never deploy an incorrect image path in CSS. That situation blows up because we can&#x2019;t find the file to calculate the hash&#x2026;and the build fails.</p> <p>The totality of node-compile&#x2019;s job is minifying the <code class="highlighter-rouge">.js</code> files (in place, not something like <code class="highlighter-rouge">.min.js</code>) and turning <code class="highlighter-rouge">.less</code> into <code class="highlighter-rouge">.css</code>. After that&#x2019;s done, MSBuild has produced all the output we need to run a fancy schmancy website. Or at least something like Stack Overflow. Note that we&#x2019;re slightly odd in that we share styles across many site themes, so we&#x2019;re transforming hundreds of <code class="highlighter-rouge">.less</code> files at once. That&#x2019;s the reason for spawning workers &#x2014; the number spawned scales based on core count.</p> <h4 id="step-6-translation-dump-c-edition">Step 6: Translation Dump (C# Edition)</h4>
<p>This step we call the transmogulator. It copies all of the to-be-localized strings we use in C# and Razor inside <code class="highlighter-rouge">_s()</code> and <code class="highlighter-rouge">_m()</code> out so we have the total set to send to the translators. This isn&#x2019;t a direct extraction, it&#x2019;s a collection of some custom attributes added when we translated things during compilation in the previous step. This step is just a slightly more complicated version of what&#x2019;s happening in step #4 for JavaScript. We dump the files in raw <code class="highlighter-rouge">.txt</code> files for use later (and as a history of sorts). We also dump the overrides here, where we supply overrides directly <em>on top of</em> what our translators have translated. These are typically community fixes we want to upstream.</p> <p>I realize a lot of that doesn&#x2019;t make a ton of sense without going heavily into how the translation system works - which will be a topic for <a href="https://trello.com/c/GdywwBgb/24-localization">a future post</a>. The basics are: we&#x2019;re dumping all the strings from our codebase so that people can translate them. When they are translated, they&#x2019;ll be available for step #5 above in the next build after.</p> <p>Here&#x2019;s the entire step:</p> <figure class="highlight"> <pre><code class="language-cmd">%system.moonspeaktools%\Transmogulator.exe .\StackOverflow\bin en;pt-br;mn-mn;ja;es;ru
  &quot;%system.translationsDumpPath%\artifact-%build.number%.{0}.txt&quot; MoonSpeak
%system.moonspeaktools%\OverrideExporter.exe export &quot;%system.translationConnectionString%&quot;
  &quot;%system.translationsDumpPath%&quot;</code></pre>
</figure> <h4 id="step-7-importing-english-strings">Step 7: Importing English Strings</h4>
<p>One of the weird things to think about in localization is the <em>simplest</em> way to translate is to <em>not</em> special case English. To that end, here we are special casing it. Dammit, we already screwed up. But, by special casing it at build time, we prevent having to special case it later. Almost every string we put in would be correct in English, only needing the translation overrides for multiples and such (e.g. &#x201C;1 item&#x201D; vs &#x201C;2 items&#x201D;), so we want to immediately import anything added to the English result set so that it&#x2019;s ready for Stack Overflow as soon as it&#x2019;s built the first time (e.g. no delay on the translators for deploying a new feature). Ultimately, this step takes the text files created for English in Steps 4 and 6 and turns around and inserts them (into our translations database) for the English entries.</p> <p>This step also posts all new strings added to a special internal chatroom alerting our translators in all languages so that they can be translated ASAP. Though we don&#x2019;t want to delay builds and deploys on new strings (they may appear in English for a build and we&#x2019;re okay with that), we want to minimize it - so we have an alert pipe so to speak. Localization delays are binary: either you wait on all languages or you don&#x2019;t. We choose faster deploys.</p> <p>Here&#x2019;s the call for step 7:</p> <figure class="highlight"> <pre><code class="language-cmd">%system.moonspeaktools%\MoonSpeak.Importer.exe &quot;%system.translationConnectionString%&quot;
  &quot;%system.translationsDumpPath%\artifact-%build.number%.en.txt&quot; 9 false 
  &quot;https://teamcity/viewLog.html?buildId=%teamcity.build.id%&amp;tab=buildChangesDiv&quot;
%system.moonspeaktools%\MoonSpeak.Importer.exe &quot;%system.translationConnectionString%&quot;
  &quot;%system.translationsDumpPath%\artifact-%build.number%-js.en.txt&quot; 9 false
  &quot;https://teamcity/viewLog.html?buildId=%teamcity.build.id%&amp;tab=buildChangesDiv&quot;</code></pre>
</figure> <h4 id="step-8-deploy-website">Step 8: Deploy Website</h4>
<p>Here&#x2019;s where all of our hard work pays off. Well, the build server&#x2019;s hard work really&#x2026;but we&#x2019;re taking credit. We have one goal here: take our built code and turn it into the active code on all target web servers. This is where you can get really complicated when you really just need to do something simple. What do you <em>really</em> need to perform to deploy updated code to a web server? Three things:</p> <ol> <li>Stop the website</li> <li>Overwrite the files</li> <li>Start the website</li>
</ol> <p>That&#x2019;s it. That&#x2019;s all the major pieces. So let&#x2019;s get as close to the stupidest, simplest process as we can. Here&#x2019;s the call for that step, it&#x2019;s a PowerShell script we pre-deploy on all build agents (with a build) that very rarely changes. We use the same set of scripts for all IIS website deployments, even the Jekyll-based blog. Here are the arguments we pass to the <code class="highlighter-rouge">WebsiteDeploy.ps1</code> script:</p> <figure class="highlight"> <pre><code class="language-powershell">-HAProxyServers <span class="s2">&quot;%deploy.HAProxy.Servers%&quot;</span> -HAProxyPort %deploy.HAProxy.Port%
-Servers <span class="s2">&quot;%deploy.ServerNames%&quot;</span>
-Backends <span class="s2">&quot;%deploy.HAProxy.Backends%&quot;</span> -Site <span class="s2">&quot;%deploy.WebsiteName%&quot;</span>
-Delay %deploy.HAProxy.Delay.IIS%
-DelayBetween %deploy.HAProxy.Delay.BetweenServers%
-WorkingDir <span class="s2">&quot;%teamcity.build.workingDir%\%deploy.WebsiteDirectory%&quot;</span>
-ExcludeFolders <span class="s2">&quot;%deploy.RoboCopy.ExcludedFolders%&quot;</span>
-ExcludeFiles <span class="s2">&quot;%deploy.RoboCopy.ExcludedFiles%&quot;</span>
-ContentSource <span class="s2">&quot;%teamcity.build.workingDir%\%deploy.contentSource%&quot;</span>
-ContentSStaticFolder <span class="s2">&quot;%deploy.contentSStaticFolder%&quot;</span></code></pre>
</figure> <p>I&#x2019;ve included script <a href="https://gist.github.com/NickCraver/b59ff38567b32936e2a3440e439d5d5c#file-deployscripts-ps1">in the Gist here</a>, with all the relevant functions from the profile included for completeness. The meat of the main script is here (lines shortened for fit below, but the complete version is in the Gist):</p> <figure class="highlight"> <pre><code class="language-powershell"><span class="nv">$ServerSession</span> <span class="o">=</span> Get-ServerSession <span class="nv">$s</span>
<span class="k">if</span> <span class="o">(</span><span class="nv">$ServerSession</span> -ne <span class="nv">$null</span><span class="o">)</span>
<span class="o">{</span> Execute <span class="s2">&quot;Server: </span><span class="nv">$s</span><span class="s2">&quot;</span> <span class="o">{</span> HAProxyPost -Server <span class="nv">$s</span> -Action <span class="s2">&quot;drain&quot;</span> <span class="c1"># delay between taking a server out and killing the site, so current requests can finish</span> Delay -Delay <span class="nv">$Delay</span> <span class="c1"># kill website in IIS</span> ToggleSite -ServerSession <span class="nv">$ServerSession</span> -Action <span class="s2">&quot;stop&quot;</span> -Site <span class="nv">$Site</span> <span class="c1"># inform HAProxy this server is down, so we don&apos;t come back up immediately</span> HAProxyPost -Server <span class="nv">$s</span> -Action <span class="s2">&quot;hdown&quot;</span> <span class="c1"># robocopy!</span> CopyDirectory -Server <span class="nv">$s</span> -Source <span class="nv">$WorkingDir</span> -Destination <span class="s2">&quot;\\</span><span class="nv">$s</span><span class="s2">\...&quot;</span> <span class="c1"># restart website in IIS</span> ToggleSite -ServerSession <span class="nv">$ServerSession</span> -Action <span class="s2">&quot;start&quot;</span> -Site <span class="nv">$Site</span> <span class="c1"># stick the site back in HAProxy rotation</span> HAProxyPost -Server <span class="nv">$s</span> -Action <span class="s2">&quot;ready&quot;</span> <span class="c1"># session cleanup</span> <span class="nv">$ServerSession</span> | Remove-PSSession <span class="o">}</span>
<span class="o">}</span></code></pre>
</figure> <p>The steps here are the minimal needed to <em>gracefully</em> update a website, informing the load balancer of what&#x2019;s happening and impacting users as little as possible. Here&#x2019;s what happens:</p> <ol> <li>Tell <a href="https://www.haproxy.org/">HAProxy</a> to stop sending new traffic</li> <li>Wait a few seconds for all current requests to finish</li> <li>Tell IIS to stop the site (<a href="https://technet.microsoft.com/en-us/library/ee790607.aspx"><code class="highlighter-rouge">Stop-Website</code></a>)</li> <li>Tell HAProxy that this webserver is down (rather than waiting for it to detect)</li> <li>Copy the new code (<a href="https://technet.microsoft.com/en-us/library/cc733145.aspx"><code class="highlighter-rouge">robocopy</code></a>)</li> <li>Tell IIS to start the new site (<a href="https://technet.microsoft.com/en-us/library/hh867884(v=wps.630).aspx"><code class="highlighter-rouge">Start-Website</code></a>)</li> <li>Tell HAProxy this website is ready to come back up</li>
</ol> <p>Note that HAProxy doesn&#x2019;t <em>immediately</em> bring the site back online. It will do so after 3 successful polls, this is a key difference between <code class="highlighter-rouge">MAINT</code> and <code class="highlighter-rouge">DRAIN</code> in HAProxy. <code class="highlighter-rouge">MAINT</code> -&gt; <code class="highlighter-rouge">READY</code> assumes the server is instantly up. <code class="highlighter-rouge">DRAIN</code> -&gt; <code class="highlighter-rouge">READY</code> assumes down. The former has a very nasty effect on <a href="https://msdn.microsoft.com/en-us/library/system.threading.threadpool.aspx">ThreadPool</a> growth waiting with the initial slam while things are spinning up.</p> <p>We repeat the above for all webservers in the build. There&#x2019;s also a slight pause between each server, all of which is tunable with TeamCity settings.</p> <p>Now the above is what happens <em>for a single website</em>. In reality, this step deploys twice. The reason why is race conditions. For the best client-side performance, our static assets have headers set to cache for 7 days. We break this cache <em>only when it changes</em>, not on every build. After all, you only need to fetch new CSS, SVGs, or JavaScript if they actually changed. Since <a href="https://cdn.sstatic.net/"><code class="highlighter-rouge">cdn.sstatic.net</code></a> comes from our web tier underneath, here&#x2019;s what <em>could</em> happen due to the nature of a rolling build:</p> <p>You hit <code class="highlighter-rouge">ny-web01</code> and get a brand spanking new querystring for the new version. Your browser then hits our CDN at <code class="highlighter-rouge">cdn.sstatic.net</code>, which let&#x2019;s say hits <code class="highlighter-rouge">ny-web07</code>&#x2026;which has the old content. Oh crap, now we have old content cached with the new hash for a hell of a long time. That&#x2019;s no good, that&#x2019;s a hard reload to fix, <em>after</em> you purge the CDN. We avoid that by pre-deploying the static assets to another website in IIS specifically serving the CDN. This way <code class="highlighter-rouge">sstatic.net</code> gets the content in one rolling deploy, just before the new code issuing new hashes goes out. This means that there is a slight chance that someone will get <em>new</em> static content with an <em>old</em> hash (if they hit a CDN miss for a piece of content that actually changed this build). The big difference is that (rarely hit) problem fixes itself on a page reload, since the hash will change as soon as the new code is running a minute later. It&#x2019;s a much better direction to fail in.</p> <p>At the end of this step (in production), 7 of 9 web servers are typically online and serving users. The last 2 will finish their spin-up shortly after. The step takes about 2 minutes for 9 servers. But yay, our code is live! Now we&#x2019;re free to deploy again for that bug we probably just sent out.</p> <h4 id="step-9-new-strings-hook">Step 9: New Strings Hook</h4>
<p>This dev-only step isn&#x2019;t particularly interesting, but useful. All it does is call a webhook telling it that some new strings were present in this build if there were any. The hook target triggers an upload to our translation service to tighten the iteration time on translations (similar to our chat mechanism above). It&#x2019;s last because strictly speaking it&#x2019;s optional and we don&#x2019;t want it to interfere.</p> <p>That&#x2019;s it. Dev build complete. Put away the <a href="https://xkcd.com/303/">rolly chairs and swords</a>.</p> <h3 id="tiers">Tiers</h3>
<p>What we covered above was the entire development CI build with all the things&#x2122;. All of the translation bits are development only because we just need to get the strings once. The meta and production builds are a simpler subset of the steps. Here&#x2019;s a simple visualization that compares the build steps across tiers:</p> <table class="comparison"> <tr><th>Build Step</th><th>Dev</th><th>Meta</th><th>Prod</th></tr> <tr><td>1 - Migrate Sites DB</td><td class="lit"></td><td></td><td></td></tr> <tr><td>2 - Migrate Q&amp;A DBs</td><td class="lit"></td><td class="lit"></td><td></td></tr> <tr><td>3 - Find MoonSpeak Tools</td><td class="lit"></td><td class="lit"></td><td class="lit"></td></tr> <tr><td>4 - Translation Dump (JavaScript)</td><td class="lit"></td><td></td><td></td></tr> <tr><td>5 - MSBuild (Compile Compress and Minify)</td><td class="lit"></td><td class="lit"></td><td class="lit"></td></tr> <tr><td>6 - Translation Dump (C#)</td><td class="lit"></td><td></td><td></td></tr> <tr><td>7 - Translations Import English Strings</td><td class="lit"></td><td></td><td></td></tr> <tr><td>8 - Deploy Website</td><td class="lit"></td><td class="lit"></td><td class="lit"></td></tr> <tr><td>9 - New Strings Hook</td><td class="lit"></td><td></td><td></td></tr>
</table> <p>What do the tiers really translate to? All of our development sites are on WEB10 and WEB11 servers (under different application pools and websites). Meta runs on WEB10 and WEB11 servers, this is specifically <a href="https://meta.stackexchange.com/">meta.stackexchange.com</a> and <a href="https://meta.stackoverflow.com/">meta.stackoverflow.com</a>. Production (all other Q&amp;A sites and metas) like Stack Overflow are on WEB01-WEB09.</p> <p>Note: we do a chat notification for build as someone goes through the tiers. Here&#x2019;s me (against all sane judgement) building out some changes at 5:17pm on a Friday. Don&#x2019;t try this at home, I&#x2019;m a professional. Sometimes. Not often.</p> <p><img src="/blog/content/SO-Deployment-Chat.png" alt="Chat Messages"></p> <h3 id="database-migrations">Database Migrations</h3>
<p>See? I promised we&#x2019;d come back to these. To reiterate: if new code is needed to handle the database migrations, <em>it must be deployed first</em>. In practice though, you&#x2019;re likely dropping a table, or adding a table/column. For the removal case, we remove it from code, deploy, then deploy again (or later) with the drop migration. For the addition case, we would typically add it as nullable or unused in code. If it needs to be <code class="highlighter-rouge">not null</code>, a foreign key, etc. we&#x2019;d do that in a later deploy as well.</p> <p>The database migrator we use is a very simple repo we could open source, but honestly, there are dozens out there and the &#x201C;same migration against n databases&#x201D; is fairly specific. The others are probably much better and ours is very specific to <em>only</em> our needs. The migrator connects to the Sites database, gets the list of databases to run against, and executes all migrations against every one (running multiple databases in parallel). This is done by looking at the passed-in migrations folder and loading it (once) as well as hashing the contents of every file. Each database has a <code class="highlighter-rouge">Migrations</code> table that keeps track of what has already been run. It looks like this (descending order):</p> <p><img src="/blog/content/SO-Deployment-Migrations-Table.png" alt="Migrations Table"></p> <p>Note that the above aren&#x2019;t all in file number order. That&#x2019;s because 724 and 725 were in a branch for a few days. That&#x2019;s not an issue, order is not guaranteed. <strong>Each migration itself is written to be idempotent</strong>, e.g. &#x201C;don&#x2019;t try to add the column if it&#x2019;s already there&#x201D;, but the specific order isn&#x2019;t usually relevant. Either they&#x2019;re all per-feature, or they&#x2019;re actually going in-order anyway. The migrator respects the <code class="highlighter-rouge">GO</code> operator to separate batches and by default runs all migrations in a transaction. The transaction behavior can be changed with a first-line comment in the <code class="highlighter-rouge">.sql</code> file: <code class="highlighter-rouge">-- no transaction --</code>. Perhaps the most useful explanation to the migrator is the README.md I wrote for it. <a href="https://gist.github.com/NickCraver/b59ff38567b32936e2a3440e439d5d5c#file-sql-migrator-readme-md">Here it is in the Gist</a>.</p> <p>In memory, we compare the list of migrations that already ran to those needing to run then execute what needs running, in file order. If we find the hash of a filename doesn&#x2019;t match the migration with the same file name in the table, we abort as a safety measure. We can <code class="highlighter-rouge">--force</code> to resolve this in the rare cases a migration <em>should</em> have changed (almost always due to developer error). After all migrations have run, we&#x2019;re done.</p> <p>Rollbacks. We rarely do them. In fact, I can&#x2019;t remember ever having done one. We avoid them through the approach in general: we deploy small and often. It&#x2019;s often quicker to fix code and deploy than reverse a migration, especially across hundreds of databases. We also make development mimic production as often as possible, restoring production data periodically. If we needed to reverse something, we could just push another migration negating whatever we did that went boom. The tooling has no concept of rollback though. Why roll back when you can roll forward?</p> <h3 id="localizationtranslations-moonspeak">Localization/Translations (Moonspeak)</h3>
<p>This will get its own post, but I wanted to hint at why we do all of this work at compile time. After all, I always advocate strongly for simplicity (yep, even in this 6,000-word blog post - the irony is not lost on me). You should only do something more complicated when you <em>need</em> to do something more complicated. This is one of those cases, for performance. <a href="https://twitter.com/m0sa">Samo</a> does a lot of work to make our localizations have as little <strong>runtime</strong> impact as possible. We&#x2019;ll gladly trade a bit of build complexity to make that happen. While there are options such as <a href="https://msdn.microsoft.com/en-us/library/ekyft91f.aspx"><code class="highlighter-rouge">.resx</code> files</a> or <a href="https://github.com/aspnet/localization">the new localization in ASP.NET Core 1.0</a>, most of these allocate more than necessary especially with tokenized strings. Here&#x2019;s what strings look like in our code:</p> <p><img src="/blog/content/SO-Deployment-Translations-1.png" alt="Translations: IDE"></p> <p>And here&#x2019;s what that line looks like compiled (via Reflector):
<img src="/blog/content/SO-Deployment-Translations-2.png" alt="Translations: Reflected">
&#x2026;and most importantly, the compiled implementation:
<img src="/blog/content/SO-Deployment-Translations-3.png" alt="Translations: Reflected 2"></p> <p>Note that we aren&#x2019;t allocating the entire string together, only the pieces (with most interned). This may seem like a small thing, but at scale that&#x2019;s a <em>huge</em> number of allocations and a lot of time in a garbage collector. I&#x2019;m sure that just raises a ton of questions about how Moonspeak works. If so, <a href="https://trello.com/c/GdywwBgb/24-localization-moonspeak-translations">go vote it up</a>. It&#x2019;s a big topic in itself, I only wanted to justify the compile-time complication it adds here. To us, it&#x2019;s worth it.</p> <h3 id="building-without-breaking">Building Without Breaking</h3>
<p>A question I&#x2019;m often asked is how we prevent breaks while rolling out new code constantly. Here are some common things we run into and how we avoid them.</p> <ul> <li>Cache object changes: <ul> <li>If we have a cache object that totally changes. That&#x2019;s a new cache key and we let the old one fall out naturally with time.</li> <li>If we have a cache object that only changes <em>locally</em> (in-memory): nothing to do. The new app domain doesn&#x2019;t collide.</li> <li>If we have a cache object that changes <em>in redis</em>, then we need to make sure the old and new <a href="https://github.com/mgravell/protobuf-net">protobuf</a> signatures are compatible&#x2026;or change the key.</li> </ul> </li> <li>Tag Engine: <ul> <li><a href="/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/#service-tier-iis-aspnet-mvc-523-net-461-and-httpsys">The tag engine</a> reloads on every build (currently). This is triggered by checking every minute for a new build hash on the web tier. If one is found, the application <code class="highlighter-rouge">\bin</code> and a few configs are downloaded to the Stack Server host process and spun up as a new app domain. This sidesteps the need for a deploy to those boxes and keeps local development setup simple (we run no separate process locally).</li> <li>This one is changing drastically soon, since reloading every build is way more often that necessary. We&#x2019;ll be moving to a more traditional deploy-it-when-it-changes model there soon. Possibly using GPUs. Stay tuned.</li> </ul> </li> <li>Renaming SQL objects: <ul> <li>&#x201C;Doctor it hurts when I do that!&#x201D;</li> <li>&#x201C;Don&#x2019;t do that.&#x201D;</li> <li>We may add and migrate, but a live rename is almost certain to cause an outage of some sort. We don&#x2019;t do that outside of dev.</li> </ul> </li> <li>APIs: <ul> <li>Deploy the new endpoint before the new consumer.</li> <li>If changing an existing endpoint, it&#x2019;s usually across 3 deploys: add (endpoint), migrate (consumer), cleanup (endpoint).</li> </ul> </li> <li>Bugs: <ul> <li>Try not to deploy bugs.</li> <li>If you screw up, try not to do it the same way twice.</li> <li>Accept that crap happens, live, learn, and move on.</li> </ul> </li>
</ul> <p>That&#x2019;s all of the major bits of our deployment process. But as always, ask any questions you have in comments below and you&#x2019;ll get an answer.</p> <p>I want to take a minute and thank the teams at Stack Overflow here. We build all of this, together. Many people help me review these blog posts before they go out to make sure everything is accurate. The posts are not short, and several people are reviewing them in off-hours because they simply saw a post in chat and wanted to help out. These same people hop into comment threads here, on Reddit, on Hacker News, and other places discussions pop up. They answer questions as they arise or relay them to someone who can answer. They do this on their own, out of a love for the community. I&#x2019;m tremendously appreciative of their effort and it&#x2019;s a privilege to work with some of the best programmers and sysadmins in the world. <a href="https://twitter.com/E_Craver">My lovely wife Elise</a> also gives her time to help edit these before they go live. To all of you: thanks.</p> <p>What&#x2019;s next? The way <a href="/blog/2016/02/03/stack-overflow-a-technical-deconstruction/">this series</a> works is I blog in order of what the community wants to know about most. Going by <a href="https://trello.com/b/0zgQjktX/blog-post-queue-for-stack-overflow-topics">the Trello board</a>, it looks like <a href="https://trello.com/c/1Oc9cC6u/11-monitoring">Monitoring</a> is the next most interesting topic. So next time expect to learn how we monitor all of the systems here at Stack. I&#x2019;ll cover how we monitor servers and services as well as the performance of Stack Overflow 24/7 as users see it all over the world. I&#x2019;ll also cover many of the monitoring tools we&#x2019;re using and have built; we&#x2019;ve open sourced several big ones. Thanks for reading this post which ended up way longer than I envisioned and see you next time.</p> </article></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>