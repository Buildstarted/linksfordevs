<!DOCTYPE html>
<html lang="en">
<head>
    <title>
JWTs: Which Signing Algorithm Should I Use? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="JWTs: Which Signing Algorithm Should I Use? - linksfor.dev(s)"/>
    <meta property="article:author" content="https://www.scottbrady91.com/About"/>
    <meta property="og:description" content="Learn the difference between each JOSE algorithm (e.g. RS256, ES256, EdDSA) and how to choose the best one available to you."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.scottbrady91.com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - JWTs: Which Signing Algorithm Should I Use?</title>
<div class="readable">
        <h1>JWTs: Which Signing Algorithm Should I Use?</h1>
            <div>by https://www.scottbrady91.com/About</div>
            <div>Reading time: 13-17 minutes</div>
        <div>Posted here: 18 Aug 2020</div>
        <p><a href="https://www.scottbrady91.com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use">https://www.scottbrady91.com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<div itemprop="articleBody">
<p>
JSON Web Tokens (JWTs) can be signed using many different algorithms: RS256, PS512, ES384, HS1; you can see why some developers scratch their heads when asked which one they would like to use.
</p>
<p>
In my experience, many of the mainstream identity providers have historically only offered RS256 or at least defaulted to it.
However, thanks to initiatives such as Open Banking, these identity providers are now expanding their support to cover more signing algorithms, which means you will need to start understanding which ones to use.
</p>
<p>
I am not a cryptographer, but through my work with OpenID Connect and FIDO2, I have gained a practitioner‚Äôs understanding of the various signing algorithms and the cryptography communities‚Äô general feelings towards each one.
In this article, I‚Äôm going to arm you with some of that knowledge so that you can understand what each ‚Äúalg‚Äù value means and choose the best signing algorithm available to you.
</p>
<p>
<span>TL;DR:</span> EdDSA &gt; ECDSA or RSASSA-PSS &gt; RSASSA-PKCS1-v1_5 and know what to expect.
</p>
<h2>Algorithm (alg) Values</h2>
<p>
Before we look at each family of signature algorithms, let‚Äôs first clarify what we mean by ‚Äúalg‚Äù values such as RS256.
These are JSON Web Algorithms (JWA), which are part of the JavaScript Object Signing and Encryption (JOSE) family.
You‚Äôll see ‚Äúalg‚Äù values in JWT headers, telling you how the JWT was signed, and in JSON Web Keys (JWK), telling you what algorithm a key is used for.
</p>
<p>
As a general rule of thumb, an ‚Äúalg‚Äù value can be broken down as:
</p>
<div>
<p><span>RS</span>
</p>
<p><span>256</span>
</p>
<p>signature algorithm</p>
<p>hashing algorithm </p>
</div>
<ul>
<li><span>Signature algorithm family:</span> In this case, RS means RSASSA-PKCS1-v1_5.</li>
<li><span>Hashing algorithm</span> used by the signature algorithm. In this case, 256 means SHA-256.</li>
</ul>
<p>
Most signing algorithms have variants for SHA-256, SHA-384, and SHA-512.
In some cases, you can even have something like ‚ÄúRS1‚Äù, which uses SHA-1 ü§¢ and is required for FIDO2 conformance.
</p>
<p>
These algorithms are typically defined in <a title="JSON Web Algorithms (JWA)" href="https://tools.ietf.org/html/rfc7518" target="_blank" rel="noopener">RFC 7518</a>, but you can find a full list of supported algorithms in the <a href="https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms" target="_blank" rel="noopener">JOSE IANA registry</a>.
</p>
<h2>Which Hashing Algorithm Should I Use?</h2>
<p>
SHA-256, SHA-384, and SHA-512 are all variations of the same hashing algorithm family: SHA-2.
</p>
<p>
As a rule of thumb, the number in an algorithm refers to the size of the hash it will generate.
For example, SHA-256 will produce a 256-bit hash, while SHA-512 will produce a 512-bit hash.
</p>
<p>
The level of security each one gives you is 50% of their output size, so SHA-256 will provide you with 128-bits of security, and SHA-512 will provide you with 256-bits of security.
This means that an attacker will have to generate 2^128 hashes before they start finding collisions, thanks to the <a href="https://en.wikipedia.org/wiki/Birthday_attack" target="_blank" rel="noopener">birthday bound</a>.
This is why we use a minimum of 128-bit security.
</p>
<p>
You‚Äôre not going to be needing anything better than SHA-256 any time soon.
Just don‚Äôt use SHA-1.
</p>
<h2>Validation: Know your Algorithm</h2>
<p>
Every application validating JWT signatures should know ahead of time which algorithms to expect and <span>exactly</span> which key to use.
You can do this by assigning each public key to an algorithm (e.g. this key is for RS384, this one for ES256).
When you have many keys for a single algorithm, you can use the key ID (<code>kid</code>) in a JWT header to understand which one to use.
</p>
<p>
Basically, you want to make sure the <code>kid</code> and <code>alg</code> values in a JWT match what you expect.
If they do not match, then someone is up to no good.
</p>
<pre><code><span>{</span>
    <span>"typ"</span><span>:</span> <span>"JWT"</span><span>,</span>
    <span>"kid"</span><span>:</span> <span>"123"</span><span>,</span> 
    <span>"alg"</span><span>:</span> <span>"RS256"</span> 
<span>}</span></code></pre>
<p>
Protocols such as OpenID Connect facilitate this using a discovery document and a JSON Web Key Set (JWKS) available on an endpoint protected by TLS.
</p>
<p>
These days, you should not trust the ‚Äúalg‚Äù value in the JWT header alone, nor should you accept JWTs with an algorithm of ‚Äúnone‚Äù or JWTs with a public key embedded in its header.
</p>
<h2>RSASSA-PKCS1-v1_5 <span>(e.g. RS256)</span></h2>
<p>RS256 = RSASSA-PKCS1-v1_5 using SHA-256</p>
<p>
While RS<span>AES</span>-PKCS1-v1_5 is no longer safe for encryption, RSA<span>SSA</span>-PKCS1-v1_5 is still suitable for digital signatures.
As I mentioned earlier, in my experience, <strong>RS256 has historically been the default for most JWT implementations</strong>, with many SaaS identity providers only offering this signature algorithm.
It‚Äôs hard to find a system that can‚Äôt support JWTs signed with RS256.
</p>
<p>
JWTs signed with RSASSA-PKCS1-v1_5 have a deterministic signature, meaning that the same JWT header &amp; payload will always generate the same signature.
</p>
<p>
RSASSA-PKCS1-v1_5 has been around for a long time, but these days, <strong>you should generally prefer RSASSA-PSS</strong> (RSA with a probabilistic signature).
That‚Äôs not to say RSASSA-PKCS1-v1_5 is broken but rather that RSASSA-PSS simply has desirable features that the other does not.
In fact, RFC 8017 now considers RSASSA-PSS a requirement when using RSA for signing:
</p>
<blockquote cite="https://tools.ietf.org/html/rfc8017">
<p>
Although no attacks are known against RSASSA-PKCS1-v1_5, in the interest of increased robustness, RSASSA-PSS is REQUIRED in new applications.
</p>

</blockquote>
<p>
That being said, when discussing <a href="https://en.wikipedia.org/wiki/Daniel_Bleichenbacher" target="_blank" rel="noopener">Bleichenbacher‚Äôs attacks</a> against the RSA PKCS#1 encryption and signature standards, David Wong in <a href="https://www.manning.com/books/real-world-cryptography" target="_blank" rel="noopener">Real-Word Cryptography</a> shares an interesting statistic:
</p>
<blockquote cite="https://www.manning.com/books/real-world-cryptography">
<p>
Unlike the first attack that broke the encryption algorithm completely, the second attack is an implementation attack [against signature validation].
This means that if the signature scheme is implemented correctly (according to the specification), the attack does not work.
</p>
<p>
Yet, it was <a href="https://www.cs.purdue.edu/homes/schau/files/pkcs1v1_5-ndss19.pdf" target="_blank" rel="noopener">shown in 2019</a> that many open source implementations of RSA PKCS#1 v1.5 for signatures actually fell for that trap and mis-implemented the standard, which enabled different variants of Bleichenbacher‚Äôs forgery attack to work!
</p>

</blockquote>
<p>
Since the attacks are against signature validation, you will have to be confident that all recipients who validate your JWTs are using a library that is not vulnerable to Bleichenbacher‚Äôs attack.
That would be difficult if you are dealing with many 3rd parties.
</p>
<p>
The work around Open Banking, such as OpenID‚Äôs Financial-grade API (FAPI), does not allow the use of RSASSA-PKCS1-v1_5.
For my regular readers, this was the only algorithm available in IdentityServer up until IdentityServer4 version 3.
</p>
<h3>Further Reading</h3>
<ul>
<li>Learn how to <a href="https://www.scottbrady91.com/OpenSSL/Creating-RSA-Keys-using-OpenSSL" title="Creating RSA Keys using OpenSSL" target="_blank">generate RSA keys</a> for JWT signing using OpenSSL</li>
</ul>
<h2>RSASSA-PSS <span>(e.g. PS256)</span></h2>
<p>PS256 = RSASSA-PSS using SHA-256 with MGF1 with SHA-256</p>
<p>
RSASSA-PSS is the probabilistic version of RSA, where the same JWT header and payload will generate a different signature each time.
Unlike other algorithms, this is probabilistic in a good way; while a random value may be used during signature generation, it is not critical to security.
In general, it‚Äôs a lot simpler to implement and therefore harder to get wrong.
</p>
<p>
<strong>If you want to use an RSA key, then it‚Äôs recommended that you use RSASSA-PSS</strong> over RSASSA-PKCS1-v1_5, but luckily an RSA key can be used for either signature scheme.
Signature length is also identical between the two.
</p>
<p>
The UK‚Äôs Open Banking initially mandated the use of PS256, but later opened it up to ES256.
</p>
<h3>Further Reading</h3>
<ul>
<li>Learn more about <a href="https://www.scottbrady91.com/C-Sharp/JWT-Signing-using-RSASSA-PSS-in-dotnet-Core" title="JWT Signing using RSASSA-PSS in .NET Core" target="_blank">RSASSA-PSS and how to use it in .NET Core</a></li>
<li>Learn how to <a href="https://www.scottbrady91.com/OpenSSL/Creating-RSA-Keys-using-OpenSSL" title="Creating RSA Keys using OpenSSL" target="_blank">generate RSA keys</a> for JWT signing using OpenSSL</li>
</ul>
<h2>ECDSA <span>(e.g. ES256)</span></h2>
<p>ES256 = ECDSA using P-256 and SHA-256</p>
<p>
In the case of Elliptical Curve Digital Signing Algorithms (ECDSA), the number in ES256 that refers to the hashing algorithm also relates to the curve.
ES256 uses P-256 (secp256r1, aka prime256v1), ES384 uses P-384 (secp384r1), and, the odd one out, ES512 uses P-521 (secp521r1).
Yes, 521.
Yes, <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/master/src/Microsoft.IdentityModel.Tokens/JsonWebKeyECTypes.cs#L40" target="_blank" rel="noopener">even Microsoft</a> has typoed this.
</p>
<p>
Elliptical Curve Cryptography (ECC) is much harder to crack than RSA (or maybe we are just really good at breaking RSA).
As a result, <strong>ECDSA can use much shorter keys than RSA along with much shorter signatures</strong>.
A short Elliptical Curve (EC) key of around 256 bits provides the same security as a 3072 bit RSA key.
</p>
<p>
You will often see ECDSA listed as faster than its equivalent in RSA, but this is only really true for signature generation; signature validation is still typically faster with RSA.
With JWTs, you‚Äôre most likely going to be signing once and verifying many times.
</p>
<p>
JWTs signed with ECDSA have a probabilistic signature, meaning that the same JWT header &amp; payload will always generate a different signature.
But unfortunately, ECDSA is probabilistic in a bad way, where random generation is vital to the security of the signature.
</p>
<p>
ECDSA uses a random nonce (no more than once) that is generated per signature.
Failure to only ever use a nonce value once makes the private key easily recoverable, and this has been seen in the wild with both <a href="https://medium.com/asecuritysite-when-bob-met-alice/not-playing-randomly-the-sony-ps3-and-bitcoin-crypto-hacks-c1fe92bea9bc" target="_blank" rel="noopener">Sony‚Äôs Playstation 3 and Bitcoin</a>.
With the Playstation 3, the private key was recovered due to a static nonce, and with Bitcoin, Android users were affected due to a bug in Java‚Äôs SecureRandom class on Android.
<span>
If random values are required for the security of a probabilistic signature, then you should prefer a deterministic signature that does not.
</span>
</p>
<p>
Whereas RSASSA-PKCS1-v1_5 has issues with signature validation, ECDSA has issues with signature generation, which is much easier to deal with when you are the token issuer.
</p>
<p>
ECDSA is gaining popularity but seems to generally be frowned upon by cryptographers due to how elliptical curve cryptography was implemented, with concerns around implementation difficulty due to the use of random values.
It has a better reputation than RSA, but <strong>cryptographers are still advocating the migration to EdDSA</strong>.
</p>
<p>
The curves JOSE initially used where defined by NIST.
If you are concerned about using curves defined by NIST but want to use ECDSA, a popular alternative is to use a Koblitz curve, such as secp256k1 (as opposed to secp256r1).
Kobiltz curves are a few bits weaker, but if you have concerns that the unexplained random numbers used in the NIST curves indicate another NSA backdoor, then Kobiltz curves offer an increasingly popular alternative.
You can find usages on these curves in Bitcoin, Ethereum, and FIDO2.
However, you should be using EdDSA if you want to use a non-NIST curve.
In JOSE, algorithms using Kobiltz end with a K, e.g. ES256K.
</p>
<h3>Further Reading</h3>
<ul>
<li>Learn <a href="https://www.scottbrady91.com/C-Sharp/JWT-Signing-using-ECDSA-in-dotnet-Core" title="JWT Signing using ECDSA in .NET Core" target="_blank"> how to use ECDSA in .NET Core</a> and how to <a href="https://www.scottbrady91.com/Identity-Server/Using-ECDSA-in-IdentityServer4" title="Using ECDSA in IdentityServer4" target="_blank">sign tokens with ECDSA in IdentityServer4</a></li>
<li>Learn how to <a href="https://www.scottbrady91.com/OpenSSL/Creating-RSA-Keys-using-OpenSSL" title="Creating RSA Keys using OpenSSL" target="_blank">generate EC keys</a> for JWT signing using OpenSSL</li>
<li>Use custom JWT signing algorithms in .NET Core, <a href="https://www.scottbrady91.com/C-Sharp/Supporting-Custom-JWT-Signing-Algorithms-in-dotnet-Core" title="Supporting Custom JWT Signing Algorithms in .NET Core" target="_blank">with examples using Kobiltz curves</a></li>
</ul>
<h2>EdDSA</h2>
<p>EdDSA = an EdDSA signature algorithm was used ü§∑‚Äç‚ôÇÔ∏è</p>
<p>
EdDSA bucks the trend of the previous algorithms and uses a single <code>alg</code> value.
Instead, it relies upon the curve (<code>crv</code>) defined in a pre-agreed key.
</p>
<p>
For example, a JWK containing an EdDSA public key would look like the following:
</p>
<pre><code><span>{</span>
  <span>"kty"</span><span>:</span> <span>"OKP"</span><span>,</span>
  <span>"alg"</span><span>:</span> <span>"EdDSA"</span><span>,</span>
  <span>"crv"</span><span>:</span> <span>"Ed25519"</span><span>,</span>
  <span>"x"</span><span>:</span> <span>"60mR98SQlHUSeLeIu7TeJBTLRG10qlcDLU4AJjQdqMQ"</span>
<span>}</span></code></pre>
<p>
This forces the modern behavior of using the curve assigned to the key,as opposed to from the JWT, and eliminates various <code>alg</code> related attacks.
</p>
<p>
EdDSA is a form of elliptical curve cryptography that takes advantage of twisted Edwards curves.
It is a variant of Schnorr‚Äôs signature system (rather than DSA).
<strong>EdDSA is fast at both signing and validation, has a short signature, and side-steps whole classes of security vulnerabilities</strong>.
</p>
<p>
RFC 8037 defines JOSE support for the following EdDSA variants:
</p>
<ul>
<li><span>Ed25519:</span> a 255-bit curve Curve25519 (32-byte private key, 32-byte public key, 64-byte signature). Signing uses SHA-512. Provides 128-bit security</li>
<li><span>Ed448:</span> a 448-bit curve Curve448-Goldilocks (57-byte private key, 57-byte public key, 114-byte signature). Signing uses SHAKE256. Provides 224-bit security</li>
</ul>
<p>
JWTs signed with EdDSA have a deterministic signature, meaning that the same JWT header &amp; payload will always generate the same signature.
This is deterministic in a good way, addressing the concern of relying on random nonce values to protect the private key.
EdDSA only uses random values during private key creation.
This is the algorithm that <a href="https://www.scottbrady91.com/JOSE/Alternatives-to-JWTs" title="Alternatives to JSON Web Tokens (JWTs)" target="_blank">critics of JOSE &amp; JWTs recommend</a>.
</p>
<p>
Support for EdDSA in JWT libraries is a little patchy, but <strong>expect to see more of EdDSA soon</strong>.
</p>
<h3>Further Reading</h3>
<ul>
<li>Learn more about <a href="https://www.scottbrady91.com/C-Sharp/EdDSA-for-JWT-Signing-in-dotnet-Core" title="EdDSA for JWT Signing in .NET Core" target="_blank">EdDSA and how to use it in .NET Core</a></li>
<li><a href="https://github.com/scottbrady91/IdentityModel" target="_blank" rel="noopener">Start using EdDSA for JWT signing</a> in .NET Core using ScottBrady.IdentityModel</li>
<li>Read more about the design benefits of EdDSA at <a href="https://ed25519.cr.yp.to/" target="_blank" rel="noopener">cr.yp.to</a></li>
</ul>
<h2>HMAC <span>(e.g. HS256)</span></h2>
<p>HS256 = HMAC using SHA-256</p>
<p>
Up until now, we‚Äôve been talking about asymmetric cryptography, where only the token issuer has the private key to create the signature, and everyone else has the corresponding public key that can be used to validate the signature.
For example, the identity provider has the private key and relying parties use a public key.
</p>
<p>
In the <span>rare</span> event that you will be the only person who issues and validates tokens, then you could consider using symmetric cryptography with something like HS256.
<strong>This uses the same key to both create and validate a signature</strong>.
</p>
<p>
In my opinion, if you find yourself in this position, then I don‚Äôt think JWTs are the right solution for you.
If the same entity is both reading and writing, then what is the requirement for round-tripping structured, plaintext data in a JWT?
I would recommend storing the data in a database and passsing around a reference or to use something like a Branca token or JSON Web Encryption (JWE) to ensure only you can read the data.
</p>
<p>
Generally, using HMAC for JWT signing is seen as something of an anti-pattern.
</p>
<h3>Further Reading</h3>
<ul>
<li>Learn more about <a href="https://www.scottbrady91.com/C-Sharp/JSON-Web-Encryption-JWE-in-dotnet-Core" title="JSON Web Encryption (JWE) in .NET Core" target="_blank">JWE and how to use them in .NET Core</a></li>
<li>Learn <a href="https://www.scottbrady91.com/C-Sharp/Replacing-JWTs-with-Branca-and-PASETO-in-dotnet-Core" title="Replacing JWTs with Branca and PASETO in .NET Core" target="_blank">how to use Branca tokens</a> with ScottBrady.IdentityModel</li>
</ul>
<h2>None</h2>
<p>none = base64 encrypted</p>
<p>
Sorry, I couldn't resist.
<span>Please don‚Äôt use this</span>.
</p>
<h2>Recommendations</h2>
<p>
<strong>Use EdDSA where possible and use ECDSA when it is not.</strong>
If you are forced to use RSA, prefer RSASSA-PSS over RSASSA-PKCS1-v1_5.
</p>
<p>
I don‚Äôt think it‚Äôs a controversial statement to say that RSA is slowly on its way out.
At the moment, offering ECDSA is a good alternative, but ideally, you‚Äôll be wanting to move to EdDSA where possible.
</p>
<p>
But, no matter which algorithm you use, make sure you know ahead of time which algorithm to expect and which key to use for validation.
</p>
<p>
A huge thank you to <a href="https://neilmadden.blog/" target="_blank" rel="noopener">Neil Madden</a> for the technical review of this blog post.
</p>
</div>
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>