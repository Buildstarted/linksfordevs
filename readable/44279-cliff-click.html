<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Cliff Click -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Cliff Click</h1>
    <div class="ui_qtext_rendered_qtext"><p class="ui_qtext_para u-ltr u-text-align--start">The JIT has actual profiles available, which no AOT or prior-profiling technology can do. So yes, which branches branch which way. This lets you decide to e.g. run code down the &#x201C;hot path&#x201D; JIT&#x2019;d and on the &#x201C;so cold its never taken path&#x201D; in the interpreter&#x2026; which means the hot path never has to merge the code-path logic in, which typically cleans out nearly all of the error check &amp; correct logic.</p><p class="ui_qtext_para u-ltr u-text-align--start">But also: which classes are loaded, or not, so typically hundreds of overloadable classes are discovered as overloaded exactly one way, leading to thousands of call sites being statically compiled (and possibly inlined), millions of virtual call invocations removed. Happens very often in large complex frameworks, where key classes are instantiated exactly 1 way based on the programmer picking certain key options at runtime.</p><p class="ui_qtext_para u-ltr u-text-align--start">Also: what to inline, leading to higher resolution profiles on the first tiers of JITing, leading even more aggressively inlined &amp; optimized code down the very specific hot code paths.</p><p class="ui_qtext_para u-ltr u-text-align--start">Also: fields which are always zero, or never set past some point (and not declared final). Any large Java program has thousands of these. You get to treat them as final (or constants), whereas a static profiler-based optimizer cannot.</p><p class="ui_qtext_para u-ltr u-text-align--start">Also: what escapes, and what does not &#x2014; allowing escape analysis on objects which blatantly escape in a AOT compilation, but which in practice either never escape, or escape extremely rarely. On the rare escape you &#x201C;inflate&#x201D; the object as needed. On the non-escape path, the entire object can be &#x201C;en-registered&#x201D; - no allocation.</p><p class="ui_qtext_para u-ltr u-text-align--start">There are lots more places where the dynamic profiles are fed back into the JIT, and in my opinion this area remains a fertile ground for future optimizations.</p><p class="ui_qtext_para u-ltr u-text-align--start">Cliff</p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>