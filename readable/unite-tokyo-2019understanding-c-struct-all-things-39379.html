<!DOCTYPE html>
<html lang="en">
<head>
    <title>
&#x3010;Unite Tokyo 2019&#x3011;Understanding C# Struct All Things - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="&#x3010;Unite Tokyo 2019&#x3011;Understanding C# Struct All Things - linksfor.dev(s)"/>
    <meta property="article:author" content="UnityTechnologiesJapan002"/>
    <meta property="og:description" content="2019/9/25-6&#x306B;&#x958B;&#x50AC;&#x3055;&#x308C;&#x305F;Unite Tokyo 2019&#x306E;&#x8B1B;&#x6F14;&#x30B9;&#x30E9;&#x30A4;&#x30C9;&#x3067;&#x3059;&#x3002; &#x6CB3;&#x5408; &#x5B9C;&#x6587;&#xFF08;&#x682A;&#x5F0F;&#x4F1A;&#x793E;Cysharp&#xFF09; &#x3053;&#x3093;&#x306A;&#x4EBA;&#x306B;&#x304A;&#x3059;&#x3059;&#x3081; &#x30FB;C#&#x3092;&#x6975;&#x3081;&#x305F;&#x3044;&#x30A8;&#x30F3;&#x30B8;&#x30CB;&#x30A2; &#x30FB;&#x30D1;&#x30D5;&#x30A9;&#x30FC;&#x30DE;&#x30F3;&#x30B9;&#x306B;&#x8208;&#x5473;&#x306E;&#x3042;&#x308B;&#x30A8;&#x30F3;&#x30B8;&#x30CB;&#x30A2; &#x30FB;&#x30D7;&#x30ED;&#x30B0;&#x30E9;&#x30DF;&#x30F3;&#x30B0;&#x8A00;&#x8A9E;&#x30DE;&#x30CB;&#x30A2; &#x53D7;&#x8B1B;&#x8005;&#x304C;&#x5F97;&#x3089;&#x308C;&#x308B;&#x77E5;&#x898B; &#x30FB;struct&#x306B;&#x95A2;&#x3059;&#x308B;&#x6DF1;&#x3044;&#x77E5;&#x8B58; &#x30FB;&#x30D1;&#x30D5;&#x30A9;&#x30FC;&#x30DE;&#x30F3;&#x30B9;&#x5411;&#x4E0A;&#x306E;&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2019understanding-c-struct-all-things"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - &#x3010;Unite Tokyo 2019&#x3011;Understanding C# Struct All Things</title>
<div class="readable">
        <h1>&#x3010;Unite Tokyo 2019&#x3011;Understanding C# Struct All Things</h1>
            <div>by UnityTechnologiesJapan002</div>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 24 Oct 2019</div>
        <p><a href="https://www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2019understanding-c-struct-all-things">https://www.slideshare.net/UnityTechnologiesJapan002/unite-tokyo-2019understanding-c-struct-all-things</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
        
        


      

        <p><span>Successfully reported this slideshow.</span>
  </p>


      
















<div id="slideview-container">
  

  <div>

    <div id="main-panel">


      

      <div itemscope="" itemtype="https://schema.org/MediaObject">


        <div>
          <meta itemprop="inLanguage" content="en">
          <meta itemprop="image" content="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-1-638.jpg?cb=1569478193">
          <meta itemprop="thumbnailUrl" content="https://cdn.slidesharecdn.com/ss_thumbnails/09261330roomayoshihumikawai-190926055210-thumbnail.jpg?cb=1569478193">
          <meta itemprop="embedURL" content="https://www.slideshare.net/slideshow/embed_code/key/h7l40rS3W9o3dI">
          <meta itemprop="playerType" content="HTML5">
          <meta itemprop="interactionCount" content="UserComments:0">
          <meta itemprop="interactionCount" content="UserLikes:11">
          <meta itemprop="interactionCount" content="UserDownloads:59">
          <meta itemprop="interactionCount" content="UserPageVisits:24940">
          <meta itemprop="interactionCount" content="UserPlays:24940">
          <meta itemprop="interactionCount" content="UserPlusOnes:0" id="meta-google">


          

          <ul id="slideshow-actions">
            <li>
              
            </li>
              <li>
                
              </li>
              <li>
                
              </li>

            <!-- Report/Flag Content -->
            <li>
              <a data-dropdown="report-dropdown" aria-controls="report-dropdown" aria-expanded="false">
                <span>...</span></a>
              <span title="You have reported this as inappropriate">
                <i></i>
                <span aria-label="You have reported this as inappropriate"></span>
              </span>
              
            </li>
          </ul>


          <div itemprop="author" itemscope="" itemtype="https://schema.org/Organization">

            <p><a href="https://www.slideshare.net/UnityTechnologiesJapan002?utm_campaign=profiletracking&amp;utm_medium=sssite&amp;utm_source=ssslideview" title="UnityTechnologiesJapan002" itemprop="url">
                <img alt="UnityTechnologiesJapan002" itemprop="image" src="https://cdn.slidesharecdn.com/profile-photo-UnityTechnologiesJapan002-48x48.jpg?cb=1580098830">
              </a>
            </p>

            
          </div>

            

          <p>
            <small>
              Published on <time datetime="Sep 26, 2019" itemprop="datePublished">Sep 26, 2019</time>
            </small>
          </p>

            <div>
              <div data-ga-cat="bigfoot_slideview" data-ga-action="description>more">
                <div>
                  <div id="slideshow-description-paragraph"><p>
                    2019/9/25-6に開催されたUnite Tokyo 2019の講演スライドです。
<br>河合 宜文（株式会社Cysharp）
</p><p>
こんな</p></div>
                </div>
                
              </div>
            </div>


            



        </div>


        

            <div>
              
              <ol itemprop="text">
                    <li>
      1.
    Understanding
C# Struct
All Things
Cysharp, Inc.
Kawai Yoshifumi
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-2-638.jpg?cb=1569478193" title="About Speaker
2
— 河合 宜文 / Kawai Yoshifumi / @neuecc
— Cysha..." target="_blank">
        2.
      </a>
    About Speaker
2
— 河合 宜文 / Kawai Yoshifumi / @neuecc
— Cysharp, Inc. – CEO/CTO
— Microsoft MVP for Developer Technologies(C#)
— 50以上のOSS公開(UniRx, MagicOnion, MessagePack for C#, etc..)
— 株式会社Cysharp
— 2019年9月, Cygamesの子会社として設立
— C#関連の研究開発/OSS/コンサルティングを行う
— C#大統一理論(サーバー/クライアントともにC#で実装する)を推進
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-3-638.jpg?cb=1569478193" title="https://github.com/Cysharp
OSS for Unity – GitHub/Cysharp
3..." target="_blank">
        3.
      </a>
    https://github.com/Cysharp
OSS for Unity – GitHub/Cysharp
3
UniTask ★288
Provides an efficient async/await integration to
Unity.
RuntimeUnitTestToolkit ★87
CLI/GUI Frontend of Unity Test Runner to test on
any platforms.
RandomFixtureKit ★16
Fill random/edge-case value to target type for
unit testing.
MagicOnion ★1240
Unified Realtime/API Engine for .NET Core and
Unity.
MasterMemory ★407
Embedded Typed Readonly In-Memory
Document Database for .NET Core and Unity.
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-4-638.jpg?cb=1569478193" title="https://github.com/neuecc
OSS for Unity – GitHub/neuecc
4
L..." target="_blank">
        4.
      </a>
    https://github.com/neuecc
OSS for Unity – GitHub/neuecc
4
LINQ-to-GameObject-for-Unity ★448
Traverse GameObject Hierarchy by LINQ.
PhotonWire ★92
Typed Asynchronous RPC Layer for Photon.
SerializableDictionary ★87
SerializableCollections for Unity.
ReMotion ★27
Hyper Fast Reactive Tween Engine for Unity.
UniRx ★3722
Reactive Extensions for Unity.
MessagePack-CSharp ★2089
Extremely Fast MessagePack Serializer.
ZeroFormatter ★1778
Infinitely Fast Deserializer.
Utf8Json ★1352
Definitely Fastest JSON Serializer.
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-5-638.jpg?cb=1569478193" title="6
The Evolution of C# Struct
 " target="_blank">
        5.
      </a>
    6
The Evolution of C# Struct
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-6-638.jpg?cb=1569478193" title="MessagePack for C#(v2-preview)
7
public ref struct MessageP..." target="_blank">
        6.
      </a>
    MessagePack for C#(v2-preview)
7
public ref struct MessagePackWriter
T Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; byteSequence)
Span&lt;byte&gt; bytes = stackalloc byte[36];
internal ref partial struct SequenceReader&lt;T&gt;
where T : unmanaged, IEquatable&lt;T&gt;
public ref byte GetPointer(int sizeHint)
ref Entry v = ref entry[0];
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-7-638.jpg?cb=1569478193" title="MessagePack for C#(v2-preview)
8
public ref struct MessageP..." target="_blank">
        7.
      </a>
    MessagePack for C#(v2-preview)
8
public ref struct MessagePackWriter
T Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; byteSequence)
Span&lt;byte&gt; bytes = stackalloc byte[36];
internal ref partial struct SequenceReader&lt;T&gt;
where T : unmanaged, IEquatable&lt;T&gt;
ref struct
Span&lt;T&gt; = stackalloc
in parameter
where : unmanaged
public ref byte GetPointer(int sizeHint)
ref Entry v = ref entry[0];
ref return
ref local
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-8-638.jpg?cb=1569478193" title="DOTS(昨日の基調講演より)
 " target="_blank">
        8.
      </a>
    DOTS(昨日の基調講演より)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-9-638.jpg?cb=1569478193" title="DOTS(昨日の基調講演より)
 " target="_blank">
        9.
      </a>
    DOTS(昨日の基調講演より)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-10-638.jpg?cb=1569478193" title="What’s new struct features
11
C# 7.2 C# 7.3 C# 8.0
in modif..." target="_blank">
        10.
      </a>
    What’s new struct features
11
C# 7.2 C# 7.3 C# 8.0
in modifier on parameter
ref readonly modifier on
method returns, local
readonly struct
declaration
ref struct declaration
ref extension method
stackalloc to Span
reassign ref local
additional generics
constraints(unmanage
d, Enum, Delegate)
stackalloc initializer
access fixed field
without pinning
readonly method
Disposable ref structs
Unmanaged
constructed types
https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/
C# 7.0
ref return statement
ref local variables
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-11-638.jpg?cb=1569478193" title="12
Which Unity Version should we support?
Unity Version C# ..." target="_blank">
        11.
      </a>
    12
Which Unity Version should we support?
Unity Version C# Version .NET Version
Unity 2017.4 6.0 .NET 3.5/.NET 4.6
Unity 2018.2 6.0 .NET 4.x/Standard 2.0
Unity 2018.3 7.3 .NET 4.x/Standard 2.0
Unity 2018.4 7.3 .NET 4.x/Standard 2.0
Unity 2019.1 7.3 .NET 4.x/Standard 2.0
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-12-638.jpg?cb=1569478193" title="13
Which Unity Version should we support?
Unity Version C# ..." target="_blank">
        12.
      </a>
    13
Which Unity Version should we support?
Unity Version C# Version .NET Version
Unity 2017.4 6.0 .NET 3.5/.NET 4.6
Unity 2018.2 6.0 .NET 4.x/Standard 2.0
Unity 2018.3 7.3 .NET 4.x/Standard 2.0
Unity 2018.4 7.3 .NET 4.x/Standard 2.0
Unity 2019.1 7.3 .NET 4.x/Standard 2.0
2018.3以上一択、それ以下の
バージョンはNot Supported
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-13-638.jpg?cb=1569478193" title="14
Which Unity Version should we support?
Unity Version C# ..." target="_blank">
        13.
      </a>
    14
Which Unity Version should we support?
Unity Version C# Version .NET Version
Unity 2017.4 6.0 .NET 3.5/.NET 4.6
Unity 2018.2 6.0 .NET 4.x/Standard 2.0
Unity 2018.3 7.3 .NET 4.x/Standard 2.0
Unity 2018.4 7.3 .NET 4.x/Standard 2.0
Unity 2019.1 7.3 .NET 4.x/Standard 2.0
2018.3から以下の言語に関するdefineが使える
CSHARP_7_3_OR_NEWER
以下のどちらか選んだほうが定義される
NET_4_6
NET_STANDARD_2_0
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-14-638.jpg?cb=1569478193" title="Struct is important for Performance!
15
— C# 7以降の急速なstruct強..." target="_blank">
        14.
      </a>
    Struct is important for Performance!
15
— C# 7以降の急速なstruct強化はパフォーマンスのため
— それは .NET Core でも、Unityでも
— アプローチは異なれど、両者とも構造体をパフォーマンスのため活用している
— 特にUnityの推すDOTS(Data Oriented Technology Stack)はstructの塊
— 今、全てを学び、備えよう
public unsafe ref struct BlobBuilderArray&lt;T&gt;
where T : struct
public unsafe static ref T AsRef&lt;T&gt;(void* ptr) where T : struct
public readonly struct BuildComponentDataToEntityLookupTask&lt;TComponentData&gt; : IDisposable
where TComponentData : unmanaged, IComponentData, IEquatable&lt;TComponentData&gt;
Unity ECSの中の
C# 7.3表現
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-15-638.jpg?cb=1569478193" title="16
The Basic of C# Memory
 " target="_blank">
        15.
      </a>
    16
The Basic of C# Memory
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-16-638.jpg?cb=1569478193" title="The Memory of C#
17
AppDomain(Managed)
Thread
Stack
HeapThr..." target="_blank">
        16.
      </a>
    The Memory of C#
17
AppDomain(Managed)
Thread
Stack
HeapThread
Stack
Unmanaged
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-17-638.jpg?cb=1569478193" title="The Memory of C#
18
AppDomain(Managed)
Thread
Stack
HeapThr..." target="_blank">
        17.
      </a>
    The Memory of C#
18
AppDomain(Managed)
Thread
Stack
HeapThread
Stack
Unmanaged
ローカル変数はスタック領域に格納される
ヒープ領域に確保されたデータは
GCの管理化に入る
UnityではC#管理外のメモリを扱う
こともよくある(特にDOTS)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-18-638.jpg?cb=1569478193" title="Let’s see memory layout
19
— SharpLabでメモリの中身を見よう！
— https:/..." target="_blank">
        18.
      </a>
    Let’s see memory layout
19
— SharpLabでメモリの中身を見よう！
— https://sharplab.io/
— C# to IL, C# to C#, C# to ASMなど豊富な機能がある
— Run と Inspectを組み合わせるとメモリの中身が見れる
なお、組み込み型の場合、Unity(mono)
とSharpLab(.NET Core)で中身が異なる
ことがある場合に注意
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-19-638.jpg?cb=1569478193" title="Struct Memory
Int(4バイト)のX, Y, Z(12バイト)が
素直にメモリ上(スタック)に並ぶ
 " target="_blank">
        19.
      </a>
    Struct Memory
Int(4バイト)のX, Y, Z(12バイト)が
素直にメモリ上(スタック)に並ぶ
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-20-638.jpg?cb=1569478193" title="Class Memory
スタック上の変数はヒープ上
のアドレスを指す
ヒープ上に確保されるメモリは管理
用のヘッダ/..." target="_blank">
        20.
      </a>
    Class Memory
スタック上の変数はヒープ上
のアドレスを指す
ヒープ上に確保されるメモリは管理
用のヘッダ/型情報 + 実データ
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-21-638.jpg?cb=1569478193" title="Pass by Reference/Pass by Value
22
— C#はデフォルトは全て「値渡し」
— つまり..." target="_blank">
        21.
      </a>
    Pass by Reference/Pass by Value
22
— C#はデフォルトは全て「値渡し」
— つまりコピーされます
— ローカル変数への代入もコピー
(T x) (ref T x)
class 参照の値渡し 参照の参照渡し
struct 値の値渡し 値の参照渡し
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-22-638.jpg?cb=1569478193" title="スタック領域は大体この辺っぽい
 " target="_blank">
        22.
      </a>
    スタック領域は大体この辺っぽい
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-23-638.jpg?cb=1569478193" title="00 00 00 00 からそれっぽ
いデータが入った気配
 " target="_blank">
        23.
      </a>
    00 00 00 00 からそれっぽ
いデータが入った気配
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-24-638.jpg?cb=1569478193" title="引き続き、 y = x で同じデ
ータが追加で入ったっぽい
 " target="_blank">
        24.
      </a>
    引き続き、 y = x で同じデ
ータが追加で入ったっぽい
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-25-638.jpg?cb=1569478193" title="別のところにxとyがコピー
されて入った気配
 " target="_blank">
        25.
      </a>
    別のところにxとyがコピー
されて入った気配
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-26-638.jpg?cb=1569478193" title="戻りのzを受け取って全部
埋まった
 " target="_blank">
        26.
      </a>
    戻りのzを受け取って全部
埋まった
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-27-638.jpg?cb=1569478193" title="int x
int y
int z
コンパイル時(C# -> IL)の段
階で変数の置き場確保してお
きます、的な
 " target="_blank">
        27.
      </a>
    int x
int y
int z
コンパイル時(C# -&gt; IL)の段
階で変数の置き場確保してお
きます、的な
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-28-638.jpg?cb=1569478193" title="Structの基本的な原則
29
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピー..." target="_blank">
        28.
      </a>
    Structの基本的な原則
29
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピーにより引き起こされる
— 大きなサイズの構造体を（基本的には）作らない
– IntPtr.Size(4 or 8バイト)以上は参照渡しに比べて大きいということになる
– それだと制限キツすぎなので、一般には16バイト以下ぐらいを目安に
— 変更可能な構造体を（基本的には）作らない
– コピーされることによって、変更したつもりが変更されない
– 一度は悩むVector3変更されない問題
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-29-638.jpg?cb=1569478193" title="Structの基本的な原則
30
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピー..." target="_blank">
        29.
      </a>
    Structの基本的な原則
30
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピーにより引き起こされる
— 大きなサイズの構造体を（基本的には）作らない
– IntPtr.Size(4 or 8バイト)以上は参照渡しに比べて大きいということになる
– それだと制限キツすぎなので、一般には16バイト以下ぐらいを目安に
— 変更可能な構造体を（基本的には）作らない
– コピーされることによって、変更したつもりが変更されない
– 一度は悩むVector3変更されない問題
// position変えたつもりが変わらない！
this.transform.position.Set(10f, 20f, 30f);
// つまりこういうことだから
this.transform.INTERNAL_get_position(out Vector3 value);
value.Set(10f, 20f, 30f);
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-30-638.jpg?cb=1569478193" title="Structの基本的な原則
31
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピー..." target="_blank">
        30.
      </a>
    Structの基本的な原則
31
— 全てはコピーに気をつける、ということ
— クラスとの違い、ほとんどの問題はコピーにより引き起こされる
— 大きなサイズの構造体を（基本的には）作らない
– IntPtr.Size(4 or 8バイト)以上は参照渡しに比べて大きいということになる
– それだと制限キツすぎなので、一般には16バイト以下ぐらいを目安に
— 変更可能な構造体を（基本的には）作らない
– コピーされることによって、変更したつもりが変更されない
– 一度は悩むVector3変更されない問題
// position変えたつもりが変わらない！
this.transform.position.Set(10f, 20f, 30f);
// つまりこういうことだから
this.transform.INTERNAL_get_position(out Vector3 value);
value.Set(10f, 20f, 30f);
positionがプロパティなのが悪い
(フィールドならコピーの問題は起きない)
が、これはtransformのデータの実体は
アンマネージドメモリ側(UnityEngine)にある
ためという、Unityならではの悩みでもある
(C#/C++越境がどうしても抱える話)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-31-638.jpg?cb=1569478193" title="Boxed Struct
ボックス化
スタック上の変数は
ヒープのアドレス ヒープ上にクラスと
同様ヘッダが付いた
う..." target="_blank">
        31.
      </a>
    Boxed Struct
ボックス化
スタック上の変数は
ヒープのアドレス ヒープ上にクラスと
同様ヘッダが付いた
うえで領域確保
アンボックスの毎に
ここからスタックへ
コピーする
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-32-638.jpg?cb=1569478193" title="Box化との戦い
33
— ボックス化はnewと一緒
— むしろアンボックスの頻度的により悪い
— ボックス化が避けら..." target="_blank">
        32.
      </a>
    Box化との戦い
33
— ボックス化はnewと一緒
— むしろアンボックスの頻度的により悪い
— ボックス化が避けられないなら最初からクラスで作ることも選択肢
— インターフェイスへのキャストに気をつける
– ジェネリクスを使って回避していく
– enumの場合はEnum(参照型)も同様
public static class BoxedInt
{
public static readonly object Zero = 0;
public static readonly object One = 1;
public static readonly object MinusOne = -1;
}
ある程度決まった値が頻繁にボッ
クス化されるようなら、先に作っ
ておいて使い回すという技
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-33-638.jpg?cb=1569478193" title="Equalsの自動実装とBox化
34
— structはEqualsが実装されていない場合、自動的に以下のものが呼ば..." target="_blank">
        33.
      </a>
    Equalsの自動実装とBox化
34
— structはEqualsが実装されていない場合、自動的に以下のものが呼ばれる
— めっちゃ遅い
— Equalsは辞書のKeyにすると呼ばれる！
そのため辞書のKeyにする構造体は
IEquatable&lt;T&gt;とGetHashCodeの
カスタム実装を必ず行うこと
internal static bool DefaultEquals(object o1, object o2)
{
RuntimeType o1_type = (RuntimeType)o1.GetType();
RuntimeType o2_type = (RuntimeType)o2.GetType();
object[] fields;
InternalEquals(o1, o2, out fields);
for (int i = 0; i &lt; fields.Length; i += 2)
{
object meVal = fields[i];
object youVal = fields[i + 1];
if (!meVal.Equals(youVal)) return false;
}
return true;
}
object, object比較のボクシング
そもそもリフレクションで全フィ
ールド比較（遅い）うえに、フィ
ールドの戻り値もボクシング
原理主義的には可能なもの全てのStructにカスタム実装を入
れたほうがいい、ということになるけれど、あまりにも面倒
なので、さすがにそこはピンポイント(辞書のKeyになるもの
だけ)でいいと思います
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-34-638.jpg?cb=1569478193" title="Struct Layout and Padding
単純計算ではbyte(1) + long(8) + int(4) ..." target="_blank">
        34.
      </a>
    Struct Layout and Padding
単純計算ではbyte(1) + long(8) + int(4) = 13ですが、
アラインメント調整のため、最長の8にそれぞれが合
わせられて8 * 3 = 24バイトの確保になっている
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-35-638.jpg?cb=1569478193" title="Struct Layout and Padding StructLayoutやFieldOffsetによってレイアウ
..." target="_blank">
        35.
      </a>
    Struct Layout and Padding StructLayoutやFieldOffsetによってレイアウ
トはカスタマイズ可能。
structのデフォルトはSequential(宣言順)
Autoに変えると、ZとXが詰められることで最
小の16バイトに縮む
参照型はstructと異なりデフォ
ルトがAuto
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-36-638.jpg?cb=1569478193" title="Heap Layout: Array
オブジェクトの共通ヘッダの後
ろに長さが付いてる
データ領域には要素がそのまま順..." target="_blank">
        36.
      </a>
    Heap Layout: Array
オブジェクトの共通ヘッダの後
ろに長さが付いてる
データ領域には要素がそのまま順番に並ぶ。構造体な
ら、値がそのまま順番に並んでいることになる（参照
型の場合はポインタが並んでいるため、実態のデータ
を更に辿る必要がある）
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-37-638.jpg?cb=1569478193" title="38
ref and readonly
 " target="_blank">
        37.
      </a>
    38
ref and readonly
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-38-638.jpg?cb=1569478193" title="Zero Allocation foreach in List<T>
39
— foreachは .GetEnumer..." target="_blank">
        38.
      </a>
    Zero Allocation foreach in List&lt;T&gt;
39
— foreachは .GetEnumerator -&gt; while(MoveNext()) に変換される
— （ただし配列の場合はコンパイル時にILでforに変換される）
— つまり IEnumerator が生成されてヒープに確保されている？
— されるようでされない
var list = new List&lt;int&gt;() { 1, 2, 3 };
foreach (var item in list)
{
/* do anything */
}
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-39-638.jpg?cb=1569478193" title="Mutable Struct is Evil but Useful
40
— 一時的な入れ物として使うものに向いてる
..." target="_blank">
        39.
      </a>
    Mutable Struct is Evil but Useful
40
— 一時的な入れ物として使うものに向いてる
public struct Enumerator : IEnumerator&lt;T&gt;
{
List&lt;T&gt; list;
int index;
int version;
T current;
}
public struct BinaryReader
{
byte[] bytes;
int offset;
}
List&lt;T&gt;は直接GetEnumeratorを呼べる
状況ではstruct List&lt;T&gt;.Enumerator を
返すためゼロアロケーション
バイナリを読みすすめる際にReadXxx
を呼ぶたびにoffsetを追加していくとい
うステートを管理
局所的にしか使わないので
classじゃなくてもいい
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-40-638.jpg?cb=1569478193" title="ref struct
41
— スタックにしか置けないという制約がref struct
– 元々はSpan<T>(Sy..." target="_blank">
        40.
      </a>
    ref struct
41
— スタックにしか置けないという制約がref struct
– 元々はSpan&lt;T&gt;(System.Memory, .NET Standard 2.0外部ライブラリ)のため
– Span&lt;T&gt;は連続したメモリ領域のビューで、配列のように扱える(NativeArrayみたいな)
– 今までポインタでしか扱えなかったstackallocを自然に扱えて便利
– しかしそれによってスタックにのみ確保したメモリ領域をヒープに移されると危険
– フィールドに置けない(ref structのfieldの場合のみ可)、ボクシングできない、インターフ
ェイスを実装できない、ジェネリクスの型引数にできない、などの制約がある
— ビュー的なものや一時的にしか使わない状態を持つものには適用しやすい
– 制約が多いので無理に使おうとするとハマりますが……
Span&lt;int&gt; temp = stackalloc int[12];
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-41-638.jpg?cb=1569478193" title="internal ref struct TempList<T>
{
int index;
T[] array;
pub..." target="_blank">
        41.
      </a>
    internal ref struct TempList&lt;T&gt;
{
int index;
T[] array;
public ReadOnlySpan&lt;T&gt; Span =&gt; new ReadOnlySpan&lt;T&gt;(array, 0, index);
public TempList(int initialCapacity)
{
this.array = ArrayPool&lt;T&gt;.Shared.Rent(initialCapacity);
this.index = 0;
}
public void Add(T value)
{
if (array.Length &lt;= index)
{
var newArray = ArrayPool&lt;T&gt;.Shared.Rent(index * 2);
Array.Copy(array, newArray, index);
ArrayPool&lt;T&gt;.Shared.Return(array, true);
array = newArray;
}
array[index++] = value;
}
public void Dispose()
{
ArrayPool&lt;T&gt;.Shared.Return(array, true); // clear for de-reference all.
}
}
ArrayPool(System.Buffers, Unityで
は似たようなものを自作すれば……)
から確保済み配列を取得し使う
Disposeで返却
一時的にしか使わない配
列を都度確保せずプール
から取得するための構造
(TempList&lt;T&gt;)
プールを扱っているので、
寿命は明確に短くあって
ほしいのでref struct
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-42-638.jpg?cb=1569478193" title="public void DoNanika(IEnumerable<int> idList)
{
var resourc..." target="_blank">
        42.
      </a>
    public void DoNanika(IEnumerable&lt;int&gt; idList)
{
var resources = idList.Select(x =&gt; Load(x));
// LINQの遅延実行により二回のLoadが走ってしまう
// それを避けるために .ToList() するとそれはそれでListの無駄を感じる
foreach (var item in resources) { /* nanika suru 1 */ }
foreach (var item in resources) { /* nanika suru 2 */ }
}
public void DoNanika(IEnumerable&lt;int&gt; idList)
{
using var resources = idList.Select(x =&gt; Load(x)).ToTempList();
foreach (var item in resources) { /* nanika suru 1 */ }
foreach (var item in resources) { /* nanika suru 2 */ }
}
usingだけで末尾で
Disposeが便利
(C# 8.0から！
Unityではまだ！)
ここの中だけで使う一時配列はPoolから
取ってるのでアロケートなしで済んだ
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-43-638.jpg?cb=1569478193" title="Avoid the copy, Everywhere
44
— 全て ref で引き回せばいい、とはいうものの現実的で..." target="_blank">
        43.
      </a>
    Avoid the copy, Everywhere
44
— 全て ref で引き回せばいい、とはいうものの現実的ではない
— あまりにも最悪な書き心地になる！
— あるいは全てunsafeでポインタで取り回すという手も……
— Unity.Entitiesのソースコードはかなりそれに近い
[StructLayout(LayoutKind.Sequential)]
internal unsafe struct Archetype
{
public ArchetypeChunkData Chunks;
public UnsafeChunkPtrList ChunksWithEmptySlots;
public ChunkListMap FreeChunksBySharedComponents;
public int EntityCount;
public int ChunkCapacity;
public int BytesPerInstance;
public ComponentTypeInArchetype* Types;
public int TypesCount;
public int NonZeroSizedTypesCount;
public int* Offsets;
public int* SizeOfs;
public int* BufferCapacities;
public int* TypeMemoryOrder;
public int* ManagedArrayOffset;
public int NumManagedArrays;
// ... まだまだいっぱい
void AddArchetypeIfMatching(
Archetype* archetype,
EntityQueryData* query)
(ECSより引用)とにかく巨大なStruct
全部ポインタで引き回すからOK(？)
（ECSはネイティブメモリを使ったり色々
と固有の事情があるので一般論は適用で
きない）
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-44-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
}
static void In(in Vector..." target="_blank">
        44.
      </a>
    static void Normal(Vector3 v3)
{
}
static void In(in Vector3 v3)
{
}
static void Ref(ref Vector3 v3)
{
}
Avoid the copy, Everywhere
45
そこで登場するのが新しいキーワード
“in”
(このコード例自体には何の意味もないです)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-45-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
}
static void In(in Vector..." target="_blank">
        45.
      </a>
    static void Normal(Vector3 v3)
{
}
static void In(in Vector3 v3)
{
}
static void Ref(ref Vector3 v3)
{
}
Avoid the copy, Everywhere
46
Normal(v3);
In(v3);
Ref(ref v3);
呼び側のコード
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-46-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
}
static void In(in Vector..." target="_blank">
        46.
      </a>
    static void Normal(Vector3 v3)
{
}
static void In(in Vector3 v3)
{
}
static void Ref(ref Vector3 v3)
{
}
Avoid the copy, Everywhere
47
ldloc.0
call Noraml
ldloca.0
call In
ldloca.0
call Ref
Normal(v3);
In(v3);
Ref(ref v3);
呼び側のIL
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-47-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
}
static void In(in Vector..." target="_blank">
        47.
      </a>
    static void Normal(Vector3 v3)
{
}
static void In(in Vector3 v3)
{
}
static void Ref(ref Vector3 v3)
{
}
Avoid the copy, Everywhere
48
ldloc.0
call Noraml
ldloca.0
call In
ldloca.0
call Ref
呼び方は普通と一緒なのに
refと同じく参照渡しされる！
Normal(v3);
In(v3);
Ref(ref v3);
じゃあ全部 in でいいね！
（にはならない）
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-48-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
_ = v3.magnitude;
}
static..." target="_blank">
        48.
      </a>
    static void Normal(Vector3 v3)
{
_ = v3.magnitude;
}
static void In(in Vector3 v3)
{
_ = v3.magnitude;
}
static void Ref(ref Vector3 v3)
{
_ = v3.magnitude;
}
Avoid the copy, Everywhere
49
ldarga.0
call get_magnitude
ldarg.0
ldobj
stloc.0
ldloca.0
call get_magnitude
ldarg.0
call get_magnitude
呼ばれ側のIL
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-49-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
_ = v3.magnitude;
}
static..." target="_blank">
        49.
      </a>
    static void Normal(Vector3 v3)
{
_ = v3.magnitude;
}
static void In(in Vector3 v3)
{
_ = v3.magnitude;
}
static void Ref(ref Vector3 v3)
{
_ = v3.magnitude;
}
Avoid the copy, Everywhere
50
ldarga.0
call get_magnitude
ldarg.0
ldobj
stloc.0
ldloca.0
call get_magnitude
ldarg.0
call get_magnitude
呼ばれ側のIL
コピーされてる（防御的コピー）
var v3_2 = v3;
_ = v3_2.magnitude;
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-50-638.jpg?cb=1569478193" title="static void Normal(Vector3 v3)
{
_ = v3.magnitude;
_ = v3.m..." target="_blank">
        50.
      </a>
    static void Normal(Vector3 v3)
{
_ = v3.magnitude;
_ = v3.magnitude;
}
static void In(in Vector3 v3)
{
_ = v3.magnitude;
_ = v3.magnitude;
}
static void Ref(ref Vector3 v3)
{
_ = v3.magnitude;
_ = v3.magnitude;
}
Avoid the copy, Everywhere
51
ldarga.0
call get_magnitude
ldarg.0
ldobj
stloc.0
ldloca.0
call get_magnitude
ldarg.0
call get_magnitude
呼ばれ側のIL
二回呼べばコピーもそのまま二つ
ldarga.0
call get_magnitude
ldarg.0
ldobj
stloc.0
ldloca.0
call get_magnitude
ldarg.0
call get_magnitude
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-51-638.jpg?cb=1569478193" title="Best practice to use `in`
52
— in はコンパイルすると([In][IsReadOnly..." target="_blank">
        51.
      </a>
    Best practice to use `in`
52
— in はコンパイルすると([In][IsReadOnly]ref T t) になる
— 読み取り専用のため、フィールドへの代入はできない
— v3.x = 10.0f; // compile error
— メソッド呼び出しは可能だが、中身が変わらない保証がないため防御的コピーが走る
— そのため、うかつに多用すると防御的コピーにより、むしろ性能低下もありうる
— もしそれがMutable Structだともはやわけわからないことに
— (Vector3.magnitudeはプロパティなのでメソッド扱い)
— 防御的コピーが走らない条件は
– プロパティ/メソッドを呼ばないこと
– あるいは readonly struct であること
– readonly structは書き換わらないことが保証されるため防御的コピーが走らない
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-52-638.jpg?cb=1569478193" title="Best practice to use `in`
53
— in はコンパイルすると([In][IsReadOnly..." target="_blank">
        52.
      </a>
    Best practice to use `in`
53
— in はコンパイルすると([In][IsReadOnly]ref T t) になる
— 読み取り専用のため、フィールドへの代入はできない
— v3.x = 10.0f; // compile error
— メソッド呼び出しは可能だが、中身が変わらない保証がないため防御的コピーが走る
— そのため、うかつに多用すると防御的コピーにより、むしろ性能低下もありうる
— もしそれがMutable Structだともはやわけわからないことに
— 防御的コピーが走らない条件は
– プロパティ/メソッドを呼ばないこと
– あるいは readonly struct であること
– readonly structは書き換わらないことが保証されるため防御的コピーが走らない
public readonly struct MyVector3
{
public readonly float x;
public readonly float y;
public readonly float z;
public MyVector3(float x, float y, float z)
{
this.x = x; this.y = y; this.z = z;
}
readonly structの条件は全てのフィ
ールドがreadonlyであること
ref readonly structもOK
原則inの引数はreadonly struct
中でフィールドしか絶対触らないと力
強く言えるならナシではない
よくわからないなら基本使わない
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-53-638.jpg?cb=1569478193" title="readonly field(struct)の罠
54
— readonlyなfieldのstructにmutable..." target="_blank">
        53.
      </a>
    readonly field(struct)の罠
54
— readonlyなfieldのstructにmutableな操作を行っても変更されない
— よって、ミュータブルな操作を行うものはreadonly fieldにすべきではない
— 原則的には「可能なものは」と言いたいところだけど
Unityの場合、可能なものが多いので……
public class NantokaBehaviour : MonoBehaviour
{
public readonly Vector3 NanikanoVector3;
public void Incr()
{
NanikanoVector3.Set(
NanikanoVector3.x + 1f,
NanikanoVector3.y + 1f,
NanikanoVector3.z + 1f);
}
}
何回Incr呼んでも0, 0, 0のまま
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-54-638.jpg?cb=1569478193" title="55
Manipulate Memory
 " target="_blank">
        54.
      </a>
    55
Manipulate Memory
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-55-638.jpg?cb=1569478193" title="改めてStructとは
56
— メモリを単純にマッピングした構造
– そのことだけ意識すれば、あとはやりたい放題でき..." target="_blank">
        55.
      </a>
    改めてStructとは
56
— メモリを単純にマッピングした構造
– そのことだけ意識すれば、あとはやりたい放題できる
[StructLayout(LayoutKind.Sequential, Size = 16)]
public struct Empty16
{
}
public struct LongLong
{
public long X;
public long Y;
}
どちらも連続して16バイトの
領域を確保しているだけ、とい
う意味（に読める）
インデックス0とインデックス
8にアクセスしやすくしている
だけ（という風に読める）
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-56-638.jpg?cb=1569478193" title="57
// 先頭6バイトがTimestamp, 後ろ10バイトがランダムというUlidという仕様(ソート可能なGuid..." target="_blank">
        56.
      </a>
    57
// 先頭6バイトがTimestamp, 後ろ10バイトがランダムというUlidという仕様(ソート可能なGuidの代替)
[StructLayout(LayoutKind.Explicit, Size = 16)]
public struct Ulid
{
// TimestampとRandomnessのはじまりの部分だけ持っておく(最悪なくても別にいい)
[FieldOffset(0)] byte timestamp0;
[FieldOffset(6)] byte randomness0;
public static Ulid NewUlid()
{
var memory = default(Ulid); // 16バイト確保
var timestampMilliseconds = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
ref var fisrtByte = ref Unsafe.As&lt;long, byte&gt;(ref timestampMilliseconds);
Unsafe.Add(ref memory.timestamp0, 0) = Unsafe.Add(ref fisrtByte, 5);
Unsafe.Add(ref memory.timestamp0, 1) = Unsafe.Add(ref fisrtByte, 4);
Unsafe.Add(ref memory.timestamp0, 2) = Unsafe.Add(ref fisrtByte, 3);
Unsafe.Add(ref memory.timestamp0, 3) = Unsafe.Add(ref fisrtByte, 2);
Unsafe.Add(ref memory.timestamp0, 4) = Unsafe.Add(ref fisrtByte, 1);
Unsafe.Add(ref memory.timestamp0, 5) = Unsafe.Add(ref fisrtByte, 0);
Unsafe.WriteUnaligned(ref memory.randomness0, xorshift.NextULong());
Unsafe.WriteUnaligned(ref Unsafe.Add(ref memory.randomness0, 2), xorshift.NextULong());
return memory;
}
Ulid:
[Timestamp(6),
Randomness(10)]
の実装
(System.Runtime
.CompilerService
s.Unsafeを利用、
Unityでも動きま
すが別途参照は必
要、ポインタでや
ってもいいです)
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-57-638.jpg?cb=1569478193" title="58
// 先頭6バイトがTimestamp, 後ろ10バイトがランダムというUlidという仕様(ソート可能なGuid..." target="_blank">
        57.
      </a>
    58
// 先頭6バイトがTimestamp, 後ろ10バイトがランダムというUlidという仕様(ソート可能なGuidの代替)
[StructLayout(LayoutKind.Explicit, Size = 16)]
public struct Ulid
{
// TimestampとRandomnessのはじまりの部分だけ持っておく(最悪なくても別にいい)
[FieldOffset(0)] byte timestamp0;
[FieldOffset(6)] byte randomness0;
public static Ulid NewUlid()
{
var memory = default(Ulid); // 16バイト確保
var timestampMilliseconds = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
ref var fisrtByte = ref Unsafe.As&lt;long, byte&gt;(ref timestampMilliseconds);
Unsafe.Add(ref memory.timestamp0, 0) = Unsafe.Add(ref fisrtByte, 5);
Unsafe.Add(ref memory.timestamp0, 1) = Unsafe.Add(ref fisrtByte, 4);
Unsafe.Add(ref memory.timestamp0, 2) = Unsafe.Add(ref fisrtByte, 3);
Unsafe.Add(ref memory.timestamp0, 3) = Unsafe.Add(ref fisrtByte, 2);
Unsafe.Add(ref memory.timestamp0, 4) = Unsafe.Add(ref fisrtByte, 1);
Unsafe.Add(ref memory.timestamp0, 5) = Unsafe.Add(ref fisrtByte, 0);
Unsafe.WriteUnaligned(ref memory.randomness0, xorshift.NextULong());
Unsafe.WriteUnaligned(ref Unsafe.Add(ref memory.randomness0, 2), xorshift.NextULong());
return memory;
}
// メモリ領域をコピーすればおｋ。
// 文字列表現としてBase32エンコード(ToString)も同様に自分のメモリ粋から算出
public bool TryWriteBytes(Span&lt;byte&gt; destination)
{
if (destination.Length &lt; 16)
{
return false;
}
Unsafe.WriteUnaligned(ref MemoryMarshal.GetReference(destination), this)
return true;
}
出力先としてbyte[]とstringがあればそれでいい
それらはほとんどメモリコピーで実現する
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-58-638.jpg?cb=1569478193" title="Union
59
[StructLayout(LayoutKind.Explicit, Pack = 1)]
inte..." target="_blank">
        58.
      </a>
    Union
59
[StructLayout(LayoutKind.Explicit, Pack = 1)]
internal struct GuidBits
{
[FieldOffset(0)]
public readonly Guid Value;
[FieldOffset(0)]
public readonly byte Byte0;
[FieldOffset(1)]
public readonly byte Byte1;
[FieldOffset(2)]
public readonly byte Byte2;
[FieldOffset(3)]
public readonly byte Byte3;
/* 中略(Byte4~Byte11) */
[FieldOffset(12)]
public readonly byte Byte12;
[FieldOffset(13)]
public readonly byte Byte13;
[FieldOffset(14)]
public readonly byte Byte14;
[FieldOffset(15)]
public readonly byte Byte15;
Guidとbyte0~16の重ね合わせ
(同一FieldOffset)
通常Stringかbyte[]からしか生成でき
ないGuidを、byte0~16を埋めるだけ
で自由に生成する(本来弄れないGuid
としてのメモリ領域を重ね合わせて
安全に(not unsafe)弄る)
MessagePack for C#でUtf8 Bytesのス
ライスから文字列のアロケーションを避
けて直接Guidに変換するのに利用
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-59-638.jpg?cb=1569478193" title="改めてStructが要素の配列とは
60
— メモリにStructが単純に並んでいる
X Y Z X Y Z X Y ..." target="_blank">
        59.
      </a>
    改めてStructが要素の配列とは
60
— メモリにStructが単純に並んでいる
X Y Z X Y Z X Y Z X Y ZVector3[]
メモリをまるごとコピーするだけで
最速のシリアライズだよね説
（エンディアンは揃える）
実際MagicOnionで有効にすることが可
能(サーバーもC#なので直接メモリをぶ
ん投げて受け取るのが簡単)
ただしStructの中には参照型(String含
む)は含めないこと。ポイン タをコピー
しても意味がない
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-60-638.jpg?cb=1569478193" title="61
public class UnsafeDirectBlitArrayFormatter<T> : IMessag..." target="_blank">
        60.
      </a>
    61
public class UnsafeDirectBlitArrayFormatter&lt;T&gt; : IMessagePackFormatter&lt;T[]&gt; where T : struct
{
public unsafe int Serialize(ref byte[] bytes, int offset, T[] value)
{
var startOffset = offset;
var byteLen = value.Length * UnsafeUtility.SizeOf&lt;T&gt;();
/* 中略(MsgPackでのExtヘッダー書き込み) */
ulong handle2;
var srcPointer = UnsafeUtility
.PinGCArrayAndGetDataAddress(value, out handle2);
try
{
fixed (void* dstPointer = &amp;bytes[offset])
{
UnsafeUtility.MemCpy(dstPointer, srcPointer, byteLen);
}
}
finally
{
UnsafeUtility.ReleaseGCObject(handle2);
}
// ...
}
T[]をbytesにシリアライズ
memcpyするだけ
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-61-638.jpg?cb=1569478193" title="62
Span and NativeArray
 " target="_blank">
        61.
      </a>
    62
Span and NativeArray
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-62-638.jpg?cb=1569478193" title="Span vs NativeArray
63
— Span<T>
— System.Memory
— .NET Sta..." target="_blank">
        62.
      </a>
    Span vs NativeArray
63
— Span&lt;T&gt;
— System.Memory
— .NET Standard 2.1では標準(現在は外部ライブラリが必要)
— C# 7.2と統合されている
— あらゆる連続したメモリ領域のビュー
— 配列、stackalloc、ネイティブメモリ(ポインタ)、文字列(String)
— NativeArray
— Unity固有, 特にDOTSのキーパーツ
— UnsafeUtility.Malloc で獲得するUnmanaged Memoryのビュー
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-63-638.jpg?cb=1569478193" title="フレームワーク対応がないと意味がない
64
— Span<T>
— 今までのAPIがT[]しか受け入れなかったりすると..." target="_blank">
        63.
      </a>
    フレームワーク対応がないと意味がない
64
— Span&lt;T&gt;
— 今までのAPIがT[]しか受け入れなかったりすると、結局T[]への変換が必要になる
— 無駄アロケート
— .NET Core 2.1で対応充実させ中
— 例えばConvert.ToBase64Stringがbyte[]のほかReadOnlySpan&lt;byte&gt;を受けとる
— つまりUnityではAPI側の対応がほとんどないのでSpanだけ入れても意味は限定的
— NativeArray
— DOTS周辺で使えるけれど、やはり一部のAPIは対応が必要
— 例えばMesh.SetVertexBufferDataとしてList&lt;T&gt;やT[]以外にNativeArray&lt;T&gt;を受け
取るようになったのは 2019.3から
— というように、スムーズに全体的に統合されていくのはもうちょっとかな？
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-64-638.jpg?cb=1569478193" title="65
Conclusion
 " target="_blank">
        64.
      </a>
    65
Conclusion
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-65-638.jpg?cb=1569478193" title="の前に。
66
— 構造体の色をクラスとは別の色に変更しておこう！
– 性能特性が異なるもののため、見分けがつくと、と..." target="_blank">
        65.
      </a>
    の前に。
66
— 構造体の色をクラスとは別の色に変更しておこう！
– 性能特性が異なるもののため、見分けがつくと、とても楽になる
 
  </li>
  <li>
      <a href="https://image.slidesharecdn.com/09261330roomayoshihumikawai-190926055210/95/unite-tokyo-2019understanding-c-struct-all-things-66-638.jpg?cb=1569478193" title="Structを恐れない
67
— Structの使いこなし自体は、もはや必須
– Classを優先する牧歌的時代は終わ..." target="_blank">
        66.
      </a>
    Structを恐れない
67
— Structの使いこなし自体は、もはや必須
– Classを優先する牧歌的時代は終わった
– 確かに罠は（いっぱい）あるが、難しい話ではない
– 覚えるパターンが（ちょっと）多いだけで
— そしてこの流れは戻らない
– 言語強化から、フレームワークの抜本的変更まで、時代は既に来てる
– ……とはいえ、じゃあいきなりめっちゃ使うかと言うと、それはまた別の話
– 使うべき時に使い、読めるようにするという、当たり前を大事にしよう
 
  </li>

              </ol>
            </div>
      </div>
    </div>

    
  </div>
</div>










      

      

        
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>