<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</h1><div><div class="post-content"><h2>Securing Your Blazor Apps (Part 2)</h2><hr><p>This is the second post in the series: Securing Your Blazor Apps. </p><p><strong>Part 1</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">Introduction to Authentication with server-side Blazor</a><br><strong>Part 2</strong> - Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity (this post)<br><strong>Part 3</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">Configuring Role-based Authorization with client-side Blazor</a><br><strong>Part 4</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-policy-based-authorization-with-blazor/">Configuring Policy-based Authorization with Blazor</a></p><hr><p>In <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">part 1</a> of this series, I showed how to create a server-side Blazor application with authentication enabled. </p><p>In this post, I'm going to show how to setup authentication with client-side Blazor using WebAPI and ASP.NET Core Identity.</p><blockquote>All the code for this post is available on <a href="https://github.com/chrissainty/AuthenticationWithClientSideBlazor">GitHub</a>.</blockquote><p>If you are not familiar with ASP.NET Core Identity then you can checkout the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-2.2&amp;tabs=visual-studio">Microsoft Docs site</a> for full and in-depth information.</p><h2 id="getting-setup-creating-the-solution">Getting Setup: Creating the solution</h2><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/08/Screenshot-2019-08-14-at-15.04.37.png" class="kg-image"></figure><p>Start by creating a new Blazor WebAssembly App (remember to tick the ASP.NET Core hosted checkbox), this template will create a Blazor application which runs in the clients browser on WebAssembly hosted by a ASP.NET Core WebAPI. Once the solution has been created we're going to start making some changes to the server project.</p><h2 id="configuring-webapi">Configuring WebAPI</h2><p>We're going to configure the API first, but before we begin let's get some NuGet packages installed.</p><pre><code>    &lt;PackageReference Include="Microsoft.AspNetCore.Blazor.Server" Version="3.1.0-preview3.19555.2" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" Version="3.1.0-preview3.19555.2" /&gt;

    &lt;PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="3.1.0-preview3.19555.2" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Identity.UI" Version="3.1.0-preview3.19555.2" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore" Version="3.1.0-preview3.19555.2" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" Version="3.1.0-preview3.19555.2" /&gt;
    &lt;PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="3.1.0-preview3.19554.8" /&gt;
    &lt;PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="3.1.0-preview3.19554.8"&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
    &lt;/PackageReference&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="3.1.0-preview3.19553.2" /&gt;
    &lt;PackageReference Include="Microsoft.VisualStudio.Web.CodeGeneration.Design" Version="3.1.0-preview3.19558.8" /&gt;
</code></pre><p>You can either add the above packages to your server projects .csproj file - or you can install them via the command line or NuGet package manager.</p><h3 id="setting-up-the-identity-database-connection-string">Setting up the Identity database: Connection string</h3><p>Before we can set anything up, database wise we need a connection string. This is usually kept in the <code>appsettings.json</code> file, but the Blazor hosted template doesn't supply one - so we are going to have to add it.</p><p>Right click on the server project and select <code>Add</code> &gt; <code>New Item</code>. Then select <code>App Settings File</code> from the list.</p><pre><code class="language-json">{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\MSSQLLocalDB;Database=AuthenticationWithClientSideBlazor;Trusted_Connection=True;MultipleActiveResultSets=true"
  }
}
</code></pre><p>The file comes with a connection string already in place, feel free to point this where ever you need to. I'm just going to add a database name and leave the rest as default.</p><h3 id="setting-up-the-identity-database-dbcontext">Setting up the Identity database: DbContext</h3><p>In the root of the server project create a folder called <code>Data</code> then add a new class called <code>ApplicationDbContext</code> with the following code.</p><pre><code class="language-csharp">public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions options) : base(options)
    {
    }
}
</code></pre><p>Because we are using Identity which needs to store information in a database we're not inheriting from <code>DbContext</code> but instead from <code>IdentityDbContext</code>. &nbsp;The <code>IdentityDbContext</code> base class contains all the configuration EF needs to manage the Identity database tables.</p><h3 id="setting-up-the-identity-database-registering-services">Setting up the Identity database: Registering services</h3><p>In the <code>Startup</code> class we need to add a constructor which takes an <code>IConfiguration</code> and a property to store it. <code>IConfiguration</code> allows us to access the settings in the <code>appsettings.json</code> file, such as the connection string.</p><pre><code class="language-csharp">public IConfiguration Configuration { get; }

public Startup(IConfiguration configuration)
{
    Configuration = configuration;
}
</code></pre><p>Now we need to add the following lines to the top of the <code>ConfigureServices</code> method.</p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
                    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

    services.AddDefaultIdentity&lt;IdentityUser&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();

    // other code removed for brevity

}
</code></pre><p>Essentially, these two lines are adding the <code>ApplicationDbContext</code> to the services collection. Then registering the various services for ASP.NET Core Identity and telling it to use Entity Framework as a backing store via the <code>ApplicationDbContext</code>.</p><h3 id="setting-up-the-identity-database-creating-the-database">Setting up the Identity database: Creating the database</h3><p>We're now in a position to create the initial migration for the database. In the package manager console run the following command.</p><pre><code class="language-powershell">Add-Migration CreateIdentitySchema -o Data/Migations
</code></pre><p>Once the command has run you should see the migrations file in <code>Data</code> &gt; <code>Migrations</code>. Run <code>Update-Database</code> in the console to apply the migration to your database.</p><p>If you have any issues with running the migration command, make sure that the server project is selected as the default project in the package manager console.</p><h3 id="enabling-authentication-registering-services">Enabling Authentication: Registering services</h3><p>The next step is to enable authentication in the API. Again, in <code>ConfigureServices</code> add the following code after the code we added in the previous section.</p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{

    // other code removed for brevity
    
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddJwtBearer(options =&gt;
        {
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = true,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                ValidIssuer = Configuration["JwtIssuer"],
                ValidAudience = Configuration["JwtAudience"],
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["JwtSecurityKey"]))
            };
        });
        
     // other code removed for brevity   

}
</code></pre><p>The code above is adding and setting up some services required for authentication to the service container. Then adding a handler for JSON Web Tokens (JWT) and configuring how received JWTs should be validated. Feel free to tweak these settings to your requirements.</p><h3 id="enabling-authentication-app-settings">Enabling Authentication: App settings</h3><p>There are a few settings which are being loaded from the <code>appsettings.json</code> file.</p><ul><li><code>Configuration["JwtIssuer"]</code></li><li><code>Configuration["JwtAudience"]</code></li><li><code>Configuration["JwtSecurityKey"]</code></li></ul><p>We haven' actually added them to the <code>appsettings</code> file yet, so let do that now. While we're there we'll also add a setting to control how long the tokens last, which we'll use in a bit.</p><pre><code class="language-json">"JwtSecurityKey": "RANDOM_KEY_MUST_NOT_BE_SHARED",
"JwtIssuer": "https://localhost",
"JwtAudience": "https://localhost",
"JwtExpiryInDays": 1,
</code></pre><p>It's really important that the <code>JwtSecurityKey</code> is kept secret as this is what is used to sign the tokens produced by the API. If this is compromised then your app would no longer be secure.</p><p>As I'm running everything locally I have my <em>Issuer</em> and <em>Audienc</em>e set to localhost. But if you're using this in a real app then you would set the <em>Issuer</em> to the domain the API is running on and the <em>Audience</em> to the domain the client app is running on.</p><h3 id="enabling-authentication-adding-middleware">Enabling Authentication: Adding middleware</h3><p>Finally, in the <code>Configure</code> method we need to add the necessary middleware to the pipeline. This will enable the authentication and authorization features in our API. Add them just above the <code>app.UseEndpoints</code> middleware.</p><pre><code class="language-csharp">app.UseAuthentication();
app.UseAuthorization();
</code></pre><p>That should be everything we need to do the <code>Startup</code> class. Authentication is now enabled for the API.</p><p>You can test everything is working by adding an <code>[Authorize]</code> attribute to the <code>WeatherForecasts</code> action on the <code>SampleDataController</code>. Then startup the app and navigate to the <em>Fetch Data</em> page, no data should load and you should see a 401 error in the console.</p><h3 id="adding-the-account-controller">Adding the account controller</h3><p>In order for people to login to our app they need to be able to signup. We're going to add an account controller which will be responsible for creating new accounts. </p><pre><code class="language-csharp">[Route("api/[controller]")]
[ApiController]
public class AccountsController : ControllerBase
{
    private static UserModel LoggedOutUser = new UserModel { IsAuthenticated = false };

    private readonly UserManager&lt;IdentityUser&gt; _userManager;

    public AccountsController(UserManager&lt;IdentityUser&gt; userManager)
    {
        _userManager = userManager;
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Post([FromBody]RegisterModel model)
    {
        var newUser = new IdentityUser { UserName = model.Email, Email = model.Email };

        var result = await _userManager.CreateAsync(newUser, model.Password);

        if (!result.Succeeded)
        {
            var errors = result.Errors.Select(x =&gt; x.Description);

            return Ok(new RegisterResult { Successful = false, Errors = errors });

        }

        return Ok(new RegisterResult { Successful = true });
    }
}
</code></pre><p>The <code>Post</code> action uses the ASP.NET Core Identity <code>UserManager</code> to create a new user in the system from a <code>RegisterModel</code>. </p><p>We haven't added the register model yet so we can do that now, put this in the shared project as this will be used by our Blazor app in a bit.</p><pre><code class="language-csharp">public class RegisterModel
{
    [Required]
    [EmailAddress]
    [Display(Name = "Email")]
    public string Email { get; set; }

    [Required]
    [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
    [DataType(DataType.Password)]
    [Display(Name = "Password")]
    public string Password { get; set; }

    [DataType(DataType.Password)]
    [Display(Name = "Confirm password")]
    [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
    public string ConfirmPassword { get; set; }
}
</code></pre><p>If all goes well then a successful <code>RegisterResult</code> is returned, otherwise a failed <code>RegisterResult</code> is returned. Again, we need to create the <code>RegisterResult</code> and again it needs to go in the shared project.</p><pre><code class="language-csharp">public class RegisterResult
{
    public bool Successful { get; set; }
    public IEnumerable&lt;string&gt; Errors { get; set; }
}
</code></pre><h3 id="adding-the-login-controller">Adding the login controller</h3><p>Now we have a way for users to signup we now need a way for them to login.</p><pre><code class="language-csharp">[Route("api/[controller]")]
[ApiController]
public class LoginController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly SignInManager&lt;IdentityUser&gt; _signInManager;

    public LoginController(IConfiguration configuration,
                           SignInManager&lt;IdentityUser&gt; signInManager)
    {
        _configuration = configuration;
        _signInManager = signInManager;
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; Login([FromBody] LoginModel login)
    {
        var result = await _signInManager.PasswordSignInAsync(login.Email, login.Password, false, false);

        if (!result.Succeeded) return BadRequest(new LoginResult { Successful = false, Error = "Username and password are invalid." });

        var claims = new[]
        {
            new Claim(ClaimTypes.Name, login.Email)
        };

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JwtSecurityKey"]));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        var expiry = DateTime.Now.AddDays(Convert.ToInt32(_configuration["JwtExpiryInDays"]));

        var token = new JwtSecurityToken(
            _configuration["JwtIssuer"],
            _configuration["JwtAudience"],
            claims,
            expires: expiry,
            signingCredentials: creds
        );

        return Ok(new LoginResult { Successful = true, Token = new JwtSecurityTokenHandler().WriteToken(token) });
    }
}
</code></pre><p>The sole job of the login controller is to verify the username and password in the <code>LoginModel</code> using the ASP.NET Core Identity <code>SignInManger</code>. If they're correct then a new JSON web token is generated and passed back to the client in a <code>LoginResult</code>.</p><p>Just like before we need to add the <code>LoginModel</code> and <code>LoginResult</code> to the shared project.</p><pre><code class="language-csharp">public class LoginModel
{
    [Required]
    public string Email { get; set; }

    [Required]
    public string Password { get; set; }

    public bool RememberMe { get; set; }
}
</code></pre><pre><code class="language-csharp">public class LoginResult
{
    public bool Successful { get; set; }
    public string Error { get; set; }
    public string Token { get; set; }
}
</code></pre><p>That's everything we need on our API. We have now configured it to use authentication via JSON web tokens. As well as setup the controllers we need for our Blazor client-side app to register new users and to login.</p><p>Let's turn our attention to Blazor. The first thing we're going to do is install <a href="https://www.nuget.org/packages/Blazored.LocalStorage/">Blazored.LocalStorage</a>, we will need this later to persist the auth token from the API when we login.</p><p>We also need to update the <code>App</code> component to use the <code>AuthorizeRouteView</code> component instead of the <code>RouteView</code> component.</p><pre><code class="language-html">&lt;Router AppAssembly="@typeof(Program).Assembly"&gt;
    &lt;Found Context="routeData"&gt;
        &lt;AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" /&gt;
    &lt;/Found&gt;
    &lt;NotFound&gt;
        &lt;CascadingAuthenticationState&gt;
            &lt;LayoutView Layout="@typeof(MainLayout)"&gt;
                &lt;p&gt;Sorry, there's nothing at this address.&lt;/p&gt;
            &lt;/LayoutView&gt;
        &lt;/CascadingAuthenticationState&gt;
    &lt;/NotFound&gt;
&lt;/Router&gt;
</code></pre><p>This component provides a cascading parameter of type <code>Task&lt;AuthenticationState&gt;</code>. This is used by the <code>AuthorizeView</code> component to determine the current users authentication state. </p><p>But any component can request the parameter and use it to do procedural logic, for example.</p><pre><code class="language-html">@code {
    [CascadingParameter] private Task&lt;AuthenticationState&gt; authenticationStateTask { get; set; }

    private async Task LogUserAuthenticationState()
    {
        var authState = await authenticationStateTask;
        var user = authState.User;

        if (user.Identity.IsAuthenticated)
        {
            Console.WriteLine($"User {user.Identity.Name} is authenticated.");
        }
        else
        {
            Console.WriteLine("User is NOT authenticated.");
        }
    }
}
</code></pre><h3 id="creating-a-custom-authenticationstateprovider">Creating a Custom AuthenticationStateProvider</h3><p>As we are using client-side Blazor we need to provide our own implementation for the <code>AuthenticationStateProvider</code> class. Because there are so many options when it comes to client-side apps there is no way to design a default class that would work for everyone. </p><p>We need to override the <code>GetAuthenticationStateAsync</code> method. In this method we need to determine if the current user is authenticated or not. We're also going to add a couple of helper methods which we will use to update the authentication state when the user logs in or out.</p><pre><code class="language-csharp">public class ApiAuthenticationStateProvider : AuthenticationStateProvider
{
    private readonly HttpClient _httpClient;
    private readonly ILocalStorageService _localStorage;

    public ApiAuthenticationStateProvider(HttpClient httpClient, ILocalStorageService localStorage)
    {
        _httpClient = httpClient;
        _localStorage = localStorage;
    }
    public override async Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync()
    {
        var savedToken = await _localStorage.GetItemAsync&lt;string&gt;("authToken");

        if (string.IsNullOrWhiteSpace(savedToken))
        {
            return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity()));
        }

        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", savedToken);

        return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(ParseClaimsFromJwt(savedToken), "jwt")));
    }

    public void MarkUserAsAuthenticated(string email)
    {
        var authenticatedUser = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Name, email) }, "apiauth"));
        var authState = Task.FromResult(new AuthenticationState(authenticatedUser));
        NotifyAuthenticationStateChanged(authState);
    }

    public void MarkUserAsLoggedOut()
    {
        var anonymousUser = new ClaimsPrincipal(new ClaimsIdentity());
        var authState = Task.FromResult(new AuthenticationState(anonymousUser));
        NotifyAuthenticationStateChanged(authState);
    }

    private IEnumerable&lt;Claim&gt; ParseClaimsFromJwt(string jwt)
    {
        var claims = new List&lt;Claim&gt;();
        var payload = jwt.Split('.')[1];
        var jsonBytes = ParseBase64WithoutPadding(payload);
        var keyValuePairs = JsonSerializer.Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(jsonBytes);

        keyValuePairs.TryGetValue(ClaimTypes.Role, out object roles);

        if (roles != null)
        {
            if (roles.ToString().Trim().StartsWith("["))
            {
                var parsedRoles = JsonSerializer.Deserialize&lt;string[]&gt;(roles.ToString());

                foreach (var parsedRole in parsedRoles)
                {
                    claims.Add(new Claim(ClaimTypes.Role, parsedRole));
                }
            }
            else
            {
                claims.Add(new Claim(ClaimTypes.Role, roles.ToString()));
            }

            keyValuePairs.Remove(ClaimTypes.Role);
        }

        claims.AddRange(keyValuePairs.Select(kvp =&gt; new Claim(kvp.Key, kvp.Value.ToString())));

        return claims;
    }

    private byte[] ParseBase64WithoutPadding(string base64)
    {
        switch (base64.Length % 4)
        {
            case 2: base64 += "=="; break;
            case 3: base64 += "="; break;
        }
        return Convert.FromBase64String(base64);
    }
}
</code></pre><p>There is a lot of code here so let's break it down step by step.</p><p>The <code>GetAuthenticationStateAsync</code> method is called by the <code>CascadingAuthenticationState</code> component to determine if the current user is authenticated or not. </p><p>In the code above, we check to see if there is an auth token in local storage. If there is no token in local storage, then we return a new <code>AuthenticationState</code> with a blank claims principal. This is the equivalent of saying the current user is not authenticated.</p><p>If there is a token, we retrieve it and set the default authorization header for the <code>HttpClient</code>. We then return a new <code>AuthenticationState</code> with a new claims principal containing the claims from the token. The claims are extracted from the token by the <code>ParseClaimsFromJwt</code> method. This method decodes the token and returns the claims contained within it.</p><p><em>Full disclosure - the <code>ParseClaimsFromJwt</code> method is borrowed from <a href="https://github.com/SteveSandersonMS/presentation-2019-06-NDCOslo/tree/master/demos/MissionControl">Steve Sandersons Mission Control</a> demo app, which he showed at <a href="https://www.youtube.com/watch?v=uW-Kk7Qpv5U">NDC Oslo 2019</a>. </em></p><p>The <code>MarkUserAsAuthenticated</code> is a helper method that's used to when a user logs in. Its sole purpose is to invoke the <code>NotifyAuthenticationStateChanged</code> method which fires an event called <code>AuthenticationStateChanged</code>. This cascades the new authentication state, via the <code>CascadingAuthenticationState</code> component.</p><p>As you may expect, <code>MarkUserAsLoggedOut</code> does almost exactly the same as the previous method but when a user logs out.</p><h3 id="auth-service">Auth Service</h3><p>The auth service is going to be the what we use in our components to register users and log them in and out of the application. It's going to be a nice abstraction for all of the stuff going on in the background. </p><pre><code class="language-csharp">public class AuthService : IAuthService
{
    private readonly HttpClient _httpClient;
    private readonly AuthenticationStateProvider _authenticationStateProvider;
    private readonly ILocalStorageService _localStorage;

    public AuthService(HttpClient httpClient,
                       AuthenticationStateProvider authenticationStateProvider,
                       ILocalStorageService localStorage)
    {
        _httpClient = httpClient;
        _authenticationStateProvider = authenticationStateProvider;
        _localStorage = localStorage;
    }

    public async Task&lt;RegisterResult&gt; Register(RegisterModel registerModel)
    {
        var result = await _httpClient.PostJsonAsync&lt;RegisterResult&gt;("api/accounts", registerModel);

        return result;
    }

    public async Task&lt;LoginResult&gt; Login(LoginModel loginModel)
    {
        var loginAsJson = JsonSerializer.Serialize(loginModel);
        var response = await _httpClient.PostAsync("api/Login", new StringContent(loginAsJson, Encoding.UTF8, "application/json"));
        var loginResult = JsonSerializer.Deserialize&lt;LoginResult&gt;(await response.Content.ReadAsStringAsync(), new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

        if (!response.IsSuccessStatusCode)
        {
            return loginResult;
        }

        await _localStorage.SetItemAsync("authToken", loginResult.Token);
        ((ApiAuthenticationStateProvider)_authenticationStateProvider).MarkUserAsAuthenticated(loginModel.Email);
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", loginResult.Token);

        return loginResult;
    }

    public async Task Logout()
    {
        await _localStorage.RemoveItemAsync("authToken");
        ((ApiAuthenticationStateProvider)_authenticationStateProvider).MarkUserAsLoggedOut();
        _httpClient.DefaultRequestHeaders.Authorization = null;
    }
}
</code></pre><p>The <code>Register</code> method posts the <code>registerModel</code> to the accounts controller and then returns the <code>RegisterResult</code> to the caller.</p><p>The <code>Login</code> method is similar to the <code>Register</code> method, it posts the <code>LoginModel</code> to the login controller. But when a successful result is returned it strips out the auth token and persists it to local storage. </p><p>It then calls the <code>MarkUserAsAuthenticated</code> method we just looked at on the <code>ApiAuthenticationStateProvider</code>. Finally, it sets the default authorization header on the <code>HttpClient</code>.</p><p>The <code>Logout</code> method is just doing the reverse of the <code>Login</code> method.</p><h3 id="register-component">Register Component</h3><p>We're on the home stretch now. We can now turn our attention to the UI and creating a component which will allow people to register with the site.</p><pre><code class="language-html">@page "/register"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

&lt;h1&gt;Register&lt;/h1&gt;

@if (ShowErrors)
{
    &lt;div class="alert alert-danger" role="alert"&gt;
        @foreach (var error in Errors)
        {
            &lt;p&gt;@error&lt;/p&gt;
        }
    &lt;/div&gt;
}

&lt;div class="card"&gt;
    &lt;div class="card-body"&gt;
        &lt;h5 class="card-title"&gt;Please enter your details&lt;/h5&gt;
        &lt;EditForm Model="RegisterModel" OnValidSubmit="HandleRegistration"&gt;
            &lt;DataAnnotationsValidator /&gt;
            &lt;ValidationSummary /&gt;

            &lt;div class="form-group"&gt;
                &lt;label for="email"&gt;Email address&lt;/label&gt;
                &lt;InputText Id="email" class="form-control" @bind-Value="RegisterModel.Email" /&gt;
                &lt;ValidationMessage For="@(() =&gt; RegisterModel.Email)" /&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password"&gt;Password&lt;/label&gt;
                &lt;InputText Id="password" type="password" class="form-control" @bind-Value="RegisterModel.Password" /&gt;
                &lt;ValidationMessage For="@(() =&gt; RegisterModel.Password)" /&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password"&gt;Confirm Password&lt;/label&gt;
                &lt;InputText Id="password" type="password" class="form-control" @bind-Value="RegisterModel.ConfirmPassword" /&gt;
                &lt;ValidationMessage For="@(() =&gt; RegisterModel.ConfirmPassword)" /&gt;
            &lt;/div&gt;
            &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
        &lt;/EditForm&gt;
    &lt;/div&gt;
&lt;/div&gt;

@code {

    private RegisterModel RegisterModel = new RegisterModel();
    private bool ShowErrors;
    private IEnumerable&lt;string&gt; Errors;

    private async Task HandleRegistration()
    {
        ShowErrors = false;

        var result = await AuthService.Register(RegisterModel);

        if (result.Successful)
        {
            NavigationManager.NavigateTo("/login");
        }
        else
        {
            Errors = result.Errors;
            ShowErrors = true;
        }
    }

}
</code></pre><p>The register component contains a form which allows the user to enter their email address and desired password. When the form is submitted the <code>Register</code> method on the <code>AuthService</code> is called passing in the <code>RegisterModel</code>. If the result of the registration is a success then the user is navigated to the login page. Otherwise any errors are displayed to the user.</p><h3 id="login-component">Login Component</h3><p>Now we can register a new account, we need to be able to login. The login component is going to be responsible for that.</p><pre><code class="language-html">@page "/login"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

&lt;h1&gt;Login&lt;/h1&gt;

@if (ShowErrors)
{
    &lt;div class="alert alert-danger" role="alert"&gt;
        &lt;p&gt;@Error&lt;/p&gt;
    &lt;/div&gt;
}

&lt;div class="card"&gt;
    &lt;div class="card-body"&gt;
        &lt;h5 class="card-title"&gt;Please enter your details&lt;/h5&gt;
        &lt;EditForm Model="loginModel" OnValidSubmit="HandleLogin"&gt;
            &lt;DataAnnotationsValidator /&gt;
            &lt;ValidationSummary /&gt;

            &lt;div class="form-group"&gt;
                &lt;label for="email"&gt;Email address&lt;/label&gt;
                &lt;InputText Id="email" Class="form-control" @bind-Value="loginModel.Email" /&gt;
                &lt;ValidationMessage For="@(() =&gt; loginModel.Email)" /&gt;
            &lt;/div&gt;
            &lt;div class="form-group"&gt;
                &lt;label for="password"&gt;Password&lt;/label&gt;
                &lt;InputText Id="password" type="password" Class="form-control" @bind-Value="loginModel.Password" /&gt;
                &lt;ValidationMessage For="@(() =&gt; loginModel.Password)" /&gt;
            &lt;/div&gt;
            &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
        &lt;/EditForm&gt;
    &lt;/div&gt;
&lt;/div&gt;

@code {

    private LoginModel loginModel = new LoginModel();
    private bool ShowErrors;
    private string Error = "";

    private async Task HandleLogin()
    {
        ShowErrors = false;

        var result = await AuthService.Login(loginModel);

        if (result.Successful)
        {
            NavigationManager.NavigateTo("/");
        }
        else
        {
            Error = result.Error;
            ShowErrors = true;
        }
    }

}
</code></pre><p>Following a similar design to the register component. There is a form for the user to input their email address and password.</p><p>When the form is submitted the <code>AuthService</code> is called and the result is returned. If the login was successful then the user is redirected to the home page, otherwise they are shown the error message.</p><h3 id="logout-component">Logout Component</h3><p>We can now register and login but we also need the ability to logout. I've gone with a page component to do this but you could also implement this on a button click somewhere.</p><pre><code class="language-html">@page "/logout"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

@code {

    protected override async Task OnInitializedAsync()
    {
        await AuthService.Logout();
        NavigationManager.NavigateTo("/");
    }

}

</code></pre><p>The component doesn't have any UI, when the user navigates to it the <code>Logout</code> method on the <code>AuthService</code> is called and then the user is redirected back to the home page. </p><h3 id="adding-a-logindisplay-and-updating-the-mainlayout">Adding a LoginDisplay and updating the MainLayout</h3><p>The final task is to add a <code>LoginDisplay</code> component and then update the <code>MainLayout</code> component to use it. </p><p>The <code>LoginDisplay</code> component is the same one used in the server-side Blazor template. If unauthenticated, it shows the R<em>egister</em> and <em>Log in</em> links - if unauthenticated, it shows the users email and the <em>Log out</em> link. </p><pre><code class="language-html">&lt;AuthorizeView&gt;
    &lt;Authorized&gt;
        Hello, @context.User.Identity.Name!
        &lt;a href="LogOut"&gt;Log out&lt;/a&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;a href="Register"&gt;Register&lt;/a&gt;
        &lt;a href="Login"&gt;Log in&lt;/a&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre><p>We just need to update the <code>MainLayout</code> component now.</p><pre><code class="language-html">@inherits LayoutComponentBase

&lt;div class="sidebar"&gt;
    &lt;NavMenu /&gt;
&lt;/div&gt;

&lt;div class="main"&gt;
    &lt;div class="top-row px-4"&gt;
        &lt;LoginDisplay /&gt;
        &lt;a href="http://blazor.net" target="_blank" class="ml-md-auto"&gt;About&lt;/a&gt;
    &lt;/div&gt;

    &lt;div class="content px-4"&gt;
        @Body
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><h3 id="registering-services">Registering Services</h3><p>The last thing that's needed is to register the various services we've been building in the <code>Startup</code> class.</p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddBlazoredLocalStorage();
    services.AddAuthorizationCore();
    services.AddScoped&lt;AuthenticationStateProvider, ApiAuthenticationStateProvider&gt;();
    services.AddScoped&lt;IAuthService, AuthService&gt;();
}
</code></pre><p>If everything has gone to plan then you should have something that looks like this.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/AuthenticationWithClientSideBlazor.gif" class="kg-image"></figure><h2 id="summary">Summary</h2><p>In this post I showed how to create a new Blazor client-side application with authentication using WebAPI and ASP.NET Core Identity. </p><p>I showed how to configure the API to process and issue JSON web tokens. As well as how to setup the various controller actions to service the client application.I then showed how to configure Blazor to use the API and the tokens it issued to set the apps authentication state.</p><p>As I mentioned at the start of this post, all the code is available on <a href="https://github.com/chrissainty/AuthenticationWithClientSideBlazor">GitHub</a>.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>