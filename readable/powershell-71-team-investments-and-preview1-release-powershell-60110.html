<!DOCTYPE html>
<html lang="en">
<head>
    <title>
PowerShell 7.1 Team Investments and Preview.1 Release | PowerShell - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="PowerShell 7.1 Team Investments and Preview.1 Release | PowerShell - linksfor.dev(s)"/>
    <meta property="article:author" content="Steve LeePrincipal Software Engineer Manager, PowerShellFollow"/>
    <meta property="og:description" content="The PowerShell 7 release marks a huge milestone for PowerShell, the community, and the team!&#xA;Today we released the first preview for PowerShell 7.1! This release includes a number of changes that did not make it in time for the 7.0 release."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/powershell/powershell-7-1-team-investments-and-preview-1-release/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - PowerShell 7.1 Team Investments and Preview.1 Release | PowerShell</title>
<div class="readable">
        <h1>PowerShell 7.1 Team Investments and Preview.1 Release | PowerShell</h1>
            <div>by Steve LeePrincipal Software Engineer Manager, PowerShellFollow</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 27 Mar 2020</div>
        <p><a href="https://devblogs.microsoft.com/powershell/powershell-7-1-team-investments-and-preview-1-release/">https://devblogs.microsoft.com/powershell/powershell-7-1-team-investments-and-preview-1-release/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>The <a href="https://devblogs.microsoft.com/powershell/announcing-powershell-7-0/">PowerShell 7</a> release marks a huge milestone for PowerShell, the community, and the team!</p><p>Today we released the first preview for PowerShell 7.1! This release includes a number of <a href="https://github.com/PowerShell/PowerShell/releases/tag/v7.1.0-preview.1" target="_blank">changes</a> that did not make it in time for the 7.0 release. It also includes <a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-1/" rel="nofollow">.NET 5 preview 1</a>!</p><p>The PowerShell team is not resting on our laurels and are committed to continuous improvement of PowerShell as we plan out our 7.1 release. This blog post details the areas of investment that the PowerShell team is funding. As we’ve done in the past, we’ll also be working with contributors interested in implementing new features as part of the 7.1 release.</p><h2>Release Cycle Changes</h2><p>PowerShell Core 6.0 through PowerShell 7 was on a (roughly) 6 month release cadence.</p><p>Starting with PowerShell 7.0, we shifted to align with <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core" rel="nofollow" target="_blank">.NET’s release and support life-cycle</a> more closely. This means we intend to ship 7.1 within a week or two of .NET 5’s release date of winter 2020 and align with their annual release cadence going forward.</p><h2>Modules and Tooling for the 7.1 Release Time Frame</h2><p>Not everything here is expected to ship with PowerShell 7.1, but the work is being done along with PowerShell 7.1 development.</p><h3>PowerShellGet 3.0</h3><p>At the beginning of PowerShell 7 development, we announced <a href="https://github.com/PowerShell/PowerShell-RFC/pull/237" target="_blank">PowerShellGet 3.0</a>. This is a complete rewrite of PowerShellGet covering 3 big areas:</p><ul><li>Improving the user experience</li><li>Removing dependency on PackageManagement (and Nuget provider) making the codebase simpler and easier to maintain</li><li>Moving from PowerShell script to C# making it easier to maintain a large and complex codebase</li></ul><p>Based on community feedback, we wanted to take an opportunity to address many of the user experience shortcomings with a major release that will have breaking changes. We also want to leverage learnings from popular package managers like <code>apt</code> (on Linux) to adopt conventions already used and proven by a large set of users.</p><p>PowerShellGet 3.0 will ship on <a href="https://www.powershellgallery.com/" rel="nofollow" target="_blank">PowerShell Gallery</a> initially, with tentative plans to deliver it into PowerShell 7.x side-by-side with PowerShellGet 2.0.</p><p>The first preview is expected later this month!</p><h3>Secret Management Module</h3><p>We are still working on completing <a href="https://devblogs.microsoft.com/powershell/secret-management-preview-2-release/" rel="nofollow">Secret Management</a> module, specifically adding Linux support, possibly macOS support, and continuing to address user feedback.</p><p>We received lots of good feedback from our preview 1 release which helped shape our preview 2 release. Thanks so much and it shows that getting previews out early really helps the project!</p><p>This module is shipped via <a href="https://www.powershellgallery.com/packages/Microsoft.PowerShell.SecretManagement" rel="nofollow" target="_blank">PowerShell Gallery</a> supporting Windows PowerShell 5.1 and PowerShell 7 and potentially included by default with PowerShell 7.1. This module enables secure storage and retrieval of secrets locally as well as using extensions to store and retrieve secrets from remote vaults (like Azure Key Vault).</p><p>We are also working with partners to have vault extensions available soon!</p><h3>VSCode-PowerShell, PSEditorServices, and PSScriptAnalyzer 2.0</h3><p>The <a href="https://github.com/PowerShell/vscode-powershell" target="_blank">PowerShell extension for Visual Studio Code</a> and <a href="https://github.com/PowerShell/PowerShellEditorServices" target="_blank">PowerShell Editor Services</a> rely on <a href="https://github.com/PowerShell/PSScriptAnalyzer" target="_blank">PSScriptAnalyzer</a> to perform real-time linting as you author or edit a PowerShell script. However, this scenario was not part of the original intent nor design of PSScriptAnalyzer and thus has become a user experience where errors and corrections lag after the user input. Major portions of PSScriptAnalyzer needs to be updated or rewritten to significantly improve throughput to make the interactive user experience more instantaneous, delightful, and productive.</p><h3>PowerShell Jupyter Kernel</h3><p><a href="https://jupyter.org/" rel="nofollow" target="_blank">Jupyter</a> notebooks are gaining popularity as a way to have executable code and text content in the same document. There have been existing Jupyter kernels available that support PowerShell, however, we wanted to invest in this space with one that would be supported by the PowerShell team and providing a complete experience.</p><p>We’ve already shipped the <a href="https://devblogs.microsoft.com/powershell/public-preview-of-powershell-support-in-jupyter-notebooks/" rel="nofollow">first preview</a> of our PowerShell sub-kernel that is part of the <a href="https://github.com/dotnet/interactive" target="_blank">DotNet Interactive</a> Jupyter kernel.</p><p>We will coontinue to improve this experience making it a great choice for PowerShell and Jupyter users.</p><h3>platyPS vNext</h3><p><a href="https://github.com/PowerShell/platyPS" target="_blank">PlatyPS</a> is a PowerShell module that we currently use to convert PowerShell documentation from markdown to updatable-help and is available via <a href="https://www.powershellgallery.com/packages/platyPS" rel="nofollow" target="_blank">PowerShell Gallery</a>. Based on feedback from content authors and partner teams, we need to invest in this tool to improve the author experience as well as improving capabilities of our documentation. This will be a rewrite to support improved Markdown parsing, rendering, and fulfilling requirements for our internal pipelines to publish updateable help.</p><h2>Themes for PowerShell 7.1</h2><h3>Installation and Updating</h3><p>A major pain point for our customers, particularly on Windows, is that installing and updating PowerShell 7 requires too many manual steps. We are exploring some options to make it easier to install as well as keep PowerShell updated. At this time, we still do not have a plan to ship PowerShell 7 in Windows due to differences in support requirements that we are still working through.</p><h3>Shell Improvements</h3><p>Most native commands work just fine from within PowerShell, however, there are some cases where the argument parsing is not ideal (like handling quotes properly). The intent is to enable users to cut sample command lines for any popular native tool, paste it into PowerShell, and it just works without needing PowerShell specific escaping.</p><p>In addition, for advanced users that want to mix PowerShell specific concepts with native commands, things may not work as expected. For example, PSDrives are a great way to abstract a file path across operating systems, but only PowerShell cmdlets and scripts can use them. We want to explore how to expose these things to native commands.</p><h3>Interactive User Experience</h3><p>To enable users to be more productive at the shell, we want to enable two new scenarios:</p><ul><li><strong>Enable predictions</strong>: We are investigating how the community can author different prediction engines helping the user complete a pipeline with minimal typing.</li><li><strong>Enable dynamic help</strong>: While authoring a pipeline in the console, the user should be able to get context aware help like presenting help on parameters as they are typing or get full help content without having to abandon their current input or open a new console.</li><li><strong>Enable use of color</strong>: We added some additional use of color in PowerShell 7.0 to provide visual cues when scanning console output. For 7.1, we are working with the .NET <a href="https://github.com/dotnet/command-line-api" target="_blank">System.CommandLine</a> team to have appropriate APIs to decorate strings so that PowerShell can render them both with color as well as plain text, as needed. This includes addressing accessibility concerns where certain colors, themes, and decorations may be hard to see.</li></ul><p>These experiences will require changes in both PSReadLine and the PowerShell engine itself.</p><p>We are also exploring some experiments such as <a href="https://devblogs.microsoft.com/powershell/introducing-consoleguitools-preview/" rel="nofollow"><code>Out-ConsoleGridView</code></a> to make the console an even more productive experience.</p><h3>Minimal PowerShell</h3><p>One of the great things about PowerShell is the plethora of APIs and cmdlets you can use. However, the cost of this is that lots of assemblies are included with PowerShell just in case a script uses them. This works fine for authoring scripts, but when deploying scripts, it would be better to have your target only install the parts of PowerShell needed for those scripts. Not only would it take less disk space, but more importantly, a minimal set of code means less patching and security attack surface.</p><p>As part of this effort, we also want to split the monolithic Utility, Management, and Security modules that ship with PowerShell into logical modules that can be innovated and published on their own cadence.</p><p>Finally, to improve performance, we also want to look at reducing dependencies on .NET assemblies that are not absolutely needed to reduce memory usage as well as improve startup time.</p><h2>Closing</h2><p>As you can see, there is a lot of work we are current exploring and prototyping. Not everything will make it into the 7.1 release and may show up in a future release. As we make progress and have more concrete definitions and scope of the work, we will publish <a href="https://github.com/powershell/powershell-rfc" target="_blank">RFCs</a> to get community feedback like we’ve done in the past. We will also leverage <a href="https://github.com/PowerShell/PowerShell/projects" target="_blank">GitHub Projects</a> to track progress and enable the community to provide feedback. I’m personally excited about the future of PowerShell and looking forward to seeing feedback on our plans!</p><p>Steve Lee<br> Principal Software Engineer Manager<br> PowerShell Team</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>