<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Moving from Node.js to .NET Core | App Center Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Moving from Node.js to .NET Core | App Center Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Jim WangFollow Jim"/>
    <meta property="og:description" content="Here on&#xA0;Visual&#xA0;Studio&#xA0;App Center, our platform is built as a set of microservices, which has afforded teams to make language and platform choices that work best for them, and ultimately allowed us to move and iterate quickly. Over time,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/appcenter/moving-from-node-js-to-net-core/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Moving from Node.js to .NET Core | App Center Blog</title>
<div class="readable">
        <h1>Moving from Node.js to .NET Core | App Center Blog</h1>
            <div>by Jim WangFollow Jim</div>
            <div>Reading time: 6-8 minutes</div>
        <div>Posted here: 23 May 2019</div>
        <p><a href="https://devblogs.microsoft.com/appcenter/moving-from-node-js-to-net-core/">https://devblogs.microsoft.com/appcenter/moving-from-node-js-to-net-core/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/appcenter/wp-content/uploads/sites/3/2019/05/jimwangAvatarTiny-150x150.jpg" width="58" height="58" alt="Jim Wang"></p><p>Jim</p></div></div></div><p>May 21st, 2019</p><p><span data-contrast="none">Here on&nbsp;</span><span data-contrast="none">Visual</span><span data-contrast="none">&nbsp;Studio&nbsp;</span><span data-contrast="none">App Center, our platform is built as a set of microservices, which has afforded teams to make language and platform choices that work best for them, and ultimately allowed us to move and iterate quickly. Over time, two distinct stacks have emerged:</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><ul><li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="none">TypeScript/JavaScript running on Node.js, deployed to AKS (</span><a href="https://azure.microsoft.com/en-us/services/kubernetes-service/" target="_blank"><span data-contrast="none">Azure&nbsp;</span><span data-contrast="none">Kubnernetes</span><span data-contrast="none">&nbsp;Service</span></a><span data-contrast="none">)</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:240}">&nbsp;</span></li><li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="none">.NET Framework (C#) running on Windows Service Fabric</span><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}">&nbsp;</span></li></ul><p><span data-contrast="none">As we have continued to merge our teams and do more and more cross-team work, i</span><span data-contrast="none">t’s become&nbsp;</span><span data-contrast="none">apparent that we should settle on a single choice and unify so that jumping between services&nbsp;</span><span data-contrast="none">is</span><span data-contrast="none">&nbsp;less jarring. The fact that a lot of our customers run non-Windows platforms, and our team runs a mix of Mac, PC, and Linux, led us to explore a new direction.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><h5 aria-level="2"><b><span data-contrast="none">Enter .NET Core</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></h5><p><span data-contrast="none">We started investigating .NET Core as a solution because of the cross-platform abilities it offered, and the fact that it works great with VS Code, our cross-platform development solution. We felt like .NET Core allowed us to preserve this flexibility, but not continue diverging our code base,&nbsp;</span><span data-contrast="none">with&nbsp;</span><span data-contrast="none">some&nbsp;</span><span data-contrast="none">new</span><span data-contrast="none">&nbsp;services written in TypeScript, and&nbsp;</span><span data-contrast="none">others&nbsp;</span><span data-contrast="none">in C# on the .NET Framework. This allows us more flexibility when moving work between teams as well. We could have also gone with TypeScript but given the skill set of&nbsp;</span><span data-contrast="none">the majority of</span><span data-contrast="none">&nbsp;the team (C#)</span><span data-contrast="none">&nbsp;and</span><span data-contrast="none">&nbsp;the pain we have seen managing Node.js dependencies, we decided on .NET Core. We’ll discuss the&nbsp;</span><span data-contrast="none">dependency issue</span><span data-contrast="none">&nbsp;in more detail later in this post. For more information on .NET Core, see the </span><a href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.2" target="_blank"><span data-contrast="none">docs</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">Our goal with this post isn’t to convince you that .NET Core is better than Node.j</span><span data-contrast="none">s:</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">w</span><span data-contrast="none">e made our decision primarily based on the skill sets of our team</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">Instead, we want to share the things that we noticed as we have been starting the porting work, in the hope that if you’re embarking on a similar journey, this information will be helpful. If you’re curious about direct comparisons regarding performance, </span><a href="https://www.techempower.com/benchmarks/" target="_blank"><span data-contrast="none">this site</span></a><span data-contrast="none"> is a good resource that is constantly updated. The .NET Core entry on that list is called </span><span data-contrast="none">aspcore</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">Another interesting post explores</span><span data-contrast="none"> </span><a href="https://www.ageofascent.com/2019/02/04/asp-net-core-saturating-10gbe-at-7-million-requests-per-second/" target="_blank"><span data-contrast="none">saturating 10GbE at 7+ million request/s</span></a><span data-contrast="none"> using .NET Core.</span><span data-contrast="none">&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">Also, n</span><span data-contrast="none">ote that for the purposes of this post we aren’t looking at specific TypeScript features, and on our team, we continue to use TypeScript for new front-end development as there are many benefits to having concrete types on top of JavaScript.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}">&nbsp;</span></p><h5 aria-level="2"><b><span data-contrast="none">The Challenge</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></h5><p><span data-contrast="none">We are not embarking on a re-write of all services, but aside from having all new services run on .NET Core targeting AKS, we are looking for opportunities to port over problematic code from either the .NET Framework or Node.js. In this blog post we’ll talk about going from Node.js to .NET Core, by exploring some key differences we noticed as we ported some targeted REST API endpoints. For our take-aways, we are mainly focused on the developer experience, and not necessarily on performance benchmarks or other orthogonal concerns.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><h5 aria-level="2"><b><span data-contrast="none">Key Take-Aways We Noticed</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></h5><p aria-level="3"><b><span data-contrast="none">Porting code into a strongly typed language takes time</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">In our existing&nbsp;</span><span data-contrast="none">TypeScript&nbsp;</span><span data-contrast="none">code base</span><span data-contrast="none">,</span><span data-contrast="none">&nbsp;we take advantage of dynamic types&nbsp;</span><span data-contrast="none">frequently</span><span data-contrast="none">, and in the C# version of the code we had to define more concrete types. Additionally, the code that we were porting specifically dealt with bit masks, so translating those concepts between JavaScript and C# presented some pain for us. One of the main things we lost was easy parsing of JSON and dynamic object graphs. .NET Core includes JSON parsing out of the box, but it isn’t quite as native as what JavaScript provides.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">Another thing that came up was the need to create more mapping types instead of relying on dynamic mapping, which we didn’t have to handle as much since we were already in TypeScript, but if you are coming from a straight JavaScript project this is something else you will want to consider.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">All in all, if you embark on this journey, be prepared to invest the&nbsp;</span><span data-contrast="none">appropriate</span><span data-contrast="none">&nbsp;amount of time on model classes and other scaffolding that you will need for a successful transition.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p aria-level="3"><b><span data-contrast="none">String comparison differences</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">In JavaScript, when doing case insensitive string comparisons, we tend towards doing </span><span data-contrast="none"> <span id="crayon-5e3999048dbcc766997599"><span><span>toLowerCase</span><span>(</span><span>)</span></span></span>&nbsp; prior to doing a <span id="crayon-5e3999048dbe2372522797"><span>===</span></span>, </span><span data-contrast="none">where we don’t care about case. Generally speaking, the equivalent C# code uses  <span id="crayon-5e3999048dbef971618030"><span><span>string</span><span>.</span><span>Equals</span></span></span>&nbsp;</span><span data-contrast="none"> and passes in&nbsp;</span><span data-contrast="none">a  <span id="crayon-5e3999048dbfc609580206"><span><span>StringComparison</span></span></span>&nbsp;</span><span data-contrast="none"> </span><span data-contrast="none">enum</span><span data-contrast="none">&nbsp;value to indicate how to handle issues of case sensitivity.&nbsp;</span><span data-contrast="none">A common case is scenarios where you do not care about case and locale, and for those you should use <span id="crayon-5e3999048dc09096704139"><span><span>StringComparison</span><span>.</span><span>OrdinalIgnoreCase</span></span></span></span><span data-contrast="none">. H</span><span data-contrast="none">ere are some useful references for other scenarios that may arise:</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}">&nbsp;</span></p><ul><li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices-strings" target="_blank"><span data-contrast="none">Picking a&nbsp;</span><span data-contrast="none">StringComparison</span><span data-contrast="none">&nbsp;Member</span></a><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:240}">&nbsp;</span></li><li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><a href="https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/" target="_blank"><span data-contrast="none">Issues with the Turkish&nbsp;</span><span data-contrast="none">i</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}">&nbsp;</span></li></ul><p><span data-contrast="none">A concrete example of porting where both examples return success under the same conditions:</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p>JavaScript:</p><div id="crayon-5e3999048dc16008736163" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>var</span><span> </span><span>desiredValue</span><span> </span>=<span> </span><span>'someValue'</span><span>;</span><span> </span></p><p><span>if</span><span> </span><span>(</span><span>envVar</span><span> </span><span>&amp;&amp; envVar.toLowerCase() === desiredValue.toLowerCase()) { </span></p><p><span>&nbsp;&nbsp;console.log('Success!');</span><span> </span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>Equivalent C#:</p><div id="crayon-5e3999048dc23051372677" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>var</span><span> </span><span>desiredValue</span><span> </span>=<span> </span><span>"someValue"</span><span>;</span><span> </span></p><p><span>if</span><span> </span><span>(</span><span>string</span><span>.</span><span>Equals</span><span>(</span><span>envVar</span><span>,</span><span> </span><span>desiredValue</span><span>,</span><span> </span><span>StringComparison</span><span>.</span><span>OrdinalIgnoreCase</span><span>)</span><span>)</span><span> </span><span>{</span><span> </span></p><p><span>&nbsp;&nbsp;</span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Success"</span><span>)</span><span>;</span><span> </span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p aria-level="3"><b><span data-contrast="none">Fewer dependencies in .NET Core</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">One thing that has been nice is to manage fewer dependencies (and a shallower dependency tree) in the .NET Core version of the code, and hopefully this means it will be easier to maintain. We have struggled with keeping dependencies up to date and managing&nbsp;</span><span data-contrast="none">many</span><span data-contrast="none">&nbsp;dependencies in our Node.js projects. Additionally, developers on our team prefer NuGet’s policy of “lowest matching version” rather than&nbsp;</span><span data-contrast="none">npm’s</span><span data-contrast="none">&nbsp;encouragement to use “highest matching patch” or “highest matching minor version” (using the </span><span data-contrast="none">~</span><span data-contrast="none">syntax in </span><span data-contrast="none">package.json</span><span data-contrast="none"> by default via </span><span data-contrast="none">npm</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">i</span><span data-contrast="none">). We recognize this is a philosophical difference and opinions on this may vary. The pros of the NuGet approach are more control and explicitness, whereas the&nbsp;</span><span data-contrast="none">npm</span><span data-contrast="none">&nbsp;approach allows for theoretically non-breaking changes to be easily applied.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}">&nbsp;</span></p><p aria-level="2"><b><span data-contrast="none">Other Thoughts</span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:360,&quot;335559739&quot;:240,&quot;335559740&quot;:240}">&nbsp;</span></p><p><span data-contrast="none">There isn’t one right answer, and the purpose of this post isn’t to convince you one way or another, just to shed some light on the process we have gone through recently as a&nbsp;</span><span data-contrast="none">team. As we discover and do more in .NET Core</span><span data-contrast="none">&nbsp;on AKS</span><span data-contrast="none">&nbsp;we will be sure to share along the way!</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}">&nbsp;</span></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>