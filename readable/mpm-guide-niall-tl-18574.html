<!DOCTYPE html>
<html lang="en">
<head>
    <title>
mpm guide - niall t.l. - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="mpm guide - niall t.l. - linksfor.dev(s)"/>
    <meta property="og:description" content="niall tl&#x27;s personal site, with an overview of some projects and a few wee articles."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://nialltl.neocities.org/articles/mpm_guide.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - mpm guide - niall t.l.</title>
<div class="readable">
        <h1>mpm guide - niall t.l.</h1>
            <div>Reading time: 32-40 minutes</div>
        <div>Posted here: 30 Apr 2019</div>
        <p><a href="https://nialltl.neocities.org/articles/mpm_guide.html">https://nialltl.neocities.org/articles/mpm_guide.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mls-mpm_37k.gif" alt="a real-time MPM fluid simulation made in Unity using the techniques outlined in this page" title="a real-time MPM fluid simulation made in Unity using the techniques outlined in this page"></p>
<p><em>a real-time 40,000 particle MPM fluid simulation made in Unity using techniques outlined in this page</em></p>
<p><strong>source code for this article: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>

<hr>

<p>i’ve been playing around with particle-based simulations for a while now, and found that some approaches feel a little more esoteric than others. one i had a hard time getting started with is the material point method (MPM).</p>
<p>i’m going to give a very broad outline of the family of methods MPM comes from, just to contextualise it a bit. i’ll then give some bare-bones example implementations, and pointers towards where i’ve found most helpful to learn more.</p>
<p>compared to a few years ago, there’s really great literature on the theory behind MPM, but i always found actual implementation references hard to come by, or webbed up in massive simulation libraries.</p>
<p>my open-source MIT licensed implementations are all single-file (almost-)self contained examples. hopefully this’ll help bridge the gap a little: <strong>source code for this article: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p><strong>note:</strong> deformable simulation is a huge field. my interest is mostly motivated by real-time interactive applications and my mode of understanding is more gestural than mathematically rigorous. i’m going to be very hand-wavey and essentialist. buuuut, hopefully this can act as a little nudge in a less confusing direction if you’d like to play around with these ideas.</p>

<hr>

<p>throughout this page i’ll be referencing existing papers and building an implementation out of them. i won’t really delve too deeply into the theoretical "why"s of how MPM works, but more why i make certain choices. for a more solid backing in what makes MPM tick, here’s a list of papers and resources i’ve found the most helpful to learn from:</p>
<ul>
<li>
<p>MPM Course (SIGGRAPH 2016 notes):</p>
<ul>
<li><a href="http://mpm.graphics/" target="_blank">http://mpm.graphics</a></li>
<li>absolute behemoth of a walkthrough. probably the best bottom-up explanation of MPM i’ve found! i’ll reference this throughout my examples.</li>
</ul>
</li>
<li>
<p>APIC original paper:</p>
<ul>
<li><a href="https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf" target="_blank">https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf</a></li>
<li>a useful reference for the actual implementation of grid-particle transfers that are used in MLS-MPM.</li>
</ul>
</li>
<li>
<p>Taichi MPM implementation, slides &amp; notes</p>
<ul>
<li><a href="https://github.com/yuanming-hu/taichi_mpm/" target="_blank">https://github.com/yuanming-hu/taichi_mpm/</a></li>
<li>the PDF slides and slides with notes are <em>really</em> helpful and give a great side-by-side comparison of MPM and MLS-MPM.</li>
</ul>
</li>
<li>
<p>MLS-MPM original paper:</p>
<ul>
<li><a href="https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html" target="_blank">https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html</a></li>
<li>this might be a bit overwhelming to launch straight into without implementing standard MPM first, but i’d recommend the section “from MPM to MLS-MPM”.</li>
</ul>
</li>
<li>
<p>MLS-MPM implemented in 88 lines of c++</p>
<ul>
<li><a href="https://github.com/yuanming-hu/taichi_mpm/blob/master/mls-mpm88-explained.cpp" target="_blank">https://github.com/yuanming-hu/taichi_mpm/blob/master/mls-mpm88-explained.cpp</a></li>
<li>this is the comments-expanded version of Yuanming Hu’s original 88-line implementation.</li>
<li>similar in structure to our Part 2 implementation, but with a Disney-style constitutive model for snow. useful to see how they differ!</li>
</ul>
</li>
<li>
<p>a maintained curated list of current MPM research</p>
<ul>
<li><a href="https://www.seas.upenn.edu/~cffjiang/mpm.html" target="_blank">https://www.seas.upenn.edu/~cffjiang/mpm.html</a></li>
<li>nice to see a lineage of MPM papers, and might give you some ideas on how to extend what you see on this page.</li>
</ul>
</li>
</ul>

<p><strong>note:</strong> this page contains <a href="#appendix__simulation_methods_and_their_general_vibes_450">an appendix</a> with a guide to the acronym soup that permeates the physics-simulation world. you can consult it to get a quick overview of what various techniques are all about.</p>

<hr>

<p>MPM is a hybrid Lagrangian-Eulerian method that’s really good at simulating a wide range of physical phenomena. you might have first come across MPM through <a href="https://www.youtube.com/watch?v=9H1gRQ6S7gg" target="_blank">this viral sensation</a> from Disney Research. in it, they showcase an implementation of a material model for snow, simulated using MPM. i think it’s a good introduction to the kind of versatility MPM affords.</p>
<p>MPM was originally introduced as an extension of FLIP, to tackle problems in computational solid dynamics. it takes the simulation framework of PIC / FLIP and generalises it to basically anything you can describe with a constitutive equation. solids, liquids, gases, squishy things, you name it.</p>
<p><strong>note:</strong> <em>constitutive equations</em> describe relationships between quantities that characterise the material you want to model. they often include terms like stress, strain, pressure, density, elasticity, etc.</p>
<p>so. as of writing this, a lot of existing MPM literature builds its examples out from a simple material model, like an isotropic elastic material using something like a Neo-Hookean constitutive model.</p>
<p>if you’re anything like me, you have / had no idea what any of them were talking about. i don’t know how common a path it is to come to MPM via other simulation mentalities, but my experience beforehand was mostly other fully particle based methods and i’d never had to confront much continuum mechanics.</p>
<p>i’m going to build out an MPM simulation incrementally, with the end goal of a simple little fluid simulation, assuming some prior knowledge of particle-based methods. specifically i’m going to be implementing a variation of <em>MLS-MPM</em>, and hack around with it a little to try and get something working real-time.</p>
<hr>
<h2><a id="overview_of_the_playing_field_62"></a>overview of the playing field</h2>
<p>to simulate any sort of matter, you need to discretise it in some way. this basically just means deciding on a concrete way to describe what the matter is made up of in terms that can be worked on numerically. this could be like a point cloud (think: particles), a discrete grid of values (think: voxels), or a mesh that describes an area/volume of the surface you’re modeling (think: wireframe vaporwave album covers).</p>
<p>broadly speaking, if you’re wanting to simulate something squishy / fluid-like / deformable, there are usually 3 viewpoints that different simulation models take.</p>
<ul>
<li>


<p>on one end of the spectrum, if the underlying spatial representation of your matter deforms along with its motion, you're using a <em>Lagrangian</em> representation. examples of this would be SPH and PBF, where the spatial representation is the makeup of the particles themselves, or Lagrangian FEM, where the grid / mesh itself deforms under motion.
</p>

</li>
<li>

<p>on the other end, if you choose a completely fixed reference frame, like a regular grid, you're using an Eulerian representation. you divide the domain into fixed chunks, and evaluate continuous field quantities like velocity and density at fixed points on the grid (usually edges or faces). examples of this would be are the Marker-and-Cell method and Lattice-Boltzmann methods.</p>

</li>
<li>

<p>then there’s the ~liminal space~ betwixt. <em>Hybrid</em> methods basically pick and choose between these two ways of looking at the domain. whatever perspective a particular model takes at any given time is basically just whatever works best for the problem it’s trying to solve.</p>


</li>
</ul>

<p>you can find a more thorough exposition of the differences of these reference frames <a href="https://en.wikipedia.org/wiki/Lagrangian_and_Eulerian_specification_of_the_flow_field" target="_blank">here.</a></p>

<p>the reason Hybrid methods are even a thing is that some aspects of physical simulation are just generally more straightforward or efficient to compute from a certain reference frame.</p>

<p>for example, particles are good for mass conservation and handling advection. grids are great for forcing incompressibility for fluids using pressure projection, and it’s significantly easier to evaluate gradients on grids with interpolation methods and finite differences.</p>
<hr>

<p>with that in mind, let’s say we want to simulate a fluid. to start with, we’ll use PIC, as it’s one of the first Hybrid approaches to appear on the scene.</p>
<p>PIC works out the box, but its major problem is that it’s really dissipative. in order to evaluate velocity it has to interpolate data back and forth between the particles and the underlying grid a bunch. because this is never perfect, a little bit of information is lost every time. the result is that a lot of sharp high-res detail of the simulation gets smoothed out, and everything’s very mushy. stable, but mushy:</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/pic.gif" alt="Particle In Cell advection showing high dissipation" title="Particle In Cell advection showing high dissipation"></p>
<p><em>Particle In Cell advection showing high dissipation</em></p>
<p>yeuch! look at all that artificial viscosity. what if we want something more turbulent, and less viscous?</p>
<p>some time later, FLIP is developed. FLIP is just an extension to PIC that uses a slightly different method of advecting particles. it basically feeds a little bit of a particle’s raw individual velocity into the advection routine. most FLIP simulations use a blending value to control how much of this velocity to feed back in, tuning it to keep things stable. here’s that same simulation above using a blending value of 0.95 — 95% FLIP velocity, 5% PIC.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/flip.gif" alt="FLIP fluid simulation showing more turbulent motion" title="FLIP fluid simulation showing more turbulent motion"></p>
<p><em>FLIP fluid simulation showing more turbulent motion</em></p>
<p><strong>sidenote:</strong> if you’re familiar with Smoothed Particle Hydrodynamics, think of this PIC-FLIP mixing as being a little like XSPH. it’s pretty much artificial viscosity made from a smooth-average / “blur” of the velocity field. here the blurred contribution comes from PIC, and the higher resolution per-particle contribution comes from FLIP.</p>
<p>FLIP is a very straightforward extension to PIC that lets you get a much wider range of fluid motion. HOWEVER, it’s still plagued by some big issues. FLIP simulations tend to be a bit less stable than standard PIC, and prone to weird noise. as an example, look at the jittery surface of the above gif. the free surface here is particularly noisy because there’s fewer particles to scatter data to the grid. as a result, the errors are more pronounced.</p>
<p>good news: the problems with FLIP have recently been pretty much solved! see the Affine Particle In Cell method (APIC), or a high-order generalisation of it, PolyPIC. these approaches one-up FLIP’s approach of mixing more info back into the grid, by storing a little affine matrix at each particle that holds a little extra context for use in our particle-grid scattering.</p>
<p>the reason this is relevant to MPM is that one recent development, Moving Least Squares MPM (MLS-MPM) makes use of APIC-style transfers at its core. i’ll be implementing MLS-MPM in my incremental simulations, because it’s both more efficient and actually <em>simpler</em> than standard MPM! wow!</p>
<p><strong>why skip straight to MLS-MPM, rather than standard MPM first?</strong></p>
<p>because it’s simpler! standard MPM requires you to calculate both grid interpolation functions and their gradients, for each particle. MLS-MPM allows you to do away with gradients completely. for me, the gradient stuff feels a bit like conceptual baggage, and is more computationally intensive. the MPM course i linked to above is a good reference for further info.</p>
<p>at this point, i’m going to pivot over to MLS-MPM from an implementation perspective. as we get further in, we’ll see how all that we’ve covered in this section links in.</p>

<hr>

<p>so, off we pop. our goal is to start by trying to make what i guess could be MPM’s “hello world”, a little elastic shape.</p>
<p><strong>more specifically:</strong> i’m going to be building a 2D simulation of an elastic material, using MLS-MPM with quadratic b-spline weights under an explicit time integration scheme. i’ll be building it out as single-file examples in Unity, using Unity’s data-oriented language <em>High-Performance C#</em>.</p>
<p>i think the most readable intro to the structure of MPM i know of is the SIGGRAPH 2016 MPM course. however, it doesn’t cover MLS-MPM. i find the original MLS-MPM paper a bit overwhelming to just drop into, so instead i’m going to reference the structure of the course pdf and then specify wherever i switch over to MLS-MPM.</p>
<hr>
<h2><a id="simulation_structure_121"></a>simulation structure</h2>
<p>to set the scene a little, here’s an overview of the structure of our data. we need particles and a grid. here is the minimum required for a basic MLS-MPM sim:</p>
<!-- HTML generated using hilite.me --><div><pre><span>struct</span> <span>Particle</span> <span>{</span>
    <span>float2</span> <span>x;</span> <span>// position</span>
    <span>float2</span> <span>v;</span> <span>// velocity</span>
    <span>float</span> <span>mass;</span>
<span>};</span>
</pre></div>

<p>our particles’ mass will stay constant throughout the simulation. it becomes more relevant if you’re doing multi-phase simulation, but in all my examples it’ll just be set to <code>1</code>.</p>
<!-- HTML generated using hilite.me --><div><pre><span>struct</span> <span>Cell</span> <span>{</span>
    <span>float2</span> <span>v;</span> <span>// velocity</span>
    <span>float</span> <span>mass;</span>
<span>}</span>
</pre></div>
<p>our grid is made up of individual cells. it’s literally just a big array of them. in the implementation below, i use a 1D grid for efficiency reasons, and remap to 2D indices when required. you can easily do this with a 2D/3D array of cells instead if you like.</p>
<p>the size of our grid determines the resolution of our simulation. if we choose a grid size of, say, 32 by 32, then our particles’ coordinates will range from <code>(0, 0)</code> to <code>(31, 31)</code>. it’s common to use a power of 2 for the grid size, for performance reasons when parallelising. i’m usually using a grid size of 64 in the gifs on this page.</p>
<p><strong>conceptual clearup</strong>: the grid in MPM is cleared at the start of every frame. it’s just a scratch-pad for calculating certain quantities, and you chuck it away at the end of each simulation step. so, none of the values in our Cell struct are constant throughout the simulation.</p>
<p><strong>note:</strong> the above is the near-minimum for a getting a classical MPM simulation moving. if we want more sophisticated behaviour (we do), we’ll likely need to keep track of a deformation gradient matrix at each particle, and some notion of their volume. when we move on to using MLS-MPM, we’ll add a little bit more info still. namely, each particle needs to store an affine momentum matrix we talked about above for APIC.</p>
<p>in traditional MPM, you would also store a force vector at each cell. with MLS-MPM, you can get rid of explicitly it entirely, and instead fuse it together with the velocity update!</p>
<hr>
<h2><a id="simulation_loop_152"></a>simulation loop</h2>
<p>below is an outline of the MLS-MPM algorithm.</p>
<p>at each step, i’ve included a brief note on what the algorithm’s trying to do, with inline references to our <a href="#references_and_useful_links_18">fave papers</a>. i find it helpful to look at the broad strokes of how MPM actually runs around the data, before diving into the specifics of how each step specifically transforms it. hopefully it’ll clear up what happens where.</p>
<p>for a more detailed step-by-step walkthrough, i recommend looking at chapter 10.5, “MPM Scheme: Full Algorithm” in the MPM course. that outlines the procedure of standard MPM. from there, look at section 4, “From MPM to MLS-MPM” in the <a href="#references_and_useful_links_18">original MLS-MPM paper</a>.</p>

<!-- HTML generated using hilite.me --><div><pre><span>Particle[]</span> <span>particles;</span>
<span>Cell[]</span> <span>grid;</span>

<span>void</span> <span>initialise</span><span>()</span> <span>{</span>
    <span>// 1.  initialise your grid - fill your grid array with (grid_res * grid_res) cells.</span>
    
    <span>// 2. create a bunch of particles. set their positions somewhere in your simulation domain.</span>
    <span>// initialise their deformation gradients to the identity matrix, as they're in their undeformed state.</span>

    <span>// 3. optionally precompute state variables e.g. particle initial volume, if your model calls for it</span>
<span>}</span>

<span>void</span> <span>each_simulation_step</span><span>()</span> <span>{</span>
    <span>// 1. reset our scratch-pad grid completely</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>grid)</span> <span>{</span>
        <span>// zero out mass and velocity for this cell</span>
    <span>}</span>

    <span>// 2. particle-to-grid (P2G). </span>
    <span>// goal: transfers data from particles to our grid</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
        <span>// 2.1: calculate weights for the 3x3 neighbouring cells surrounding the particle's position </span>
        <span>// on the grid using an interpolation function</span>

        <span>// 2.2: calculate quantities like e.g. stress based on constitutive equation</span>

        <span>// 2.3:</span>
        <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>particle_neighbourhood)</span> <span>{</span>
            <span>// scatter our particle's momentum to the grid, using the cell's interpolation weight calculated in 2.1</span>
        <span>}</span>
    <span>}</span>

    <span>// 3. calculate grid velocities</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>grid)</span> <span>{</span>
        <span>// 3.1: calculate grid velocity based on momentum found in the P2G stage</span>

        <span>// 3.2: enforce boundary conditions</span>
    <span>}</span>

    <span>// 4. grid-to-particle (G2P). </span>
    <span>// goal: report our grid's findings back to our particles, and integrate their position + velocity forward</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
        <span>// 4.1: update particle's deformation gradient using MLS-MPM's velocity gradient estimate</span>
        <span>// Reference: MLS-MPM paper, Eq. 17</span>

        <span>// 4.2: calculate neighbouring cell weights as in step 2.1.</span>
        <span>// note: our particle's haven't moved on the grid at all by this point, so the weights will be identical</span>

        <span>// 4.3: calculate our new particle velocities</span>
        <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>particle_neighbourhood)</span> <span>{</span>
            <span>// 4.3.1: </span>
            <span>// get this cell's weighted contribution to our particle's new velocity</span>
        <span>}</span>

        <span>// 4.4: advect particle positions by their velocity</span>
    <span>}</span>
<span>}</span>
</pre></div>


<hr>

<p>ok, so at this point, a lot of the actual details are pretty occluded. i think the above-mentioned papers do a pretty good job of filling in the conceptual details. so let’s look at fleshing it out a little.</p>
<p>i’ve annotated the source code with references to the papers that give more detail, so i think learning from a combination of these references and the source itself will be the best way to work your way through it.</p>
<p>the first version of our MPM implementation just creates some particles initialised with random velocities, and the MPM takes over the rest and moves them around a wee bit.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_first_pass.gif" alt="MPM simulation with no deformation model" title="MPM simulation with no deformation model"></p>
<p><em>MPM with no deformation model, just randomised initial velocities</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>this is a first blush with how things generally move in MLS-MPM, using APIC-style grid transfers. it completely omits anything to do with modeling deformations, but we’ll build from here.</p>
<p>i use quadratic interpolation for calculating the cell weights, which evalates the 3x3 cell-neighbourhood of each particle. it’s a good balance between performance and stability. you’ll get more physically accurate and stable simulations if you use higher order interpolation over bigger stencil sizes. but quadratic interpolation strikes a nice balance of being cheap to compute and a improving significantly on linear interpolation behaviour-wise.</p>
<p>i’m using a neat trick for calculating the weights that i first came across in Yuangmin Hu’s <a href="#references_and_useful_links_18">88-line MLS-MPM example</a>. it just stores 3 float2’s and cross-multiplies them when iterating over the 9 cells surrounding a given particle. depending on how you end up arranging your cell memory accesses, you may want to lay things out differently.</p>

<hr>

<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_neohookean.gif" alt="MPM simulation with isotropic elasticity using a Neo-Hookean model" title="MPM simulation with isotropic elasticity using a Neo-Hookean model"></p>
<p><em>MPM simulation with isotropic elasticity using a Neo-Hookean model</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>we’re now actually making use of the deformation gradient and affine momentum matrix we’d set up for part 1. as in part 1, references to derivations are included inline in the source. just to get your bearings, here’s a stripped back focus on where the majority of the actual material modelling is implemented:</p><!-- HTML generated using hilite.me --><div><pre><span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>var</span> <span>F</span> <span>=</span> <span>p.F;</span> <span>// deformation gradient</span>

    <span>// MPM course page 13, "Kinematics Theory"</span>
    <span>var</span> <span>J</span> <span>=</span> <span>math.determinant(F);</span>
    <span>var</span> <span>volume</span> <span>=</span> <span>p.volume_0</span> <span>*</span> <span>J;</span>

    <span>// required terms for Neo-Hookean model (eq. 48, MPM course)</span>
    <span>var</span> <span>F_T</span> <span>=</span> <span>math.transpose(F);</span>
    <span>var</span> <span>F_inv_T</span> <span>=</span> <span>math.inverse(F_T);</span>
    <span>var</span> <span>F_minus_F_inv_T</span> <span>=</span> <span>F</span> <span>-</span> <span>F_inv_T;</span>
    
    <span>// eq. 48, MPM course</span>
    <span>var</span> <span>P_term_0</span> <span>=</span> <span>elastic_mu</span> <span>*</span> <span>(F_minus_F_inv_T);</span>
    <span>var</span> <span>P_term_1</span> <span>=</span> <span>elastic_lambda</span> <span>*</span> <span>math.log(J)</span> <span>*</span> <span>F_inv_T;</span>
    <span>var</span> <span>P</span> <span>=</span> <span>P_term_0</span> <span>+</span> <span>P_term_1;</span>

    <span>// Cauchy stress = (1 / det(F)) * P * F_T</span>
    <span>// equation 38, MPM course</span>
    <span>stress</span> <span>=</span> <span>(</span><span>1.0f</span> <span>/</span> <span>J)</span> <span>*</span> <span>math.mul(P,</span> <span>F_T);</span>

    <span>// (M_p)^-1 = 4, see APIC paper and MPM course page 42</span>
    <span>// this term is used in MLS-MPM paper eq. 16. with quadratic weights, Mp = (1/4) * (delta_x)^2.</span>
    <span>// in this simulation, delta_x = 1, because i scale the rendering of the domain rather than the domain itself.</span>
    <span>// we multiply by dt as part of the process of fusing the momentum and force update for MLS-MPM</span>
    <span>var</span> <span>eq_16_term_0</span> <span>=</span> <span>-volume</span> <span>*</span> <span>4</span> <span>*</span> <span>dt</span> <span>*</span> <span>stress;</span>

    <span>// we calculate the rest of the force term inside the loop</span>
    <span>foreach</span> <span>(Cell</span> <span>cell</span> <span>in</span> <span>p.neighbourhood)</span> <span>{</span>
        <span>float2</span> <span>cell_dist</span> <span>=</span> <span>(cell.x</span> <span>-</span> <span>p.x)</span> <span>+</span> <span>0.5f</span><span>;</span>
        <span>float2</span> <span>Q</span> <span>=</span> <span>math.mul(p.C,</span> <span>cell_dist);</span>

        <span>// MPM course equation (172)</span>
        <span>float</span> <span>weighted_mass</span> <span>=</span> <span>weight</span> <span>*</span> <span>p.mass;</span>
        
        <span>cell.mass</span> <span>+=</span> <span>weighted_mass;</span>
        <span>cell.v</span> <span>+=</span> <span>weighted_mass</span> <span>*</span> <span>(p.v</span> <span>+</span> <span>Q);</span>
        
        <span>// fused force/momentum update from MLS-MPM</span>
        <span>// see MLS-MPM paper, equation listed after eqn. 28</span>
        <span>float2</span> <span>momentum</span> <span>=</span> <span>math.mul(eq_16_term_0,</span> <span>cell_dist)</span> <span>*</span> <span>cell.weight;</span>
        <span>cell.v</span> <span>+=</span> <span>momentum;</span>
        
        <span>// total update on cell.v is now: weight * (dt * M^-1 * p.volume * p.stress + p.mass * p.C)</span>
        <span>// this is the fused momentum + force from MLS-MPM. however, instead of our stress </span>
        <span>// being derived from the energy density, i use the weak form with cauchy stress. converted:</span>
        <span>// p.volume_0 * (dΨ/dF)(Fp)*(Fp_transposed)</span>
        <span>// is equal to p.volume * σ</span>
    <span>}</span>
<span>}</span>
</pre></div>


<p>for part 2, i’ve parallelised some of the steps of the MPM algorithm. this is easy to do with HPC# in Unity, and hopefully doesn’t confuse you too much. it’s mostly for performance in the demos.</p>
<p>i’ve only parallelised the parts that can be done ‘naively’, namely steps 1, 3 &amp; 4 of the pseudocode outline above. i just split the workload of each loop evenly into several blocks, without rearranging the structure of our data. we can do this for these steps of the algorithm as they only do concurrent reads to shared areas of memory, and there’s no risk of a data race when writing here as each thread is effectively dedicated to either 1 cell or 1 particle independently.</p>

<hr>

<p>you can get an absolutely wild range of motion just from part 2. you can even kinda approximate fluid just by changing the <a href="https://en.wikipedia.org/wiki/Lam%C3%A9_parameters" target="_blank">Lamé parameters</a> (try e.g. <code>lambda = 100, mu = 0.1</code>). but the fact is, we’ve chosen a constitutive model most suited to elastic deformation. for fluids, we want a different approach.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_fake_fluid.gif" alt="&amp;quot;Fake&amp;quot; fluid with a non-linear isotropic elasticity model&amp;quot;" title="&quot;Fake&quot; fluid with a non-linear isotropic elasticity model">
<img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_fluid_constitutive_model.gif" alt="MPM with a constitutive model for isotropic fluids" title="MPM with a constitutive model for isotropic fluids"></p>
<p><em>left: “fake” fluids with Neo-Hookean elasticity  —  right: using a constitutive model for isotropic fluids</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>i was first drawn to MPM by its real-time fluid simulation potential (particularly the work of <a href="https://www.grantkot.com/" target="_blank">Grant Kot</a>). i generally found that MPM out of the box isn’t actually that great for this, compared to something like Position Based Fluids. the reason being mostly that for a fluid, the deformation that happens at an individual particle can be massive relative to its initial configuration, extremely quickly, e.g. when a liquid splashes. this means you typically would need to use a prohibitively low timestep. MPM is also kind of tricky to fully parallelise (it’s do-able, but a bit of a pain).</p>
<p>to get to the real-time fluid sims you see on this page, i tweak a few things from standard MPM. credits to Grant Kot for the altered volume calculations and boundary conditions tricks.</p>
<hr>
<h2><a id="constitutive_model_switchup_318"></a>constitutive model switchup</h2>
<p>to start with, we need a constitutive model better suited to fluids. i trawled the web and found <a href="https://en.wikipedia.org/wiki/Newtonian_fluid" target="_blank">the stress-strain relationship of Newtonian fluids</a>, and from there it’s just a matter of swapping out the stress-strain model we used in part 2 for something appropriate for fluids. in code it looks roughly like this:</p>
<!-- HTML generated using hilite.me --><div><pre><span>// end goal, constitutive equation for isotropic fluid: </span>
<span>// stress = -pressure * I + viscosity * (velocity_gradient + velocity_gradient_transposed)</span>

<span>float2x2</span> <span>stress</span> <span>=</span> <span>math.float2x2(</span>
    <span>-pressure,</span> <span>0</span><span>,</span> 
    <span>0</span><span>,</span> <span>-pressure</span>
<span>);</span>

<span>// velocity gradient - MLS-MPM eq. 17, where derivative of quadratic polynomial is linear</span>
<span>float2x2</span> <span>dudv</span> <span>=</span> <span>p.C;</span>

<span>// build strain from the velocity gradient</span>
<span>float2x2</span> <span>strain</span> <span>=</span> <span>dudv;</span>
<span>strain[</span><span>0</span><span>][</span><span>1</span><span>]</span> <span>=</span> <span>strain[</span><span>1</span><span>][</span><span>0</span><span>]</span> <span>=</span> <span>trace(dudv);</span>

<span>float2x2</span> <span>viscosity_term</span> <span>=</span> <span>dynamic_viscosity</span> <span>*</span> <span>strain;</span>
<span>stress</span> <span>+=</span> <span>viscosity_term;</span>
</pre></div>

<p>the pressure term here is given by an <a href="https://en.wikipedia.org/wiki/Equation_of_state" target="_blank">equation of state</a>, which you might recognise from SPH simulations. in the attached example, i use the Tait equation of state, which is a pretty typical choice for weakly compressible fluids (look up <em>WCSPH</em> as an example of this in an SPH context).</p>
<hr>
<h2><a id="evolving_volume_346"></a>evolving volume</h2>
<p>in part 2, we used the “classic MPM” way of determining volume. you start with an initial value for each particle’s volume at the start of your simulation. you then update your understanding of the volume a particle occupies by looking at its deformation gradient as it undergoes change. the issue with this is that volume is susceptible to inaccuracies that snowball over time. the accuracy of your volume estimate is determined heavily by the accuracy of your numerical integration scheme and the timestep that you choose. for a fluid, where the surrounding area of an individual particle can rapidly change and is basically undergoing constant plastic deformation, it can blow up very easily.</p>
<p>a way of tackling this is to re-do that initial calculation of each particle’s volume that you did at the start of the simulation, and go through that process every simulation step. this means your volume is no longer a quantity integrated over time and thus susceptible to that kind of numerical error. the downside: it’s significantly less computationally efficient per-frame. the upside: you can get away with a significantly higher timestep! in practice, i found that this tradeoff was definitely worth it.</p>
<p>the way i calculate a particle’s volume is reminiscent of the way SPH/PBF does it: by looking at neighbourhoods to get a density estimate. first, we scatter every particle’s mass to the grid. then, we gather them back up, weighting each grid cell’s contribution by the interpolation weights (or “shape function”, in MPM-speak). scattering mass is already a step in the P2G phase of MPM, so it comes down to injecting another subroutine to loop over particles and sum up density. skipping over the boilerplate cell/weight calculations, it’s roughly like this:</p>

<!-- HTML generated using hilite.me --><div><pre><span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>float</span> <span>density</span> <span>=</span> <span>0.0f</span><span>;</span>
    <span>// sum up mass contribution of each of the 9 cells surrounding tthe particle</span>
    <span>foreach</span> <span>(Cell</span> <span>cell</span> <span>in</span> <span>p.neighbourhood)</span> <span>{</span>
            <span>density</span> <span>+=</span> <span>cell.mass</span> <span>*</span> <span>cell.weight;</span>
        <span>}</span>
    <span>}</span>
    <span>float</span> <span>volume</span> <span>=</span> <span>1.0f</span> <span>/</span> <span>density;</span>

    <span>// ...</span>
<span>}</span>
</pre></div>


<p>this is the exact same procedure i used in part 2’s initialisation phase, to determine particles’ initial volumes. if you exchanged part 2’s existing volume calculation based on <code>p.volume_0</code>, it’d yield very similar results. this of course comes at the cost of significantly more scattered memory reads at each particle. but it’s worth it for those sweet soupy vortices. i promise you.</p>
<hr>
<h2><a id="softened_boundary_conditions_371"></a>softened boundary conditions</h2>
<p>i’ve been using a very simple boundary condition up until now: a ‘slip’ condition that zeroes out the tangent component of the grid’s velocity field at the edges.</p>
<p>for improved stability in our real-time simulation, we can alter the boundary conditions a bit to operate on particles <em>directly</em>, as well as on cells. in addition to zeroing out particle velocities, we can do a bit of a predictive leap in deciding when to enforce our boundary conditions. this generally helps with particles ‘tunneling’ through to the boundary at high speed.</p>
<p>here’s an isolated view of where and how boundary conditions are actually enforced this way:</p>

<!-- HTML generated using hilite.me --><div><pre><span>// standard cell boundary conditions</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_cells;</span> <span>++i)</span> <span>{</span>
    <span>var</span> <span>cell</span> <span>=</span> <span>cells[i];</span>

    <span>// convert 1D index to 2D</span>
    <span>int</span> <span>x</span> <span>=</span> <span>i</span> <span>/</span> <span>grid_res;</span>
    <span>int</span> <span>y</span> <span>=</span> <span>i</span> <span>%</span> <span>grid_res;</span>

    <span>// zero out velocities around the perimeter</span>
    <span>if</span> <span>(x</span> <span>&lt;</span> <span>2</span> <span>||</span> <span>x</span> <span>&gt;</span> <span>grid_res</span> <span>-</span> <span>3</span><span>)</span> <span>{</span> <span>cell.v.x</span> <span>=</span> <span>0</span><span>;</span> <span>}</span>
    <span>if</span> <span>(y</span> <span>&lt;</span> <span>2</span> <span>||</span> <span>y</span> <span>&gt;</span> <span>grid_res</span> <span>-</span> <span>3</span><span>)</span> <span>{</span> <span>cell.v.y</span> <span>=</span> <span>0</span><span>;</span> <span>}</span>
<span>}</span>

<span>const</span> <span>int</span> <span>wall_min</span> <span>=</span> <span>3</span><span>;</span>
<span>const</span> <span>int</span> <span>wall_max</span> <span>=</span> <span>(grid_res</span> <span>-</span> <span>1</span><span>)</span> <span>-</span> <span>wall_min;</span>

<span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>// safely clamp particle positions to be inside the grid</span>
    <span>p.x</span> <span>=</span> <span>math.clamp(p.x,</span> <span>1</span><span>,</span> <span>grid_res</span> <span>-</span> <span>2</span><span>);</span>

    <span>// NEW: predictive boundary conditions that soften velocities near the domain's edges </span>
    <span>float2</span> <span>x_n</span> <span>=</span> <span>p.x</span> <span>+</span> <span>p.v;</span>
    <span>if</span> <span>(x_n.x</span> <span>&lt;</span> <span>wall_min)</span> <span>p.v.x</span> <span>+=</span> <span>wall_min</span> <span>-</span> <span>x_n.x;</span>
    <span>if</span> <span>(x_n.x</span> <span>&gt;</span> <span>wall_max)</span> <span>p.v.x</span> <span>+=</span> <span>wall_max</span> <span>-</span> <span>x_n.x;</span>
    <span>if</span> <span>(x_n.y</span> <span>&lt;</span> <span>wall_min)</span> <span>p.v.y</span> <span>+=</span> <span>wall_min</span> <span>-</span> <span>x_n.y;</span>
    <span>if</span> <span>(x_n.y</span> <span>&gt;</span> <span>wall_max)</span> <span>p.v.y</span> <span>+=</span> <span>wall_max</span> <span>-</span> <span>x_n.y;</span>
<span>}</span>
</pre></div>


<hr>
<h2><a id="conclusion_410"></a>conclusion</h2>
<p>with the above-mentioned 3 tweaks, i’ve managed to get some really nice interactive and stable fluid simulations running in real-time. the main trade-off being made is that of continuously reevaluating the volume, as it does create another memread bottleneck (and MPM already has quite a few of these).</p>
<p>i don’t imagine MPM being a go-to solution for real-time simulations like this in general as it has such high computational overhead. nonetheless, i think shooting for real-time has been really nice when experimenting with new material models. and it makes for some fun squishy toys.</p>
<p><strong>a note on multi-phase simulation</strong>:</p>
<p>getting multiple phases running in your simulations is literally as easy as storing material properties with your particles rather than globally. you can then instantiate particles with the desired individual characteristics and everything will be nicely coupled together.</p>
<p><strong>a note about surface tension</strong>:</p>
<p>i haven’t actually directly implemented any solution for this. however, a combination of 1) the equation of state giving negative pressures (that i clamp a little), and 2) the quadratic kernels themselves, yield really nice filaments already.</p>
<p>if you do want to explicitly mix in more tweakable surface tension, i’d maybe start by looking at the paper <a href="https://web.archive.org/web/20190426162509/http://www.techscience.com/doi/10.3970/cmes.2012.086.199.pdf" target="_blank">“On the Modeling of Surface Tension and its Applications by the Generalized Interpolation Material Point Method”</a>.<br>
however, that approach requires evaluating weight gradients for determining surface curvature, which MLS-MPM manages to otherwise avoid. finding a way to integrate surface tension models into a gradient-free MLS-MPM implementation would be a cool direction for further research!</p>

<hr>

<p>hip-hip hooray, this is just the beginning!!</p>
<p>there are so many avenues left unexplored right now. i’ve written up a small list below.</p>
<p>if you have any questions feel free to reach out to me. i’m easiest to reach on twitter <a href="https://twitter.com/nialltl" target="_blank">@nialltl</a>.</p>
<ul>
<li>implicit time integration
<ul>
<li>my MLS-MPM implementation uses a explicit integration. implicit approaches are way more computationally intensive per-simulation-step. but, in some cases, they make up for this by allowing you to take wayyyy bigger timesteps, and can end up faster overall as a result. this <em>isn't a guarantee</em>, though. <a href="#acknowledgements_489">Yuanming Hu</a> alerted me to the fact that since we don't have a good preconditioner for MPM, unlike e.g.  Lagrangian cloth or SPH-style incompressible fluids, an implicit solver for MPM is generally not likely to be worth its weight. might be worth exploring anyway though. </li>
<li>the reason i’ve not delved into this is because it’s just harder! implicit MPM iteratively solves a system of equations to determine force updates on cells. existing implementations i could find tend to rely on big number-crunching libraries like Eigen to do the bulk of this work. if you dive into this please let me know, i’d love to see how you get on!</li>
</ul>
</li>
<li>extended boundary conditions
<ul>
<li>currently we only have a slip condition at the edges of the simulation domain. would be nice to have more extensive collision handling with static objects (and dynamic, if you’re willing to go absolutely nuts)</li>
</ul>
</li>
<li>parallelisation
<ul>
<li>huge topic that i’ve lost a lot of hours in! there are a bunch of ways you can go about improving MPM’s multithreading potential. being able to perform the expensive P2G step in parallel is a huge performance win.</li>
<li>i’m hoping to write another article about this soon! i’ll be sharing my GPU implementation with compute shaders in due course. i’ll <a href="https://twitter.com/nialltl" target="_blank">tweet about this</a> when it happens.</li>
</ul>
</li>
<li>adaptive / asynchronous time stepping
<ul>
<li>asynchronous MPM is a cool optimisation area. basically, you don’t have to simulate all of your simulation domain at the same rate. if some of your scene is barely moving or under little pressure, there’s no need to waste cycles there. you could start with <a href="https://web.archive.org/web/20190427141455/http://squarefk.com/static/files/fang2018async.pdf" target="_blank">"A Temporally Adaptive Material Point Method with Regional Time Stepping"</a>.</li>
</ul>
</li>
<li>more complex deformation models and material behaviour
<ul>
<li>a never-ending realm of possibility. you could look at <a href="https://web.archive.org/web/20190426233329/https://www.math.ucla.edu/~jteran/papers/GHFGTT18.pdf" target="_blank">simulating thin shells for e.g. fabrics</a>, <a href="https://web.archive.org/web/20170105121042/https://www.math.ucla.edu/~jteran/papers/RGJSSTK15.pdf" target="_blank">viscoelastic foams &amp; sponges</a>, or <a href="https://www.seas.upenn.edu/~cffjiang/mpm.html" target="_blank">anything listed here</a>.</li>
</ul>
</li>
</ul>

<hr>

<p>there are heaps of techniques for simulating deformable objects. i found it easy to get overwhelmed with the amount of criss-crossing references to different approaches and histories when trying to pick up MPM. here’s a quick overview of some stuff that you might come across:</p>
<h3>Lagrangian</h3>
<ul>
<li>SPH: Smoothed Particle Hydrodynamics
<ul>
<li>particle-based fluid simulation method. computes field quantities by looking at surrounding particle neighbourhoods.</li>
<li>has a hilarious amount of variations differing mostly in acronym length (ISPH, IISPH, PCISPH, DCSPH, … generally trying to improve incompressibility).</li>
</ul>
</li>
<li>PBD: Position Based Dynamics
<ul>
<li>general simulation methodology, handles constraints geometrically using direct positional corrections.</li>
<li>not that physically motivated but generally fast and great for real-time applications. super stable.</li>
<li>often suffers from damping, but higher order PBD integrators help with this.</li>
</ul>
</li>
<li>PBD: Position Based Fluids
<ul>
<li>like SPH, but using a PBD integrator. enforces incompressibility by putting a constraint on particles’ densities.</li>
</ul>
</li>
</ul>
<h3>Hybrid Lagrangian-Eulerian</h3>
<ul>
<li>PIC: Particle-In-Cell
<ul>
<li>general family of methods using a mixture of grids and particles for simulation. an absolute classic, been around a long time.</li>
<li>used for astronomical simulations and liquids / gases generally.</li>
</ul>
</li>
<li>FLIP: Fluid Implicit Particle
<ul>
<li>like PIC, but with an improved way of advecting particles.</li>
<li>typically used for fluids. common in a lot of 3D simulation packages, e.g. Blender, Houdini.</li>
</ul>
</li>
<li>MPM: Material Point Method
<ul>
<li>another PIC method, more versatile than something like FLIP.</li>
<li>good for deformable soft matter and fluids.</li>
<li>supports multiple phases (different materials interacting with each other) fairly effortlessly.</li>
<li>typically requires a very small timestep, comparatively high memory requirements.</li>
<li>easily exhibits numerical fracture (stuff splitting apart), which you might not always want.</li>
</ul>
</li>
<li>GIMP: Generalised Interpolation Material Point Method
<ul>
<li>a particular flavour of MPM that emerged early on that solved early issues with linearly weighted MPM, to stop particles oscillating erroneously at cell boundaries.</li>
</ul>
</li>
<li>APIC: Affine Particle-In-Cell
<ul>
<li>very recent significant improvement on PIC, one-upping a fix for PIC’s dissipation problems that FLIP tried to solve.</li>
</ul>
</li>
<li>PolyPIC: Polynomial Particle-In-Cell
<ul>
<li>the wider family of methods that APIC belongs to. basically a higher-order generalisation.</li>
</ul>
</li>
<li>MLS-MPM: Moving Least Squares Material Point Method
<ul>
<li>like MPM, but taking ideas from APIC and bringing them in</li>
<li>state o’ the art. a straight up improvement on MPM. simplifies the whole algorithm and is more computationally efficient too.</li>
<li>this algorithm is what we just implemented! :o)</li>
</ul>
</li>
</ul>

<hr>

<ul>
<li>
<p><a href="https://benedikt-bitterli.me/" target="_blank">Benedikt Bitterli</a>'s project <a href="https://github.com/tunabrain/incremental-fluids" target="_blank">Incremental Fluids</a> inspired the format of my built-out examples. it’s a really great resource on Eulerian fluid simulation.</p>
</li>
<li>
<p><a href="https://www.grantkot.com/" target="_blank">Grant Kot</a>'s work on MPM and real-time sims in general has been really inspiring and useful! he also helped me out a bunch with MPM back in the day.</p>
</li>
<li>
<p><a href="http://taichi.graphics/me/" target="_blank">Yuanming Hu</a> very kindly looked over this page to ensure i wasn’t spreading any cursedly off-piste information about MPM, thanks Yuanming!</p>
</li>
<li>
<p><a href="https://twitter.com/sebaaltonen" target="_blank">Sebastian Aaltonen</a>'s various twitter threads on simulations and parallel architecture for real-time work have been a great reference and source of motivation.</p>
</li>
</ul>
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>