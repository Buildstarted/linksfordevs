<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Nintendo 64 Architecture | A Practical Analysis - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Nintendo 64 Architecture | A Practical Analysis - linksfor.dev(s)"/>
    <meta property="og:description" content="An in-depth analysis that explains how this console works internally"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://copetti.org/projects/consoles/nintendo-64/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Nintendo 64 Architecture | A Practical Analysis</title>
<div class="readable">
        <h1>Nintendo 64 Architecture | A Practical Analysis</h1>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 22 Apr 2020</div>
        <p><a href="https://copetti.org/projects/consoles/nintendo-64/">https://copetti.org/projects/consoles/nintendo-64/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div class="page"><nav id="navbar"></nav><hr><h2 id="a-quick-introduction">A quick introduction</h2><p>Nintendo’s goal was to give players the <em>best</em> graphics possible, for this it will partner with one of the biggest players in computer graphics to produce the <em>ultimate</em> graphics chip.</p><p>The result was a nice-looking console for the family… and a 500-page manual for the developer.</p><p>Don’t worry, I promise you this article will not be <em>that</em> long… Enjoy!</p><hr><h2 id="cpu">CPU</h2><p>The main processor is a <strong>NEC VR4300</strong> that runs at 93.75 MHz, it’s a binary-compatible version of Silicon Graphics’ <strong>MIPS R4300i</strong> that features:</p><ul><li>A <strong>MIPS III ISA</strong>: Succeeds the MIPS II featuring new 64-bit instructions. 64-bit words are called <em>doublewords</em>.</li><li>An internal <strong>64-bit bus</strong> while connected to an <strong>external 32-bit data bus</strong>.</li><li><strong>5-stage pipeline</strong>: Up to five instructions can be executed simultaneously.</li><li><strong>24 KB L1 cache</strong>: Divided in 16 KB for instructions and 8 KB for data.</li></ul><p>An internal <strong>64-bit FPU</strong> is also included in this package, the CPU identifies it as a co-processor (<em>COP1</em>) although the unit is fitted next to the ALU and it’s only accessed through the ALU pipeline, meaning there’s no co-processing per se.</p><h4 id="simplified-memory-access">Simplified memory access</h4><p>The way RAM is assembled follows the <strong>unified-memory architecture</strong> or ‘UMA’ where all available RAM is centralised in one place only and all components that need to use will access this same location. The component arbitrating its access is, in this case, the GPU.</p><p>The reason for choosing this design comes to the fact that it saves a considerable amount of production costs while, on the other side, it increments access contention if not managed properly.</p><h4 id="no-dma-controller">No DMA controller?</h4><p>Due to the unified memory architecture, the CPU no longer has direct access to RAM, so the GPU will be providing DMA functionality as well.</p><h4 id="ram-available">RAM Available</h4><p>Apart from the UMA, the way of addressing RAM is a little bit complicated, so I’ll try to keep it simple, here it goes…</p><p>The system physically contains <strong>4.5 MB of RAM</strong>, however it’s connected using a <strong>9-bit</strong> bus where the 9th bit can only be accessed by the GPU (more details later). As a consequence, every component except the GPU will only find <strong>up to 4 MB</strong>.</p><p>The type of RAM fitted in the board is called <strong>Rambus DRAM</strong> or ‘RDRAM’ for short, this was just another design that competed against SDRAM on becoming the next standard. RDRAM is connected in <strong>serial</strong> (where transfers are done one bit at a time) while SDRAM uses a <strong>parallel connection</strong> (transfers multiple bits at a time).</p><p>RDRAM’s latency is directly proportional to the number of banks installed and as a consequence, with the amount of RAM this system has, the resulting latency <strong>is significant</strong>.</p><p>By contrast, the amount of available RAM on this console <strong>can be expanded</strong> by installing the <em>Expansion Pak</em> accessory: A fancy-looking small box that includes 4.5 MB. Curiously enough, the RAM bus must be terminated, so the console always shipped with a terminator (called <em>Jumper Pak</em>) fitted in the place of the Expansion Pak. Now, you may ask, what would happen if you switch on the console without any <em>Pak</em> installed? <strong>Literally nothing</strong>, you get a blank screen!</p><hr><h2 id="graphics">Graphics</h2><p>The core of the graphics reside on a huge chip designed by Silicon Graphics called <strong>Reality Co-Processor</strong> running at 62.5 MHz. This package contains <em>a lot</em> of circuitry so don’t worry if you find it difficult to follow, the graphics sub-system has a very complex architecture!<br>The main philosophy of this design is that the GPU is not meant to be a ‘simple’ rasteriser like the <a href="https://copetti.org/projects/consoles/playstation/#graphics">competitor’s</a>. Instead, it should also be capable of <strong>accelerating geometry calculations</strong> (offloading the CPU), and for that, more circuitry will be needed.</p><p>Having said that, this chip is divided into three main modules, two of them are used for graphics processing:</p><div><ul><li id="tab-1-1-reality-signal-processor-link"><a href="#tab-1-1-reality-signal-processor">Reality Signal Processor</a></li><li id="tab-1-2-reality-display-processor-link"><a href="#tab-1-2-reality-display-processor">Reality Display Processor</a></li></ul><div><div id="tab-1-1-reality-signal-processor"><h4>Reality Signal Processor</h4><div><div><a href="https://copetti.org/images/consoles/nintendo64/RSP.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/nintendo64/RSP.png" data-src="https://copetti.org/images/consoles/nintendo64/RSP.png"></picture></a><figcaption>Architecture of the RSP</figcaption></div><p>Also known as <strong>RSP</strong>, it’s just another CPU package composed of:</p><ul><li>The <strong>Scalar Unit</strong>: A MIPS R400-based CPU which implements a subset of the R400 instruction set.</li><li>The <strong>Vector Unit</strong>: A co-processor that performs vector operations with 32 128-bit registers. Each register is <em>sliced</em> in eight parts to operate eight 16-bit vectors at once (just like SIMD instructions on conventional CPUs).</li><li>The <strong>System Control</strong>: Another co-processor that provides DMA functionality and controls its neighbour module, the RDP (more about it later on).</li></ul><p>In order to operate this module, the CPU stores in RAM a series of commands called <strong>Display list</strong> along with the data that will be manipulated, then the RSP reads the list and applies the required operations on it. The available features include geometry transformations (such as perspective projection), clipping and lighting.</p><p>This seems straightforward, but how does it perform these operations? Well, here’s the interesting part: Unlike its competitors (PS1 and Saturn), <strong>the geometry engine is not hard-wired</strong>. Instead, the RSP contains some memory (4 KB for instructions and 4 KB for data) to store <strong>microcode</strong>, a small program, with no more than 1000 instructions, that <strong>implements the graphics pipeline</strong>. In other words, it directs the Scalar Unit on how it should operate our graphics data. The microcode is fed by the CPU during runtime.</p><p>Nintendo provided different microcodes to choose from and, similarly to the <a href="https://copetti.org/projects/consoles/super-nintendo/#graphics">SNES’ background modes</a>, each one balances the resources differently.</p></div></div><div id="tab-1-2-reality-display-processor"><h4>Reality Display Processor</h4><div><div><a href="https://copetti.org/images/consoles/nintendo64/RDP.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/nintendo64/RDP.png" data-src="https://copetti.org/images/consoles/nintendo64/RDP.png"></picture></a><figcaption>Architecture of the RDP</figcaption></div><p>After the RSP finished processing our polygon data, it will start sending <strong>rasterisation commands</strong> to the next module, the <strong>RDP</strong>, to draw the frame. These commands are either sent using a dedicated bus called <strong>XBUS</strong> or through main RAM.</p><p>The RDP is another processor (this time with fixed functionality) that includes multiple engines used to map textures onto our polygons, mix colours and build the new frame.</p><p>It can process either <strong>triangles</strong> or <strong>rectangles</strong> as primitives, the latter is useful for drawing sprites. The RDP’s rasterisation pipeline contains the following blocks:</p><ul><li>A <strong>Rasteriser</strong>: Allocates the initial bitmap that will serve as frame-buffer.</li><li>A <strong>Texture Unit</strong>: Processes textures using 4 KB of dedicated memory (called ‘TMEM’) allowing up to eight tiles to be used for texturing. It can perform the following operations on them:<ul><li><strong>Bilinear filtering</strong>: Maps the selected 2D texture over the 3D shape and smooths it to avoid pixelated areas.<ul><li>A ‘complete’ filter would require four points to carry out the interpolation, however, this console only uses three (<strong>triangular interpolation</strong>) resulting in some anomalies. Thus, certain textures will have to be ‘adapted’ beforehand.</li></ul></li><li><strong>Mip-Mapping</strong>: Automatically selects a scaled-down version of the texture depending on its <strong>level of detail</strong>. This avoids computing large textures that would be seen far away from the camera and prevents aliasing.<ul><li>If enabled, the N64 maps textures using <strong>trilinear filtering</strong> instead. This new algorithm will also interpolate between the mipmaps to soften sudden changes in the level of detail.</li></ul></li><li><strong>Perspective correction</strong>: Chosen algorithm for mapping textures onto triangles. Unlike <a href="https://copetti.org/projects/consoles/playstation/#graphics">other algorithms</a>, this one takes into account the depth value of each primitive, achieving better results.</li></ul></li><li>A <strong>Colour Combiner</strong>: Mixes and interpolates multiples layers of colours (for instance, to apply shaders).</li><li>A <strong>Blender</strong>: Mixes pixels against the current frame-buffer to apply translucency, anti-aliasing, fog, dithering. It also performs z-buffering (more about it later on).</li><li>A <strong>Memory interface</strong>: Used by the previous blocks to read and write the current frame-buffer in RAM and/or fill the TMEM.</li></ul><p>The RDP provides four modes of functioning, each mode combines these blocks differently in order to optimise specific operations.</p><p>Since this module is constantly updating the frame-buffer in RAM, it uses a <strong>special addressing mode</strong>: Remember the unusual 9-bit addressing? The ninth bit is reserved for special calculations (like z-buffering) which can only be accessed using the Memory interface.</p></div></div></div></div><hr><p>The resulting frame-buffer will be captured by the video encoder and sent through the video signal. The theoretical maximum capabilities are 24-bit colour depth (16.8 million colours) and 640x480 resolution (or 720x576 in the PAL region).</p><p>I mention it as ‘theoretical’ since using the maximum capabilities can be resource-hungry, so programmers will tend to use lower stats to free up enough resources for other services.</p><h4 id="quick-demo">Quick demo</h4><p>Let’s put all the previous explanations into perspective, for that I’ll borrow Nintendo’s <em>Super Mario 64</em> to show, in a nutshell, how a frame is composed:</p><div><ul><li id="tab-2-1-models-and-lighting-link"><a href="#tab-2-1-models-and-lighting">Models and Lighting</a></li><li id="tab-2-2-textures-and-rasterisation-link"><a href="#tab-2-2-textures-and-rasterisation">Textures and Rasterisation</a></li></ul><div><div id="tab-2-1-models-and-lighting"><h4>Models and Lighting</h4><div><div><a href="https://copetti.org/images/consoles/nintendo64/mario/wireframe.jpg"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/nintendo64/mario/wireframe.jpg" data-src="https://copetti.org/images/consoles/nintendo64/mario/wireframe.jpg"></picture></a><figcaption>Primitive view of our scene<br>In order to save polygons, some characters are designed to be sprites (using quads)</figcaption></div><p>To start with, our 3D models are located in the cartridge ROM, but in order to keep a steady bandwidth, we need to copy them to RAM first.</p><p>Then it’s time to build a scene using our models, the CPU could do it by itself but it may take ages, so the task is delegated to the RCP. The CPU will instead send orders to the RCP, this is done by carrying out these tasks:</p><ol><li>Compose the Display List that contains the operations to be carried out by the RSP and store it in RAM.</li><li>Point the RSP where the display lists are.</li><li>Send microcode to the RSP to kickstart the Scalar Unit.</li></ol><p>Afterwards, the RSP will start performing the first batch of tasks and the result will be sent to the RDP in the form of rasterisation commands.</p></div></div><div id="tab-2-2-textures-and-rasterisation"><h4>Textures and Rasterisation</h4><div><div><a href="https://copetti.org/images/consoles/nintendo64/mario/result.jpg"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/nintendo64/mario/result.jpg" data-src="https://copetti.org/images/consoles/nintendo64/mario/result.jpg"></picture></a><figcaption>Rendered frame (<i>Tada!</i>)</figcaption></div><p>So far we managed to process our data and apply some effects on it, but we still need to:</p><ul><li>Apply textures and other effects.</li><li>Draw a frame-buffer, so we can display it on a screen.</li></ul><p>As you may guess, these tasks will be performed by the RDP. The CPU will feed the data (such as textures) by placing it on RAM, this module has a fixed pipeline but we can select the optimal mode of operation based on the current task to improve the frame-rate.</p><p>When the RDP finished it will write the last bitmap to the frame-buffer area in RAM, then the CPU will transfer the frame-buffer to the <strong>Video Interface</strong> (preferably using the DMA) which is then sent to the <strong>Video Encoder</strong> for display.</p></div></div></div></div><hr><h4 id="designs">Designs</h4><p>Here are some examples of previous 2D characters for the <a href="https://copetti.org/projects/consoles/super-nintendo/">Super Nintendo</a> that have been redesigned for the new 3D era, they are interactive so I encourage you to check them out!</p><h4 id="modern-visible-surface-determination">Modern visible surface determination</h4><p>If you’ve read about the previous consoles, you came across the never-ending problem regarding <a href="https://copetti.org/projects/consoles/sega-saturn/#an-introduction-to-the-visibility-problem">visibility of surfaces</a> and by now may think polygon sorting is the only way out of this. Well, for the first time in this series, the RDP features a hardware-based approach called <strong>Z-buffering</strong>. In a nutshell, the RDP allocates an extra buffer called <strong>Z-Buffer</strong> in memory. This has the same dimensions of a frame-buffer, but instead of storing RGB values, each entry contains the depth (Z-value) of the nearest pixel with respect to the camera.</p><p>After the RDP rasterises the vectors, the z-value of the new pixel is compared against the respective value in Z-buffer. If the new pixel contains a smaller z-value, it means the new pixel is positioned in front of the previous one, so it’s applied onto the frame-buffer and the z-buffer is also updated. Otherwise, the pixel is discarded.</p><p>Overall, this is a huge welcomed addition: Programmers do not need to worry anymore about implementing <a href="https://copetti.org/projects/consoles/playstation/#tab-2-2-visibility-approach">software-based</a> polygon sorting methods which drain a lot of CPU resources. However, Z-buffer does not save you from feeding unnecessary geometry (discarded or overdrawn, both consuming resources). For this, game engines may choose to include an <strong>occlusion culling</strong> algorithm to discard unseen geometry as early as possible.</p><h4 id="secrets-and-limitations">Secrets and limitations</h4><p>SGI clearly invested a lot of technology into this system. Nonetheless, this was a console meant for the household and as such, it had to keep its cost down. Some hard decisions resulted in difficult challenges for programmers:</p><div><ul><li id="tab-3-1-pipeline-stalls-link"><a href="#tab-3-1-pipeline-stalls">Pipeline Stalls</a></li><li id="tab-3-2-texture-memory-link"><a href="#tab-3-2-texture-memory">Texture memory</a></li></ul><div><div id="tab-3-1-pipeline-stalls"><h4>Pipeline Stalls</h4><div><p>Due to the huge number of components and operations in the graphics pipeline, the RCP ended up being very susceptible to <strong>stalls</strong>: An undesirable situation where sub-components keep idling for considerable periods because the required data is delayed at the back of the pipeline.</p><p>This will always result in performance degradation and is up to the programmer to avoid them. Although to make things easier, some CPUs such as the Scalar Unit implement a feature called <strong>Bypassing</strong> which enables to execute similar instructions at a faster rate by bypassing some execution stages that can be skipped.
For example, if we have to compute sequential <code>ADD</code> instructions there’s no need to write the result back to a register and then read it back every time each <code>ADD</code> is finished, we can instead keep using the same register for all additions and do the write-back once the last <code>ADD</code> is completed.</p></div></div><div id="tab-3-2-texture-memory"><h4>Texture memory</h4><div><p>Inside the RDP there are 4 KB Texture memory available to be used as <strong>Texture Cache</strong>, its main goal is to avoid stalling read cycles from RAM. Unfortunately, in practice 4 KB happened to be insufficient for high-resolution textures. Furthermore, if mipmapping is used, the available amount of cache is then reduced to half.</p><p>As a result, some games used solid colours with Gouraud shading (like <em>Super Mario 64</em>) and others relied on pre-computed textures (for example, where multiple layers had to be mixed).</p></div></div></div></div><hr><h2 id="audio">Audio</h2><p>Before we go into the details, let’s define the two endpoints of the audio sub-system:</p><ul><li>Our starting point is the cartridge ROM, it contains data that only the CPU can interpret.</li><li>The ending point is the <strong>Digital-to-Analog converter</strong> or ‘DAC’, which only understands <em>waveform data</em>.</li></ul><p>Now, how do we connect both ends? Consoles normally include a dedicated audio chip that does the work for us. Unfortunately, the Nintendo 64 <strong>doesn’t have such dedicated chip</strong>, so this task is distributed across these components:</p><ul><li>The <strong>main CPU</strong>: Transfers the audio data from the game’s ROM to RAM, then it initialises <strong>Audio Lists</strong> to be used by the RSP.</li><li>The <strong>RSP</strong>: With the use of even more microcode, it interprets the audio lists previously stored in RAM and performs the required operations to the audio data which, for example, can include:<ul><li>Uncompressing <strong>ADPCM samples</strong> and applying effects.</li><li>Sequencing and mixing <strong>MIDI data</strong> using <strong>audio banks</strong> stored in RAM as well.</li></ul></li></ul><p>The resulting data is, as expected, waveform data. This is then sent to the <strong>Audio Interface</strong> or ‘AI’ block which will then transfer it to the digital-to-analogue converter. The resulting waveform contains two channels (since our system is stereo) with 16-bit resolution each.</p><div><a href="https://copetti.org/images/consoles/nintendo64/Audio.png"><picture>
<img name="image_cover" alt="Image" src="https://copetti.org/images/consoles/nintendo64/Audio.png" data-src="https://copetti.org/images/consoles/nintendo64/Audio.png"></picture></a><figcaption>Overview of how the audio pipeline is often programmed</figcaption></div><h4 id="the-repertoire">The repertoire</h4><p>Time to checkout the soundtracks made for the N64. There are too many (good ones) to mention in this article, so here are some that caught my attention:</p><h4 id="secrets-and-limitations-1">Secrets and limitations</h4><p>Because of this design, the constraints will depend on the implementation:</p><ul><li>Sampling rate can be up to 44.1Hz, but using the top rate will steal lots of CPU cycles.</li><li>There’s no strict limit in the number of channels, it all depends how much the RSP is capable of mixing (often around 16-24 channels if processing ADPCM or ~100 if PCM).</li><li>Storage is another concern, while competitors relied on a larger media like the CD-ROM, Nintendo 64 cartridges hold much less data (let alone music data). For those reasons, players may notice that N64 ports contain lesser quality music or repeated tunes. Fortunately, MIDI sequencing helped to overcome this situation.</li></ul><hr><h2 id="operating-system">Operating System</h2><p>Similar to the PS1 and Saturn, N64 games are written for bare-metal. However, there are no BIOS routines available to simplify some operations. As a substitute, <strong>games embed small OS</strong> that provides a fair amount of abstraction to efficiently handle the CPU, GPU and I/O.</p><p>This is not the conventional <em>desktop OS</em> that we may imagine at first, it’s just a micro-kernel with the smallest footprint possible that provides the following functionality:</p><ul><li>Multi-Threading (implemented as a single core system).</li><li>Scheduling and Pre-emption.</li><li>Simplified register and I/O access.</li></ul><p>The kernel is automatically embedded by using Nintendo’s libraries, additionally, if programmers decide not to include one of the libraries, the respective portion of the kernel is skipped to avoid cartridge space being wasted.</p><h4 id="inputoutput">Input/Output</h4><p>As you know by now, I/O is not directly connected to the CPU, so the RCP’s third module (which I haven’t mentioned until now) serves as an <strong>I/O interface</strong>, it basically communicates with the CPU, controllers, game cartridge and Audio/Video DACs.</p><hr><h2 id="games">Games</h2><p>Nintendo held on to the cartridge medium for storage and as a consequence, games enjoyed higher bandwidths (between 5-50 MB/s depending on the ROM’s speed) while being more expensive to produce. The biggest cartridge found in the market has 64 MB.</p><p>Inside cartridges manufacturers may include extra memory (in the form of <em>EEPROM</em>, <em>flash</em> or <em>SRAM</em> with a battery) to hold saves, however this is not a strong requirement any more since certain accessories could be used to store saves as well.</p><h4 id="accessories">Accessories</h4><p>The Nintendo 64 controller included a connector used to plug in accessories, some of them are:</p><ul><li>The <strong>Controller Pak</strong>: Another medium (similar to Sony’s <em>Memory Card</em>) used to store save data and use it on other consoles.</li><li>The <strong>Rumble Pak</strong>: Contains a small motor in order to provide haptic feedback, useful for immersing the player on certain games.</li></ul><p>All accessories connected to the controller are managed by the <strong>Peripheral Interface</strong>.</p><p>Apart from that, this console included a special connector at the bottom of its motherboard which was meant to be used by the yet-unreleased <strong>Disk drive</strong>, some sort of an ‘extra floor’ that contained a proprietary disk reader, the drive was only released on Japan nonetheless and eventually cancelled for the rest of the world.</p><h4 id="source-development-kit">Source Development Kit</h4><p>In general, development was mainly done in C, assembly was also used to achieve better performance. While this system contained a 64-bit instruction set, 64-bit instructions were rarely used since in practice, 32-bit instructions happened to be faster to execute and required half the storage.</p><p>Libraries contained several layers of abstractions in order to command the RCP, for example, structs like the <strong>Graphics Binary Interface</strong> or ‘GBI’ were designed to assemble the necessary Display lists more easily, the same applied for audio functions (its struct was called <strong>Audio Binary Interface</strong> or ‘ABI’).</p><p>In terms of microcode development, Nintendo already provided a set of microcode programs to choose from, however if developers wanted to customise it, that would indeed be a challenging tasks: The Scalar Unit instruction set wasn’t initially documented (at the request of Nintendo, of course), later on the company changed its position and SGI finally released some documentation for microcode programming.</p><p>Hardware used for development included workstations supplied by SGI, like the <em>Indy</em> machine which came with an extra daughterboard called ‘U64’ that emulates the retail console. Tools were supplied for Windows computers as well.</p><p>Other third-party tools consisted in cartridges containing wide cables that connected to the workstation, this cartridge was fitted on a normal Nintendo 64 and included internal circuitry to redirect the <em>read</em> requests from the console to the workstation’s RAM. Debugging was carried out by transferring a copy of the game to RAM and then, when the console was switched on, it would start reading from there.</p><hr><h2 id="anti-piracy--region-lock">Anti-piracy / Region Lock</h2><p>The anti-piracy system is a continuation of the <a href="https://copetti.org/projects/consoles/super-nintendo/#anti-piracy--region-lock">SNES’ CIC</a>. As you know, bootleg detection and region locking are possible thanks to the CIC chip (which must be present in every <em>authorised</em> game cartridge), the Nintendo 64 improved this system by requiring different games to have a specific variant of the CIC chips in order to make sure the cartridge was not a counterfeit or contained a CIC clone, the <strong>Peripheral Interface</strong> or ‘PIF’ would do checksum checks at the start and during gameplay to supervise current CIC installed on the cartridge.</p><p>If by any reason the PIF considers the current cartridge is not valid, it will then induce the console in a permanent freeze.</p><p>Region-locking was done by slightly altering the shape of the cartridge between different regions so the user can’t physically insert the game on an N64 from a different region.</p><p>Overall, there was not too much concern regarding piracy thanks to the use of cartridge medium, although game prices were three times higher than CD-based ones.</p><h4 id="unused-ports">Unused ports</h4><p>As silly as it may seem, Nintendo left one door opened: The <strong>Disk Drive port</strong>.</p><p>A few companies reversed engineered the interface in order to develop their own hardware, and some of the resulting products became a concern for piracy.</p><p>I guess the one worth mentioning is the <strong>Doctor v64</strong>, this device has the same shape as the Disk Drive port but included a CD-ROM drive that’s used to clone the contents of the cartridge to a CD, the opposite (reading Roms from a CD) is also possible.</p><h4 id="emulation">Emulation</h4><p>When I was a kid I used to play some N64 games on a Pentium II machine using an emulator, it wasn’t <em>that bad</em> but then I wondered now <em>how the freck</em> was it able to happily emulate a complex 64-bit machine since, among other things, my PC barely had enough RAM to keep the integrated video alive.</p><p>The truth is, while reproducing the architecture of this console can be complex, things like microcode will give a hint of what the console is trying to do, and since emulators <em>don’t have to be</em> cycle-accurate, they can apply enough optimisations to provide more performance in exchange for real emulation.<br>Another example are the 64-bit instructions, since games barely used them, emulation speed would hardly be hit when running on a 32-bit host machine.</p><hr><h2 id="thats-all-folks">That’s all folks</h2><p>I have to say, this article may be the longest one I’ve ever written, but hopefully you found it a nice read!</p><p>I’ll probably take the following days to tide up some things on the website instead of starting to write the next article.</p><p>Anyway, if you enjoy my articles and would like to help, please take a look <a href="https://copetti.org/support">here</a>. If you have any comments or suggestions, feel free to email me here.</p><p>Until next time!<br>Rodrigo</p><hr><h2 id="sources--keep-reading">Sources / Keep Reading</h2><h4 id="general">General</h4><ul><li><a href="http://n64devkit.square7.ch/"><strong>Detailed N64 programming manual</strong></a></li><li><a href="http://ultra64.ca/resources/software/"><strong>Development Software Archive</strong></a></li><li><a href="https://tomplaskon.wordpress.com/2014/06/30/anatomy-of-a-nintendo-64/"><strong>Anatomy of this system</strong></a></li></ul><h4 id="cpu-1">CPU</h4><ul><li><a href="http://datasheets.chipdb.org/MIPS/R4300i_datasheet.pdf"><strong>MIPS R4300i datasheet</strong></a></li><li><a href="http://datasheets.chipdb.org/NEC/Vr-Series/Vr43xx/U10504EJ7V0UMJ1.pdf"><strong>NEC VR4300 datasheet</strong></a></li></ul><h4 id="graphics--audio">Graphics / Audio</h4><ul><li><strong>Nintendo Ultra64 RSP Programmer’s Guide</strong></li><li><a href="https://www.retroreversing.com/n64rsp"><strong>Different Microcodes</strong></a></li><li><a href="https://web.archive.org/web/20200216025504/https://www.models-resource.com/"><strong>The Models Resource</strong> (Archived)</a></li></ul><h4 id="games-1">Games</h4><ul><li><a href="https://en.wikipedia.org/wiki/Nintendo_64_Game_Pak"><strong>GamePak (Wikipedia)</strong></a></li><li><a href="https://imgur.com/gallery/KteOi"><strong>Inside some GamePaks</strong></a></li><li><a href="https://n64squid.com/homebrew/n64-sdk/development-hardware/"><strong>Development Hardware</strong></a></li><li><a href="http://n64devkit.square7.ch/n64man/u64/u64.htm"><strong>More about the U64</strong></a></li></ul><h4 id="anti-piracy">Anti-piracy</h4><ul><li><a href="https://www.youtube.com/watch?v=HwEdqAb2l50"><strong>Reversing the Nintendo 64 CIC (REcon talk)</strong></a></li></ul><h4 id="photography">Photography</h4><ul><li>Motherboard and console: <a href="https://commons.wikimedia.org/wiki/User:Evan-Amos"><strong>Evan Amos Gallery</strong></a></li><li>Diagrams and game screenshots: <strong>Me</strong></li></ul><h4 id="bonus">Bonus</h4><ul><li><a href="http://www.nec.co.jp/press/en/9801/2002.html"><strong>Laserjet printers use the same CPU!</strong></a></li></ul><hr><h3 id="contributing">Contributing</h3><p id="contributing-body">This article is part of the <a href="https://copetti.org/projects/consoles/">Architecture of Consoles</a> series.
If you found it interesting please consider donating, your contribution will be used to get more tools and resources that will help to improve the quality of current articles and upcoming ones.</p><p>A list of desirable tools and latest acquisitions for this article are tracked in here:</p><div><pre><code data-lang="markdown"><span>## Interesting hardware to get (ordered by priority)
</span><span></span>
<span>-</span> Nintendo 64 console and a controller (£40 - £60)
<span>-</span> A N64 game (£5 - £15)
<span>-</span> Any Dev kit (only if found at a reasonable price)
<span>-</span> N64 DD (only if found at a reasonable price)
<span>-</span> N64RGB board (£25)
- RAD2X (£47.99)</code></pre></div><hr><h3>Changelog</h3><p>Always nice to keep a record of changes.</p><div><pre><code data-lang="markdown"><span>## 2020-04-14
</span><span></span>
<span>-</span> Small changes to perspective correction info.

<span>## 2020-04-11
</span><span></span>
<span>-</span> Dedicated more text to the visibility approach 

<span>## 2020-02-26
</span><span></span>
<span>-</span> Expanded texture unit section.

<span>## 2020-01-11
</span><span></span>
<span>-</span> Added repertoire

<span>## 2019-10-29
</span><span></span>
<span>-</span> Added some 3d models to fiddle with

<span>## 2019-09-17
</span><span></span>
<span>-</span> Added a quick introduction
<span>-</span> Corrected some explanations

<span>## 2019-09-12
</span><span></span>
- Released to the public, yay</code></pre></div><hr></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>