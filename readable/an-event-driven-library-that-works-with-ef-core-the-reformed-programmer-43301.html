<!DOCTYPE html>
<html lang="en">
<head>
    <title>
EfCore.GenericEventRunner: an event-driven library that works with EF Core &#x2013; The Reformed Programmer - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="EfCore.GenericEventRunner: an event-driven library that works with EF Core &#x2013; The Reformed Programmer - linksfor.dev(s)"/>
    <meta property="og:description" content="Last Updated: January 3, 2020 | Created: December 1, 2019"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.thereformedprogrammer.net/efcore-genericeventrunner-an-event-driven-library-that-works-with-ef-core/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - EfCore.GenericEventRunner: an event-driven library that works with EF Core &#x2013; The Reformed Programmer</title>
<div class="readable">
        <h1>EfCore.GenericEventRunner: an event-driven library that works with EF Core &#x2013; The Reformed Programmer</h1>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 02 Dec 2019</div>
        <p><a href="https://www.thereformedprogrammer.net/efcore-genericeventrunner-an-event-driven-library-that-works-with-ef-core/">https://www.thereformedprogrammer.net/efcore-genericeventrunner-an-event-driven-library-that-works-with-ef-core/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

		<p><span>Last Updated: January 3, 2020 | Created: December 1, 2019</span>
					</p>

		
<p>In the <a href="https://www.thereformedprogrammer.net/a-robust-event-driven-architecture-for-using-with-entity-framework-core/">first article</a> I described an event-driven architecture that work with Entity Framework Core (EF Core). In this article I go into the details of how to use the EfCore.GenericEventRunner that implements this event-driven design. This article covers the specific details of why and how to use this library. </p>



<blockquote><p>NOTE: The EfCore.GenericEventRunner is an open-source (MIT licence) <a href="https://www.nuget.org/packages/EfCore.GenericEventRunner/">NuGet library</a> designed to work with EF Core 3 and above. You can also find the code in <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner">this GitHub repo</a>.</p></blockquote>



<p>The articles in this series are:</p>



<ul><li><a href="https://www.thereformedprogrammer.net/a-robust-event-driven-architecture-for-using-with-entity-framework-core/">A robust event-driven architecture for using with Entity Framework Core</a></li><li>EfCore.GenericEventRunner: an event-driven library that works with EF Core (<strong>this article</strong>)</li><li> <a href="https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/">A technique for building high-performance databases with EF Core</a>. </li></ul><h2 id="tldr-summary">TL;DR; – summary <a href="#tldr-summary"></a></h2>



<ul><li>This article describes how to use the EfCore.GenericEventRunner
library, available on <a href="https://www.nuget.org/packages/EfCore.GenericEventRunner/">NuGet </a>&nbsp;and on <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner">GitHub</a>.</li><li>EfCore.GenericEventRunner adds a specific
event-driven system to EF Core. See <a href="https://www.thereformedprogrammer.net/a-robust-event-driven-architecture-for-using-with-entity-framework-core/">this
article</a> for a description of this event-driven design.</li><li>I break up the description into five sections<ul><li>Code to allow your EF Core classes to send
events</li></ul><ul><li>How to build event handlers</li></ul><ul><li>How the events are run when
SaveChanges/SaveChangesAsync is called.</li></ul><ul><li>How to register your event handlers and GenericEventRunner
itself.</li></ul><ul><li>How to unit test an application which uses GenericEventRunner.</li></ul></li></ul><h2 id="overview-of-efcore-genericeventrunner-library">Overview of EfCore.GenericEventRunner library<a href="#overview-of-efcore-genericeventrunner-library"></a></h2>



<p>I’m going to go though the four parts of the EfCore.GenericEventRunner
library (plus something on unit testing) to demonstrate how to use this library.
I start with a diagram which will give you an idea of how you might use GenericEventRunner.
Then I will dive into the four parts.</p>



<blockquote><p>NOTE: If you haven’t read the <a href="https://www.thereformedprogrammer.net/a-robust-event-driven-architecture-for-using-with-entity-framework-core/">first article</a>, then I recommend you read/skim that article – it might make understanding what I am trying to do. </p></blockquote>



<p>In the diagram the blue rectangles are classes mapped to the database, with the events shown in light color at the bottom. The orange rounded rectangle is an event handler.</p>



<figure><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2019/12/GenericEventRunnerExampleAllocate-1024x763.png" alt="" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2019/12/GenericEventRunnerExampleAllocate-1024x763.png 1024w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/12/GenericEventRunnerExampleAllocate-300x224.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/12/GenericEventRunnerExampleAllocate-768x572.png 768w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/12/GenericEventRunnerExampleAllocate.png 1189w" sizes="(max-width: 1024px) 100vw, 1024px"></figure><p>Here are the four parts of the library, plus a section on
unit testing:</p>



<ol><li>ForEntities: This has the code that allows a class to contain and create events.</li><li>ForHandlers: This contains the interfaces for building handlers.</li><li>ForDbContext: The DbContextWithEvents&lt;T&gt; which contains the overriding of the SaveChanges/ SaveChangesAsync.</li><li> The code for registering your event handlers and GenericEventRunner’s EventsRunner.</li><li> How to unit test an application which uses GenericEventRunner (and logging).</li></ol><blockquote><p>NOTE: This code in is article taken from the code in the EfCore.GenericEventRunner repo used to test the library. I suggest you look at that code and the unit tests to see how it works.</p></blockquote>



<h3 id="1-forentities-code-for-your-entity-classes-see-datalayer-in-genericeventrunnerrepo">1. ForEntities: code for your entity classes (see DataLayer in GenericEventRunner
repo)<a href="#1-forentities-code-for-your-entity-classes-see-datalayer-in-genericeventrunnerrepo"></a></h3>



<p>For this example, I am going to show you how I built the “1.
Create new Order” (LHS of last diagram). The purpose of this event is to query
the stock part a) is there enough stock to manage this order, and b) allocate some
stock ready for this order.</p>



<p>The first thing I needed is an “allocate” event. An event is class that inherits the IDomainEvent interface. Here is my “allocate” event.</p>


<div><div id="highlighter_535834"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>public</code> <code>class</code> <code>AllocateProductEvent : IDomainEvent</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>AllocateProductEvent(</code><code>string</code> <code>productName, </code><code>int</code> <code>numOrdered)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProductName = productName;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>NumOrdered = numOrdered;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>string</code> <code>ProductName { </code><code>get</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>int</code> <code>NumOrdered { </code><code>get</code><code>; }</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>In this case this event is sent from a new order which hasn’t been saved to the database. Therefore, I have to send the ProductName (which in my system is a unique key) and the number ordered because its not (yet) in the main database. Even if the data is in the database, I recommend sending the data in the event, as a) it saves a database access and b) it reduces the likelihood of concurrency issues (I’ll talk more on concurrency issues in the next article).</p>



<p>The next thing is to add that event to the Order class. To be able to do that the Order class must inherit abstract class called <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner/blob/master/GenericEventRunner/ForEntities/EntityEvents.cs">EntityEvents</a>, e.g.</p>


<div><div id="highlighter_273579"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><div><p><code>public</code> <code>class</code> <code>Order : EntityEvents</code></p><p><code>{ </code></p></div></td></tr></tbody></table></div></div>


<p>The EntityEvents class provides an AddEvent method which
allows you to add a new event to your entity. It also stores the events for the
Event Runner to look at when SaveChanges is called. (note that the events
aren’t saved to the database – they only hang around as long as the class
exists).</p>



<p>Below is the Order constructor, with the focus on the AllocateProductEvent – see the highlighted lines 10 and 11</p>


<div><div id="highlighter_791594"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><div><p><code>public</code> <code>Order(</code><code>string</code> <code>userId, DateTime expectedDispatchDate,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ICollection&lt;BasketItemDto&gt; orderLines)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>TotalPriceNoTax = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>foreach</code> <code>(</code><code>var</code> <code>basketItem </code><code>in</code> <code>orderLines)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>TotalPriceNoTax += basketItem.ProductPrice * basketItem.NumOrdered;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AddEvent(</code><code>new</code> <code>AllocateProductEvent(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>basketItem.ProductName, basketItem.NumOrdered));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>If you don’t use DDD, then the typical way to create an
event is to catch the setting of a property. Here is an example of doing that
taken from the first article.</p>


<div><div id="highlighter_421024"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>private</code> <code>string</code> <code>_county;</code></p><p><code>public</code> <code>decimal</code> <code>County</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>get</code> <code>=&gt; _county;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>private</code> <code>set</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(value != _county)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AddEvent(</code><code>new</code> <code>LocationChangeEvent(value));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_county = value;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>This works because the property Country is changed into an
EF Core <a href="https://docs.microsoft.com/en-us/ef/core/modeling/backing-field">backing
field</a>, and the name of the column in the table is unchanged. But because it’s
now a backing field EF Core 3 will (by default) will read/write the field, not
the property, which is good otherwise the load could cause an event.</p>



<blockquote><p>NOTE: EF Core 3 default action is to read/write the field, but before EF Core 3 the default was to set via the property, which would have generated an event.</p></blockquote>



<h4 id="types-of-events">Types of events<a href="#types-of-events"></a></h4>



<p>When it comes to adding an event there are two separate
lists: one for BeforeSave events and one for AfterSave events. The names give
you a clue to when the handler is run: the BeforeSave events run before SaveChanges
is called, and AfterSave events are run after SaveChanges is called. </p>



<p>I cover the two types of events in the next section, but I
can say that BeforeSave events are by far the most used type, so that is the
default for the AddEvent method. If you want to send an event to be run after
SaveChanges, then you need to add a second parameter with the type, e.g.
AddEvent(…, EventToSend.AfterSave).</p>



<h3 id="2-forhandlers-building-the-event-handlers">2. ForHandlers: Building the event handlers<a href="#2-forhandlers-building-the-event-handlers"></a></h3>



<p>You need to create the event handlers to handle the events
that the entity classes sent out. There are two types of event handler IBeforeSaveEventHandler&lt;TEvent&gt;
and IAfterSaveEventHandler&lt;TEvent&gt;. Let me explain why I have the two
types.</p>



<h4 id="beforesave-events-and-handlers">BeforeSave events and handlers <a href="#beforesave-events-and-handlers"></a></h4>



<p>The BeforeSave events and handlers are all about the
database. The idea is the BeforeSave handlers can change the entity classes in
the database, and those changes are saved with the original data that your normal
(non-event trigger) code set up. As I explained in the first article saving the
original data and any data changed by the event together in one transaction is
safe, as the data can’t get out of step. </p>



<p>Typically, a BeforeSave event will be triggered when
something changes, or an event happens. The handler then either does some
calculation, maybe accessing the database and returns a result to be saved in
the calling entity and/or it might create, update or remove (delete) some other
entity classes. The data changes applied by the normal code and the data
changes applied by the event handler are saved together.</p>



<p>BeforeSave event handlers also have two extra features:</p>



<p>1. Firstly, they can return an (optional) IStatusGeneric status,
which can send back errors. If it returns null or a status with no errors then
the SaveChanges will be called. </p>



<p>Here is an example of a BeforeSave event handler which was
called by the AllocateProductEvent you saw before. This checks that there is
enough stock to accept this order. If it returns a status with any errors, then
that stops <a>SaveChanges</a>/ SaveChangesAsync from being
called.</p>


<div><div id="highlighter_957892"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></td><td><div><p><code>public</code> <code>class</code> <code>AllocateProductHandler : IBeforeSaveEventHandler&lt;AllocateProductEvent&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>private</code> <code>readonly</code> <code>ExampleDbContext _context;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>AllocateProductHandler(ExampleDbContext context)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_context = context;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>IStatusGeneric Handle(EntityEvents callingEntity,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AllocateProductEvent domainEvent)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>status = </code><code>new</code> <code>StatusGenericHandler();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>stock = _context.Find&lt;ProductStock&gt;(domainEvent.ProductName);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(stock.NumInStock &lt; domainEvent.NumOrdered)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>status.AddError(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>$</code><code>"I could not accept this order because there wasn't enough {domainEvent.ProductName} in stock."</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>stock.NumAllocated += domainEvent.NumOrdered;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>status;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>The lines of code to highlight are:</p>



<ul><li>Lines 18 to 19. If there isn’t enough stock it adds an error to the status and returns it immediately. This will stop the SaveChanges from being called.</li></ul><p>The default situation is the first BeforeSave event handler
that returns an error will stop immediately. If you want all the BeforeSave
events to continue, say to get all the possible error messages, then you can
set the StopOnFirstBeforeHandlerThatHasAnError property to false in the GenericEventRunnerConfig
class provided at setup time (see 4. ForSetup: Registering service on config).</p>



<p>If the returned status has errors, then all the events are
cleared and SaveChanges/Async isn’t called (see section “3. ForDbContext” for
how these errors are returned to the application).</p>



<blockquote><p>NOTE: Only a few of your BeforeSave handlers will need a status so you can return null as a quick way to say there are no errors (or more precisely the handler is not looking for errors). You can return a status with no errors and update the statues’ success Message string which will mean that Message will be returned at the top level (assuming a later BeforeSave handler doesn’t overwrite it).</p></blockquote>



<p>2. Secondly, BeforeSave handlers can raise more events directly or indirectly. For instance, say an event handler changed a property that raised another event we need to pick that new event too. For that reason, the BeforeSave handler runner keeps looping around checking for new events until there are no more.</p>



<blockquote><p>NOTE:&nbsp; There is a property in the GenericEventRunnerConfig class called MaxTimesToLookForBeforeEvents value to stop circular events, e.g. an event calls something that calls the same event, which would loop for ever. If the BeforeSave handler runner loops around more than the MaxTimesToLookForBeforeEvents value (default 6) it throws an exception. See section “4. For setup” on how to change the GenericEventRunner’s configuration.</p></blockquote>



<h4 id="aftersave-events-and-handlers">AfterSave events and handlers <a href="#aftersave-events-and-handlers"></a></h4>



<p>AfterSave events are there to do things once the SaveChanges is successful and you know the data is OK. Typical uses are clearing a cache because certain data has changed, or maybe use SignalR to update a screen with the changed data. Unlike the BeforeSave events the events runner only looks once at all the events in the entity classes, so AfterSave events handlers can’t trigger new events.</p>



<p>Here is an example of an AfterSaveEventHandler that would
send an internal message to the dispatch department once an Order is
successfully placed in the database.</p>


<div><div id="highlighter_81056"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>public</code> <code>class</code> <code>OrderReadyToDispatchAfterHandler : </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IAfterSaveEventHandler&lt;OrderReadyToDispatchEvent&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>Handle(EntityEvents callingEntity,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>OrderReadyToDispatchEvent domainEvent)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>AfterSave event handers aren’t “safe” like the BeforeSave events in that if they fail the database update is already done and can’t be undone. Therefore, you want to make your AfterSave event handlers aren’t going to cause exceptions. They also shouldn’t update the database (that’s the job of the BeforeSave event handlers). </p>



<p>AfterSave event handers also don’t return any status so you
can’t know if they worked on not (see one way around this in section “4. Setup”
on how to check an AfterSave event handler ran). </p>



<h3 id="3-fordbcontext-overriding-of-ef-cores-base-savechanges-savechangesasync">3. ForDbContext: Overriding of EF Core’s base SaveChanges/SaveChangesAsync<a href="#3-fordbcontext-overriding-of-ef-cores-base-savechanges-savechangesasync"></a></h3>



<p>To make this all work GenericEventRunner needs to override
the base SaveChanges/ SaveChangesAsync methods. GenericEventRunner library
provides a class called <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner/blob/master/GenericEventRunner/ForDbContext/DbContextWithEvents.cs">DbContextWithEvents&lt;T&gt;</a>,
which contains overrides for the SaveChanges/ SaveChangesAsync and two extra
versions called SaveChangesWithStatus/ SaveChangesWithStatusAsync that return a
status. Here is a my ExampleDbContext that I use for unit testing
GenericEventRunner.</p>


<div><div id="highlighter_962005"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p></td><td><div><p><code>public</code> <code>class</code> <code>ExampleDbContext</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: DbContextWithEvents&lt;ExampleDbContext&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>DbSet&lt;Order&gt; Orders { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>DbSet&lt;LineItem&gt; LineItems { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>DbSet&lt;ProductStock&gt; ProductStocks { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>DbSet&lt;TaxRate&gt; TaxRates { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>ExampleDbContext(DbContextOptions&lt;ExampleDbContext&gt; options, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IEventsRunner eventRunner = </code><code>null</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: </code><code>base</code><code>(options, eventRunner)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>protected</code> <code>override</code> <code>void</code> <code>OnModelCreating(ModelBuilder modelBuilder)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>modelBuilder.Entity&lt;ProductStock&gt;().HasKey(x =&gt; x.ProductName);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>Line 2 is the only change in your DbContext. Instead of inheriting DbContext, you inherit GenericEventRunner’s DbContextWithEvents&lt;T&gt;, where T is your class. This overrides the SaveChanges/ SaveChangesAsync and adds some other methods and the IStatusGeneric&lt;int&gt; StatusFromLastSaveChanges property.</p>



<p>For people who are already overriding SaveChanges you can either still layer DbContextWithEvents&lt;T&gt; class on top of your SaveChanges method, which GenericEventRunner will override, and call at the apporriate time. If you want to customise your DbContext then the methods used in the DbContextWithEvents&lt;T&gt; class are public, so you can use them directly. This allows you to reconfigure the GenericEventRunner SaveChanges/ SaveChangesAsync to suit your system.</p>



<h4 id="what-happens-if-beforesave-event-handler-send-back-an-error">What happens if BeforeSave event handler send back an error?<a href="#what-happens-if-beforesave-event-handler-send-back-an-error"></a></h4>



<p>As I said earlier if the BeforeSave event handlers return an
error it does not call SaveChanges/Async, but you most likely want to get the
error messaged, which are designed to be shown to the user. I expect most
developers to call SaveChanges/Async so the GenericEventRunner throws a GenericEventRunnerStatusException
if the combined statuses of all the BeforeSave handlers has any errors. You can
then get the errors in two ways:</p>



<ul><li>The Message property of the GenericEventRunnerStatusException
contains a string starting with an overall message and then each error
(separated by the Environment.NewLine characters). This returns just the error
text, not the full ValidationResult.</li><li>For a more detailed error response you can
access the IStatusGeneric&lt;int&gt; StatusFromLastSaveChanges property in the
DbContext. This provides you with access to the Errors list, where each error
has an ErrorResult of type ValidationResult, where you can specify the exact
property that caused a problem.</li></ul><blockquote><p>NOTE: The IStatusGeneric&lt;int&gt; StatusFromLastSaveChanges property will be null if SaveChanges hasn’t yet been called.</p></blockquote>



<p>The alternative is to call the SaveChangesWithStatus/ SaveChangesWithStatusAsync
methods directly. That way you can get the status directly without having to
use a try/catch. This makes getting the status easier, but if you have a lot of
existing code that already calls SaveChanges/SaveChangesAsync then its most
likely best to stay with SaveChanges/Async and capture the exception where you
need to.</p>



<h4 id="what-is-the-state-of-the-current-dbcontext-when-there-are-exceptions">What is the state of the current DbContext when there are exceptions?<a href="#what-is-the-state-of-the-current-dbcontext-when-there-are-exceptions"></a></h4>



<p>We need to consider what state the DbContext is in when
there are exceptions. Here is the list:</p>



<ul><li><strong>Exceptions
before SaveChanges is called</strong> (other than GenericEventRunnerStatusException):
In this state there may be changes in the database and any events are still
there. Therefore, you need to be very careful if you want to call SaveChanges
again (Note: this isn’t much different from what happens if you don’t have
events – you don’t really know what state the DbContext is in after an
exception and you should not try to call SaveChanges).</li><li><strong>Exceptions
during SaveChanges</strong>, e.g. DbUpdateConcurrencyException. If you get an
exception during SaveChanges itself then it’s something about the database. The
DbContext will have all the data ready to retry the SaveChanges, if you can
“fix” the problem. If you call SaveChanges again (after fixing it) and it
succeeds then all the BeforeEvents have been cleared (because they have already
been applied to the DbContext), but any AfterSave events are still there and
will run.</li><li><strong>Exceptions
after SaveChanges was called</strong>. The database is up to date. If an AfterSave
event handler throws an exception then other AfterSave event handlers may be
lost. As I said AfterSave event handlers are not robust.</li></ul><h3 id="4-forsetup-registering-your-event-handlers">4. ForSetup: Registering your event handlers<a href="#4-forsetup-registering-your-event-handlers"></a></h3>



<p>The final stage is to register all your event handlers, and
the EventsRunner from the GenericEventRunner library. This is done using the
extension method called RegisterGenericEventRunner. There are two signatures
for this method. Both need an array of assemblies that is needs to scan to find
your BeforeSave/AfterSave event handlers, but one starts with property of type
IGenericEventRunnerConfig by which you can change the GenericEventRunner default
configuration. Here is an example in ASP.NET Core without a config.</p>


<div><div id="highlighter_641705"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><div><p><code>public void ConfigureServices(IServiceCollection services)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>//… other service registeration left out</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>services.RegisterGenericEventRunner(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Assembly.GetAssembly(typeof(OneOfMyEventHandlers)));</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>NOTES:</p>



<ul><li>You can provide multiple assemblies to scan.</li><li>If you don’t provide any assemblies it will scan the calling assembly.</li><li>If its scan doesn’t find any AfterSave event handlers then it sets the NotUsingAfterSaveHandlers config property to false (saves time in the the SaveChanges/ SaveChangesAsync).</li></ul><blockquote><p>NOTE:  If you send an event has hasn’t got a registered handler then you will get a GenericEventRunnerException at run time.  </p></blockquote>



<p>There are two ways to configure GenericEventRunner and the event handlers at startup. </p>



<ol><li>You can provide a <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner/blob/master/GenericEventRunner/ForSetup/GenericEventRunnerConfig.cs">GenericEventRunnerConfig</a> class at the first parameter to the  RegisterGenericEventRunner. You can change the default setting of various parts of  GenericEventRunner  (see the config class for what features it controls).</li><li>There is an EventHandlerConfig Attribute which you can add to an event handler class. From this you can set the lifetime of the handler. The default is transient</li></ol><blockquote><p>NOTE: The ability to change the lifetime of an event handler is there in case you need to communicate to event handler in some way, e.g. to check that an AfterSave event handler has run properly. In this case you could set the event handler’s lifetime to “Scoped” and use DI to inject the same handler into your code. (This is advanced stuff! – be careful).</p></blockquote>



<h2 id="5-unit-testing-applications-which-use-genericeventrunner">5. Unit Testing applications which use GenericEventRunner<a href="#5-unit-testing-applications-which-use-genericeventrunner"></a></h2>



<p>I recommend unit testing your events system, as if you
haven’t provided an event handler you will get a runtime exception. Setting up
the system to test events is a little complex because GenericEventRunner uses
dependency injection (DI). I have therefore built some code you might find
useful in unit tests.</p>



<p>The class called <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner/blob/master/Test/EfHelpers/SetupToTestEvents.cs">SetupToTestEvents</a> in the GenericEventRunner’s Test assembly that contains an extension method called CreateDbWithDiForHandlers that registers your event handlers and return an instance of your DbContext, with the required EventsRunner, to use in your unit tests. Here is an example of how you would use it in a unit test.</p>


<div><div id="highlighter_135495"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></td><td><div><p><code>[Fact]</code></p><p><code>public</code> <code>void</code> <code>TestOrderCreatedHandler()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>options = SqliteInMemory.CreateOptions&lt;ExampleDbContext&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>context = options.CreateDbWithDiForHandlers </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>&lt;OrderCreatedHandler&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.Database.EnsureCreated();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.SeedWithTestData();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>itemDto = </code><code>new</code> <code>BasketItemDto</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProductName = context.ProductStocks.OrderBy(x =&gt; x.NumInStock).First().ProductName,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>NumOrdered = 2,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ProductPrice = 123</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>order = </code><code>new</code> <code>Order(</code><code>"test"</code><code>, DateTime.Now, </code><code>new</code> <code>List&lt;BasketItemDto&gt; { itemDto });</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.Add(order);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.SaveChanges();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>order.TotalPriceNoTax.ShouldEqual(2 * 123);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>order.TaxRatePercent.ShouldEqual(4);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>order.GrandTotalPrice.ShouldEqual(order.TotalPriceNoTax * (1 + order.TaxRatePercent / 100));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.ProductStocks.OrderBy(x =&gt; x.NumInStock).First().NumAllocated.ShouldEqual(2);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>} </code></p></div></td></tr></tbody></table></div></div>


<p>The lines of code to highlight are:</p>



<ul><li>Line 5: You create your database options. In this case I am using a method in my EfCore.TestSupport library to create an in-memory Sqlite database, but it could be any type of database.</li><li>Line 6 and 7: This is where I call the CreateDbWithDiForHandlers extension method which needs two types:<ul><li>TContext: This is your DbContext class</li></ul><ul><li>THandler: This should be one of your event handlers. This is used for find an assembly which GenericEventRunner needs to scan to find all your event handlers are in so that it can register them in DI. (It also registers any event handlers in the executing assembly – that allows you to add extra handlers for unit testing).</li></ul></li></ul><p>The CreateDbWithDiForHandlers extension method has some
useful optional parameters- have a look at the code to see what they provide.</p>



<blockquote><p>NOTE: I didn’t include the <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner/blob/master/Test/EfHelpers/SetupToTestEvents.cs">SetupToTestEvents</a> class in the EfCore.GeneriEventHandler because it uses code from my EfCore.TestSupport library. You will need to copy it by hand from the GitHub repo into your unit test assembly.</p></blockquote>



<h3 id="logging">Logging <a href="#logging"></a></h3>



<p>The GenericEventRunner Event Runner logs each event handler
before it is run. The log message starts with a prefix:</p>



<ul><li>First letter: ‘A’ for AfterSave event handlers
and ‘B’ for BeforeSave event handlers</li><li>Then number: this show what loop was it run, e.g.
1, 2, 3 etc. (remember, BeforeHandlers can create new events, which needs another
loop around to find them). This is generally useful to see what events are
fired when.</li></ul><p>Here is an example from one of m GenericEventRunner unit
tests. Notice that the last log message starts with “B2”, which means it must
have been triggered by a change caused by one of the event handlers that run in
the first (i.e. “B1”) event loop.</p>


<div><div id="highlighter_170009"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><div><p><code>"B1: About to run a BeforeSave event handler …OrderCreatedHandler."</code></p><p><code>"B1: About to run a BeforeSave event handler …AllocateProductHandler."</code></p><p><code>"B2: About to run a BeforeSave event handler …TaxRateChangedHandler."</code></p></div></td></tr></tbody></table></div></div>


<p>Also, the unit test CreateDbWithDiForHandlers method allows you to capture logs, which can be useful in testing that events handlers run at the correct time.</p>



<h2 id="conclusions">Conclusions<a href="#conclusions"></a></h2>



<p>Well done for getting here! It’s a long article but I hope
it told you “why” and well as “how” to use the EfCore.GenericEventRunner
library. If you are thinking of using this library I recommend you inspecting/cloning
the <a href="https://github.com/JonPSmith/EfCore.GenericEventRunner">EfCore.GenericEventRunner
GitHub repo</a> and look at the examples and the unit tests to see how it
works.</p>



<p>While this library is new, I have been working on a similar
system in my client’s application for some time. That means the features and
approach of this library has been proven in the real-world. In fact, the
AfterSave events have been added to help deal with some issues that cropped up
in the client’s original implementation. </p>



<p>The third article in this series is “<a href="https://www.thereformedprogrammer.net/a-technique-for-building-high-performance-databases-with-ef-core/">A technique for building high-performance databases with EF Core</a>” which uses this event library to improve the the performance of my  “book app”. I build a similar version in chapter 13 in my book “<a href="http://bit.ly/2m8KRAZ">Entity Framework Core in Action</a>”, but in my opinion the new version that uses events is much better (You can see the original article from the book called “<a href="https://www.thereformedprogrammer.net/entity-framework-core-performance-tuning-a-worked-example/">Entity Framework Core performance tuning – a worked example</a>”). </p>



<p>Happy coding.</p>
	</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>