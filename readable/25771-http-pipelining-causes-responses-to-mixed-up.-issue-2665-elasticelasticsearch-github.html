<!DOCTYPE html>
<html lang="en">
<head>
    <title>
HTTP Pipelining causes responses to mixed up. &#xB7; Issue #2665 &#xB7; elastic/elasticsearch &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>HTTP Pipelining causes responses to mixed up. · Issue #2665 · elastic/elasticsearch · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>To better illustrate for people the impact here, let's compare a real world example. Let's say for example I'm querying our elasticsearch cluster in Oregon from New York. I have 10 requests to make. The trip from NY to OR takes about 40ms, and elasticsearch only takes 10ms to fulfill each request. Let's compare performance with and without pipelining:</p><p>Pipelining:</p><pre><code>10 requests issued in order immediately
40ms travel time
10 requests processed (any order), responded to (in order) (10+ms, elasticsearch processing)
40ms travel time
10 responses received in order
</code></pre><p>We're talking about 90+ ms (the + depends on how well elasticsearch handles the concurrent queries). Let's say it's not even concurrent (worst case), then we're talking 100ms for elastic, so 190ms total.</p><p>Now let's turn pipelining off:</p><pre><code>1 request issued
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Single request received, next request sent
40ms travel time
10ms 1 request processed, 1 response sent
40ms travel time
Last request received
</code></pre><p>That took 90ms <strong>per request</strong>, so at best it's 900ms. Hopefully that better illustrates the performance problem that not having HTTP pipelining working introduces. The same happens at &lt; 1ms latency which adds up for millions of requests per day. We hit some systems like this (redis for example) with 4 billion+ hits a day...without pipelining Stack Overflow would be hosed.</p><p>Currently, if one for 10 indexing operations fails (especially on the indexing side) we can get an "okay, indexed!" when in fact it failed...and we don't even know <em>which one</em> failed. So not only is this a major problem (which is why I feel this makes easily the resiliency list), it's a problem a user is incapable of solving. You currently just have to turn off pipelining and take a <em>huge</em> performance hit for high traffic applications.</p><p>As for execution order, yes it <em>does</em> matter. If a Stack Overflow post changes, we may issue an index request as soon as that happens - edits can happen rapidly and 2 indexing requests for the same document (with a new post body, title, tags, last activity date, etc. in our case) can easily be in the pipeline. If the last index command doesn't execute last, then an invalid document has been indexed which is out of date.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>