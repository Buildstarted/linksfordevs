<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Breaking Down Barriers &#x2013; Part 2: Synchronizing GPU Threads - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Breaking Down Barriers &#x2013; Part 2: Synchronizing GPU Threads - linksfor.dev(s)"/>
    <meta property="og:description" content="This is Part 2 of a series about GPU synchronization and preemption. You can find the other articles here: Part 1 &#x2013; What&#x2019;s a Barrier? Part 2 &#x2013; Synchronizing GPU Threads Part 3 &amp;#8&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://mynameismjp.wordpress.com/2018/04/01/breaking-down-barriers-part-2-synchronizing-gpu-threads/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Breaking Down Barriers &#x2013; Part 2: Synchronizing GPU Threads</title>
<div class="readable">
        <h1>Breaking Down Barriers &#x2013; Part 2: Synchronizing GPU Threads</h1>
            <div>Reading time: 16-21 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://mynameismjp.wordpress.com/2018/04/01/breaking-down-barriers-part-2-synchronizing-gpu-threads/">https://mynameismjp.wordpress.com/2018/04/01/breaking-down-barriers-part-2-synchronizing-gpu-threads/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article id="post-7803">

		<!-- .entry-header -->

		
		<div>

			<div>
				<p data-adtags-visited="true"><em>This is Part 2 of a series about GPU synchronization and preemption. You can find the other articles here:</em></p>
<p data-adtags-visited="true"><a href="https://mynameismjp.wordpress.com/2018/03/06/breaking-down-barriers-part-1-whats-a-barrier/">Part 1 – What’s a Barrier?</a><br>
<a href="https://mynameismjp.wordpress.com/2018/04/01/breaking-down-barriers-part-2-synchronizing-gpu-threads/">Part 2 – Synchronizing GPU Threads</a><br>
<a href="https://mynameismjp.wordpress.com/2018/06/17/breaking-down-barriers-part-3-multiple-command-processors/">Part 3 – Multiple Command Processors</a><br>
<a href="https://mynameismjp.wordpress.com/2018/07/03/breaking-down-barriers-part-4-gpu-preemption/">Part 4 – GPU Preemption</a><br>
<a href="https://mynameismjp.wordpress.com/2018/09/08/breaking-down-barriers-part-5-back-to-the-real-world/">Part 5 – Back To The Real World</a><br>
<a href="https://mynameismjp.wordpress.com/2018/12/09/breaking-down-barriers-part-6-experimenting-with-overlap-and-preemption/">Part 6 – Experimenting With Overlap and Preemption</a></p>
<p data-adtags-visited="true">Welcome to part 2 of the series! In the <a href="https://mynameismjp.wordpress.com/2018/03/06/breaking-down-barriers-part-1-whats-a-barrier/">previous article</a>, I explained the basics of what a barrier is, and talked about the various reasons for why you need to use a barrier on a GPU. One such use case that I brought up was to ensure that the many threads kicked off by a Draw or Dispatch call don’t overlap with previous Draw/Dispatch’s threads when there’s some kind of dependency between the two calls. In this article I’m going to dive into the specifics of how GPU’s handle this kind of synchronization, and also discuss the high-level performance implications of these approaches.</p>
<h3>Programming the MJP-3000</h3>
<p data-adtags-visited="true">To explain the basics of GPU thread synchronization, I’m going to walk through some examples using a completely fictional architecture: the MJP-3000. This made-up GPU is much simpler than real graphics hardware, which&nbsp;will (hopefully) make it easier to demonstrate high-level concepts without getting lost in the weeds. I also don’t want to give the impression that what I describe is <em>exactly</em> how real GPU’s do things, especially since many of those details aren’t publicly available. However the commands and behavior are still loosely based on real-world GPU’s, since otherwise the example wouldn’t be&nbsp;very useful!</p>
<p data-adtags-visited="true">With the prologue out of the way, let’s have a look at&nbsp;the amazing feat of engineering that is the MJP-3000:</p>
<p data-adtags-visited="true"><a href="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png"><img data-attachment-id="6583" data-permalink="https://mynameismjp.wordpress.com/gpu-overview/" data-orig-file="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png" data-orig-size="1200,559" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gpu-overview" data-image-description="" data-medium-file="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=300" data-large-file="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=756" src="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=756" alt="gpu-overview" srcset="https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=756 756w, https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=150 150w, https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=300 300w, https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=768 768w, https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png?w=1024 1024w, https://mynameismjp.files.wordpress.com/2017/01/gpu-overview1.png 1200w" sizes="(max-width: 756px) 100vw, 756px"></a></p>
<p data-adtags-visited="true">The interesting parts here are the <strong><a href="https://fgiesen.wordpress.com/2011/07/02/a-trip-through-the-graphics-pipeline-2011-part-2/">command processor</a></strong> on the left, and the <strong>shader cores</strong>&nbsp;in the middle. The command processor&nbsp;is the brains of the operation, and its job is to read commands (the green blocks) from a <b>command buffer</b>&nbsp;and coordinate the <strong>shader cores</strong>. The command processor&nbsp;reads commands one at time from the command buffer, always in the exact order they’re submitted. When the command processor&nbsp;encounters the appropriate commands, it can add a group of threads to the <strong>thread queue</strong>&nbsp;immediately to the right of the command processor. The 16 shader cores pull threads from this queue in a first-in first-out (FIFO) scheme, after which the shader program for that thread is actually executed on the shader core.&nbsp;The cores&nbsp;are&nbsp;all identical, and completely independent of each other. This means that together they can&nbsp;simultaneously run 16 threads of the same shader program, or they can each run a thread from a completely different program. The shader cores can also read or write to arbitrary locations in device memory, which is on the right. Since the cores&nbsp;are independent and can all access memory, you can think of the array like a 16-core CPU. The major difference is that unlike a CPU they can’t tell themselves what to do, since they instead rely on the command processor to enqueue work for them. The <strong>Current Cycle Count</strong> in the top-left corner shows how many GPU cycles have executed for a particular example, which will help us keep track of how long it took for a particular example to complete execution.</p>
<p data-adtags-visited="true">For some reason, the designers of the MJP-3000 decided that their hardware could only run&nbsp;compute shaders. I suppose they felt that it would make things a lot simpler to only focus on the one shader stage that doesn’t rely on a complicated rasterization pipeline. Because of that, the command processor only has 1 command that actually kicks off threads to run on the shader cores: <strong>DISPATCH</strong>. The DISPATCH command specifies two things: how many threads need to run, and what shader program should be executed. When a DISPATCH command is encountered by the command processor,&nbsp;the threads from that dispatch are immediately placed in the thread queue, where they are grabbed by waiting shader cores. Since there are 16 cores, only 16 threads can&nbsp;be executing at any given time. Any threads that aren’t running on the shader cores stay in the thread queue until a core finishes a different thread and&nbsp;pulls the waiting thread out of the queue. The command processor can parse a DISPATCH command and enqueue its threads in 1 cycle, and the shader cores can dequeue a thread from the thread queue in 1 cycle.</p>
<h3>Dispatches and Flushes</h3>
<p data-adtags-visited="true">Let’s now try a simple example where we dispatch 32 threads that each write something to a separate element of&nbsp; a buffer located in device memory. This dispatch will run shader program “A”, which takes 100 cycles to complete. So with 16 cores we would expect the whole dispatch to take around 200 cycles from start to end. Let’s go through the steps:</p>
<div id="gallery-7803-13-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6685&quot;,&quot;title&quot;:&quot;single_dispatch_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6686&quot;,&quot;title&quot;:&quot;single_dispatch_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6687&quot;,&quot;title&quot;:&quot;single_dispatch_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6688&quot;,&quot;title&quot;:&quot;single_dispatch_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6689&quot;,&quot;title&quot;:&quot;single_dispatch_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/single_dispatch_0005_layer-6.png&quot;,&quot;id&quot;:&quot;6690&quot;,&quot;title&quot;:&quot;single_dispatch_0005_layer-6&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/single_dispatch_0000_layer-1.png" title="single_dispatch_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">In the first step, the command processor encounters a DISPATCH command in the command buffer that requests 32 threads of program A. 1 cycle later, the command processor has enqueued the 32 requested threads in the thread queue. 1 cycle after that, the 16 shader cores have each picked up a thread of program A and have started executing them. Meanwhile, 16 threads are left in the queue. 100 cycles later the first batch of threads have completed, and their result is in memory. 1 cycle after that we’re at the 103 cycle count, and the second batch of 16 threads are pulled from the now-empty queue to start executing on the shader cores. Finally after a total of 203 cycles, the threads are all finished and their results are in memory.</p>
<p data-adtags-visited="true">Now that we understand the basics of how this GPU works, let’s introduce some synchronization. As we already know from the previous article, synchronization implies that we’re going to somehow wait for all of our threads to hit a certain point before continuing. On a GPU where you’re constantly spinning up lots of new threads, this actually translates into something more like “wait for all of the threads from one group to finish before the threads from a second group start executing”. The common case where we’ll need to do this is where one dispatch needs to read the results that were written out by another dispatch. So for instance, say we run 24&nbsp;threads of program A that collectively write their results to 24&nbsp;elements of a buffer. After program A completes that we want to run 24 threads of program B, which will then read those 24 elements from the original output buffer and use them to compute new results written into a different buffer. If we were to try to do this by simply putting two DISPATCH commands in our command buffer,&nbsp;it would go something like this (program A is red, and program B is green):</p>
<div id="gallery-7803-14-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/dispatch_overlap_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6675&quot;,&quot;title&quot;:&quot;dispatch_overlap_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/dispatch_overlap_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6676&quot;,&quot;title&quot;:&quot;dispatch_overlap_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/dispatch_overlap_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6677&quot;,&quot;title&quot;:&quot;dispatch_overlap_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/dispatch_overlap_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6678&quot;,&quot;title&quot;:&quot;dispatch_overlap_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/dispatch_overlap_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6679&quot;,&quot;title&quot;:&quot;dispatch_overlap_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/dispatch_overlap_0000_layer-1.png" title="dispatch_overlap_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">Take a look at the the third step: since dispatch A&nbsp;wasn’t a multiple of 16, the bottom 8 shader cores pulled from dispatch B to keep the cores from going idle.&nbsp;This caused the two dispatches to&nbsp;<em>overlap</em>, meaning that&nbsp;the end of dispatch A was still executing while the start of dispatch B was simultaneously executing. This is actually really bad for our case, because we now have a race condition: the threads of dispatch B might read from dispatch A’s output buffer before the threads of dispatch A have finished! Without knowing the specifics of which memory is accessed by programs A and B and how exactly the threads execute on the GPU, we have no choice but to insert a sync point between the two dispatches. This sync point will need to cause the command processor to wait until all threads of dispatch A run to completion before&nbsp;processing dispatch B. So let’s now introduce&nbsp;a FLUSH command that will do exactly that: when the command processor hits the flush, it waits for all shader cores to become idle before processing any further commands. The term “flush” is common for this sort of operation because it implies that it will “flush out” all pending work that’s waiting to execute. Let’s now try the same scenario again, this time&nbsp;using a flush to synchronize:</p>
<div id="gallery-7803-15-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6665&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6666&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6667&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6668&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6669&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0005_layer-6.png&quot;,&quot;id&quot;:&quot;6670&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0005_layer-6&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0006_layer-71.png&quot;,&quot;id&quot;:&quot;6753&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0006_layer-7&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_between_dispatches_0007_layer-8.png&quot;,&quot;id&quot;:&quot;6672&quot;,&quot;title&quot;:&quot;flush_between_dispatches_0007_layer-8&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/flush_between_dispatches_0000_layer-1.png" title="flush_between_dispatches_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">Notice how the command processor hits the FLUSH command, and then stops reading commands until dispatch A is completely finished and the thread queue is empty. This ensures that dispatch B never overlaps with dispatch A, which means it will be safe for any thread in dispatch B to access any result that that was output by dispatch A. This is pretty much exactly what I was talking about in part 1 when I mentioned the need for barriers to prevent dependent Draw/Dispatch calls from overlapping. In fact, you can usually expect something like a FLUSH to happen on current GPU’s if you issued dispatch A, issued a&nbsp;barrier to transition the output buffer from a write state to a read state, and then issued dispatch B (it’s also similar to what you would get in response to issuing a D3D12_RESOURCE_UAV_BARRIER in D3D12, since that also implies waiting for all pending writes to finish). Hopefully this example makes it even more clear as to why a barrier is necessary for this sort of data dependency, and why results could be wrong if the barrier is omitted.</p>
<p data-adtags-visited="true">It’s also very important to note that in this case the flush/barrier was not free from a performance point of view: our total processing time for both dispatches went from 304 cycles to 406 cycles. That’s a 25% increase! The reason for this should be intuitive: with the flush between dispatches, we now have more idle shader cores&nbsp;during&nbsp;the tail end of both dispatches. In fact&nbsp;the increase in processing time is exactly the same as the increase in the&nbsp;amount of idle time: without the flush we had about 0% idle cores over both dispatches, but&nbsp;<em>with</em> the flush our cores were idle about 25% of the time on average. This leads us to a simple conclusion: <strong>the performance cost of a flush is directly tied to&nbsp;the decrease in utilization</strong>. This ultimately means that the relative cost of introducing a thread synchronization barrier will vary depending on the number of threads, how long those threads execute, and how well the threads can fully saturate the available shader cores. We can confirm this with a simple thought experiment: imagine we ran dispatch A and dispatch B with 40 threads each instead of 24. The process would go almost exactly as it did before, except both dispatches would have another “phase” of 100 cycles where all 16 cores were in-use. Without our barrier the whole process would take about (40 + 40) / 16 = 500 cycles, while with the barrier&nbsp;it would take about 600 cycles. Therefore the relative cost of the barrier is about 16.5% as opposed to the 25% cost when our thread counts were lower.</p>
<p data-adtags-visited="true">The other way to look at this is that <strong>removing an unnecessary flush can result in a performance increase that’s relative to the amount of idle shader cores</strong>. So if we’re syncing between two dispatches and they have no dependency between them, it’s most likely a good idea to remove the barrier and let them overlap with each other. For larger dispatches (in terms of thread count) that can saturate the GPU on their own there won’t be much benefit, since there won’t be much idle time to exploit. However for very small dispatches the difference can be significant. This time let’s imagine that dispatch A and B both have 8 threads each. With a flush in between the total time will be about 200 cycles, but with no flush they can perfectly overlap and finish in only 100 cycles! Or as another example, imagine we had another completely independent workload of 8 threads that we’ll call dispatch C (and color its threads blue). If we were to overlap it with dispatch A, we could essentially get it for “free” by utilizing the idle cores:</p>
<div id="gallery-7803-16-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6756&quot;,&quot;title&quot;:&quot;flush_with_overlap_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6757&quot;,&quot;title&quot;:&quot;flush_with_overlap_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6758&quot;,&quot;title&quot;:&quot;flush_with_overlap_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6759&quot;,&quot;title&quot;:&quot;flush_with_overlap_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6760&quot;,&quot;title&quot;:&quot;flush_with_overlap_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_0005_layer-6.png&quot;,&quot;id&quot;:&quot;6761&quot;,&quot;title&quot;:&quot;flush_with_overlap_0005_layer-6&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/flush_with_overlap_0000_layer-1.png" title="flush_with_overlap_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">If you squint a bit and look at our GPU as if it were a CPU executing instructions instead of a GPU executing commands, then this kind of overlapping of work could be considered a kind of <a href="https://en.wikipedia.org/wiki/Instruction-level_parallelism"><strong>Instruction Level Parallelism</strong></a>. In this case the parallel operations are being explicitly specified in our command stream, making it somewhat similar to how&nbsp;<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">VLIW</a> architectures work.</p>
<h3>Waits and Labels</h3>
<p data-adtags-visited="true">In the previous example, we were able to basically hide dispatch C in the idle time left by the barrier between dispatch A and dispatch B. But what if dispatch C was very complicated, and took&nbsp;much longer than 100 cycles to complete? Let’s re-do the example, except this time dispatch C will&nbsp;execute for 400 cycles instead of 100:</p>
<div id="gallery-7803-17-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6792&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6793&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6794&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6795&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6796&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0005_layer-6.png&quot;,&quot;id&quot;:&quot;6797&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0005_layer-6&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/flush_with_overlap_long_0006_layer-7.png&quot;,&quot;id&quot;:&quot;6798&quot;,&quot;title&quot;:&quot;flush_with_overlap_long_0006_layer-7&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/flush_with_overlap_long_0000_layer-1.png" title="flush_with_overlap_long_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">Things didn’t go as well this time around. We still got a bit of overlap between A and C,&nbsp;but that was immediately followed by 300 cycles where half of our shader cores were idle. This happened because our FLUSH command ends up waiting for dispatch C to finish, since the flush works by waiting for the thread queue to become completely empty. We could re-arrange things&nbsp;so that dispatch C gets kicked off&nbsp;<em>after</em> the flush, but this is not ideal either because there would still be a bit of idle time during the tail end of dispatch A, and also a long period of half-idle cores when dispatch C is running.</p>
<p data-adtags-visited="true">Lucky for us, there’s a new driver update for the MJP-3000 that should be able to help us out. MJP xPerience 3D Nocturnal<b>™</b> Driver v5.444.198754 adds support for two new commands that can be parsed and executed by the command processor. The first one is called SIGNAL_POST_SHADER, and the other is called WAIT_SIGNAL. The first command is pretty fancy: it tells the command processor to write a signal value to an address in memory (often called a <em>fence</em> or <em>label</em>) once all shaders have completed.&nbsp;The cool part is that it’s a “deferred” write: the write is actually performed by the thread queue once it determines that all previously-queued threads have run to completion. This allows the command processor to move on to other commands while previous dispatches are still executing. The other command, WAIT_SIGNAL, tells the command processor to stall and wait for a memory address to be signaled. This can be used in conjunction with SIGNAL_POST_SHADER to&nbsp;wait for a particular dispatch to complete, but with the added bonus that the command processor can kick off more work in between those steps. To help visualize this process, let’s update the GPU diagram with a new component:</p>
<p data-adtags-visited="true"><a href="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png"><img data-attachment-id="6852" data-permalink="https://mynameismjp.wordpress.com/2018/03/06/breaking-down-barriers-part-1-whats-a-barrier/label-overview/" data-orig-file="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png" data-orig-size="1033,400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="label-overview" data-image-description="" data-medium-file="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=300" data-large-file="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=756" src="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=756" alt="label-overview" srcset="https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=756 756w, https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=150 150w, https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=300 300w, https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=768 768w, https://mynameismjp.files.wordpress.com/2017/01/label-overview.png?w=1024 1024w, https://mynameismjp.files.wordpress.com/2017/01/label-overview.png 1033w" sizes="(max-width: 756px) 100vw, 756px"></a></p>
<p data-adtags-visited="true">Once a SIGNAL_POST_SHADER command is executed, any pending labels will show up&nbsp;as a colored block in a new area under the thread queue. The number on the block shows the current status of the label: “0” means it hasn’t been signaled yet, and “1” means that it’s in the signaled state and any dependent waits will be released.</p>
<p data-adtags-visited="true">Let’s now try&nbsp;out our new commands with the previous example:</p>
<div id="gallery-7803-18-slideshow" data-trans="fade" data-autostart="false" data-gallery="[{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0000_layer-1.png&quot;,&quot;id&quot;:&quot;6830&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0000_layer-1&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0001_layer-2.png&quot;,&quot;id&quot;:&quot;6831&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0001_layer-2&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0002_layer-3.png&quot;,&quot;id&quot;:&quot;6832&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0002_layer-3&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0003_layer-4.png&quot;,&quot;id&quot;:&quot;6833&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0003_layer-4&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0004_layer-5.png&quot;,&quot;id&quot;:&quot;6834&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0004_layer-5&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0005_layer-6.png&quot;,&quot;id&quot;:&quot;6835&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0005_layer-6&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0006_layer-7.png&quot;,&quot;id&quot;:&quot;6836&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0006_layer-7&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0007_layer-8.png&quot;,&quot;id&quot;:&quot;6837&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0007_layer-8&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0008_layer-9.png&quot;,&quot;id&quot;:&quot;6838&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0008_layer-9&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;},{&quot;src&quot;:&quot;https:\/\/mynameismjp.files.wordpress.com\/2017\/01\/split_barrier_overlap_0009_layer-10.png&quot;,&quot;id&quot;:&quot;6839&quot;,&quot;title&quot;:&quot;split_barrier_overlap_0009_layer-10&quot;,&quot;alt&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;itemprop&quot;:&quot;image&quot;}]" itemscope="" itemtype="https://schema.org/ImageGallery"><div itemprop="associatedMedia" itemscope="" itemtype="https://schema.org/ImageObject"><p><img src="https://mynameismjp.files.wordpress.com/2017/01/split_barrier_overlap_0000_layer-1.png" title="split_barrier_overlap_0000_layer-1" alt="" itemprop="image"><span>&nbsp;</span></p></div></div>
<p data-adtags-visited="true">Very nice!&nbsp;By removing the long stall on dispatch C, we’ve effectively eliminated all of the idle time and kept the GPU busy&nbsp;for the entire duration of the 3 dispatches. As a result we’ve increased our overall throughput: previously the process took about 700 cycles, but now it’s down to about 500 cycles. Unfortunately this is still more time than it took to complete when we only had dispatch A and B to worry about, which means the <em>latency</em> for the A-&gt;B job increased by about 100 cycles. But at the same time the latency for dispatch C&nbsp;is&nbsp;is lower than it would be if it weren’t overlapped, since it would otherwise need to wait for either A or&nbsp;B to finish before it could start processing.</p>
<p data-adtags-visited="true">If the MJP-3000 were being programmed via D3D12 or Vulkan, then this signal/wait behavior is probably what you would hope to see&nbsp;when issuing a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899226(v=vs.85).aspx#split_barriers">split barrier</a>&nbsp;(vkCmdSetEvent + vkCmdWaitEvents in Vulkan-ese). Split barriers&nbsp;let you&nbsp;effectively specify 2 different points in a resource’s lifetime:&nbsp;the point where you’re done using it&nbsp;in its current state (read, write, etc.), and the point where you actually need the resource to be in its new state. By doing this and issuing some work between the begin and end of the barrier, the driver (potentially) has enough information to know that it can overlap the in-between work while it’s waiting for the pre-barrier work to finish. So for the example I outlined above, the D3D12 commands might go something like this:</p>
<ul>
<li>Issue Dispatch A which writes to Buffer A</li>
<li>Begin Transition Buffer A from writable&nbsp;-&gt;&nbsp;readable</li>
<li>Issue Dispatch C which writes to Buffer C</li>
<li>End Transition Buffer A from writable -&gt; readable</li>
<li>Issue Dispatch B which writes to Buffer B</li>
</ul>
<p data-adtags-visited="true">For real-world GPU’s the benefits of split barriers can possibly be even greater than the sync point removal that I demonstrated with my imaginary GPU. As I mentioned in part 1, barriers on GPU’s are also responsible for handing things like cache flushes and decompression steps. These things increase the relative cost of a barrier past the simple “idle shader core tax” that we saw on our imaginary GPU, which gives us even more incentive to try to overlap the barrier with with some non-dependent work. However, the ability to overlap barrier operations with Draws and Dispatches is totally dependent on the specifics of the GPU architecture.</p>
<p data-adtags-visited="true">Before we wrap up, I’d like to point out that our GPU is still rather limited in terms of how it can overlap different dispatches, even with the new label/wait functionality that we just added. You can only do so much when the command processor is completely tied up every time that you need to wait for a previous dispatch to finish, which really starts to hurt you if you have more complex dependency chains. Later on in part 3 we’ll revisit this topic, and look at at how some hardware changes can help us get around these limitations.</p>
<h3>Next Up</h3>
<p data-adtags-visited="true">In <a href="https://mynameismjp.wordpress.com/2018/06/17/breaking-down-barriers-part-3-multiple-command-processors/">Part 3</a>, I’m going to discuss why explicit API’s expose multiple queues for submitting command buffers. I’ll also show how multiple queues could work on the fictional GPU architecture we’ve been using as an example, and discuss some implementations in real-world GPU’s.</p>
			
			
										</div><!-- .entry-content -->

			<!-- .entry-footer -->

			
<!-- #comments -->

		</div>

		<!-- .sidebar -->

	</article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>