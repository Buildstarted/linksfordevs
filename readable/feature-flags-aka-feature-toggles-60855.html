<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Feature Flags (aka Feature Toggles) - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Feature Flags (aka Feature Toggles) - linksfor.dev(s)"/>
    <meta property="article:author" content="Roland Roos ICT Architectures"/>
    <meta property="og:description" content="Separation of deployment and feature releases: how to enable and disable features in applications (services) at configuration time"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codeproject.com/Articles/5265400/Feature-Flags-aka-Feature-Toggles"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Feature Flags (aka Feature Toggles)</title>
<div class="readable">
        <h1>Feature Flags (aka Feature Toggles)</h1>
            <div>by Roland Roos ICT Architectures</div>
            <div>Reading time: 34-42 minutes</div>
        <div>Posted here: 20 Apr 2020</div>
        <p><a href="https://www.codeproject.com/Articles/5265400/Feature-Flags-aka-Feature-Toggles">https://www.codeproject.com/Articles/5265400/Feature-Flags-aka-Feature-Toggles</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>In modern (agile) (micro)service oriented application landscapes, you want to deliver features as soon as possible. Preferably, through an automated deployment pipeline. However, you want to separate releasing features from deployments, and you want to have control when and to whom to release functionality (or, when and to whom to revoke functionality). Putting features behind a flag that can be enabled and disabled for groups can help achieve this goal.</p><div id="contentdiv">
						



<ul>
	<li><a href="https://www.codeproject.com/KB/architecture/5265400/Code.zip">Download source - 64.7 KB</a></li></ul>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/article_small.jpeg" data-sizes="auto" data-srcset="/KB/architecture/5265400/article_small-r-400.jpeg 400w, /KB/architecture/5265400/article_small.jpeg 640w" sizes="640px" srcset="/KB/architecture/5265400/article_small-r-400.jpeg 400w, /KB/architecture/5265400/article_small.jpeg 640w"></p>

<p>Using feature flags to drive your productâ€™s release strategy and continuous delivery</p>

<h2>Introduction</h2>

<p>This article provides the concept of Feature Flags, aka Feature Toggles; after that, a possible design follows with pros and cons; then, two possible implementations follow; one in Java (11), one in C# (7).</p>

<p>Last but not least, a wrapup and conclusion is given with some (I trust) good advice.</p>

<p>In short, Feature Flagging allows to modify system behavior by configuration, without changing code. So, in your production application environment, functionality ("features") can be switched on and off for certain (groups of) users without (re-, rollback-) deployment of binaries. This concept is a pattern of the type "Separation of concern", or "Single responsibility". After all, releasing binaries (deployment) and releasing functionality are separated from each other. In general, it is a good idea not to combine two responsibilities in one action (or component). By applying feature flagging, a new release with new features can be deployed, without releasing per-se the new features to everyone. And even so, it is possible to revoke features for certain groups or individuals, without having to rollback a binary release (deployment of a previous version).</p>

<p>See related articles:</p>

<ol>
	<li><a href="https://www.codeproject.com/Articles/5264376/Aspect-Oriented-Programming-and-More-Patterns-in-M">Roland Roos, Aspect-Oriented Programming and More Patterns in Micro-Services</a></li>	<li><a href="https://martinfowler.com/articles/feature-toggles.html">Martin Fowler, feature-toggles</a></li>	<li><a href="https://stackoverflow.com/questions/7707383/what-is-a-feature-flag">Stack Flow What-is-a-feature-flag</a></li>	<li><a href="https://github.com/cottsak/DevCookie">Other possible C# implementation example</a></li></ol>

<p>How is this article built up?</p>

<ul>
	<li>Examples in Java and C# of final usage</li>	<li>Concept of Feature Flagging/Toggling</li>	<li>High level design and rationale (pros and cons of the design)</li>	<li>Java implementation details</li>	<li>C# implementation details</li>	<li>Wrap-up and conclusions, and more</li></ul>

<h3>Before Reading this Article</h3>

<p>Before you start reading this article, a general advice; If you are not familiar with aspect-orientation, it is advised to first read my article on this or the links in there, as the design and implementation in this article relies heavily on aspect-orientation. See <a href="https://www.codeproject.com/Articles/5264376/Aspect-Oriented-Programming-and-More-Patterns-in-M">[1.] Aspect-Oriented Programming and More Patterns in Micro-Services</a></p>

<h3>Using the Code in Java (11+, Spring boot 2.2+, MVC thymeleaf, Aspectj)</h3>

<p><span id="prehide363580" onclick="processCodeBlocks.togglePre(363580);">Hide</span>  &nbsp; <span id="preShrink363580" onclick="processCodeBlocks.shrinkExpand(363580);">Shrink</span> <img id="preimg363580" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(363580);">  &nbsp; <span id="copycode363580" onclick="return processCodeBlocks.copyCode(363580);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre363580" processed="true">


featureFlags:
	feature1:
		enabled : true
		included :
			user1
		










<span>@FeatureFlag</span>(features = {<span>"</span><span>feature1"</span>}, paramNameForKeyOfFeature = <span>"</span><span>user"</span>)
<span>public</span> <span>void</span> annotatedFeatureOnController(
	<span>String</span> user, 
	Model model, 
	ModelAndView modelandView) {
	
	<span>if</span> (user.compereTo(<span>"</span><span>user1"</span>) == <span>0</span>) {
		<span>assert</span>.isTrue(modelandView[<span>"</span><span>feature1"</span>]);
	}
}
...

Controller.annotatedFeatureOnController(<span>"</span><span>user1"</span>, viewModel);</pre>

<h3>Using the Code in C# (7&gt;, .NET MVC Core 2.1+, Autofac, Caste Core Dynamic Proxy)</h3>

<p><span id="prehide846957" onclick="processCodeBlocks.togglePre(846957);">Hide</span>  &nbsp; <span id="preShrink846957" onclick="processCodeBlocks.shrinkExpand(846957);">Shrink</span> <img id="preimg846957" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(846957);">  &nbsp; <span id="copycode846957" onclick="return processCodeBlocks.copyCode(846957);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre846957" processed="true">


<span>"</span><span>featureFlags"</span>: [
	{
		<span>"</span><span>name"</span>: <span>"</span><span>feature1"</span>,
		<span>"</span><span>enabled"</span>: true,
		<span>"</span><span>included"</span>: [
			<span>"</span><span>user1"</span>
		]
	}
]
		










[FeatureFlag(<span>"</span><span>user"</span>, <span>new</span> <span>String</span>[] { <span>"</span><span>feature1"</span> })]
<span>public</span> ActionResult AnnotatedFeatureOnController([FeatureFlagKey] <span>String</span> user)
{
	<span>if</span> (user.compereTo(<span>"</span><span>user1"</span>) == <span>0</span>) 
	{
		<span>assert</span>.isTrue( ViewData[<span>"</span><span>feature1"</span>]);
	}
}
...

HomeController.AnnotatedFeatureOnController(<span>"</span><span>user1"</span>);
or
http:</pre>

<h2>Concept: The Basic Principles</h2>

<h3>What Is Feature Flagging?</h3>

<p>There are already good articles on this, in general. See also <a href="https://martinfowler.com/articles/feature-toggles.html">[2.] Martin Fowler, feature-toggles</a></p>

<p><strong>Remark</strong>: Feature toggle and feature flag are synonyms.</p>

<p>A flag in coding-land is commonly known as a boolean 1/0, true/false, on/off. So, the feature is either on or off.</p>

<p>A toggle in coding-land is generally the more dynamic flipping of the flag, 0&lt;-&gt;1 , true &lt;-&gt; false, on &lt;-&gt; off. So it refers to flipping the feature from on to off, and vice-versa.</p>

<h3>Why Use Feature Flagging?</h3>

<p>In modern, micro-service oriented application landscapes that use a "real" agile approach, we would like to deploy and release functionality (features) as early as possible. Preferably, right after it is automatically built, and automatically tested as ok in the build pipeline. However, we don't want this feature to be always released and available to "everyone" once deployed. Wouldn't it be nice to have the functionality deployed to production at once, skipping complex acceptation periods? Wouldn't it be nice if you could just acceptance test it in production, side-by-side with old implementations, without having the feature available? And then, if proven not to interfere with other functionality, to "release" it for early adapters? And finally, if it was proven stable and usable by the early adapters, gradually release it to everyone? Or, if proven to be disruptive, to disable (revoke) it at once without re-deployment or complex rollbacks?<br>
I bet you would say: yes please, but no thanks. "Not possible".<br>
I bet you: it is possible, hands down, I kid you not.<br>
But it comes with a cost and another burden: feature administration.</p>

<p>In this article, we describe a possible, low-impact, relatively simple design and a possible implementation in both Java and C#. In the wrap-up conclusion, we also address some important strategies with this pattern, to prevent a big clutter-up of boolean <code>if</code>-<code>then</code>-<code>else</code> flows in your code.</p>

<h3>High Level Design</h3>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/FeatureFlag_Service_API.png" data-src="/KB/architecture/5265400/FeatureFlag_Service_API.png" data-sizes="auto" data-srcset="/KB/architecture/5265400/FeatureFlag_Service_API-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Service_API.png 640w" srcset="/KB/architecture/5265400/FeatureFlag_Service_API-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Service_API.png 640w"></p>

<p>Looking at this model, we can see the following:</p>

<ul>
	<li>We did not use the word "user" in the model. It is called a "Key", which is an abstraction of a "user". That allows for other type of keys then only users to switch features on.</li>	<li>It uses Feature aspects to deliver the feature toggles to your code</li>	<li>a feature can be either "enabled" (available to everyone), "disabled" (available to no-one) or "filtered" (available to certain users).</li>	<li>A "KeyGroup" is a group of "Keys";</li>	<li>A feature can have a list of included and/or excluded Keys (aka users) and/or KeyGroups (aka UserGroups).</li>	<li>The feature aspects are delivered by a binary library, using a service facade instead of a client-proxy-service facade. As a consequence of that, we have chosen not to remote the feature flag administration. We simply supply a configuration file per service/component, with the needed feature flags for that service/component. If you would need that kind of centralized feature flag functionality, you would need to replace that with a remote feature service and a client concept, with probably some caching and refreshing. This local configuration file per service type of implementation is not very good suited for clustered load-balanced services, like Containers under a Kubernetes load balancer. Indeed, a form of centralization and remoting would be more applicable then.</li>	<li>There is no GUI delivered for editing and toggling. <strong>Note</strong>: In modern (micro-)service oriented landscapes, a scattering of configuration files is not good for either maintenance, nor traceability. To solve that, a very pragmatic but good workable pattern is available (see Config servers in Spring Boot). Just create separate Config Git repositories with all configuration files in there, and treat configuration as "source code". So, checkin/out to your Git Config, with full versioning and traceability. All services can pull their config from there.</li></ul>

<p>So, indeed, as promised, a very KISS (<b>K</b>eep <b>I</b>t <b>S</b>tupid and <b>S</b>imple) straight-forward implementation, but quite easily extendable to other needs.</p>

<h3>General Implementation Details</h3>

<p>We have in both implementations (Java/C#) unit tests to test the code. And a small demo app MVC-ViewModel service with a tag library (in Java, Thymeleaf, in C# Tag Helpers). That is to show how the features "flow" through the chain of control: config file -&gt; model -&gt; service -&gt; controller -&gt; view -&gt; html. And, like any modern setup, we use IOC and a container: Java Spring Boot AppContext with @Autowiring, in C# Autofac attached to the default Microsoft MVC container. I'll write an article on the how and why of IOC with Java Spring Boot and C# Autofac later, so bear with me and skip that if you're not up to speed there. Same holds for unit testing with mocking frameworks (Mockito, Fakeiteasy). An article on how and why of that is coming up as well.</p>

<p>I promised a KISS simple solution in both Java and C#. Here it is in outline.</p>

<h3>Model Implementation</h3>

<p>Regarding the <code>FeatureFlags</code> model:</p>

<ul>
	<li>4 simple structure classes (<code>FeatureFlags</code>, <code>Feature</code>, <code>KeyGroup</code>, <code>Key</code>)</li>	<li>1 simple data file (<em>.yml</em> in Java, <em>.json</em> in C#)</li>	<li>1 simple service, that holds the <code>FeatureFlags</code> model, and does the <code>Feature</code> lookup in this structure by <code>Feature.name</code></li>	<li>Some initialization code to parse the config data to the class model data structures (Java uses Spring <code>@ConfigurationProperties</code>, C# <code>ConfigurationBuilder</code> with a little bit more setup code)</li></ul>

<p>Regarding the <code>@FeatureFlag("feature1")</code> annotation:</p>

<ul>
	<li>Two annotations, <code>@FeatureFlag</code>, <code>@FeatureFlagKey</code></li>	<li>One Aspect: <code>FeatureFlagAspect</code>, that does the lookup of the <code>Feature</code> properties in the model, through the service, and finds the <code>Key</code> value in the <code>Method</code> params, and does the lookup on the Tuple {&lt;keyvalue&gt;, &lt;featurename&gt;}</li>	<li>1 simple service, that does the lookup in this structure: <code>Feature</code> <code>FeatureFlagServiceImpl.getFeature(String forKey, String forFeatureName){..}</code></li></ul>

<h2>Java Implementation Details (Java 11, Spring Boot, Spring AOP, Lombok, Thymeleaf MVC)</h2>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/DemoAppJava.png" data-src="/KB/architecture/5265400/DemoAppJava.png" data-sizes="auto" data-srcset="/KB/architecture/5265400/DemoAppJava-r-400.png 400w, /KB/architecture/5265400/DemoAppJava.png 640w" srcset="/KB/architecture/5265400/DemoAppJava-r-400.png 400w, /KB/architecture/5265400/DemoAppJava.png 640w"></p>

<h3>Data Structure to Hold Feature Config</h3>

<p>Remember, this was the model:</p>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/FeatureFlag_Model.png" data-src="/KB/architecture/5265400/FeatureFlag_Model.png" data-sizes="auto" data-srcset="/KB/architecture/5265400/FeatureFlag_Model-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Model.png 640w" srcset="/KB/architecture/5265400/FeatureFlag_Model-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Model.png 640w"></p>

<p>First, implement the configuration in this Spring Boot yaml structure according to this model:</p>

<p><span id="prehide221317" onclick="processCodeBlocks.togglePre(221317);">Hide</span>  &nbsp; <span id="copycode221317" onclick="return processCodeBlocks.copyCode(221317);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre221317">featureFlags:
    feature1:
         enabled : true
         included :
            group1,
            user3
         excluded :
            user4

keyGroups:
    feature1 : 
        keys : 
            user1,
            user2</pre>

<p>Second, define a set of classes that match this yaml structure:</p>

<p><span id="prehide483182" onclick="processCodeBlocks.togglePre(483182);">Hide</span>  &nbsp; <span id="preShrink483182" onclick="processCodeBlocks.shrinkExpand(483182);">Shrink</span> <img id="preimg483182" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(483182);">  &nbsp; <span id="copycode483182" onclick="return processCodeBlocks.copyCode(483182);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre483182" processed="true"><span>@Configuration</span>
<span>@ConfigurationProperties</span>
<span>public</span> <span>class</span> FeatureFlags 
{
    <span>private</span> <span>static</span> <span>final</span> Logger log = LoggerFactory.getLogger(FeatureFlags.<span>class</span>);
    
    
    
    <span>private</span> <span>final</span> Map&lt;string, feature=<span>"</span><span>"</span>&gt; featureFlags = <span>new</span> HashMap&lt;&gt;();

    
    
    
    <span>public</span> Map&lt;string, feature=<span>"</span><span>"</span>&gt; getFeatureFlags() 
    {
        log.debug(<span>"</span><span>getFeatureFlags"</span>);
        <span>return</span> featureFlags1;
    }
    <span>private</span> <span>final</span> Map&lt;string, keygroup=<span>"</span><span>"</span>&gt; keygroups = <span>new</span> HashMap&lt;&gt;();

	
    
	
    <span>public</span> Map&lt;string, keygroup=<span>"</span><span>"</span>&gt; getKeyGroups() 
    {
        log.debug(<span>"</span><span>getKeyGroups"</span>);
        <span>return</span> keygroups;
    }
    
    <span>@Data</span>
    <span>public</span> <span>static</span> <span>class</span> Feature {
       <span>private</span> <span>String</span> enabled;
       <span>private</span> List&lt;string&gt; included;
       <span>private</span> List&lt;string&gt; excluded;
    }
    
    <span>@Data</span>
    <span>public</span> <span>static</span> <span>class</span> KeyGroup 
    {
       <span>private</span> List&lt;string&gt; keys;
    }
}</pre>

<p><strong>Remark 1</strong>: The "<code>root</code>" keys in yaml {<code>featureFlags</code>, <code>keyGroups</code>} must match the <code>{getFeatureFlags(), getKeyGroups()}</code> getters.</p>

<p><strong>Remark 2</strong>: If you just have a list of Strings to map, use this construction, with line-separated, comma-separated list (<strong>Note</strong>: Lombok generates with <code>@Data</code> the public getters/setters):</p>

<p><span id="prehide769684" onclick="processCodeBlocks.togglePre(769684);">Hide</span>  &nbsp; <span id="copycode769684" onclick="return processCodeBlocks.copyCode(769684);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre769684">List&lt;String&gt; included;

included :
    group1,
    user3 </pre>

<p><strong>Remark 3</strong>: Don't forget the <code>@ConfigurationProperties</code> above the class structure.</p>

<p><strong>Remark 4</strong>: Just <code>@autowire FeatureFlags</code> as property in a class, that will parse the yaml file to the class structure:</p>

<p><span id="prehide303704" onclick="processCodeBlocks.togglePre(303704);">Hide</span>  &nbsp; <span id="copycode303704" onclick="return processCodeBlocks.copyCode(303704);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre303704"><span>@Service</span>
<span>@ConfigurationProperties</span>
<span>public</span> <span>class</span> FeatureFlagServiceImpl <span>implements</span> FeatureFlagService
{
    <span>private</span> <span>static</span> <span>final</span> Logger log = LoggerFactory.getLogger(FeatureFlagServiceImpl.<span>class</span>);

    <span>@Autowired</span>
	
	
    
	
    <span>private</span> FeatureFlags  featureConfig; 
...
}</pre>

<p>This finalizes setting up the data structure parsing.</p>

<h3>@FeatureFlag Annotation</h3>

<p>I will not go into detail on aspect-orientation, and just give code and some remarks. See for more aspect-oriented details <a href="https://www.codeproject.com/Articles/5264376/Aspect-Oriented-Programming-and-More-Patterns-in-M">[1.]</a> For this purpose, we use LTW (Load Time Weaving) with only Spring AOP.</p>

<p>First, define the <code>@FeatureFlag</code> annotation:</p>

<p><span id="prehide989883" onclick="processCodeBlocks.togglePre(989883);">Hide</span>  &nbsp; <span id="copycode989883" onclick="return processCodeBlocks.copyCode(989883);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre989883"><span>@Target</span>(ElementType.METHOD)
<span>@Retention</span>(RetentionPolicy.RUNTIME)
<span>public</span> <span>@interface</span> FeatureFlag {
    
    
    
    <span>String</span>[] features() <span>default</span> {<span>"</span><span>"</span>};
    
    
    
    
    <span>String</span> paramNameForKeyOfFeature() <span>default</span> <span>"</span><span>"</span>;
}</pre>

<p><strong>Note 1</strong>: I did not implement the <code>@FeatureFlagKey</code>, but use the <code>FeatureFlag.paramNameForKeyOfFeature</code> as the <code>keyName</code> to lookup in the method;</p>

<p>So, define the <code>@Before @Aspect</code>:</p>

<p><span id="prehide626947" onclick="processCodeBlocks.togglePre(626947);">Hide</span>  &nbsp; <span id="preShrink626947" onclick="processCodeBlocks.shrinkExpand(626947);">Shrink</span> <img id="preimg626947" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(626947);">  &nbsp; <span id="copycode626947" onclick="return processCodeBlocks.copyCode(626947);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre626947" processed="true"><span>@Aspect</span>
<span>@Component</span>
<span>public</span> <span>class</span> FeatureFlagAspect 
{
    
    <span>private</span> <span>static</span> <span>final</span> Logger log = LoggerFactory.getLogger(FeatureAspect.<span>class</span>);
    
    
    <span>@Autowired</span>
    <span>private</span> FeatureFlagService  featureConfigService; 
    
     
    <span>@Before</span>(<span>"</span><span>@annotation(featureFlag)"</span>)
    <span>public</span> <span>void</span> featureFlag(
            <span>final</span> JoinPoint joinPoint,
            FeatureFlag featureFlag) 
                <span>throws</span> Throwable 
    {
        <span>String</span> features = Arrays.asList(featureFlag.features())
                .stream()
                .collect(Collectors.joining(<span>"</span><span>,"</span>));

        log.info(<span>"</span><span>for features {} of param {}"</span>, features, 
                  featureFlag.paramNameForKeyOfFeature());
        Method method = MethodSignature.<span>class</span>.cast(joinPoint.getSignature()).getMethod();
        log.debug(<span>"</span><span>on {}"</span>, method.getName());
        Object[] args = joinPoint.getArgs();
        MethodSignature methodSignature = 
            (MethodSignature) joinPoint.getStaticPart().getSignature();
        <span>String</span>[] paramNames = methodSignature.getParameterNames();

        Class[] paramTypes= methodSignature.getParameterTypes();
        <span>String</span> curKey = null;
        Model modelParam = null;
        ModelAndView modelAndViewParam = null;
        <span>for</span> (<span>int</span> argIndex = <span>0</span>; argIndex &lt; args.length; argIndex++)
        {
            <span>String</span> curParamName = paramNames[argIndex];

            Object curValue = args[argIndex];

            <span>if</span> (curParamName.equals(featureFlag.paramNameForKeyOfFeature()))
            {
                curKey = curValue.toString();
            }
            log.debug(<span>"</span><span>arg {} value {}"</span>, curParamName, curValue);

            <span>if</span> (curValue <span>instanceof</span> Model)
            {
                modelParam = (Model)curValue;
            }
            <span>else</span> <span>if</span> (curValue <span>instanceof</span> ModelAndView)
            {
                modelAndViewParam = (ModelAndView)curValue;
            }
        }
        <span>if</span> (curKey != null)
        {
            <span>for</span>(<span>String</span> featureName : featureFlag.features())
            {
                nl.ricta.featureflag.FeatureFlags.Feature curFeature = 
                    featureConfigService.getFeature(curKey.toString(), featureName);
                <span>if</span> (curFeature != null )
                {
                    <span>if</span> (modelParam != null)
                    {
                        modelParam.addAttribute(featureName, curFeature);
                    }
                     <span>if</span> (modelAndViewParam != null)
                    {
                        modelAndViewParam.addObject(featureName, curFeature);
                    }
                }
            }
        }
    }</pre>

<p><strong>Note 2</strong>: There is logic defined in the <code>FeatureFlagService.getFeature()</code>, that is called from the aspect, that does the lookup in the <code>FeatureFlags</code> model, of the <code>Feature</code> and its properties:</p>

<p><span id="prehide101208" onclick="processCodeBlocks.togglePre(101208);">Hide</span>  &nbsp; <span id="preShrink101208" onclick="processCodeBlocks.shrinkExpand(101208);">Shrink</span> <img id="preimg101208" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(101208);">  &nbsp; <span id="copycode101208" onclick="return processCodeBlocks.copyCode(101208);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre101208" processed="true"><span>@Service</span>
<span>@ConfigurationProperties</span>
<span>public</span> <span>class</span> FeatureFlagServiceImpl <span>implements</span> FeatureFlagService
{
    <span>private</span> <span>static</span> <span>final</span> Logger log = LoggerFactory.getLogger(FeatureFlagServiceImpl.<span>class</span>);

    <span>private</span> FeatureFlags  featureConfig;  

    <span>@Autowired</span>
    <span>public</span> FeatureFlagServiceImpl(FeatureFlags  featureConfig)
    {
        log.debug(<span>"</span><span>FeatureFlagServiceImpl : #features = {}"</span>, 
                   featureConfig.getFeatureFlags().size());
        <span>this</span>.featureConfig = featureConfig;
    }
    
    <span>public</span> Map&lt;string, feature=<span>"</span><span>"</span>&gt; getFeatureFlags() 
    {
        <span>return</span> <span>this</span>.featureConfig.getFeatureFlags();
    }
    
	<span>public</span> Feature getFeature(<span>String</span> forKey, <span>String</span> forFeatureName)
    {
        require(featureConfig != null);
        require(forKey != null);
        require(forFeatureName != null);
        log.debug(<span>"</span><span>getFeature, forkey={}, forFeatureName={}"</span>, forKey, forFeatureName);
        Feature lookupFeature = featureConfig.getFeatureFlags().get(forFeatureName);
        <span>if</span> (lookupFeature == null)
        {
            log.debug(<span>"</span><span>forkey={} has no feature {}"</span>,forKey, forFeatureName);
            <span>return</span> null;
        }
        <span>if</span> (lookupFeature.getEnabled()==<span>"</span><span>true"</span>)
        {
            log.debug(<span>"</span><span>forkey={} enabled feature for everyone {}"</span>,forKey, forFeatureName);
            <span>return</span> lookupFeature;
        }
        <span>else</span> <span>if</span> (lookupFeature.getEnabled()==<span>"</span><span>false"</span>)
        {
            log.debug(<span>"</span><span>forkey={} enable feature for none {}"</span>,forKey, forFeatureName);
            <span>return</span> null;
        }
        
        List&lt;string&gt; includedInFeaureList = lookupFeature.getIncluded();
        <span>boolean</span> direct = includedInFeaureList.contains(forKey);
        <span>if</span> (direct)
        {
            log.debug(<span>"</span><span>forkey={} directly has feature {}"</span>,forKey, forFeatureName);
            <span>return</span> lookupFeature;
        }
        log.debug(<span>"</span><span>looking up all included keys in keygroups, 
                   to see if key={} is included there..."</span>);
        
        <span>for</span> (<span>String</span> included : includedInFeaureList)
        {
            log.debug(<span>"</span><span>lookup group for {}"</span>, included);
            KeyGroup lookupGroup = featureConfig.getKeyGroups().get(included);
            <span>if</span> (lookupGroup == null)
            {
                log.debug(<span>"</span><span>forkey={} has no feature {}"</span>,forKey, forFeatureName);
            }
            <span>else</span>
            {
                <span>boolean</span> inGroup = lookupGroup.getKeys().contains(forKey);
                <span>if</span> (inGroup)
                {
                    log.debug(<span>"</span><span>forkey={} has feature {}"</span>,forKey, forFeatureName);
                    <span>return</span> lookupFeature;
                }
            }
        }
        log.debug(<span>"</span><span>forkey={} has no feature {}"</span>,forKey, forFeatureName);
        <span>return</span> null;
    }
}</pre>

<p>Now, we are set for the MVC and Controller part:</p>

<p><span id="prehide766833" onclick="processCodeBlocks.togglePre(766833);">Hide</span>  &nbsp; <span id="copycode766833" onclick="return processCodeBlocks.copyCode(766833);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre766833"><span>@FeatureFlag</span>(features = <span>"</span><span>{feature1}"</span>, paramNameForKeyOfFeature = <span>"</span><span>user"</span>)
<span>@GetMapping</span>(value = <span>"</span><span>/features"</span>)
<span>public</span> <span>String</span> featuresPage(Model model, <span>@RequestParam</span>(value = <span>"</span><span>user"</span>) <span>String</span> user) {
	model.addAttribute(<span>"</span><span>featureEntries"</span>, featureFlagService.getFeatureFlags().entrySet());
	<span>return</span> <span>"</span><span>featureflags/features"</span>;
}</pre>

<p>And, the view html <em>Features.cshtml</em> with <code>Thymeleaf</code>:</p>

<p><span id="prehide586143" onclick="processCodeBlocks.togglePre(586143);">Hide</span>  &nbsp; <span id="preShrink586143" onclick="processCodeBlocks.shrinkExpand(586143);">Shrink</span> <img id="preimg586143" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(586143);">  &nbsp; <span id="copycode586143" onclick="return processCodeBlocks.copyCode(586143);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre586143" processed="true">...
&lt;div class=<span>"</span><span>main"</span>&gt;
&lt;div&gt;
	&lt;h2&gt;Features&lt;/h2&gt;
	&lt;div class=<span>'</span><span>rTable'</span> &gt;
		&lt;div class=<span>"</span><span>rTableRow"</span>&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Type&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Included&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Excluded&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt; 
		&lt;div class=<span>'</span><span>rTableRow'</span> th:each=<span>"</span><span>featureEntry : ${featureEntries}"</span>&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getKey()}"</span>&gt;&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getEnabled()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getIncluded()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getExcluded()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=<span>"</span><span>rTableRow"</span>&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Type&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Included&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Excluded&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt; 
	&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
	&lt;h2&gt;Features&lt;/h2&gt;
	&lt;div class=<span>'</span><span>rTable'</span> &gt;
		&lt;div class=<span>"</span><span>rTableRow"</span>&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Type&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Included&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Excluded&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt; 
		&lt;div class=<span>'</span><span>rTableRow'</span> th:each=<span>"</span><span>featureEntry : ${featureEntries}"</span>&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getKey()}"</span>&gt;&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getEnabled()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getIncluded()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>'</span><span>rTableCell'</span>&gt;&lt;span th:text=<span>"</span><span>${featureEntry.getValue().getExcluded()}"</span>&gt;
            &lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=<span>"</span><span>rTableRow"</span>&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Type&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableHead"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Included&lt;/span&gt;&lt;/div&gt;
			&lt;div class=<span>"</span><span>rTableFoot"</span>&gt;&lt;span style=<span>"</span><span>font-weight: bold;"</span>&gt;Excluded&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt; 
	&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
...</pre>

<h2>C# DotNet Implementation Details (C# 7, .NET Core 2.1 MVC, Razor, AutoFac, Castle Core, AutoFac Dynamic Proxy)</h2>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/DemoApp.png" data-src="/KB/architecture/5265400/DemoApp.png" data-sizes="auto" data-srcset="/KB/architecture/5265400/DemoApp-r-400.png 400w, /KB/architecture/5265400/DemoApp.png 520w" srcset="/KB/architecture/5265400/DemoApp-r-400.png 400w, /KB/architecture/5265400/DemoApp.png 520w"></p>

<h3>Data Structure to Hold Feature Config</h3>

<p>Remember, this was the model:</p>

<p><img alt="Sample Image - maximum width is 600 pixels" src="https://www.codeproject.com/KB/architecture/5265400/FeatureFlag_Model.png" data-src="/KB/architecture/5265400/FeatureFlag_Model.png" data-sizes="auto" data-srcset="/KB/architecture/5265400/FeatureFlag_Model-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Model.png 640w" srcset="/KB/architecture/5265400/FeatureFlag_Model-r-400.png 400w, /KB/architecture/5265400/FeatureFlag_Model.png 640w"></p>

<p>First, implement the configuration in a json format (<em>featureFlagConfig.json</em>) structure according to this model:</p>

<p><span id="prehide659753" onclick="processCodeBlocks.togglePre(659753);">Hide</span>  &nbsp; <span id="copycode659753" onclick="return processCodeBlocks.copyCode(659753);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre659753">{
	<span>"</span><span>features"</span>: [
		{
			<span>"</span><span>name"</span>: <span>"</span><span>feature1"</span>,
			<span>"</span><span>type"</span>: <span>"</span><span>enabled"</span>,
			<span>"</span><span>included"</span>: [
				<span>"</span><span>group1"</span>,
				<span>"</span><span>user3"</span>
			],
			<span>"</span><span>excluded"</span>: [
				<span>"</span><span>user4"</span>
			]
		}
	],
	<span>"</span><span>keyGroups"</span>: [
		{
			<span>"</span><span>Name"</span>: <span>"</span><span>feature1"</span>,
			<span>"</span><span>keys"</span>: [
				<span>"</span><span>user1"</span>,
				<span>"</span><span>user2"</span>
			]
		}
	]
}</pre>

<p>Next, define the class structure model to hold the <code>Feature</code> configuration data:</p>

<p><span id="prehide970545" onclick="processCodeBlocks.togglePre(970545);">Hide</span>  &nbsp; <span id="copycode970545" onclick="return processCodeBlocks.copyCode(970545);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre970545"><span>public</span> <span>enum</span> FeatureType
{
	enabled, 
	disabled,
	filtered
}

<span>public</span> <span>class</span> Feature
{
	<span>public</span> string name { get; set; }
	<span>public</span> FeatureType type { get; set; }
	<span>public</span> List&lt;string&gt; included { get; set; }
	<span>public</span> List&lt;string&gt; excluded { get; set; }
}
<span>public</span> <span>class</span> KeyGroup
{
	<span>public</span> string name { get; set; }
	<span>public</span> List&lt;string&gt; keys { get; set; }
}
<span>public</span> <span>class</span> FeatureFlags
{
	<span>public</span> Dictionary&lt;string, feature=<span>"</span><span>"</span>&gt; features { get; set; }
	<span>public</span> Dictionary&lt;string, keygroup=<span>"</span><span>"</span>&gt; keyGroups { get; set; }
}</pre>

<p>Next, to load this configuration json into the model, I used the .NET <code>ConfigurationBuilder</code>:</p>

<p><span id="prehide341943" onclick="processCodeBlocks.togglePre(341943);">Hide</span>  &nbsp; <span id="copycode341943" onclick="return processCodeBlocks.copyCode(341943);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre341943">ConfigurationBuilder configurationBuilder = <span>new</span> ConfigurationBuilder();
configurationBuilder.AddJsonFile
       (<span>"</span><span>featureFlagConfig.json"</span>, optional: true, reloadOnChange: true);

IConfigurationRoot config = configurationBuilder.Build();

var sectionFeatureFlags = config.GetSection(<span>"</span><span>features"</span>);
List&lt;Feature&gt; features = sectionFeatureFlags.Get&lt;List&lt;Feature&gt;&gt;();

var sectionKeyGroups = config.GetSection(<span>"</span><span>keyGroups"</span>);
List&lt;KeyGroup&gt; keyGroups = sectionKeyGroups.Get&lt;List&lt;KeyGroup&gt;&gt;();

FeatureFlags featureFlags = <span>new</span> FeatureFlags()
{
	features = features.ToDictionary(f =&gt; f.name, f =&gt; f),
	keyGroups = keyGroups.ToDictionary(kg =&gt; kg.name, kg =&gt; kg),
};</pre>

<p>We also need a service, that defines the logic on the feature flag model:</p>

<p><span id="prehide603347" onclick="processCodeBlocks.togglePre(603347);">Hide</span>  &nbsp; <span id="preShrink603347" onclick="processCodeBlocks.shrinkExpand(603347);">Shrink</span> <img id="preimg603347" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(603347);">  &nbsp; <span id="copycode603347" onclick="return processCodeBlocks.copyCode(603347);">Copy Code</span></p><pre lang="Java" data-lang-orig="Java" id="pre603347" processed="true"><span>public</span> <span>interface</span> FeatureFlagService
{
	FeatureFlags FeatureConfig { get; set; }
	<span>void</span> LoadFeatureFlags(<span>String</span> fileName);
	Feature getFeature(<span>String</span> forKey, <span>String</span> forFeatureName);
	List&lt;Feature&gt; getFeatures(<span>String</span> forKey, List&lt;String&gt; forFeatureNames);
}
<span>public</span> <span>class</span> FeatureFlagServiceImpl : FeatureFlagService
{
	<span>public</span> FeatureFlags FeatureConfig { get; set; }

	
	
	
	
	<span>public</span> virtual <span>void</span> LoadFeatureFlags(<span>String</span> fileName)
	{
		ConfigurationBuilder configurationBuilder = <span>new</span> ConfigurationBuilder();
		configurationBuilder.AddJsonFile(fileName, optional: true, reloadOnChange: true);

		IConfigurationRoot config = configurationBuilder.Build();

		var sectionFeatureFlags = config.GetSection(<span>"</span><span>features"</span>);
		List&lt;Feature&gt; features = sectionFeatureFlags.Get&lt;List&lt;Feature&gt;&gt;();

		var sectionKeyGroups = config.GetSection(<span>"</span><span>keyGroups"</span>);
		List&lt;KeyGroup&gt; keyGroups = sectionKeyGroups.Get&lt;List&lt;KeyGroup&gt;&gt;();

		<span>this</span>.FeatureConfig = <span>new</span> FeatureFlags()
		{
			features = features.ToDictionary(f =&gt; f.name, f =&gt; f),
			keyGroups = keyGroups.ToDictionary(kg =&gt; kg.name, kg =&gt; kg),
		};
	}

	
	
	
	
	
	
	<span>public</span> virtual List&lt;Feature&gt; getFeatures(<span>String</span> forKey, List&lt;String&gt; forFeatureNames)
	{
		var features = <span>new</span> List&lt;Feature&gt;();
		foreach(var featureName in forFeatureNames)
		{
			Feature f = getFeature(forKey, featureName);
			<span>if</span> (f != null)
			{
				features.Add(f);
			}
		}
		<span>return</span> features;
	}
	
	
	
	
	
	
	
	<span>public</span> virtual Feature getFeature(<span>String</span> forKey, <span>String</span> forFeatureName)
	{
		Debug.WriteLine($<span>"</span><span>getFeature, forkey={forKey}, forFeatureName={forFeatureName}"</span>);

		FeatureConfig.features.TryGetValue(forFeatureName, out Feature lookupFeature);
		<span>if</span> (lookupFeature == null)
		{
			Debug.WriteLine($<span>"</span><span>forkey={forKey} has no feature {forFeatureName}"</span>);
			<span>return</span> null;
		}
		<span>if</span> (lookupFeature.type == FeatureType.enabled)
		{
			Debug.WriteLine($<span>"</span><span>forkey={forKey} enabled feature for everyone {forFeatureName}"</span>);
			<span>return</span> lookupFeature;
		}
		<span>else</span> <span>if</span> (lookupFeature.type == FeatureType.disabled)
		{
			Debug.WriteLine($<span>"</span><span>forkey={forKey} enable feature for none {forFeatureName}"</span>);
			<span>return</span> null;
		}
		
		List&lt;String&gt; includedInFeaureList = lookupFeature.included;
		Boolean direct = includedInFeaureList.Contains(forKey);
		<span>if</span> (direct)
		{
			Debug.WriteLine($<span>"</span><span>forkey={forKey} directly has feature {forFeatureName}"</span>);
			<span>return</span> lookupFeature;
		}
		Debug.WriteLine($<span>"</span><span>looking up all included keys in keygroups, 
                        to see if key={forKey} is included there..."</span>);

		foreach (<span>String</span> included in includedInFeaureList)
		{
			Debug.WriteLine($<span>"</span><span>lookup group for {included}"</span>);
		   
			FeatureConfig.keyGroups.TryGetValue(included, out KeyGroup lookupGroup);
			<span>if</span> (lookupGroup == null)
			{
				Debug.WriteLine($<span>"</span><span>forkey={forKey} has no feature {forFeatureName}"</span>);
			}
			<span>else</span>
			{
				Boolean inGroup = lookupGroup.keys.Contains(forKey);
				<span>if</span> (inGroup)
				{
					Debug.WriteLine($<span>"</span><span>forkey={forKey} has feature {forFeatureName}"</span>);
					<span>return</span> lookupFeature;
				}
			}
		}
		Debug.WriteLine($<span>"</span><span>forkey={forKey} has no feature {forFeatureName}"</span>);
		<span>return</span> null;
	}
}</pre>

<p>That finalizes setting up the data structure, feature flag logic and the parsing in C#. As promised simple, in approximately 50 lines of code.</p>

<h3>C# [FeatureFlag] Annotation</h3>

<p>We begin (again see <a href="https://www.codeproject.com/Articles/5264376/Aspect-Oriented-Programming-and-More-Patterns-in-M">[1.] Aspect-Oriented Programming and More Patterns in Micro-Services</a>) with defining the <code>FeatureFlag</code> attributes:</p>

<p><span id="prehide827002" onclick="processCodeBlocks.togglePre(827002);">Hide</span>  &nbsp; <span id="copycode827002" onclick="return processCodeBlocks.copyCode(827002);">Copy Code</span></p><pre lang="cs" data-lang-orig="cs" id="pre827002"> [AttributeUsage(
   AttributeTargets.Method,
   AllowMultiple = <span>true</span>)]
<span>public</span> <span>class</span> FeatureFlagAttribute : System.Attribute
{
	<span>public</span> FeatureFlagAttribute(<span>String</span> keyName, <span>string</span>[] features)
	{
		Features = features.ToList();
		KeyName = keyName;
	}
	<span>public</span> List&lt;string&gt; Features { <span>get</span>; <span>set</span>; } = <span>new</span> List&lt;string&gt;();
	<span>public</span> <span>String</span> KeyName { <span>get</span>; <span>set</span>; } = <span>"</span><span>"</span>;
}</pre>

<p>Then, we define the aspect (interceptor) on this annotation:</p>

<p><span id="prehide428303" onclick="processCodeBlocks.togglePre(428303);">Hide</span>  &nbsp; <span id="preShrink428303" onclick="processCodeBlocks.shrinkExpand(428303);">Shrink</span> <img id="preimg428303" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(428303);">  &nbsp; <span id="copycode428303" onclick="return processCodeBlocks.copyCode(428303);">Copy Code</span></p><pre lang="cs" data-lang-orig="cs" id="pre428303" processed="true"><span>public</span> <span>class</span> FeatureFlagIntersceptor : Castle.DynamicProxy.IInterceptor
{
	<span>public</span> FeatureFlagService featureFlagService { <span>get</span>; <span>set</span>; }

	<span>public</span> <span>void</span> Intercept(Castle.DynamicProxy.IInvocation invocation)
	{
		Debug.Print($<span>"</span><span>1. @Before Method called {invocation.Method.Name}"</span>);

		<span>var</span> methodAttributes = invocation.Method.GetCustomAttributes(<span>false</span>);
		FeatureFlagAttribute theFeatureFlag = (FeatureFlagAttribute)methodAttributes.Where
		(a =<span>&gt;</span> a.GetType() == <span>typeof</span>(FeatureFlagAttribute)).SingleOrDefault();
	
		<span>if</span> (theFeatureFlag != <span>null</span>)
		{
			<span>var</span> paramNameForKeyOfFeature = theFeatureFlag.ParamNameForKeyOfFeature;
			ParameterInfo[] paramsOfMethod = invocation.Method.GetParameters();
			
			
			
			<span>int</span> iParam;
			<span>for</span> (iParam = <span>0</span>; iParam <span>&lt;</span> paramsOfMethod.Count(); iParam++)
			{
				ParameterInfo p = paramsOfMethod[iParam];
				<span>if</span> (p.Name.CompareTo(paramNameForKeyOfFeature) == <span>0</span>)
				{
					<span>break</span>;
				}
			}
			
			
			
			<span>string</span> <span>value</span> = (<span>string</span>)invocation.Arguments[iParam];
			List&lt;feature&gt; features = featureFlagService.getFeatures
&nbsp;                                    (<span>value</span>, theFeatureFlag.Features);
			Debug.Print($<span>"</span><span>2. FeatureFlagAttribute on method found with name = 
                       {theFeatureFlag.Features}
"</span>);
			<span>foreach</span>(Feature f <span>in</span> features)
			{
				Debug.Print($<span>"</span><span>3. Feature {f.name} exists and type = {f.type}"</span>);
			}
		}
		
		
		
		
		invocation.Proceed();
		
		
		
		Debug.Print($<span>"</span><span>5. @After method: {invocation.Method.Name}
"</span>);
	}
}</pre>

<p>And, since we need the <code>FeatureFlag</code> in a REST controller to supply the feature properties to the Razor <code>ViewModel</code> and HTML GUI, we also need the REST controller solution for aspect-orientation, where attribute and aspect are combined in one <code>ActionFilterAttribute</code> class:</p>

<p><span id="prehide866364" onclick="processCodeBlocks.togglePre(866364);">Hide</span>  &nbsp; <span id="preShrink866364" onclick="processCodeBlocks.shrinkExpand(866364);">Shrink</span> <img id="preimg866364" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(866364);">  &nbsp; <span id="copycode866364" onclick="return processCodeBlocks.copyCode(866364);">Copy Code</span></p><pre lang="cs" data-lang-orig="cs" id="pre866364" processed="true"><span>public</span> <span>class</span> FeatureFlagActionAtrribute : 
    Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute
    {
		<span>public</span> List&lt;string&gt; Features { <span>get</span>; <span>set</span>; } = <span>new</span> List&lt;string&gt;();
        <span>public</span> <span>String</span> KeyName { <span>get</span>; <span>set</span>; } = <span>"</span><span>"</span>;
		<span>public</span> <span>override</span> <span>void</span> OnActionExecuting
                (Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext context)
		{
			ControllerActionDescriptor actionDescriptor = 
                   (ControllerActionDescriptor)context.ActionDescriptor;
            Debug.Print($<span>"</span><span>2. @Before Method called 
               {actionDescriptor.ControllerName}Controller.{actionDescriptor.ActionName}"</span>);
            <span>var</span> controllerName = actionDescriptor.ControllerName;
            <span>var</span> actionName = actionDescriptor.ActionName;
            IDictionary&lt;object, <span>object</span>=<span>"</span><span>"</span><span>&gt;</span> properties = actionDescriptor.Properties;
            ParameterInfo[] paramsOfMethod = actionDescriptor.MethodInfo.GetParameters();
            <span>var</span> fullName = actionDescriptor.DisplayName;

            <span>var</span> paramNameForKeyOfFeature = ParamNameForKeyOfFeature;

            <span>var</span> arguments = context.ActionArguments;
            <span>string</span> <span>value</span> = (<span>string</span>)arguments[paramNameForKeyOfFeature];
            
            <span>using</span> (ILifetimeScope scope = BootStrapper.Container.BeginLifetimeScope())
            {
                <span>var</span> featureFlagService = scope.Resolve&lt;featureflagservice&gt;();
                List&lt;feature&gt; features = featureFlagService.getFeatures(<span>value</span>, Features);
                Debug.Print($<span>"</span><span>2. 
                    FeatureFlagAttribute on method found with name = {Features}
"</span>);
                <span>var</span> ctrler = (Controller)context.Controller;
                <span>foreach</span> (Feature f <span>in</span> features)
                {
                    Debug.Print($<span>"</span><span>3. Feature {f.name} exists and type = {f.type}"</span>);
                    ctrler.ViewData[f.name] = f;
                }
                ctrler.ViewData[<span>"</span><span>features"</span>] = 
                      featureFlagService.FeatureConfig.features.Values;
            }
            
            <span>base</span>.OnActionExecuting(context);
        }
		<span>public</span> <span>override</span> <span>void</span> OnActionExecuted
               (Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext context)
        {...}
	}</pre>

<p>Now, let's connect it all together, in a real life controller like we started in the article:</p>

<p><span id="prehide867412" onclick="processCodeBlocks.togglePre(867412);">Hide</span>  &nbsp; <span id="copycode867412" onclick="return processCodeBlocks.copyCode(867412);">Copy Code</span></p><pre lang="cs" data-lang-orig="cs" id="pre867412">[FeatureFlagActionAtrribute(<span>"</span><span>user"</span>, <span>new</span> <span>String</span>[] { <span>"</span><span>feature1"</span> })]
<span>public</span> IActionResult DoSomethingWithFilterAction(<span>String</span> user)
{
	Debug.Assert(ViewData[<span>"</span><span>Features"</span>] != <span>null</span>);
	Debug.Assert(ViewData[<span>"</span><span>feature1"</span>] != <span>null</span>);
	<span>return</span> View(<span>"</span><span>Features"</span>);
}</pre>

<p>And, the view html <em>Features.cshtml</em> with Razor:</p>

<p><span id="prehide18055" onclick="processCodeBlocks.togglePre(18055);">Hide</span>  &nbsp; <span id="copycode18055" onclick="return processCodeBlocks.copyCode(18055);">Copy Code</span></p><pre lang="html" data-lang-orig="html" id="pre18055">...
<span>&lt;</span><span>table</span><span>&gt;</span>
	<span>&lt;</span><span>tr</span><span>&gt;</span>
		<span>&lt;</span><span>th</span><span>&gt;</span>enabled for user<span>&lt;</span><span>/th</span><span>&gt;</span>
		<span>&lt;</span><span>th</span><span>&gt;</span>type<span>&lt;</span><span>/th</span><span>&gt;</span>
		<span>&lt;</span><span>th</span><span>&gt;</span>included<span>&lt;</span><span>/th</span><span>&gt;</span>
		<span>&lt;</span><span>th</span><span>&gt;</span>excluded<span>&lt;</span><span>/th</span><span>&gt;</span>
	<span>&lt;</span><span>/tr</span><span>&gt;</span>
	@foreach (var feature in ViewData["Features"] 
&nbsp;             as IEnumerable<span>&lt;</span><span>nl.ricta.featureflag.Feature</span><span>&gt;</span>)
	{
		<span>&lt;</span><span>tr</span><span>&gt;</span>
			<span>&lt;</span><span>td</span><span>&gt;</span>@feature.name <span>&lt;</span><span>input</span><span> </span><span>type</span><span>="</span><span>checkbox"</span><span> </span><span>checked</span><span>=</span><span>@ViewData[feature.name]</span><span>&gt;</span><span>&lt;</span><span>/td</span><span>&gt;</span>
			<span>&lt;</span><span>td</span><span>&gt;</span>@feature.type<span>&lt;</span><span>/td</span><span>&gt;</span>
			<span>&lt;</span><span>td</span><span>&gt;</span>@(string.Join(",", @feature.included));<span>&lt;</span><span>/td</span><span>&gt;</span>
			<span>&lt;</span><span>td</span><span>&gt;</span>@(string.Join(",", @feature.excluded));<span>&lt;</span><span>/td</span><span>&gt;</span>
		<span>&lt;</span><span>/tr</span><span>&gt;</span>
	}
<span>&lt;</span><span>/table</span><span>&gt;</span>
...</pre>

<p><strong>Note 1</strong>: A feature checkbox is "checked" in the view, if the <code>FeatureFlagActionAtrribute</code> feature name for that user value is "checked", so either enabled,&nbsp;or filtered and user value is in included list</p>

<p><strong>Note 2</strong>: I use autofac as IOC container. I'll write another article on IOC, and add it to the referenced articles in due time. I enabled autofac module registration and the feature flag loading via the (singleton) <code>FeatureFlagService</code> in <code>Startup</code>:</p>

<p><span id="prehide673570" onclick="processCodeBlocks.togglePre(673570);">Hide</span>  &nbsp; <span id="copycode673570" onclick="return processCodeBlocks.copyCode(673570);">Copy Code</span></p><pre lang="cs" data-lang-orig="cs" id="pre673570"><span>public</span> <span>void</span> ConfigureServices(IServiceCollection services)
{
	<span>var</span> builder = <span>new</span> ContainerBuilder();
	builder.RegisterModule(<span>new</span> FeatureFlagModule());
	BootStrapper.BuildContainer(builder);
	<span>using</span> (<span>var</span> scope = BootStrapper.Container.BeginLifetimeScope())
	{
		FeatureFlagService featureFlagService = scope.Resolve&lt;featureflagservice&gt;();
		featureFlagService.LoadFeatureFlags(<span>"</span><span>featureFlagConfig.json"</span>);
	}
	...
}</pre>

<h2>Conclusion and Points of Interest</h2>

<h3>What Did We Learn in this Article?</h3>

<ul>
	<li>Feature flagging allows for earlier release of functionality</li>	<li>Feature flagging separates deployment from releasing functionality</li>	<li>Defining and implementing the model is relatively easy, in a simple Feature flag model in a re-usable binary library, in a simple file format (<em>.json</em>, <em>.yaml</em>)</li>	<li>Defining and implementing the logic is relatively easy, with a simple Feature flag logic service in a re-usable binary library</li>	<li>Using aspect-oriented Feature flagging in the Apps, is basically one or two lines of code and a bit of config data, and we added a <code>FeatureFlag</code> (when all library plumbing is in place)</li>	<li>Resulting in a simple ViewModel feature flags where we can react on, within the MVC HTML taglibrarys (Razor, Thymeleaf, ...) in the HTML view.</li></ul>

<p>As mentioned, in a clustered, loadbalanced environment, the above solution is not the best implementation(or, just plain bad and unworkable). A remote central feature flag service would be the way to go then. What needs to be added/changed in the model above? Basically, you need to adjust one piece of implementation: loading the model from that remote service, instead of via a file. That's well within a day of work. And move the model loading to a central feature flag micro-service. Okay, another day or two of work.</p>

<h3>Strategies for Feature Flagging: Do's and Dont's</h3>

<p>I also promised a pattern or strategy for applying Feature flagging in such a way, that the feature flag administration overhead and code clutter-up does not become too big a burden.</p>

<h4>Do's</h4>

<p>Actually, there are three patterns/strategies you should all apply:</p>

<ol>
	<li>Only put a feature behind a feature flag if:
	<ol type="a">
		<li>some technical stability issues are to be expected when the feature is on</li>		<li>some business and/or usability issues are to be expected when the feature is on</li>		<li>you want (permanently) to dis/allow a subset of users to some feature</li>	</ol>
	</li>	<li>Remove feature flags as soon as possible in the code (mostly, when everyone has access and the feature is proven stable and usable)</li>	<li>Remove features from the code that were proven unusable for everyone.</li></ol>

<p>In other words: put a feature only behind a flag if there is a very, very good reason, and then and only then; And remove it as soon as the reason is gone.</p>

<h4><b>Dont's</b></h4>

<p>And one strategy you should not apply:</p>

<p>Put everything behind a flag without good reason and let it stay there forever.</p>

<p>The "better save than sorry flagging" habit is a common mistake all too often made when using feature flagging, which usually comes from several "abusive" reasons:</p>

<ul>
	<li>Nobody takes responsibility for decisions of whether a flag is needed or not, resulting in "better save than sorry flagging": developers put all new functionality behind a flag by default: "you never know.."</li>	<li>"Quality excuse flagging": Quality of all features and code it so bad, that everything is put behind a flag, so you can always disable it if proven too bad.</li>	<li>"Hide bad unusable functionality behind a flag": Features that were proven not usable are not removed from the code, but stay disabled behind a flag for ever, for everyone.</li></ul>

<p>If you apply this very bad strategy, both feature flag administration overhead, and flagging code, will become such a burden and source of agony and pain with issues, bugs and degraded testability and usability, that it will very soon become unworkable.</p>

<h3>Conclusion</h3>

<p>Feature flagging can be implemented simple, and when used properly, allows for (much) faster and smoother releasing of features.</p>

<p><b>Please do!</b></p>

<p>But if feature flagging is abused for purposes it was not meant to be, it can lead to mayhem, serious agony, pain and sorrow. It will lead to degraded code, degraded testability, degraded usability and terrible quality.</p>

<p><b>Don't do that please?</b></p>

<h2>History</h2>

<ul>
	<li>16<sup>th</sup> April, 2020: Initial version</li></ul>


						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>