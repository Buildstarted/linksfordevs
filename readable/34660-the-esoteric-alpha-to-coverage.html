<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Esoteric Alpha To Coverage -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>The Esoteric Alpha To Coverage</h1><div><div class="ac ae af ag ah cz aj ak"><h2 id="41c7" class="ha gp dc bk bj gq hb hc hd he hf hg hh hi hj hk hl">This One Simple Trick …</h2><p id="88e6" class="fm fn dc bk fo b fp hm fr hn ft ho fv hp fx hq fz cu">Alpha to Coverage (sometimes referred to as A2C or ATOC) is a less commonly mentioned graphics technique. While used by several big games, it is seemingly unknown to the vast majority of smaller devs. It’s a powerful tool that is often overlooked due to the requirement of MSAA. Games often treat MSAA as an expensive option for high end PCs. Or they’ve used rendering techniques that don’t allow for easy use of MSAA to begin with, like deferred rendering. The result is games have overwhelmingly preferred post process anti-aliasing like <a href="https://en.wikipedia.org/wiki/Fast_approximate_anti-aliasing" class="at cg ga gb gc gd" target="_blank" rel="noopener nofollow">FXAA</a>. This made Alpha to Coverage even more uncommon for a while. But the rise of VR has lead to the resurgence of forward rendering and of MSAA. This means A2C has become a useful tool again, especially for VR.</p><p id="5109" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Anti-aliased alpha test is one of the most basic use cases for Alpha to Coverage. The basic idea for this has been around for as long as A2C has existed. It may even have been the original intended use for it. The first time I saw this idea was on Emil Persson’s (better known to many as Humus) site <a href="http://www.humus.name/index.php?page=3D&amp;ID=61" class="at cg ga gb gc gd" target="_blank" rel="noopener nofollow">here</a>. I believe the method in this article is superior to the one used in his original demo.</p><h2 id="d276" class="ha gp dc bk bj gq hb hc hd he hf hg hh hi hj hk hl">Multi Sample Anti-Aliasing</h2><p id="15f0" class="fm fn dc bk fo b fp hm fr hn ft ho fv hp fx hq fz cu">Before we get into that though, I’m going to quickly run down what Alpha to Coverage <em class="il">is</em> and why MSAA is a requirement.</p><p id="168b" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Alpha to Coverage maps the alpha output from a pixel shader to the coverage mask of MSAA. Obvious, right?!</p><p id="466c" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Okay, that’s going to take a little more explanation. Be warned, I’m going to get into some of the gritty details here.</p><p id="9336" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">The big trick with MSAA and how it differs from super sampling is what Multi Sample Anti-Aliasing is doing multiple samples <em class="il">of</em>. Super sampling at its most basic is rendering <em class="il">everything </em>at a higher resolution. The final on screen image is a scaled down average of this higher resolution render. MSAA renders the color at the same resolution as the target resolution, but multiple <em class="il">coverage </em>samples per pixel. In simpler terms it’s rendering the depth of the scene at a higher resolution than the target resolution. Each rendered triangle’s depth samples are its coverage. If you’re using 4x MSAA it’s rendering 4 depth / coverage samples within the bounds of each pixel. Each coverage sample can store a unique color. But it’s only getting a color by running the pixel shader once <em class="il">per triangle</em>, per pixel. Most of time all 4 depth samples will be the same triangle. In this case all 4 coverage samples use the same single pixel shader output color. This behaves no different than when having no MSAA enabled at all.</p><p id="ab3f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Where MSAA’s strength comes into play is when a triangle doesn’t cover all the depth samples. For example, if a triangle only covers two depth samples the two matching coverage samples are set to the pixel shader ouput. The other coverage samples can store the color of other triangles’s pixel shaders that can be seen.</p><figure class="hs ht hu hv hw hx cl cm paragraph-image"><figcaption class="bo eg it iu gi cn cl cm iv iw bj ef">from <a href="https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/" class="at cg ga gb gc gd" target="_blank" rel="noopener nofollow">https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/</a></figcaption></figure><p id="c5ed" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">More in depth write ups can be found elsewhere, like on Matt Pettineo’s (MJP) site.</p><p id="ee59" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><a href="https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/" class="at cg ga gb gc gd" target="_blank" rel="noopener nofollow">https://mynameismjp.wordpress.com/2012/10/24/msaa-overview/</a></p><p id="9edd" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">I’m glossing over a bunch of details, but the main point is MSAA can store a list of multiple colors per pixel, one color per coverage sample. These get averaged together to make the final on screen pixel color. But it’s not always having to render a pixel shader more than once per pixel resulting in significant savings over super sampling of similar quality.</p><h2 id="1606" class="ha gp dc bk bj gq hb hc hd he hf hg hh hi hj hk hl">Alpha to Coverage</h2><p id="dec4" class="fm fn dc bk fo b fp hm fr hn ft ho fv hp fx hq fz cu">This is where Alpha to Coverage comes in. Alpha to Coverage let’s the pixel shader’s output alpha change the fraction of coverage samples rendered to. Hence the name. In the simple case of a triangle covering all 4 depth samples, all 4 coverage samples store the color output. With Alpha to Coverage enabled and an output color alpha of 0.5, only half of the possible coverage samples will store the color. The result will be as if it’s half<a href="#5995" class="at cg ga gb gc gd" rel="noopener">²</a> as opaque as it’s only contributing color to half the samples!</p><p id="6c45" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Okay, so with 4x MSAA and Alpha to Coverage you get 5 levels of opacity you can play with, 4/4 through 0/4 samples. What good is that? With traditional alpha blending you get at least 256 levels, so why would you ever want to use this? Because with Alpha to Coverage those coverage samples are opaque. That means they can be depth sorted! You can have a mesh of polygon soup and have intersecting triangles accurately sort at better than per pixel accuracy. This is no different than opaque objects or even alpha test with MSAA, but you also get soft edges.</p><p id="0362" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Lets just turn Alpha to Coverage on and see how that looks. In Unity’s ShaderLab it’s enabled by just adding <code class="if ix iy iz ja b">AlphaToMask On</code> to an otherwise opaque shader that outputs alpha. So here we go …</p><figure class="hs ht hu hv hw hx cl cm paragraph-image"><p id="8240" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">And we’re done, doesn’t that look so much better than before?! Lets compare it to the original alpha test version!</p></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>