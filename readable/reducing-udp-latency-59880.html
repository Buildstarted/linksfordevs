<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Reducing UDP latency - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Reducing UDP latency - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@deryugin.denis"/>
    <meta property="og:description" content="Hi! I&#x2019;m one of Embox RTOS developers, and in this article I&#x2019;ll tell you about one of the typical problems in the world of embedded systems&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@deryugin.denis/reducing-udp-latency-ce60d98c7bff"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Reducing UDP latency</title>
<div class="readable">
        <h1>Reducing UDP latency</h1>
            <div>by https://medium.com/@deryugin.denis</div>
            <div>Reading time: 8-9 minutes</div>
        <div>Posted here: 20 Mar 2020</div>
        <p><a href="https://medium.com/@deryugin.denis/reducing-udp-latency-ce60d98c7bff">https://medium.com/@deryugin.denis/reducing-udp-latency-ce60d98c7bff</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@deryugin.denis?source=post_page-----ce60d98c7bff----------------------"><img alt="Денис Дерюгин" src="https://miro.medium.com/fit/c/96/96/0*lybpWEILqPQApAqx.jpg" width="48" height="48"></a></p></div></div></div></div><p id="b11a" data-selectable-paragraph="">Hi! I’m one of <a href="http://embox.github.io/" target="_blank" rel="noopener nofollow">Embox RTOS</a> developers, and in this article I’ll tell you about one of the typical problems in the world of embedded systems and how we were solving it.</p><figure><div><div><div><p><img src="https://miro.medium.com/freeze/max/60/1*8mPRoeJU-A-J_4XRUE2ypA.gif?q=20" width="364" height="240" role="presentation"></p><p><img width="364" height="240" role="presentation" src="https://miro.medium.com/max/364/1*8mPRoeJU-A-J_4XRUE2ypA.gif"></p></div></div></div></figure><p id="bdcb" data-selectable-paragraph="">Control and responsibility is a key point for a wide range of embedded systems. On the one hand, sensors and detectors must notify some other devices that some event occurred, on the other hand, other systems should react as soon as possible. Examples of such systems include CNC, vehicle control, avionics, distributed sensor systems and lot of others.</p><p id="51b8" data-selectable-paragraph="">At the same time, it’s really hard to develop bare-metal programs for a number of reasons:</p><ul><li id="82bb" data-selectable-paragraph="">Developers don’t have much choice for frameworks and languages: it probably will be ANSI C and assembly language even for non-time-critical parts of code which can be developed faster with something else (for example, debugging output, collecting statistics, some user interface for diagnostics and so on)</li><li id="b6bd" data-selectable-paragraph="">There are really lots of solutions which require different hardware hardware drivers: network, interrupt controller, timer and UART driver are bare minimum</li><li id="fe7c" data-selectable-paragraph="">Some systems have both FPGA and HPS, which leads to additional steps to “glue” all the parts together</li></ul><p id="91ac" data-selectable-paragraph="">This leads popularity of Linux kernel in embedded systems and it works great in lots of applications, as it gives portable and stable code base.</p><p id="d160" data-selectable-paragraph="">But let’s see some specific case: time-critical applications that rely on network.</p><p id="136e" data-selectable-paragraph="">“Time-critical” may mean different things:</p><ul><li id="c7ef" data-selectable-paragraph="">Applications that require high bandwidth</li><li id="28df" data-selectable-paragraph="">Applications that require low latency</li></ul><p id="2a75" data-selectable-paragraph="">Linux works great with the first case as there are a number of possible optimizations (turn off interrupt coalescing and so on…), but can you achieve better results in terms of low latency? Let’s find out!</p><p id="d13f" data-selectable-paragraph="">We had a following task: minimize possible latency for every single UDP response over the ethernet. DE0-Nano-Soc board was used as an embedded system core which would control some peripheral devices as a reaction for commands in those UDP packets.</p><p id="61c7" data-selectable-paragraph="">Network topology is Point-to-Point, so there are no intermediate hubs, routers and other network devices.</p><p id="7c22" data-selectable-paragraph="">Maximum acceptable latency is 0.1ms while basic Linux solution could only provide 0.5ms.</p><p id="5a81" data-selectable-paragraph="">At the same time it was necessary to support POSIX-compatible programs.</p><figure><div><div><div><p><img alt="DE0 Nano SoC kit" src="https://miro.medium.com/max/60/1*_m23p8tXv-hGRmFwJDY4JA.jpeg?q=20" width="550" height="489"></p><p><img alt="DE0 Nano SoC kit" width="550" height="489"></p></div></div></div></figure><p id="754e" data-selectable-paragraph="">To measure estimated response time we will use two hosts.<br>The first host will be a desktop computer running GNU/Linux operating system, the second host will be DE0-Nano-SoC development board. This board has FPGA and HPS (Harp Processing System, it’s basically ARM), and we’re going to minimize response time for HPS running Embox RTOS.</p><p id="0ae7" data-selectable-paragraph="">We will use simple testing application which looks like this:</p><pre><span id="cd1a" data-selectable-paragraph="">while (1) {<br> char buf[BUFLEN];</span><span id="0a36" data-selectable-paragraph="">recvfrom(s, buf, BUFLEN); <br> sendto(s, buf, BUFLEN);<br>}</span></pre><p id="a7fb" data-selectable-paragraph="">This program will run on the second host, i.e. DE0-Nano-SoC.</p><p id="3f8d" data-selectable-paragraph="">First host will be sending UDP packets and waiting response for each of them, measuring time for the response.</p><pre><span id="6581" data-selectable-paragraph="">for (int i = 0; i &lt; N; i++) {<br>  char buf_tx[BUFLEN], buf_rx[BUFLEN];</span><span id="4dae" data-selectable-paragraph="">sprintf(buf_tx, “This is packet %d
”, i);</span><span id="fed3" data-selectable-paragraph="">time_t time_begin = time_now();</span><span id="73cd" data-selectable-paragraph="">sendto(s, buf_tx, BUFLEN);<br>  recvfrom(s, buf_rx, BUFLEN);</span><span id="eaee" data-selectable-paragraph="">time_t time_end = time_now();<br>  if (memcmp(buf_tx, buf_rx, sizeof(buf))) {<br>    printf(“%d: Buffer mismatch
”, i);<br>  }<br>  if (time_end — time_begin &gt; TIME_LIMIT) {<br>    printf(“Slow answer #%d: %d
”, i, time_end — time_begin);<br>  }<br>}</span></pre><p id="3113" data-selectable-paragraph="">Also we measure average, minimal and maximal response time.</p><p id="a83e" data-selectable-paragraph="">Source code is available on <a href="https://github.com/Deryugin/udp_test" target="_blank" rel="noopener nofollow">GitHub</a>.</p><p id="c655" data-selectable-paragraph="">With test run we made sure that packets are received successfully, so we have started to make some basic optimizations:</p><ul><li id="db49" data-selectable-paragraph="">Get rid of all debug UART output: it turned out to be the slowest part</li><li id="ca05" data-selectable-paragraph="">Compiling with -O2</li><li id="8249" data-selectable-paragraph="">Enabling L2 cache controller PL310 (this point was the least effective)</li></ul><p id="662a" data-selectable-paragraph="">After sending 500 000 packets we have following measurements:</p><pre><span id="729f" data-selectable-paragraph="">Avg: 4.52ms<br>Min: 3.12ms<br>Max: 12.24ms</span></pre><p id="c2f2" data-selectable-paragraph="">This is still multiple times slower than time limits we need to meet, and average response time should be almost ten times lower to compete with Linux.</p><p id="47c5" data-selectable-paragraph="">One of the possible sources for slow data processing may be other processes who use system resources, but in this case nothing else is running.</p><p id="0d45" data-selectable-paragraph="">May be there are too much interrupts from some peripherals? But that’s not the case too: we only process network and timer interrupts; first ones are necessary to process ethernet frames and second ones do not tend to do any effect: if timer goes slower, response time doesn’t decrease anyway.</p><p id="0edb" data-selectable-paragraph="">Eventually we have found out that high latency was caused by low link speed: we used 100 Mbit/s USB-to-ethernet adapter; net driver didn’t support 1Gbit/s link too.</p><p id="0a2b" data-selectable-paragraph="">After patching driver and replacing ethernet adapter with faster one we’re getting following results:</p><pre><span id="ccbd" data-selectable-paragraph="">Avg: 0.08ms<br>Min: 0.07ms<br>Max: 4.31ms</span></pre><p id="e9b7" data-selectable-paragraph="">As we are using POSIX-compatible application for our measurements, it’s very easy to cross-build it for Linux:<br><code>arm-linux-gnueabihf-gcc server.c -O2</code>, which builds ELF file.</p><p id="356e" data-selectable-paragraph="">Running with the same client on the host side:</p><pre><span id="71c4" data-selectable-paragraph="">Avg: 0.77ms<br>Min: 0.74ms<br>Max: 5.31ms</span></pre><p id="8d6b" data-selectable-paragraph="">As you can see, in this test Embox is able to respond almost 9 times faster than Linux, which is a pretty good result.</p><p id="f21d" data-selectable-paragraph="">While average response time is pretty good, maximum time kills the positive effect for two reasons:</p><ul><li id="cc1a" data-selectable-paragraph="">Of course it’s long enough to fail time limit, but even more importantly</li><li id="b29e" data-selectable-paragraph="">It creates significant uncertainty to system behavior</li></ul><p id="d111" data-selectable-paragraph="">How can you investigate the reason for such dispersion? We decided to start with measuring time which takes ethernet frame to be fully processed between receiving and responding. It was possible to collect statistics on the development board for future analyzing, but it’s much simpler just to send this data in the UDP packet itself and process in on the desktop computer.</p><p id="93d1" data-selectable-paragraph="">Time of packet receive time is written to some variable inside interrupt handler, send time is written just before activating netcard DMA.</p><pre><span id="a640" data-selectable-paragraph="">int net_tx(…) {<br>  if (is_udp_packet()) {<br>    timestamp2 = timer_get();<br>    memcpy(packet[UDP_OFFT],<br>            &amp;timestamp1,<br>            sizeof(timestamp1));<br>    memcpy(packet[UDP_OFFT + sizeof(timestamp2)],<br>            &amp;timestamp2,<br>            sizeof(timestamp2));<br>    …<br>  }<br>}</span></pre><p id="2b2a" data-selectable-paragraph="">This time we got following results:</p><pre><span id="322e" data-selectable-paragraph="">Avg: 8673<br>Min: 6191 <br>Max: 11950</span></pre><p id="4fa5" data-selectable-paragraph="">It turned out that dispersion for Embox processing UDP packet is not big at all: it’s just about 25% which hardly explains final 5000% dispersion (Avg: 0.08ms Max: 4.31ms).<br>Even if Embox will process every UDP packet with the same time, it may reduce it by just 1/4 which still will be too much, so we have started to find out another reason for such behavior.</p><p id="0cdc" data-selectable-paragraph="">So now we have two potential problems:</p><ul><li id="cd6c" data-selectable-paragraph="">Hardware issues</li><li id="5283" data-selectable-paragraph="">Linux host latency</li></ul><p id="73c5" data-selectable-paragraph="">It’s much harder to solve the first problem, so in hope that it’s not the case we started to think how to solve this problem.</p><p id="e935" data-selectable-paragraph="">How do we check it?</p><p id="41a9" data-selectable-paragraph="">First of all, we can just try to set highest priority to this test on the host system.</p><p id="163e" data-selectable-paragraph=""><code>nice -n -20 ./client</code></p><p id="2fa4" data-selectable-paragraph="">However, this didn’t have any significant effect. It seemed that average time reduced slightly, but still was too small compared to big dispersion.</p><p id="1724" data-selectable-paragraph="">Another solution is to change scheduling policy to round-robin. You can do it with <code>chrt</code> command like this:</p><p id="1119" data-selectable-paragraph=""><code>chrt --rr 99 ./client</code></p><p id="42cc" data-selectable-paragraph="">Finally, it worked!</p><p id="961a" data-selectable-paragraph="">Number of “slow” responses has decreased dramatically. This histogram shows difference for round-robin and regular scheduling:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/58/1*ax62CQat1Ml0L1BxbIX4hQ.png?q=20" width="958" height="977" role="presentation"></p><p><img width="958" height="977" role="presentation"></p></div></div></div></div></figure><ul><li id="a28b" data-selectable-paragraph="">Using raw sockets. It’s not exactly the same task, but if you really need lowest possible latency, it’s probably not that good idea to use UDP at all :)</li><li id="1e34" data-selectable-paragraph="">Interrupt coalescing may increase network latency, so it can be helpful to turn it off</li><li id="b1b7" data-selectable-paragraph="">You can use libpcap and TPACKETv3 supported by Linux kernel. Speed increase is being achieved by removing the overhead for copying from kernel space to user space. pcap also allows to apply packet filtering</li><li id="3058" data-selectable-paragraph="">XDP or eXpress Data Path is a BPF-like project which allows to lower overhead too</li><li id="0309" data-selectable-paragraph="">Some other ways are considered in <a href="https://blog.cloudflare.com/how-to-achieve-low-latency/amp/" target="_blank" rel="noopener nofollow">this Cloudflare blogpost</a></li></ul></div></div></section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>