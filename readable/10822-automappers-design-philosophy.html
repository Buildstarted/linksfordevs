<!DOCTYPE html>
<html lang="en">
<head>
    <title>
AutoMapper&#x27;s Design Philosophy -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>AutoMapper's Design Philosophy</h1><div><div class="post-content"><p>While a lot of people use AutoMapper, and love it, I meet just as many people that <em>hate</em> it. When I hear their stories, it becomes clear to me that it's not that AutoMapper was "abused" per se, but that it was used without understanding why AutoMapper exists and what problems it was designed to solve.</p><p>AutoMapper originated at the beginning of a large MVC application way back in the early days on MVC. Back then, there really wasn't any guidance about what exactly the "M" in "MVC" should be. Most MVC frameworks have a strong concept of a model - in Rails, Django, and many others, the M is a first-class citizen. The joke in ASP.NET MVC is the "M" is silent.</p><p>So we adopted the name "view model" to describe <a href="https://lostechies.com/jimmybogard/2009/06/30/how-we-do-mvc-view-models/">our models in MVC</a> - these were models specifically designed for a view.</p><p>We started this long-running project with a few rules for our view models:</p><ul><li>Each view model would be designed for one and only one view</li><li>Only the information needed to render or model bind is contained on the view model</li></ul><p>With these rules in place, we started building screens. A few dozen screens in, we started to notice a problem.</p><h3 id="bespokemodels">Bespoke models</h3><p>As we built screens, we needed to build out our view model types. We knew we wanted to create view models per screen, but what past that? How should we name the type? How should we name the members?</p><p>We found that nearly all of our screens were just subsets of data from a richer model. We had a lot of boring assignment code:</p><pre><code class="language-csharp">var order = dbContext.FindById(id);
var orderDto = new OrderDto {
    Id = order.Id,
    CustomerName = order.Customer.FullName,
    LineItems = order.LineItems.Select(li =&gt; new OrderDto.OrderLineItem 
    {
        Id = li.Id,
        ProductName = li.Product.ShortName,
        Description = li.Product.Description,
        Count = li.Count,
        Price = li.ItemPrice
    }).ToList();
};
</code></pre><p>I noticed a couple of things:</p><ul><li>DTO names were arbitrary. Sometimes we called it "model", sometimes "Dto"</li><li>Member names were shortened/abbreviated arbitrarily</li></ul><p>There wasn't any rhyme or reason behind this, it was whatever the developer decided to do. On top of this, we would get null reference exceptions fairly frequently - when there was missing data for whatever reason, our simple assignment expressions would blow up (this was also before the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators">null conditional operator</a>).</p><p>On top of this, we would have to unit test all of this - making sure all of the properties were populated appropriately, and nothing was missing.</p><p>Putting these two together, and it was going to be a recipe for disaster for an app that would eventually have nearly 1000 screens.</p><h3 id="enterautomapper">Enter AutoMapper</h3><p>The architect showed me all this (I was tech lead on the project at the time) and said "fix it". The main problems as I saw it were:</p><ul><li>The view models were all subtly, but pointlessly, different</li><li>The code to handle sparse models or missing data was error-prone and often missed</li><li>The tests for all those assignments was easy to get wrong</li></ul><p>Was there any business value in having a property named "Price" instead of "ItemPrice"? And since we worked so hard on the original model names, adhering to the ubiquitous language of our broader team, why was it then OK for the developer to take shortcuts in the view model design?</p><p>With this in front of me, I set out to build a tool that:</p><ul><li>Enforced a convention for destination types</li><li>Removed all those null reference exceptions</li><li>Made it super easy to test</li></ul><p>And thus AutoMapper was born.</p><h3 id="automappersdesignphilosophy">AutoMapper's Design Philosophy</h3><p>AutoMapper works because it enforces a convention. It assumes that your destination types are a subset of the source type. It assumes that everything on your destination type is meant to be mapped. It assumes that the destination member names follow the exact name of the source type. It assumes that you want to flatten complex models into simple ones.</p><p>All of these assumptions come from our original use case - view models for MVC, where all of those assumptions are in line with our view model design. With AutoMapper, we could <em>enforce</em> our view model design philosophy. This is the true power of conventions - laying down a set of enforceable design rules that help you streamline development along the way.</p><p>By enforcing conventions, we let our developers focus on the value add activities, and less on the activities that provided zero or negative value, like designing bespoke view models or writing a thousand dumb unit tests.</p><p>And this is why our usage of AutoMapper has stayed so steady over the years - because our design philosophy for view models hasn't changed. If you find yourself hating a tool, it's important to ask - for what problems was this tool designed to solve? And if those problems are different than yours, perhaps that tool isn't a good fit.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>