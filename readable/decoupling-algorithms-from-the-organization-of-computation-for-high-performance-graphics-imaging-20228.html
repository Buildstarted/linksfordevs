<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Decoupling Algorithms from the Organization of Computation for High-Performance Graphics \u0026 Imaging - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Decoupling Algorithms from the Organization of Computation for High-Performance Graphics \u0026 Imaging - linksfor.dev(s)"/>
    <meta property="article:author" content="Microsoft Research"/>
    <meta property="og:description" content="Future graphics and imaging applications&#xFFFD;from photorealistic real-time rendering, to 4D light field cameras and pervasive sensing, to multi-material 3D printing&#xFFFD;demand orders of magnitude more computation than we currently have. The efficiency and performance of an application are determined by the algorithm and the hardware architecture on which it runs, but critically also by the organization of computations and data. Real graphics and imaging applications have complex dependencies, and are limited by locality (the distance over which data has to move, e.g., from nearby caches or far away main memory) and synchronization. Increasingly, the cost of communication&#xFFFD;both within a chip and over a network&#xFFFD;dominates computation and power consumption, and limits the gains realized from shrinking transistors.  This talk will focus on the Halide language and compiler for image processing. Halide explicitly separates what computations define an algorithm from the choices of execution structure which determine parallelism, locality, memory footprint, and synchronization. For image processing algorithms with the same complexity&#xFFFD;even the exact same set of arithmetic operations and data&#xFFFD;executing on the same hardware, the order and granularity of execution and placement of data can easily change performance by an order of magnitude because of locality and parallelism. I will show that, for data-parallel pipelines common in graphics, imaging, and other data-intensive applications, the organization of computations and data for a given algorithm is constrained by a fundamental tension between parallelism, locality, and redundant computation of shared values. I will present a systematic model of "/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.youtube.com/watch?v=dnFccCGvT90"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Decoupling Algorithms from the Organization of Computation for High-Performance Graphics \u0026 Imaging</title>
<div class="readable">
        <h1>Decoupling Algorithms from the Organization of Computation for High-Performance Graphics \u0026 Imaging</h1>
            <div>by Microsoft Research</div>
            <div>Watching time: 70 minutes</div>
        <div>Posted here: 07 May 2019</div>
        <p><a href="https://www.youtube.com/watch?v=dnFccCGvT90">https://www.youtube.com/watch?v=dnFccCGvT90</a></p>
        <iframe allowFullScreen="allowFullScreen" src="https://www.youtube-nocookie.com/embed/dnFccCGvT90?ecver=1&amp;iv_load_policy=1&amp;yt:stretch=16:9&amp;autohide=1&amp;color=red&amp;width=980" width="980" height="600" allowtransparency="true" frameborder="0"></iframe>
        <br />
        <p style="text-align:left">
            Future graphics and imaging applications�from photorealistic real-time rendering, to 4D light field cameras and pervasive sensing, to multi-material 3D printing�demand orders of magnitude more computation than we currently have. The efficiency and performance of an application are determined by the algorithm and the hardware architecture on which it runs, but critically also by the organization of computations and data. Real graphics and imaging applications have complex dependencies, and are limited by locality (the distance over which data has to move, e.g., from nearby caches or far away main memory) and synchronization. Increasingly, the cost of communication�both within a chip and over a network�dominates computation and power consumption, and limits the gains realized from shrinking transistors.  This talk will focus on the Halide language and compiler for image processing. Halide explicitly separates what computations define an algorithm from the choices of execution structure which determine parallelism, locality, memory footprint, and synchronization. For image processing algorithms with the same complexity�even the exact same set of arithmetic operations and data�executing on the same hardware, the order and granularity of execution and placement of data can easily change performance by an order of magnitude because of locality and parallelism. I will show that, for data-parallel pipelines common in graphics, imaging, and other data-intensive applications, the organization of computations and data for a given algorithm is constrained by a fundamental tension between parallelism, locality, and redundant computation of shared values. I will present a systematic model of 
        </p>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>