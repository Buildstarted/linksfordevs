<!DOCTYPE html>
<html lang="en">
<head>
    <title>
tidwall/buntdb - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="tidwall/buntdb - linksfor.dev(s)"/>
    <meta property="article:author" content="tidwall"/>
    <meta property="og:description" content="BuntDB is an embeddable, in-memory key/value database for Go with custom indexing and geospatial support - tidwall/buntdb"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/tidwall/buntdb"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - tidwall/buntdb</title>
<div class="readable">
        <h1>tidwall/buntdb</h1>
            <div>by tidwall</div>
            <div>Reading time: 17-22 minutes</div>
        <div>Posted here: 08 Aug 2019</div>
        <p><a href="https://github.com/tidwall/buntdb">https://github.com/tidwall/buntdb</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
        

      <div>
        <article itemprop="text"><p>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/tidwall/buntdb/blob/master/logo.png"><img src="https://github.com/tidwall/buntdb/raw/master/logo.png" width="307" height="150" alt="BuntDB"></a>
<br>
<a href="https://travis-ci.org/tidwall/buntdb" rel="nofollow"><img src="https://camo.githubusercontent.com/e0a4b65f2f14637f5796a6171c9cd15dca92dab6/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f74696477616c6c2f62756e7464622e7376673f7374796c653d666c61742d737175617265" alt="Build Status" data-canonical-src="https://img.shields.io/travis/tidwall/buntdb.svg?style=flat-square"></a>
<a href="http://gocover.io/github.com/tidwall/buntdb" rel="nofollow"><img src="https://camo.githubusercontent.com/06839d89b3f5051c24270025326c653a5d69f208/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f7665726167652d39352532352d627269676874677265656e2e7376673f7374796c653d666c61742d737175617265" alt="Code Coverage" data-canonical-src="https://img.shields.io/badge/coverage-95%25-brightgreen.svg?style=flat-square"></a>
<a href="https://goreportcard.com/report/github.com/tidwall/buntdb" rel="nofollow"><img src="https://camo.githubusercontent.com/d76321e218b4b5d6a8df6dc9ff22c7177be147da/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f74696477616c6c2f62756e7464623f7374796c653d666c61742d737175617265" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/tidwall/buntdb?style=flat-square"></a>
<a href="https://godoc.org/github.com/tidwall/buntdb" rel="nofollow"><img src="https://camo.githubusercontent.com/1a9f5a297cc3aba08815fd43517cf9a772bb6fe2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6170692d7265666572656e63652d626c75652e7376673f7374796c653d666c61742d737175617265" alt="GoDoc" data-canonical-src="https://img.shields.io/badge/api-reference-blue.svg?style=flat-square"></a>
</p>
<p>BuntDB is a low-level, in-memory, key/value store in pure Go.
It persists to disk, is ACID compliant, and uses locking for multiple
readers and a single writer. It supports custom indexes and geospatial
data. It's ideal for projects that need a dependable database and favor
speed over data size.</p>

<ul>
<li>In-memory database for <a href="#performance">fast reads and writes</a></li>
<li>Embeddable with a <a href="https://godoc.org/github.com/tidwall/buntdb" rel="nofollow">simple API</a></li>
<li><a href="#spatial-indexes">Spatial indexing</a> for up to 20 dimensions; Useful for Geospatial data</li>
<li>Index fields inside <a href="#json-indexes">JSON</a> documents</li>
<li><a href="#collate-i18n-indexes">Collate i18n Indexes</a> using the optional <a href="https://github.com/tidwall/collate">collate package</a></li>
<li>Create <a href="#custom-indexes">custom indexes</a> for any data type</li>
<li>Support for <a href="#multi-value-index">multi value indexes</a>; Similar to a SQL multi column index</li>
<li><a href="#built-in-types">Built-in types</a> that are easy to get up &amp; running; String, Uint, Int, Float</li>
<li>Flexible <a href="#iterating">iteration</a> of data; ascending, descending, and ranges</li>
<li><a href="#append-only-file">Durable append-only file</a> format for persistence</li>
<li>Option to evict old items with an <a href="#data-expiration">expiration</a> TTL</li>
<li>Tight codebase, under 2K loc using the <code>cloc</code> command</li>
<li>ACID semantics with locking <a href="#transactions">transactions</a> that support rollbacks</li>
</ul>

<h2>Installing</h2>
<p>To start using BuntDB, install Go and run <code>go get</code>:</p>
<div><pre>$ go get -u github.com/tidwall/buntdb</pre></div>
<p>This will retrieve the library.</p>
<h2>Opening a database</h2>
<p>The primary object in BuntDB is a <code>DB</code>. To open or create your
database, use the <code>buntdb.Open()</code> function:</p>
<div><pre><span>package</span> main

<span>import</span> (
	<span><span>"</span>log<span>"</span></span>

	<span><span>"</span>github.com/tidwall/buntdb<span>"</span></span>
)

<span>func</span> <span>main</span>() {
	<span><span>//</span> Open the data.db file. It will be created if it doesn't exist.</span>
	<span>db</span>, <span>err</span> <span>:=</span> buntdb.<span>Open</span>(<span><span>"</span>data.db<span>"</span></span>)
	<span>if</span> err != <span>nil</span> {
		log.<span>Fatal</span>(err)
	}
	<span>defer</span> db.<span>Close</span>()

	...
}</pre></div>
<p>It's also possible to open a database that does not persist to disk by using <code>:memory:</code> as the path of the file.</p>
<div><pre>buntdb.<span>Open</span>(<span><span>"</span>:memory:<span>"</span></span>) <span><span>//</span> Open a file that does not persist to disk.</span></pre></div>
<h2>Transactions</h2>
<p>All reads and writes must be performed from inside a transaction. BuntDB can have one write transaction opened at a time, but can have many concurrent read transactions. Each transaction maintains a stable view of the database. In other words, once a transaction has begun, the data for that transaction cannot be changed by other transactions.</p>
<p>Transactions run in a function that exposes a <code>Tx</code> object, which represents the transaction state. While inside a transaction, all database operations should be performed using this object. You should never access the origin <code>DB</code> object while inside a transaction. Doing so may have side-effects, such as blocking your application.</p>
<p>When a transaction fails, it will roll back, and revert all changes that occurred to the database during that transaction. There's a single return value that you can use to close the transaction. For read/write transactions, returning an error this way will force the transaction to roll back. When a read/write transaction succeeds all changes are persisted to disk.</p>
<h3>Read-only Transactions</h3>
<p>A read-only transaction should be used when you don't need to make changes to the data. The advantage of a read-only transaction is that there can be many running concurrently.</p>
<div><pre><span>err</span> <span>:=</span> db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	...
	<span>return</span> <span>nil</span>
})</pre></div>
<h3>Read/write Transactions</h3>
<p>A read/write transaction is used when you need to make changes to your data. There can only be one read/write transaction running at a time. So make sure you close it as soon as you are done with it.</p>
<div><pre><span>err</span> <span>:=</span> db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	...
	<span>return</span> <span>nil</span>
})</pre></div>
<h2>Setting and getting key/values</h2>
<p>To set a value you must open a read/write transaction:</p>
<div><pre><span>err</span> <span>:=</span> db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	<span>_</span>, <span>_</span>, <span>err</span> <span>:=</span> tx.<span>Set</span>(<span><span>"</span>mykey<span>"</span></span>, <span><span>"</span>myvalue<span>"</span></span>, <span>nil</span>)
	<span>return</span> err
})</pre></div>
<p>To get the value:</p>
<div><pre><span>err</span> <span>:=</span> db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	<span>val</span>, <span>err</span> <span>:=</span> tx.<span>Get</span>(<span><span>"</span>mykey<span>"</span></span>)
	<span>if</span> err != <span>nil</span>{
		<span>return</span> err
	}
	fmt.<span>Printf</span>(<span><span>"</span>value is <span>%s</span><span>\n</span><span>"</span></span>, val)
	<span>return</span> <span>nil</span>
})</pre></div>
<p>Getting non-existent values will cause an <code>ErrNotFound</code> error.</p>
<h3>Iterating</h3>
<p>All keys/value pairs are ordered in the database by the key. To iterate over the keys:</p>
<div><pre><span>err</span> <span>:=</span> db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	<span>err</span> <span>:=</span> tx.<span>Ascend</span>(<span><span>"</span><span>"</span></span>, <span>func</span>(key, value <span>string</span>) <span>bool</span> {
		fmt.<span>Printf</span>(<span><span>"</span>key: <span>%s</span>, value: <span>%s</span><span>\n</span><span>"</span></span>, key, value)
	})
	<span>return</span> err
})</pre></div>
<p>There is also <code>AscendGreaterOrEqual</code>, <code>AscendLessThan</code>, <code>AscendRange</code>, <code>AscendEqual</code>, <code>Descend</code>, <code>DescendLessOrEqual</code>, <code>DescendGreaterThan</code>, <code>DescendRange</code>, and <code>DescendEqual</code>. Please see the <a href="https://godoc.org/github.com/tidwall/buntdb" rel="nofollow">documentation</a> for more information on these functions.</p>
<h2>Custom Indexes</h2>
<p>Initially all data is stored in a single <a href="https://en.wikipedia.org/wiki/B-tree" rel="nofollow">B-tree</a> with each item having one key and one value. All of these items are ordered by the key. This is great for quickly getting a value from a key or <a href="#iterating">iterating</a> over the keys. Feel free to peruse the <a href="https://github.com/tidwall/btree">B-tree implementation</a>.</p>
<p>You can also create custom indexes that allow for ordering and <a href="#iterating">iterating</a> over values. A custom index also uses a B-tree, but it's more flexible because it allows for custom ordering.</p>
<p>For example, let's say you want to create an index for ordering names:</p>
<div><pre>db.<span>CreateIndex</span>(<span><span>"</span>names<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, buntdb.<span>IndexString</span>)</pre></div>
<p>This will create an index named <code>names</code> which stores and sorts all values. The second parameter is a pattern that is used to filter on keys. A <code>*</code> wildcard argument means that we want to accept all keys. <code>IndexString</code> is a built-in function that performs case-insensitive ordering on the values</p>
<p>Now you can add various names:</p>
<div><pre>db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Set</span>(<span><span>"</span>user:0:name<span>"</span></span>, <span><span>"</span>tom<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:1:name<span>"</span></span>, <span><span>"</span>Randi<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:2:name<span>"</span></span>, <span><span>"</span>jane<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:4:name<span>"</span></span>, <span><span>"</span>Janet<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:5:name<span>"</span></span>, <span><span>"</span>Paula<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:6:name<span>"</span></span>, <span><span>"</span>peter<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:7:name<span>"</span></span>, <span><span>"</span>Terri<span>"</span></span>, <span>nil</span>)
	<span>return</span> <span>nil</span>
})</pre></div>
<p>Finally you can iterate over the index:</p>
<div><pre>db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Ascend</span>(<span><span>"</span>names<span>"</span></span>, <span>func</span>(key, val <span>string</span>) <span>bool</span> {
	fmt.<span>Printf</span>(buf, <span><span>"</span><span>%s</span> <span>%s</span><span>\n</span><span>"</span></span>, key, val)
		<span>return</span> <span>true</span>
	})
	<span>return</span> <span>nil</span>
})</pre></div>
<p>The output should be:</p>
<pre><code>user:2:name jane
user:4:name Janet
user:5:name Paula
user:6:name peter
user:1:name Randi
user:7:name Terri
user:0:name tom
</code></pre>
<p>The pattern parameter can be used to filter on keys like this:</p>
<div><pre>db.<span>CreateIndex</span>(<span><span>"</span>names<span>"</span></span>, <span><span>"</span>user:*<span>"</span></span>, buntdb.<span>IndexString</span>)</pre></div>
<p>Now only items with keys that have the prefix <code>user:</code> will be added to the <code>names</code> index.</p>
<h3>Built-in types</h3>
<p>Along with <code>IndexString</code>, there is also <code>IndexInt</code>, <code>IndexUint</code>, and <code>IndexFloat</code>.
These are built-in types for indexing. You can choose to use these or create your own.</p>
<p>So to create an index that is numerically ordered on an age key, we could use:</p>
<div><pre>db.<span>CreateIndex</span>(<span><span>"</span>ages<span>"</span></span>, <span><span>"</span>user:*:age<span>"</span></span>, buntdb.<span>IndexInt</span>)</pre></div>
<p>And then add values:</p>
<div><pre>db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Set</span>(<span><span>"</span>user:0:age<span>"</span></span>, <span><span>"</span>35<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:1:age<span>"</span></span>, <span><span>"</span>49<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:2:age<span>"</span></span>, <span><span>"</span>13<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:4:age<span>"</span></span>, <span><span>"</span>63<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:5:age<span>"</span></span>, <span><span>"</span>8<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:6:age<span>"</span></span>, <span><span>"</span>3<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>user:7:age<span>"</span></span>, <span><span>"</span>16<span>"</span></span>, <span>nil</span>)
	<span>return</span> <span>nil</span>
})</pre></div>
<div><pre>db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Ascend</span>(<span><span>"</span>ages<span>"</span></span>, <span>func</span>(key, val <span>string</span>) <span>bool</span> {
	fmt.<span>Printf</span>(buf, <span><span>"</span><span>%s</span> <span>%s</span><span>\n</span><span>"</span></span>, key, val)
		<span>return</span> <span>true</span>
	})
	<span>return</span> <span>nil</span>
})</pre></div>
<p>The output should be:</p>
<pre><code>user:6:age 3
user:5:age 8
user:2:age 13
user:7:age 16
user:0:age 35
user:1:age 49
user:4:age 63
</code></pre>
<h2>Spatial Indexes</h2>
<p>BuntDB has support for spatial indexes by storing rectangles in an <a href="https://en.wikipedia.org/wiki/R-tree" rel="nofollow">R-tree</a>. An R-tree is organized in a similar manner as a <a href="https://en.wikipedia.org/wiki/B-tree" rel="nofollow">B-tree</a>, and both are balanced trees. But, an R-tree is special because it can operate on data that is in multiple dimensions. This is super handy for Geospatial applications.</p>
<p>To create a spatial index use the <code>CreateSpatialIndex</code> function:</p>
<div><pre>db.<span>CreateSpatialIndex</span>(<span><span>"</span>fleet<span>"</span></span>, <span><span>"</span>fleet:*:pos<span>"</span></span>, buntdb.<span>IndexRect</span>)</pre></div>
<p>Then <code>IndexRect</code> is a built-in function that converts rect strings to a format that the R-tree can use. It's easy to use this function out of the box, but you might find it better to create a custom one that renders from a different format, such as <a href="https://en.wikipedia.org/wiki/Well-known_text" rel="nofollow">Well-known text</a> or <a href="http://geojson.org/" rel="nofollow">GeoJSON</a>.</p>
<p>To add some lon,lat points to the <code>fleet</code> index:</p>
<div><pre>db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Set</span>(<span><span>"</span>fleet:0:pos<span>"</span></span>, <span><span>"</span>[-115.567 33.532]<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>fleet:1:pos<span>"</span></span>, <span><span>"</span>[-116.671 35.735]<span>"</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>fleet:2:pos<span>"</span></span>, <span><span>"</span>[-113.902 31.234]<span>"</span></span>, <span>nil</span>)
	<span>return</span> <span>nil</span>
})</pre></div>
<p>And then you can run the <code>Intersects</code> function on the index:</p>
<div><pre>db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Intersects</span>(<span><span>"</span>fleet<span>"</span></span>, <span><span>"</span>[-117 30],[-112 36]<span>"</span></span>, <span>func</span>(key, val <span>string</span>) <span>bool</span> {
		...
		<span>return</span> <span>true</span>
	})
	<span>return</span> <span>nil</span>
})</pre></div>
<p>This will get all three positions.</p>
<h3>k-Nearest Neighbors</h3>
<p>Use the <code>Nearby</code> function to get all the positions in order of nearest to farthest :</p>
<div><pre>db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Nearby</span>(<span><span>"</span>fleet<span>"</span></span>, <span><span>"</span>[-113 33]<span>"</span></span>, <span>func</span>(key, val <span>string</span>, dist <span>float64</span>) <span>bool</span> {
		...
		<span>return</span> <span>true</span>
	})
	<span>return</span> <span>nil</span>
})</pre></div>
<h3>Spatial bracket syntax</h3>
<p>The bracket syntax <code>[-117 30],[-112 36]</code> is unique to BuntDB, and it's how the built-in rectangles are processed. But, you are not limited to this syntax. Whatever Rect function you choose to use during <code>CreateSpatialIndex</code> will be used to process the parameter, in this case it's <code>IndexRect</code>.</p>
<ul>
<li>
<p><strong>2D rectangle:</strong> <code>[10 15],[20 25]</code>
<em>Min XY: "10x15", Max XY: "20x25"</em></p>
</li>
<li>
<p><strong>3D rectangle:</strong> <code>[10 15 12],[20 25 18]</code>
<em>Min XYZ: "10x15x12", Max XYZ: "20x25x18"</em></p>
</li>
<li>
<p><strong>2D point:</strong> <code>[10 15]</code>
<em>XY: "10x15"</em></p>
</li>
<li>
<p><strong>LonLat point:</strong> <code>[-112.2693 33.5123]</code>
<em>LatLon: "33.5123 -112.2693"</em></p>
</li>
<li>
<p><strong>LonLat bounding box:</strong> <code>[-112.26 33.51],[-112.18 33.67]</code>
<em>Min LatLon: "33.51 -112.26", Max LatLon: "33.67 -112.18"</em></p>
</li>
</ul>
<p><strong>Notice:</strong> The longitude is the Y axis and is on the left, and latitude is the X axis and is on the right.</p>
<p>You can also represent <code>Infinity</code> by using <code>-inf</code> and <code>+inf</code>.
For example, you might have the following points (<code>[X Y M]</code> where XY is a point and M is a timestamp):</p>
<pre><code>[3 9 1]
[3 8 2]
[4 8 3]
[4 7 4]
[5 7 5]
[5 6 6]
</code></pre>
<p>You can then do a search for all points with <code>M</code> between 2-4 by calling <code>Intersects</code>.</p>
<div><pre>tx.<span>Intersects</span>(<span><span>"</span>points<span>"</span></span>, <span><span>"</span>[-inf -inf 2],[+inf +inf 4]<span>"</span></span>, <span>func</span>(key, val <span>string</span>) <span>bool</span> {
	<span>println</span>(val)
	<span>return</span> <span>true</span>
})</pre></div>
<p>Which will return:</p>
<pre><code>[3 8 2]
[4 8 3]
[4 7 4]
</code></pre>
<h2>JSON Indexes</h2>
<p>Indexes can be created on individual fields inside JSON documents. BuntDB uses <a href="https://github.com/tidwall/gjson">GJSON</a> under the hood.</p>
<p>For example:</p>
<div><pre><span>package</span> main

<span>import</span> (
	<span><span>"</span>fmt<span>"</span></span>

	<span><span>"</span>github.com/tidwall/buntdb<span>"</span></span>
)

<span>func</span> <span>main</span>() {
	<span>db</span>, <span>_</span> <span>:=</span> buntdb.<span>Open</span>(<span><span>"</span>:memory:<span>"</span></span>)
	db.<span>CreateIndex</span>(<span><span>"</span>last_name<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, buntdb.<span>IndexJSON</span>(<span><span>"</span>name.last<span>"</span></span>))
	db.<span>CreateIndex</span>(<span><span>"</span>age<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, buntdb.<span>IndexJSON</span>(<span><span>"</span>age<span>"</span></span>))
	db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
		tx.<span>Set</span>(<span><span>"</span>1<span>"</span></span>, <span><span>`</span>{"name":{"first":"Tom","last":"Johnson"},"age":38}<span>`</span></span>, <span>nil</span>)
		tx.<span>Set</span>(<span><span>"</span>2<span>"</span></span>, <span><span>`</span>{"name":{"first":"Janet","last":"Prichard"},"age":47}<span>`</span></span>, <span>nil</span>)
		tx.<span>Set</span>(<span><span>"</span>3<span>"</span></span>, <span><span>`</span>{"name":{"first":"Carol","last":"Anderson"},"age":52}<span>`</span></span>, <span>nil</span>)
		tx.<span>Set</span>(<span><span>"</span>4<span>"</span></span>, <span><span>`</span>{"name":{"first":"Alan","last":"Cooper"},"age":28}<span>`</span></span>, <span>nil</span>)
		<span>return</span> <span>nil</span>
	})
	db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
		fmt.<span>Println</span>(<span><span>"</span>Order by last name<span>"</span></span>)
		tx.<span>Ascend</span>(<span><span>"</span>last_name<span>"</span></span>, <span>func</span>(key, value <span>string</span>) <span>bool</span> {
			fmt.<span>Printf</span>(<span><span>"</span><span>%s</span>: <span>%s</span><span>\n</span><span>"</span></span>, key, value)
			<span>return</span> <span>true</span>
		})
		fmt.<span>Println</span>(<span><span>"</span>Order by age<span>"</span></span>)
		tx.<span>Ascend</span>(<span><span>"</span>age<span>"</span></span>, <span>func</span>(key, value <span>string</span>) <span>bool</span> {
			fmt.<span>Printf</span>(<span><span>"</span><span>%s</span>: <span>%s</span><span>\n</span><span>"</span></span>, key, value)
			<span>return</span> <span>true</span>
		})
		fmt.<span>Println</span>(<span><span>"</span>Order by age range 30-50<span>"</span></span>)
		tx.<span>AscendRange</span>(<span><span>"</span>age<span>"</span></span>, <span><span>`</span>{"age":30}<span>`</span></span>, <span><span>`</span>{"age":50}<span>`</span></span>, <span>func</span>(key, value <span>string</span>) <span>bool</span> {
			fmt.<span>Printf</span>(<span><span>"</span><span>%s</span>: <span>%s</span><span>\n</span><span>"</span></span>, key, value)
			<span>return</span> <span>true</span>
		})
		<span>return</span> <span>nil</span>
	})
}</pre></div>
<p>Results:</p>
<pre><code>Order by last name
3: {"name":{"first":"Carol","last":"Anderson"},"age":52}
4: {"name":{"first":"Alan","last":"Cooper"},"age":28}
1: {"name":{"first":"Tom","last":"Johnson"},"age":38}
2: {"name":{"first":"Janet","last":"Prichard"},"age":47}

Order by age
4: {"name":{"first":"Alan","last":"Cooper"},"age":28}
1: {"name":{"first":"Tom","last":"Johnson"},"age":38}
2: {"name":{"first":"Janet","last":"Prichard"},"age":47}
3: {"name":{"first":"Carol","last":"Anderson"},"age":52}

Order by age range 30-50
1: {"name":{"first":"Tom","last":"Johnson"},"age":38}
2: {"name":{"first":"Janet","last":"Prichard"},"age":47}
</code></pre>
<h2>Multi Value Index</h2>
<p>With BuntDB it's possible to join multiple values on a single index.
This is similar to a <a href="http://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" rel="nofollow">multi column index</a> in a traditional SQL database.</p>
<p>In this example we are creating a multi value index on "name.last" and "age":</p>
<div><pre><span>db</span>, <span>_</span> <span>:=</span> buntdb.<span>Open</span>(<span><span>"</span>:memory:<span>"</span></span>)
db.<span>CreateIndex</span>(<span><span>"</span>last_name_age<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, buntdb.<span>IndexJSON</span>(<span><span>"</span>name.last<span>"</span></span>), buntdb.<span>IndexJSON</span>(<span><span>"</span>age<span>"</span></span>))
db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Set</span>(<span><span>"</span>1<span>"</span></span>, <span><span>`</span>{"name":{"first":"Tom","last":"Johnson"},"age":38}<span>`</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>2<span>"</span></span>, <span><span>`</span>{"name":{"first":"Janet","last":"Prichard"},"age":47}<span>`</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>3<span>"</span></span>, <span><span>`</span>{"name":{"first":"Carol","last":"Anderson"},"age":52}<span>`</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>4<span>"</span></span>, <span><span>`</span>{"name":{"first":"Alan","last":"Cooper"},"age":28}<span>`</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>5<span>"</span></span>, <span><span>`</span>{"name":{"first":"Sam","last":"Anderson"},"age":51}<span>`</span></span>, <span>nil</span>)
	tx.<span>Set</span>(<span><span>"</span>6<span>"</span></span>, <span><span>`</span>{"name":{"first":"Melinda","last":"Prichard"},"age":44}<span>`</span></span>, <span>nil</span>)
	<span>return</span> <span>nil</span>
})
db.<span>View</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Ascend</span>(<span><span>"</span>last_name_age<span>"</span></span>, <span>func</span>(key, value <span>string</span>) <span>bool</span> {
		fmt.<span>Printf</span>(<span><span>"</span><span>%s</span>: <span>%s</span><span>\n</span><span>"</span></span>, key, value)
		<span>return</span> <span>true</span>
	})
	<span>return</span> <span>nil</span>
})

<span><span>//</span> Output:</span>
<span><span>//</span> 5: {"name":{"first":"Sam","last":"Anderson"},"age":51}</span>
<span><span>//</span> 3: {"name":{"first":"Carol","last":"Anderson"},"age":52}</span>
<span><span>//</span> 4: {"name":{"first":"Alan","last":"Cooper"},"age":28}</span>
<span><span>//</span> 1: {"name":{"first":"Tom","last":"Johnson"},"age":38}</span>
<span><span>//</span> 6: {"name":{"first":"Melinda","last":"Prichard"},"age":44}</span>
<span><span>//</span> 2: {"name":{"first":"Janet","last":"Prichard"},"age":47}</span></pre></div>
<h2>Descending Ordered Index</h2>
<p>Any index can be put in descending order by wrapping it's less function with <code>buntdb.Desc</code>.</p>
<div><pre>db.<span>CreateIndex</span>(<span><span>"</span>last_name_age<span>"</span></span>, <span><span>"</span>*<span>"</span></span>,
buntdb.<span>IndexJSON</span>(<span><span>"</span>name.last<span>"</span></span>),
buntdb.<span>Desc</span>(buntdb.<span>IndexJSON</span>(<span><span>"</span>age<span>"</span></span>)))</pre></div>
<p>This will create a multi value index where the last name is ascending and the age is descending.</p>
<h2>Collate i18n Indexes</h2>
<p>Using the external <a href="https://github.com/tidwall/collate">collate package</a> it's possible to create
indexes that are sorted by the specified language. This is similar to the <a href="https://msdn.microsoft.com/en-us/library/ms174596.aspx" rel="nofollow">SQL COLLATE keyword</a> found in traditional databases.</p>
<p>To install:</p>
<pre><code>go get -u github.com/tidwall/collate
</code></pre>
<p>For example:</p>
<div><pre><span>import</span> <span><span>"</span>github.com/tidwall/collate<span>"</span></span>

<span><span>//</span> To sort case-insensitive in French.</span>
db.<span>CreateIndex</span>(<span><span>"</span>name<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, collate.<span>IndexString</span>(<span><span>"</span>FRENCH_CI<span>"</span></span>))

<span><span>//</span> To specify that numbers should sort numerically ("2" &lt; "12")</span>
<span><span>//</span> and use a comma to represent a decimal point.</span>
db.<span>CreateIndex</span>(<span><span>"</span>amount<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, collate.<span>IndexString</span>(<span><span>"</span>FRENCH_NUM<span>"</span></span>))</pre></div>
<p>There's also support for Collation on JSON indexes:</p>
<div><pre>db.<span>CreateIndex</span>(<span><span>"</span>last_name<span>"</span></span>, <span><span>"</span>*<span>"</span></span>, collate.<span>IndexJSON</span>(<span><span>"</span>CHINESE_CI<span>"</span></span>, <span><span>"</span>name.last<span>"</span></span>))</pre></div>
<p>Check out the <a href="https://github.com/tidwall/collate">collate project</a> for more information.</p>
<h2>Data Expiration</h2>
<p>Items can be automatically evicted by using the <code>SetOptions</code> object in the <code>Set</code> function to set a <code>TTL</code>.</p>
<div><pre>db.<span>Update</span>(<span>func</span>(tx *buntdb.<span>Tx</span>) <span>error</span> {
	tx.<span>Set</span>(<span><span>"</span>mykey<span>"</span></span>, <span><span>"</span>myval<span>"</span></span>, &amp;buntdb.<span>SetOptions</span>{Expires:<span>true</span>, TTL:time.<span>Second</span>})
	<span>return</span> <span>nil</span>
})</pre></div>
<p>Now <code>mykey</code> will automatically be deleted after one second. You can remove the TTL by setting the value again with the same key/value, but with the options parameter set to nil.</p>
<h2>Delete while iterating</h2>
<p>BuntDB does not currently support deleting a key while in the process of iterating.
As a workaround you'll need to delete keys following the completion of the iterator.</p>
<div><pre><span>var</span> <span>delkeys</span> []<span>string</span>
tx.<span>AscendKeys</span>(<span><span>"</span>object:*<span>"</span></span>, <span>func</span>(k, v <span>string</span>) <span>bool</span> {
	<span>if</span> <span>someCondition</span>(k) == <span>true</span> {
		delkeys = <span>append</span>(delkeys, k)
	}
	<span>return</span> <span>true</span> <span><span>//</span> continue</span>
})
<span>for</span> <span>_</span>, <span>k</span> <span>:=</span> <span>range</span> delkeys {
	<span>if</span> _, err = tx.<span>Delete</span>(k); err != <span>nil</span> {
		<span>return</span> err
	}
}</pre></div>
<h2>Append-only File</h2>
<p>BuntDB uses an AOF (append-only file) which is a log of all database changes that occur from operations like <code>Set()</code> and <code>Delete()</code>.</p>
<p>The format of this file looks like:</p>
<pre><code>set key:1 value1
set key:2 value2
set key:1 value3
del key:2
...
</code></pre>
<p>When the database opens again, it will read back the aof file and process each command in exact order.
This read process happens one time when the database opens.
From there on the file is only appended.</p>
<p>As you may guess this log file can grow large over time.
There's a background routine that automatically shrinks the log file when it gets too large.
There is also a <code>Shrink()</code> function which will rewrite the aof file so that it contains only the items in the database.
The shrink operation does not lock up the database so read and write transactions can continue while shrinking is in process.</p>
<h3>Durability and fsync</h3>
<p>By default BuntDB executes an <code>fsync</code> once every second on the <a href="#append-only-file">aof file</a>. Which simply means that there's a chance that up to one second of data might be lost. If you need higher durability then there's an optional database config setting <code>Config.SyncPolicy</code> which can be set to <code>Always</code>.</p>
<p>The <code>Config.SyncPolicy</code> has the following options:</p>
<ul>
<li><code>Never</code> - fsync is managed by the operating system, less safe</li>
<li><code>EverySecond</code> - fsync every second, fast and safer, this is the default</li>
<li><code>Always</code> - fsync after every write, very durable, slower</li>
</ul>
<h2>Config</h2>
<p>Here are some configuration options that can be use to change various behaviors of the database.</p>
<ul>
<li><strong>SyncPolicy</strong> adjusts how often the data is synced to disk. This value can be Never, EverySecond, or Always. Default is EverySecond.</li>
<li><strong>AutoShrinkPercentage</strong> is used by the background process to trigger a shrink of the aof file when the size of the file is larger than the percentage of the result of the previous shrunk file. For example, if this value is 100, and the last shrink process resulted in a 100mb file, then the new aof file must be 200mb before a shrink is triggered. Default is 100.</li>
<li><strong>AutoShrinkMinSize</strong> defines the minimum size of the aof file before an automatic shrink can occur. Default is 32MB.</li>
<li><strong>AutoShrinkDisabled</strong> turns off automatic background shrinking. Default is false.</li>
</ul>
<p>To update the configuration you should call <code>ReadConfig</code> followed by <code>SetConfig</code>. For example:</p>
<div><pre><span>var</span> <span>config</span> buntdb.<span>Config</span>
<span>if</span> <span>err</span> <span>:=</span> db.<span>ReadConfig</span>(&amp;config); err != <span>nil</span>{
	log.<span>Fatal</span>(err)
}
<span>if</span> <span>err</span> <span>:=</span> db.<span>SetConfig</span>(config); err != <span>nil</span>{
	log.<span>Fatal</span>(err)
}</pre></div>
<h2>Performance</h2>
<p>How fast is BuntDB?</p>
<p>Here are some example <a href="https://github.com/tidwall/raft-buntdb#raftstore-performance-comparison">benchmarks</a> when using BuntDB in a Raft Store implementation.</p>
<p>You can also run the standard Go benchmark tool from the project root directory:</p>
<pre><code>go test --bench=.
</code></pre>
<h3>BuntDB-Benchmark</h3>
<p>There's a <a href="https://github.com/tidwall/buntdb-benchmark">custom utility</a> that was created specifically for benchmarking BuntDB.</p>
<p><em>These are the results from running the benchmarks on a MacBook Pro 15" 2.8 GHz Intel Core i7:</em></p>
<pre><code>$ buntdb-benchmark -q
GET: 4609604.74 operations per second
SET: 248500.33 operations per second
ASCEND_100: 2268998.79 operations per second
ASCEND_200: 1178388.14 operations per second
ASCEND_400: 679134.20 operations per second
ASCEND_800: 348445.55 operations per second
DESCEND_100: 2313821.69 operations per second
DESCEND_200: 1292738.38 operations per second
DESCEND_400: 675258.76 operations per second
DESCEND_800: 337481.67 operations per second
SPATIAL_SET: 134824.60 operations per second
SPATIAL_INTERSECTS_100: 939491.47 operations per second
SPATIAL_INTERSECTS_200: 561590.40 operations per second
SPATIAL_INTERSECTS_400: 306951.15 operations per second
SPATIAL_INTERSECTS_800: 159673.91 operations per second
</code></pre>
<p>To install this utility:</p>
<pre><code>go get github.com/tidwall/buntdb-benchmark
</code></pre>
<h2>Contact</h2>
<p>Josh Baker <a href="http://twitter.com/tidwall" rel="nofollow">@tidwall</a></p>
<h2>License</h2>
<p>BuntDB source code is available under the MIT <a href="https://github.com/tidwall/buntdb/blob/master/LICENSE">License</a>.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>