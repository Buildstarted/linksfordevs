<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using strongly-typed entity IDs to avoid primitive obsession (Part 3) - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Using strongly-typed entity IDs to avoid primitive obsession (Part 3) - linksfor.dev(s)"/>
    <meta property="og:description" content="In this post I discuss using strongly-typed IDs with EF Core by using value converters. Unfortunately this has some issues I only partially fix in this post"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Using strongly-typed entity IDs to avoid primitive obsession (Part 3)</title>
<div class="readable">
        <h1>Using strongly-typed entity IDs to avoid primitive obsession (Part 3)</h1>
            <div>Reading time: 21-27 minutes</div>
        <div>Posted here: 16 Apr 2019</div>
        <p><a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/">https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-3/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

<div>
<p>In a <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/">previous post</a>, I described a common problem in which primitive arguments (e.g. <code>System.Guid</code> or <code>string</code>) are passed in the wrong order to a method, resulting in bugs. This problem is a symptom of primitive obsession: using primitive types to represent higher-level concepts. In <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">my second post</a>, I showed how to create a <code>JsonConverter</code> and <code>TypeConverter</code> to make using the strongly-typed IDs easier with ASP.NET Core.</p>
<blockquote>
<p><a href="https://disq.us/p/213e7lq">Martin Liversage noted</a> that JSON.NET will use a <code>TypeConverter</code> where one exists, so you generally don't need the custom <code>JsonConverter</code> I provided <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#strongly-typed-ids-make-for-ugly-json-apis">in the previous post</a>!</p>
</blockquote>
<p>In this post, I discuss using strongly-typed IDs with EF Core. I personally don't use EF Core a huge amount, but after a little playing I came up with something that I thought worked pretty well. Unfortunately, there's one huge flaw which puts a cloud over the whole approach, as <a href="#custom-value-converters-result-in-client-side-evaluation">I'll describe later</a> üôÅ. </p>
<h2 id="interfacing-with-external-system-using-strongly-typed-ids">Interfacing with external system using strongly typed IDs<a href="#interfacing-with-external-system-using-strongly-typed-ids"></a></h2>
<p>As a very quick reminder, strongly-typed IDs are types that can be used to represent the ID of an object, for example an <code>OrderId</code> or a <code>UserId</code>. A basic implementation (ignoring the overloads and converters etc.) looks something like this:</p>
<pre><code><span>public</span> <span>readonly</span> <span>struct</span> OrderId <span>:</span> IComparable<span>&lt;</span>OrderId<span>&gt;</span><span>,</span> IEquatable<span>&lt;</span>OrderId<span>&gt;</span>
<span>{</span>
    <span>public</span> <span>Guid</span> Value <span>{</span> <span>get</span><span>;</span> <span>}</span>
    <span>public</span> <span>OrderId</span><span>(</span><span>Guid</span> <span>value</span><span>)</span>
    <span>{</span>
        Value <span>=</span> <span>value</span><span>;</span>
    <span>}</span>

    
<span>}</span>
</code></pre>
<p>You only get the full benefit of strongly-typed IDs if you can use them throughout your application. That includes at the "edges" of the app, where you interact with external systems. In the <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">previous post</a> I described the interaction at the public-facing end of your app, in ASP.NET Core MVC controllers. </p>
<p>The other main external system you will likely need to interface with is the database. At the <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#other-type-converters-for-interfacing-with-the-world-">end of the last post</a>, I very briefly described a converter for using strongly-typed IDs with Dapper by creating a custom <code>TypeHandler</code>:</p>
<pre><code><span>class</span> <span>OrderIdTypeHandler</span> <span>:</span> <span>SqlMapper<span>.</span>TypeHandler</span><span>&lt;</span>OrderId<span>&gt;</span>
<span>{</span>
    <span>public</span> <span>override</span> <span>void</span> <span>SetValue</span><span>(</span><span>IDbDataParameter</span> parameter<span>,</span> <span>OrderId</span> <span>value</span><span>)</span>
    <span>{</span>
        parameter<span>.</span>Value <span>=</span> <span>value</span><span>.</span>Value<span>;</span>
    <span>}</span>

    <span>public</span> <span>override</span> <span>OrderId</span> <span>Parse</span><span>(</span><span>object</span> <span>value</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>new</span> <span>OrderId</span><span>(</span><span>(</span>Guid<span>)</span><span>value</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>This needs to be registered globally using <code>SqlMapper.AddTypeHandler(new OrderIdTypeHandler());</code> to be used directly in your Dapper database queries.</p>
<p>Dapper is the ORM that I use the most in my day job, but EF Core is possibly going to be the most common ORM in ASP.NET Core apps. Making EF Core play nicely with the strongly-typed IDs is possible, but requires a bit more work.</p>
<h2 id="building-an-ef-core-data-model-using-strongly-typed-ids">Building an EF Core data model using strongly typed IDs<a href="#building-an-ef-core-data-model-using-strongly-typed-ids"></a></h2>
<p>We'll start by creating a very simple data model that uses strongly-typed IDs. The classic ecommerce <code>Order</code>/<code>OrderLine</code> example contains everything we need:</p>
<pre><code><span>public</span> <span>class</span> <span>Order</span>
<span>{</span>
    <span>public</span> <span>OrderId</span> OrderId <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
    <span>public</span> <span>string</span> Name <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>public</span> ICollection<span>&lt;</span>OrderLine<span>&gt;</span> OrderLines <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>OrderLine</span>
<span>{</span>
    <span>public</span> <span>OrderId</span> OrderId <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
    <span>public</span> <span>OrderLineId</span> OrderLineId <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
    <span>public</span> <span>string</span> ProductName <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<p>We have two entities:</p>
<ul>
<li><code>Order</code> which has an <code>OrderId</code>, and has a collection of <code>OrderLine</code>s. </li>
<li><code>OrderLine</code> which has as <code>OrderLineId</code> and an <code>OrderId</code>. All of the IDs are strongly-typed. </li>
</ul>
<p>After creating these entities, we need to add them to the EF Core <code>DbContext</code>. We create a <code>DbSet&lt;Order&gt;</code> for the collection of <code>Order</code>s, and let EF Core discover the <code>OrderLine</code> entity itself:</p>
<pre><code> <span>public</span> <span>class</span> <span>ApplicationDbContext</span> <span>:</span> <span>DbContext</span>
<span>{</span>
    <span>public</span> <span>ApplicationDbContext</span><span>(</span>DbContextOptions<span>&lt;</span>ApplicationDbContext<span>&gt;</span> options<span>)</span>
        <span>:</span> <span>base</span><span>(</span>options<span>)</span>
    <span>{</span>
    <span>}</span>

    <span>public</span> DbSet<span>&lt;</span>Order<span>&gt;</span> Orders <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<p>Unfortunately, if we try and generate a new migration for updated model using the <code>dotnet ef</code> tool, we'll get an error:</p>
<pre><code><span>&gt;</span> dotnet ef migrations add OrderSchema

System.InvalidOperationException: The property <span>'Order.OrderId'</span> could not be mapped, 
because it is of <span>type</span> <span>'OrderId'</span> <span>which</span> is not a supported primitive <span>type</span> or a valid 
entity type. Either explicitly map this property, or ignore it using the 
<span>'[NotMapped]'</span> attribute or by using <span>'EntityTypeBuilder.Ignore'</span> <span>in</span> <span>'OnModelCreating'</span><span>.</span>
</code></pre>
<p>EF Core complains that it doesn't know how to map our strongly-typed IDs (<code>OrderId</code>) to a database type. Luckily, there's a mechanism we can use to control this as of EF Core 2.1: value converters.</p>
<h2 id="creating-a-custom-valueconverter-for-ef-core">Creating a custom ValueConverter for EF Core<a href="#creating-a-custom-valueconverter-for-ef-core"></a></h2>
<p>As <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions">described in the EF Core documentation</a>: </p>
<blockquote>
<p>Value converters allow property values to be converted when reading from or writing to the database. This conversion can be from one value to another of the same type (for example, encrypting strings) or from a value of one type to a value of another type (for example, converting enum values to and from strings in the database.)</p>
</blockquote>
<p>The latter conversion, converting from one type to another, is what we need for the strongly-typed IDs. By using a value converter, we can convert our IDs into a <code>Guid</code>, just before they're written to the database. When reading a value, we convert the <code>Guid</code> value from the database into a strongly typed ID.</p>
<p>EF Core allows you to <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions#configuring-a-value-converter">configure value converters manually for each property in your modelling code using lambdas</a>. Alternatively, you can create reusable, standalone, custom value converters for each type. That's the approach I show here.</p>
<p>To implement a custom value converter you create an instance of a <code>ValueConverter&lt;TModel, TProvider&gt;</code>. <code>TModel</code> is the type being converted (the strongly-typed ID in our case), while <code>TProvider</code> is the database type. To create the converter you provide two lambda functions in the constructor arguments:</p>
<ul>
<li><code>convertToProviderExpression</code>: an expression that is used to convert the strongly-typed ID to the database value (a <code>Guid</code>)</li>
<li><code>convertFromProviderExpression</code>: an expression that is used to convert the database value (a <code>Guid</code>) into an instance of the strongly-typed ID.</li>
</ul>
<p>You can create an instance of the generic <code>ValueConverter&lt;&gt;</code> directly, but I chose to create a derived converter to simplify instantiating a new converter. Taking the <code>OrderId</code> example, we can create a custom <code>ValueConverter&lt;&gt;</code> using the following:</p>
<pre><code><span>public</span> <span>class</span> <span>OrderIdValueConverter</span> <span>:</span> <span>ValueConverter</span><span>&lt;</span>OrderId<span>,</span> Guid<span>&gt;</span>
<span>{</span>
    <span>public</span> <span>OrderIdValueConverter</span><span>(</span><span>ConverterMappingHints</span> mappingHints <span>=</span> <span>null</span><span>)</span>
        <span>:</span> <span>base</span><span>(</span>
            id <span>=</span><span>&gt;</span> id<span>.</span>Value<span>,</span>
            <span>value</span> <span>=</span><span>&gt;</span> <span>new</span> <span>OrderId</span><span>(</span><span>value</span><span>)</span><span>,</span>
            mappingHints
        <span>)</span> <span>{</span> <span>}</span>
<span>}</span>
</code></pre>
<p>The lambda functions are simple - to obtain a <code>Guid</code> we use the <code>Value</code> property of the ID, and to create a new instance of the ID we pass the <code>Guid</code> to the constructor. The <code>ConverterMappingHints</code> parameter can allow setting things such as <code>Scale</code> and <code>Precision</code> for some database types. We don't need it here but I've included it for completeness in this example.</p>
<h2 id="registering-the-custom-valueconverter-with-ef-core-s-db-context">Registering the custom ValueConverter with EF Core's DB Context<a href="#registering-the-custom-valueconverter-with-ef-core-s-db-context"></a></h2>
<p>The value converters describe how to store our strongly-typed IDs in the database, but EF Core need's to know <em>when</em> to use each converter. There's no way to do this using attributes, so you need to customise the model in <code>DbContext.OnModelCreating</code>. That makes for some pretty verbose code:</p>
<pre><code><span>public</span> <span>class</span> <span>ApplicationDbContext</span> <span>:</span> <span>IdentityDbContext</span>
<span>{</span>
    <span>public</span> <span>ApplicationDbContext</span><span>(</span>DbContextOptions<span>&lt;</span>ApplicationDbContext<span>&gt;</span> options<span>)</span>
        <span>:</span> <span>base</span><span>(</span>options<span>)</span>
    <span>{</span> <span>}</span>

    <span>public</span> DbSet<span>&lt;</span>Order<span>&gt;</span> Orders <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>protected</span> <span>override</span> <span>void</span> <span>OnModelCreating</span><span>(</span><span>ModelBuilder</span> builder<span>)</span>
    <span>{</span>
        <span>base</span><span>.</span><span>OnModelCreating</span><span>(</span>builder<span>)</span><span>;</span>

        builder
            <span>.</span><span><span>Entity</span><span>&lt;</span><span>Order</span><span>&gt;</span></span><span>(</span><span>)</span>
            <span>.</span><span>Property</span><span>(</span>o <span>=</span><span>&gt;</span> o<span>.</span>OrderId<span>)</span>
            <span>.</span><span>HasConversion</span><span>(</span><span>new</span> <span>OrderIdValueConverter</span><span>(</span><span>)</span><span>)</span><span>;</span>

        builder
            <span>.</span><span><span>Entity</span><span>&lt;</span><span>OrderLine</span><span>&gt;</span></span><span>(</span><span>)</span>
            <span>.</span><span>Property</span><span>(</span>o <span>=</span><span>&gt;</span> o<span>.</span>OrderLineId<span>)</span>
            <span>.</span><span>HasConversion</span><span>(</span><span>new</span> <span>OrderLineIdValueConverter</span><span>(</span><span>)</span><span>)</span><span>;</span>

        builder
            <span>.</span><span><span>Entity</span><span>&lt;</span><span>Order</span><span>&gt;</span></span><span>(</span><span>)</span>
            <span>.</span><span>Property</span><span>(</span>o <span>=</span><span>&gt;</span> o<span>.</span>OrderId<span>)</span>
            <span>.</span><span>HasConversion</span><span>(</span><span>new</span> <span>OrderIdValueConverter</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>It's clearly not optimal having to add a manual mapping for <em>each</em> usage of a strongly-typed ID in your entities. Luckily we can simplify this code somewhat.</p>
<h2 id="automatically-using-a-value-converter-for-all-properties-of-a-given-type-">Automatically using a value converter for all properties of a given type.<a href="#automatically-using-a-value-converter-for-all-properties-of-a-given-type-"></a></h2>
<p>Ideally our custom value converters would be used automatically by EF Core every time a given strongly-typed ID is used. <a href="https://github.com/aspnet/EntityFrameworkCore/issues/10784">There's an issue on GitHub for exactly this functionality</a>, but in the meantime, we can emulate the behaviour by looping over all the model entities, as <a href="https://github.com/aspnet/EntityFrameworkCore/issues/10784#issuecomment-415769754">described in a comment on that issue</a>.</p>
<p>In the code below, we loop over every entity in the model, and for each entity, find all those properties that are of the required type (<code>OrderId</code> for the <code>OrderIdValueConverter</code>). For each property we register the <code>ValueConverter</code>, in a process similar to the manual registrations above:</p>
<pre><code><span>public</span> <span>static</span> <span>class</span> <span>ModelBuilderExtensions</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>ModelBuilder</span> <span>UseValueConverter</span><span>(</span>
        <span>this</span> <span>ModelBuilder</span> modelBuilder<span>,</span> <span>ValueConverter</span> converter<span>)</span>
    <span>{</span>
        
        <span>var</span> type <span>=</span> converter<span>.</span>ModelClrType<span>;</span>

        
        <span>foreach</span> <span>(</span><span>var</span> entityType <span>in</span> modelBuilder<span>.</span>Model<span>.</span><span>GetEntityTypes</span><span>(</span><span>)</span><span>)</span>
        <span>{</span>
            
            <span>var</span> properties <span>=</span> entityType
                <span>.</span>ClrType
                <span>.</span><span>GetProperties</span><span>(</span><span>)</span>
                <span>.</span><span>Where</span><span>(</span>p <span>=</span><span>&gt;</span> p<span>.</span>PropertyType <span>==</span> type<span>)</span><span>;</span>

            <span>foreach</span> <span>(</span><span>var</span> property <span>in</span> properties<span>)</span>
            <span>{</span>
                
                modelBuilder
                    <span>.</span><span>Entity</span><span>(</span>entityType<span>.</span>Name<span>)</span>
                    <span>.</span><span>Property</span><span>(</span>property<span>.</span>Name<span>)</span>
                    <span>.</span><span>HasConversion</span><span>(</span>converter<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> modelBuilder<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>All that remains is to register the value converter for each strongly-typed ID type in the DbContext:</p>
<pre><code><span>public</span> <span>class</span> <span>ApplicationDbContext</span> <span>:</span> <span>IdentityDbContext</span>
<span>{</span>
    <span>public</span> <span>ApplicationDbContext</span><span>(</span>DbContextOptions<span>&lt;</span>ApplicationDbContext<span>&gt;</span> options<span>)</span>
        <span>:</span> <span>base</span><span>(</span>options<span>)</span>
    <span>{</span> <span>}</span>

    <span>public</span> DbSet<span>&lt;</span>Order<span>&gt;</span> Orders <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>protected</span> <span>override</span> <span>void</span> <span>OnModelCreating</span><span>(</span><span>ModelBuilder</span> builder<span>)</span>
    <span>{</span>
        <span>base</span><span>.</span><span>OnModelCreating</span><span>(</span>builder<span>)</span><span>;</span>

        builder<span>.</span><span>UseValueConverter</span><span>(</span><span>new</span> <span>OrderIdValueConverter</span><span>(</span><span>)</span><span>)</span>
        builder<span>.</span><span>UseValueConverter</span><span>(</span><span>new</span> <span>OrderLineIdValueConverter</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>It's a bit frustrating having to manually register each of these value converters - every time you create a new strongly typed ID you have to remember to register it in the <code>DbContext</code>. </p>
<blockquote>
<p>Creating the <code>ValueConverter</code> implementation itself for every strongly-typed ID is not a big deal if you're using snippets to generate your IDs, like I <a href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#that-s-a-lot-of-boilerplate-code-">described in the last post</a>.</p>
</blockquote>
<p>It would be nice if we were able to generate a new ID, use it in an entity, and not have to remember to update the <code>OnModelCreating</code> method.</p>
<h2 id="automatically-registering-value-converters-for-strongly-typed-ids">Automatically registering value converters for strongly typed IDs<a href="#automatically-registering-value-converters-for-strongly-typed-ids"></a></h2>
<p>We can achieve this functionality with a little bit of reflection and some attributes. We'll start by creating an attribute that we can use to link each strongly-typed ID to a specific value converter, called <code>EfCoreValueConverterAttribute</code>:</p>
<pre><code><span>public</span> <span>class</span> <span>EfCoreValueConverterAttribute</span> <span>:</span> <span>Attribute</span>
<span>{</span>
    <span>public</span> <span>EfCoreValueConverterAttribute</span><span>(</span><span>Type</span> valueConverter<span>)</span>
    <span>{</span>
        ValueConverter <span>=</span> valueConverter<span>;</span>
    <span>}</span>

    <span>public</span> <span>Type</span> ValueConverter <span>{</span> <span>get</span><span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<p>We'll decorate each strongly typed ID with the attribute as part of the snippet generation, which will give something like the following:</p>
<pre><code>
<span>[</span><span>EfCoreValueConverter</span><span>(</span><span>typeod</span><span>(</span>OrderIdValueConverter<span>)</span><span>)</span><span>]</span>
<span>public</span> <span>readonly</span> <span>struct</span> OrderId <span>:</span> IComparable<span>&lt;</span>OrderId<span>&gt;</span><span>,</span> IEquatable<span>&lt;</span>OrderId<span>&gt;</span>
<span>{</span>
    <span>public</span> <span>Guid</span> Value <span>{</span> <span>get</span><span>;</span> <span>}</span>
    <span>public</span> <span>OrderId</span><span>(</span><span>Guid</span> <span>value</span><span>)</span>
    <span>{</span>
        Value <span>=</span> <span>value</span><span>;</span>
    <span>}</span>

    
    <span>public</span> <span>class</span> <span>OrderIdValueConverter</span> <span>:</span> <span>ValueConverter</span><span>&lt;</span>OrderId<span>,</span> Guid<span>&gt;</span>
    <span>{</span>
        <span>public</span> <span>OrderIdValueConverter</span><span>(</span><span>)</span>
            <span>:</span> <span>base</span><span>(</span>
                id <span>=</span><span>&gt;</span> id<span>.</span>Value<span>,</span>
                <span>value</span> <span>=</span><span>&gt;</span> <span>new</span> <span>OrderId</span><span>(</span><span>value</span><span>)</span>
            <span>)</span> <span>{</span> <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>Next, we'll add another method to the <code>ModelBuilderExtensions</code> this loops through all the types in an <code>Assembly</code> and finds all those that are decorated with the <code>EfCoreValueConverterAttribute</code> (i.e. the strongly typed IDs). The <code>Type</code> of the value converter is extracted from the custom attribute, and an instance of the value converter is created using the <code>ValueConverter</code>. We can then pass that to the <code>UseValueConverter</code> method we created previously.</p>
<pre><code><span>public</span> <span>static</span> <span>class</span> <span>ModelBuilderExtensions</span>
    <span>{</span>
        <span>public</span> <span>static</span> ModelBuilder <span><span>AddStronglyTypedIdValueConverters</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span>
            <span>this</span> <span>ModelBuilder</span> modelBuilder<span>)</span>
        <span>{</span>
            <span>var</span> assembly <span>=</span> <span>typeof</span><span>(</span>T<span>)</span><span>.</span>Assembly<span>;</span>
            <span>foreach</span> <span>(</span><span>var</span> type <span>in</span> assembly<span>.</span><span>GetTypes</span><span>(</span><span>)</span><span>)</span>
            <span>{</span>
                
                <span>var</span> attribute <span>=</span> type
                    <span>.</span><span><span>GetCustomAttributes</span><span>&lt;</span><span>EfCoreValueConverterAttribute</span><span>&gt;</span></span><span>(</span><span>)</span>
                    <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>attribute <span>is</span> <span>null</span><span>)</span>
                <span>{</span>
                    <span>continue</span><span>;</span>
                <span>}</span>

                
                <span>var</span> converter <span>=</span> <span>(</span>ValueConverter<span>)</span> Activator<span>.</span><span>CreateInstance</span><span>(</span>attribute<span>.</span>ValueConverter<span>)</span><span>;</span>

                
                modelBuilder<span>.</span><span>UseValueConverter</span><span>(</span>converter<span>)</span><span>;</span>
            <span>}</span>

            <span>return</span> modelBuilder<span>;</span>
        <span>}</span>

        
        <span>public</span> <span>static</span> <span>ModelBuilder</span> <span>UseValueConverter</span><span>(</span>
            <span>this</span> <span>ModelBuilder</span> modelBuilder<span>,</span> <span>ValueConverter</span> converter<span>)</span>
        <span>{</span>
            <span>var</span> type <span>=</span> converter<span>.</span>ModelClrType<span>;</span>

            <span>foreach</span> <span>(</span><span>var</span> entityType <span>in</span> modelBuilder<span>.</span>Model<span>.</span><span>GetEntityTypes</span><span>(</span><span>)</span><span>)</span>
            <span>{</span>
                <span>var</span> properties <span>=</span> entityType
                    <span>.</span>ClrType
                    <span>.</span><span>GetProperties</span><span>(</span><span>)</span>
                    <span>.</span><span>Where</span><span>(</span>p <span>=</span><span>&gt;</span> p<span>.</span>PropertyType <span>==</span> type<span>)</span><span>;</span>

                <span>foreach</span> <span>(</span><span>var</span> property <span>in</span> properties<span>)</span>
                <span>{</span>
                    modelBuilder
                        <span>.</span><span>Entity</span><span>(</span>entityType<span>.</span>Name<span>)</span>
                        <span>.</span><span>Property</span><span>(</span>property<span>.</span>Name<span>)</span>
                        <span>.</span><span>HasConversion</span><span>(</span>converter<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>return</span> modelBuilder<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<p>With this code in place, we can register <em>all</em> our value converters in one fell swoop in the <code>DbContext.OnModelCreating</code> method:</p>
<pre><code><span>public</span> <span>class</span> <span>ApplicationDbContext</span> <span>:</span> <span>IdentityDbContext</span>
<span>{</span>
    <span>public</span> <span>ApplicationDbContext</span><span>(</span>DbContextOptions<span>&lt;</span>ApplicationDbContext<span>&gt;</span> options<span>)</span>
        <span>:</span> <span>base</span><span>(</span>options<span>)</span>
    <span>{</span>
    <span>}</span>

    <span>public</span> DbSet<span>&lt;</span>Order<span>&gt;</span> Orders <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>protected</span> <span>override</span> <span>void</span> <span>OnModelCreating</span><span>(</span><span>ModelBuilder</span> builder<span>)</span>
    <span>{</span>
        <span>base</span><span>.</span><span>OnModelCreating</span><span>(</span>builder<span>)</span><span>;</span>

        
        builder<span>.</span><span><span>AddStronglyTypedIdValueConverters</span><span>&lt;</span><span>OrderId</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>The type parameter <code>OrderId</code> in the above example is used to identify the <code>Assembly</code> to scan to find the strongly-typed IDs. If required, it would be simple to add another overload to allowing scanning multiple assemblies. </p>
<p>With the code above, we don't have to touch the <code>DbContext</code> when we add a new strongly-typed ID, which is a much better experience for developers. If we run the migrations now, all is well:</p>
<pre><code><span>&gt;</span> dotnet ef migrations add OrderSchema

Done. To undo this action, use <span>'ef migrations remove'</span>
</code></pre>
<p>If you check the generated migration, you'll see that the <code>OrderId</code> column is created as a non-nullable <code>Guid</code>, and is the primary key, as you'd expect.</p>
<pre><code><span>public</span> <span>partial</span> <span>class</span> <span>OrderSchema</span> <span>:</span> <span>Migration</span>
<span>{</span>
    <span>protected</span> <span>override</span> <span>void</span> <span>Up</span><span>(</span><span>MigrationBuilder</span> migrationBuilder<span>)</span>
    <span>{</span>
        migrationBuilder<span>.</span><span>CreateTable</span><span>(</span>
            name<span>:</span> <span>"Orders"</span><span>,</span>
            columns<span>:</span> table <span>=</span><span>&gt;</span> <span>new</span>
            <span>{</span>
                OrderId <span>=</span> table<span>.</span><span><span>Column</span><span>&lt;</span><span>Guid</span><span>&gt;</span></span><span>(</span>nullable<span>:</span> <span>false</span><span>)</span><span>,</span>
                Name <span>=</span> table<span>.</span><span><span>Column</span><span>&lt;</span><span>string</span><span>&gt;</span></span><span>(</span>nullable<span>:</span> <span>true</span><span>)</span>
            <span>}</span><span>,</span>
            constraints<span>:</span> table <span>=</span><span>&gt;</span>
            <span>{</span>
                table<span>.</span><span>PrimaryKey</span><span>(</span><span>"PK_Orders"</span><span>,</span> x <span>=</span><span>&gt;</span> x<span>.</span>OrderId<span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>This solves most of the problems you'll encounter using strongly typed IDs with EF Core, but there's one place where this doesn't quite work, and unfortunately, it might be a deal breaker.</p>
<h2 id="custom-value-converters-result-in-client-side-evaluation">Custom value converters result in client-side evaluation<a href="#custom-value-converters-result-in-client-side-evaluation"></a></h2>
<p>Saving entities that use your strongly-typed IDs to the database is no problem for EF Core. However, if you try and load an entity from the database, and filter based on the strongly-typed ID:</p>
<pre><code><span>var</span> order <span>=</span> _dbContext<span>.</span>Orders
    <span>.</span><span>Where</span><span>(</span>order <span>=</span><span>&gt;</span> order<span>.</span>OrderId <span>==</span> orderId<span>)</span>
    <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>then you'll see a warning in the logs that the <code>where</code> clause must be evaluated <em>client-side</em>: </p>
<pre><code>warn: Microsoft.EntityFrameworkCore.Query<span>[</span>20500<span>]</span>
      The LINQ expression <span>'where ([x].OrderId == __orderId_0)'</span> 
      could not be translated and will be evaluated locally.

info: Microsoft.EntityFrameworkCore.Database.Command<span>[</span>20101<span>]</span>
      Executed DbCommand <span>(</span>12ms<span>)</span> <span>[</span>Parameters<span>=</span><span>[</span><span>]</span>, CommandType<span>=</span><span>'Text'</span>, CommandTimeout<span>=</span><span>'30'</span><span>]</span>
      SELECT <span>[</span>x<span>]</span>.<span>[</span>OrderId<span>]</span>, <span>[</span>x<span>]</span>.<span>[</span>Name<span>]</span>
      FROM <span>[</span>Orders<span>]</span> AS <span>[</span>x<span>]</span>
</code></pre>
<p>That's terrible. This query has got to be a contender for the most common thing you'll ever do, and the above solution will not be good enough. Fetching an <code>Order</code> by ID with client-side execution involves loading <em>all</em> <code>Order</code>s into memory and filtering in memory!</p>
<p>In fairness <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions">the documentation</a> does mention this limitation right at the bottom of the page (emphasis mine):</p>
<blockquote>
<p>Use of value conversions <strong>may</strong> impact the ability of EF Core to translate expressions to SQL. A warning will be logged for such cases. Removal of these limitations is being considered for a future release.</p>
</blockquote>
<p>But this value converter is pretty much the most basic you could imagine - if this converter results in client-side evaluation, they all will! </p>
<p>There is <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12045">an issue to track this problem</a>, but unfortunately there's no easy work around to this one. üôÅ </p>
<p>All is not <em>entirely</em> lost. It's not pretty, but after some playing I eventually found something that will let you use strongly-typed IDs in your EF Core models that doesn't force client-side evaluation.</p>
<h2 id="avoiding-client-side-evaluation-in-ef-core-with-conversion-operators">Avoiding client-side evaluation in EF Core with conversion operators<a href="#avoiding-client-side-evaluation-in-ef-core-with-conversion-operators"></a></h2>
<p>The key is adding implicit or explicit conversion operators to the strongly-typed IDs, such that EF Core doesn't bork on seeing the strongly-typed ID in a query. There's two possible options, an explicit conversion operator, or an implicit conversion operator.</p>
<h3 id="using-an-explicit-conversion-operator-with-strongly-typed-ids">Using an explicit conversion operator with strongly typed IDs<a href="#using-an-explicit-conversion-operator-with-strongly-typed-ids"></a></h3>
<p>The first approach is to add an explicit conversion operator to your strongly-typed ID to go from the ID type to a <code>Guid</code>:</p>
<pre><code><span>public</span> <span>readonly</span> <span>struct</span> OrderId
<span>{</span>
    <span>public</span> <span>static</span> <span>explicit</span> <span>operator</span> <span>Guid</span><span>(</span><span>OrderId</span> orderId<span>)</span> <span>=</span><span>&gt;</span> orderId<span>.</span>Value<span>;</span>

    
<span>}</span>
</code></pre>
<p>Adding this sort of operator means you can cast an <code>OrderId</code> to a <code>Guid</code>, for example:</p>
<pre><code><span>var</span> orderId <span>=</span> <span>new</span> <span>OrderId</span><span>(</span>Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>var</span> result <span>=</span> <span>(</span>Guid<span>)</span> orderId<span>;</span> 
</code></pre>
<p>So how does that help? Essentially we can trick EF Core into running the query server-side, by using a construction similar to the following:</p>
<pre><code><span>Guid</span> orderIdValue <span>=</span> orderId<span>.</span>Value<span>;</span> 
<span>var</span> order <span>=</span> _dbContext<span>.</span>Orders
    <span>.</span><span>Where</span><span>(</span>order <span>=</span><span>&gt;</span> <span>(</span>Guid<span>)</span> order<span>.</span>OrderId <span>==</span> orderIdValue<span>)</span> 
    <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>The key point is the explicit conversion of <code>order.OrderId</code> to a <code>Guid</code>. When EF Core evaluates the query, it no longer sees an <code>OrderId</code> type that it doesn't know what to do with, and instead generates the SQL we wanted in the first place:</p>
<pre><code>info: Microsoft.EntityFrameworkCore.Database.Command<span>[</span>20101<span>]</span>
      Executed DbCommand <span>(</span>7ms<span>)</span> <span>[</span>Parameters<span>=</span><span>[</span>@__orderId_Value_0<span>=</span><span>'?'</span> <span>(</span>DbType <span>=</span> Guid<span>)</span><span>]</span>, CommandType<span>=</span><span>'Text'</span>, CommandTimeout<span>=</span><span>'30'</span><span>]</span>
      SELECT TOP<span>(</span>1<span>)</span> <span>[</span>x<span>]</span>.<span>[</span>OrderId<span>]</span>, <span>[</span>x<span>]</span>.<span>[</span>Name<span>]</span>
      FROM <span>[</span>Orders<span>]</span> AS <span>[</span>x<span>]</span>
      WHERE <span>[</span>x<span>]</span>.<span>[</span>OrderId<span>]</span> <span>=</span> @__orderId_Value_0
</code></pre>
<p>This shows the <code>where</code> clause being sent to the database, so all is well again. Well, apart from the fact it's an ugly hack. üòï Implicit operators make the process very slightly less ugly.</p>
<h3 id="using-an-implicit-conversion-operator-with-strongly-typed-ids">Using an implicit conversion operator with strongly typed IDs<a href="#using-an-implicit-conversion-operator-with-strongly-typed-ids"></a></h3>
<p>The implicit conversion operator implementation is almost identical to the explicit implementation, just with a different keyword:</p>
<pre><code><span>public</span> <span>readonly</span> <span>struct</span> OrderId
<span>{</span>
    <span>public</span> <span>static</span> <span>implicit</span> <span>operator</span> <span>Guid</span><span>(</span><span>OrderId</span> orderId<span>)</span> <span>=</span><span>&gt;</span> orderId<span>.</span>Value<span>;</span>

    
<span>}</span>
</code></pre>
<p>With this code, you no longer need an explicit <code>(Guid)</code> cast to convert an <code>OrderId</code> to a <code>Guid</code>, so we can write the query as:</p>
<pre><code><span>Guid</span> orderIdValue <span>=</span> orderId<span>.</span>Value<span>;</span> 
<span>var</span> order <span>=</span> _dbContext<span>.</span>Orders
    <span>.</span><span>Where</span><span>(</span>order <span>=</span><span>&gt;</span> order<span>.</span>OrderId <span>==</span> orderIdValue<span>)</span> 
    <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>This query generates identical SQL, so technically you could use either approach. But which should you choose?</p>
<h3 id="implicit-vs-explicit-operators">Implicit vs Explicit operators<a href="#implicit-vs-explicit-operators"></a></h3>
<p>For simple ugliness, the implicit operator seems slightly preferable, as you don't have to add the extra cast, but I'm not sure if that's a bad thing. The trouble is that the implicit conversions apply throughout your code base, so suddenly code like this will compile:</p>
<pre><code><span>public</span> <span>Order</span> <span>GetOrderForUser</span><span>(</span><span>Guid</span> orderId<span>,</span> <span>Guid</span> userId<span>)</span>
<span>{</span>
    
<span>}</span>

<span>OrderId</span> orderId <span>=</span> OrderId<span>.</span><span>New</span><span>(</span><span>)</span><span>;</span>
<span>UserId</span> userId <span>=</span> UserId<span>.</span><span>New</span><span>(</span><span>)</span><span>;</span>

<span>var</span> order <span>=</span> <span>GetOrderForUser</span><span>(</span>userId<span>,</span> orderId<span>)</span><span>;</span> 
</code></pre>
<p>The <code>GetOrderForUser()</code> method should obviously be using the strongly-typed IDs, but the fact that this is possible without any indication of errors just makes me a little uneasy. For that reason, I think I prefer the explicit operators. </p>
<p>Either way, you should definitely hide away the cast from callers wherever possible:</p>
<pre><code>
<span>public</span> <span>class</span> <span>OrderService</span>
<span>{</span>
    
    <span>public</span> <span>Order</span> <span>GetOrder</span><span>(</span><span>OrderId</span> orderId<span>)</span> <span>=</span><span>&gt;</span> <span>GetOrder</span><span>(</span>orderId<span>.</span>Value<span>)</span><span>;</span>

    
    <span>private</span> <span>Order</span> <span>GetOrder</span><span>(</span><span>Guid</span> orderId<span>)</span>
    <span>{</span>
        <span>return</span> _dbContext<span>.</span>Orders
            <span>.</span><span>Where</span><span>(</span>x <span>=</span><span>&gt;</span> <span>(</span>Guid<span>)</span> x<span>.</span>OrderId <span>==</span> orderId<span>)</span>
            <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>


<span>public</span> <span>class</span> <span>OrderService</span>
<span>{</span>
    
    <span>public</span> <span>Order</span> <span>GetOrder</span><span>(</span><span>OrderId</span> orderId<span>)</span> <span>=</span><span>&gt;</span> <span>GetOrder</span><span>(</span>orderId<span>.</span>Value<span>)</span><span>;</span>

    
    <span>private</span> <span>Order</span> <span>GetOrder</span><span>(</span><span>Guid</span> orderId<span>)</span>
    <span>{</span>
        <span>return</span> _dbContext<span>.</span>Orders
            <span>.</span><span>Where</span><span>(</span>x <span>=</span><span>&gt;</span> x<span>.</span>OrderId <span>==</span> orderId<span>)</span> 
            <span>.</span><span>FirstOrDefault</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>It's probably also worth configuring your <code>DbContext</code> to throw an error when client-side evaluation occurs so you don't get client-side errors creeping in without you noticing. Override the <code>DbContext.OnConfiguring</code> method, and configure the options:</p>
<pre><code><span>protected</span> <span>override</span> <span>void</span> <span>OnConfiguring</span><span>(</span><span>DbContextOptionsBuilder</span> optionsBuilder<span>)</span>
<span>{</span>
    optionsBuilder<span>.</span><span>ConfigureWarnings</span><span>(</span>warning <span>=</span><span>&gt;</span> 
            warning<span>.</span><span>Throw</span><span>(</span>RelationalEventId<span>.</span>QueryClientEvaluationWarning<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<p>Even with all this effort, there's still gotchas. As well as standard <code>IQueryable&lt;T&gt;</code> LINQ syntax, the <code>DbSet&lt;&gt;</code> exposes a <code>Find</code> method which is effectively a shorthand for <code>SingleOrDefault()</code> for querying by an entities primary key. Unfortunately, nothing we do here will work:</p>
<pre><code><span>var</span> orderId <span>=</span> <span>new</span> <span>OrderId</span><span>(</span>Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span><span>)</span><span>;</span>
_dbContext<span>.</span>Orders<span>.</span><span>Find</span><span>(</span>orderId<span>)</span><span>;</span> 
_dbContext<span>.</span>Orders<span>.</span><span>Find</span><span>(</span>order<span>.</span>Value<span>)</span><span>;</span> 
</code></pre>
<p>So close‚Ä¶</p>
<p>This post is plenty long enough, and I haven't <em>quite</em> worked out a final solution but I have a couple of ideas. Check back in a couple of days, and hopefully I'll have it figured out üôÇ</p>
<h2 id="summary">Summary<a href="#summary"></a></h2>
<p>In this post I explored possible solutions that would allow you to use strongly-typed IDs directly in your EF Core entities. The <code>ValueConverter</code> approach described in this post gets you 90% of the way there, but unfortunately the fact that queries will be executed client-side really makes the whole approach more difficult <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12045">until this issue is resolved</a>. You can get <em>some</em> success by using explicit or implicit conversions, but there are still edge cases. I'm playing with a different approach as we speak, and hope to have something working in a couple of days, so check back soon!</p>
</div>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>