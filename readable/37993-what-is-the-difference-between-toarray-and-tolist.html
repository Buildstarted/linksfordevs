<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What is the difference between ToArray and&#xA0;ToList? -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>What is the difference between ToArray and&#xA0;ToList?</h1>
    <div id="content" class="site-content"> <p id="primary" class="content-area"> <main id="main" class="site-main"> <article id="post-1333" class="post-1333 post type-post status-publish format-standard hentry category-developers-story tag-net tag-c"> <div class="entry-content"> <p>In the beginning of June I attended <a href="https://dotnetsummit.by/">.NET Summit</a> conference in Minsk, Belarus. Besides interesting presentations (recording are available on <a href="https://www.youtube.com/playlist?list=PLpVeA1tdgfCDIuCqslWaTpOUBQRPIHTM2&amp;utm_source=.NET+Summit+2019+-+ORG+Info+for+Attendees&amp;utm_campaign=b75f7fe4a9-90201+RubyConfBY+introduction_COPY_01&amp;utm_medium=email&amp;utm_term=0_44625ef95f-b75f7fe4a9-417654865">YouTube</a>, language is Russian / English) there were interesting quizzes. </p> <p>One of the questions was:</p> <blockquote class="wp-block-quote"><p> What is the difference between <code>ToArray</code> and <code>ToList</code>?</p><cite>Software Engineer</cite></blockquote> <p>Hmm&#x2026; what could be the difference besides one returns <code>T[]</code> and another one returns <code>List&lt;T&gt;</code>?</p> <p>If you don&#x2019;t know the answer or just like digging into sources of <a href="https://github.com/dotnet/corefx/blob/release/3.0/README.md">dotnet/corefx</a> then I invite you to join me and find out the answer!</p> <div class="wp-block-group note"><div class="wp-block-group__inner-container">
<div class="wp-block-group note-section"><div class="wp-block-group__inner-container">
<p><strong>Note</strong></p> <p>All code snippets were taken from <a href="https://github.com/dotnet/corefx/blob/release/3.0/README.md">release/3.0 branch of dotnet/corefx</a> repository. All code snippets were truncated to make them more representative (removed input argument checks, contracts, &#x2026;, etc.).</p><p>Tests were targeting .NET Core 3.0 preview 7. However most of the information should be relevant for .NET Core 2.0+ and .NET Framework 4.5+.</p></div></div></div></div></div></article></main></p> <span id="more-1333"></span> <h2>Benchmark</h2> <p>Every journey has it&#x2019;s first step. I usually start with a simple benchmark.</p> <p>Here is one I&#x2019;ve created using <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>:</p> <pre class="brush: csharp; auto-links: false; title: ; notranslate">
[CoreJob]
[RPlotExporter, MemoryDiagnoser, RankColumn]
public class ToArrayToList
{
  private IEnumerable&lt;int&amp;gt; data;

  [Params(10, 100, 1000, 10000)]
  public int N;

  [GlobalSetup]
  public void Setup()
  {
    this.data = new int[this.N];
  }

  [Benchmark]
  public int[] ToArray() =&amp;gt; this.data.ToArray();

  [Benchmark]
  public List&lt;int&amp;gt; ToList() =&amp;gt; this.data.ToList();
}

public class Program
{
  public static void Main(string[] args)
  {
    var summary = BenchmarkRunner.Run&lt;ToArrayToList&amp;gt;();
  }
}
</pre> <p>On my machine this benchmark produces the following results:</p> <figure class="wp-block-table"><table class><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>49.527 ns</td><td>0.0153</td><td>&#x2013;</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>45.850 ns</td><td>0.0229</td><td>&#x2013;</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>82.490 ns</td><td>0.1013</td><td>&#x2013;</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>78.811 ns</td><td>0.1090</td><td>&#x2013;</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>324.100 ns</td><td>0.9613</td><td>&#x2013;</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>321.039 ns</td><td>0.9689</td><td>&#x2013;</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>3,223.046 ns</td><td>9.5215</td><td>1.1902</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>3,278.019 ns</td><td>9.5215</td><td>1.9035</td><td>40056 B</td></tr></tbody></table></figure> <p>At the first glance there is no significant difference between two methods. However in such cases it is important to be absolutely sure and the only way to make sure is to examine the source code.</p> <h3>Examining ToArray and ToList methods</h3> <p>All required source code is on <a href="https://github.com/">GitHub </a>so it is easy to find implementations of <code>ToArray</code> and <code>ToList</code> methods inside <a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository:</p> <pre class="brush: csharp; auto-links: false; highlight: [7,15]; title: ; notranslate">
public static partial class Enumerable
{
  // ...
  public static TSource[] ToArray&lt;TSource&amp;gt;(
    this IEnumerable&lt;TSource&amp;gt; source)
  {
    return source is IIListProvider&lt;TSource&amp;gt; arrayProvider
      ? arrayProvider.ToArray()
      : EnumerableHelpers.ToArray(source);
  }
  // ...
  public static List&lt;TSource&amp;gt; ToList&lt;TSource&amp;gt;(
    this IEnumerable&lt;TSource&amp;gt; source)
  {
    return source is IIListProvider&lt;TSource&amp;gt; listProvider 
      ? listProvider.ToList() 
      : new List&lt;TSource&amp;gt;(source);
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L11">ToArray</a> and <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L23">ToList</a> were obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em> </p> <p>Both methods start from an attempt to convert input <code>source</code> to <code>IIListProvider&lt;TSource&gt;</code> (lines: 7, 15) and since in benchmark input sequence is initialized as <code>int[]</code> array: </p> <pre class="brush: csharp; first-line: 9; highlight: [13]; title: ; notranslate">
// ...
[GlobalSetup]
public void Setup()
{
  this.data = new int[this.N];
}
// ...
</pre> <p>&#x2026; and in .NET all arrays are descendants of <code>System.Array</code> class which <strong>doesn&#x2019;t</strong> implement <code>IIListProvider&lt;T&gt;</code> interface &#x2013; we can be sure that execution proceeds right to the <code>else</code> branch. </p> <h3>Stepping into Enumerable.ToArray &#x201C;else&#x201D; branch</h3> <p>The <code>else</code> branch of <code>Enumerable.ToArray</code> continues with a call to <code>EnumerableHelpers.ToArray</code> method:</p> <pre class="brush: csharp; auto-links: false; highlight: [8,15,16]; title: ; notranslate">
internal static partial class EnumerableHelpers
{
  // ...
  
  internal static T[] ToArray&lt;T&amp;gt;(
    IEnumerable&lt;T&amp;gt; source)
  {
    if (source is ICollection&lt;T&amp;gt; collection)
    {
      int count = collection.Count;
      if (count == 0)
      {
        return Array.Empty&lt;T&amp;gt;();
      }
      var result = new T[count];
      collection.CopyTo(result, arrayIndex: 0);
      return result;
    }
    var builder = new LargeArrayBuilder&lt;T&amp;gt;(initialize: true);
    builder.AddRange(source);
    return builder.ToArray();
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs#L93">EnumerableHelpers.ToArray</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>Method starts with an attempt to convert input <code>source</code> to <code>ICollection&lt;T&gt;</code>. Successful conversion results into &#x201C;happy path&#x201D; where it allocates new array and copies all <code>source</code> (aliased as <code>collection</code>) items into it. </p> <h3>Stepping into Enumerable.ToList &#x201C;else&#x201D; branch</h3> <p> The <code>else</code> branch of <code>Enumerable.ToList</code> continues with an instantiation of a new <code>List&lt;T&gt;</code> object with <code>source</code> passed as constructor argument:</p> <pre class="brush: csharp; auto-links: false; highlight: [6,15,16]; title: ; notranslate">
internal static partial class EnumerableHelpers
{
  // ...
  public List(IEnumerable&lt;T&amp;gt; collection)
  {
    if (collection is ICollection&lt;T&amp;gt; c)
    {
      int count = c.Count;
      if (count == 0)
      {
        _items = s_emptyArray;
      }
      else
      {
        _items = new T[count];
        c.CopyTo(_items, 0);
        _size = count;
      }
    }
    else
    {
      _size = 0;
      _items = s_emptyArray;
      using (IEnumerator&lt;T&amp;gt; en = collection!.GetEnumerator())
      {
        while (en.MoveNext())
        {
          Add(en.Current);
        }
      }
    }
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>Method starts with the attempt to convert input <code>source</code> to <code>ICollection&lt;T&gt;</code>. Successful conversion results into &#x201C;happy path&#x201D; where it allocates new array and copies all <code>source</code> (aliased as <code>collection</code>) items into it. </p> <h3>Unexpected discovery</h3> <p>You might already noticed the reason why benchmark results are so close &#x1F642; If not let&#x2019;s take another look at the benchmark setup:</p> <pre class="brush: csharp; auto-links: false; first-line: 9; highlight: [13]; title: ; notranslate">
// ...
[GlobalSetup]
public void Setup()
{
  this.data = new int[this.N];
}
// ...
</pre> <p>Here we initialize sequence with <code>int[]</code> array. As was mentioned previously all arrays are descendants of <code>System.Array</code> class which <strong>does</strong> implement <code>ICollection&lt;T&gt;</code> interface. </p> <p>So both <code>ToArray</code> and <code>ToList</code> methods basically do the same thing:</p> <pre class="brush: csharp; auto-links: false; title: ; notranslate">
// ...
var array = new T[collection.Count];
collection.CopyTo(array, 0);
// ...
</pre> <p>While this isn&#x2019;t quite what one can expect from benchmark it is always important to know the edge cases. </p> <h2>Benchmark #2</h2> <p>Let&#x2019;s modify the benchmark to use <code>Enumerable.Range</code> method:</p> <pre class="brush: csharp; first-line: 9; highlight: [13]; title: ; notranslate">
// ...
[GlobalSetup]
public void Setup()
{
  this.data = Enumerable.Range(0, this.N);
}
// ...
</pre> <p>Executing this new benchmark on my machine produces the following results: </p> <figure class="wp-block-table"><table class><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>15.56 ns</td><td>0.0153</td><td>&#x2013;</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>31.97 ns</td><td>0.0229</td><td>&#x2013;</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>87.93 ns</td><td>0.1013</td><td>&#x2013;</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>176.19 ns</td><td>0.1090</td><td>&#x2013;</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>771.31 ns</td><td>0.9613</td><td>&#x2013;</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>1,568.32 ns</td><td>0.9689</td><td>&#x2013;</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>7,296.05 ns</td><td>9.5215</td><td>0.0076</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>15,276.89 ns</td><td>9.5215</td><td>0.0153</td><td>40056 B</td></tr></tbody></table></figure> <p>Wooow! These results looks amazing! Do you feel this? The feeling of uncovered conspiracy theory? &#x1F642; </p> <p>Before starting the celebration&#x2026; Have you noticed one very strange thing in these results?</p> <p>Here is a union of two tables where (#1 are the results of the first benchmark and #2 are the results of current benchmark):</p> <figure class="wp-block-table"><table class><thead><tr><th>Method</th><th>N</th><th>(#1) Mean</th><th>(#2) Mean </th><th>(#1) Allocated</th><th>(#2) Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>49.527 ns</td><td>15.56 ns</td><td>64 B</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>45.850 ns</td><td>31.97 ns</td><td>96 B</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>82.490 ns</td><td>87.93 ns</td><td>424 B</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>78.811 ns</td><td>176.19 ns</td><td>456 B</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>324.100 ns</td><td>771.31 ns</td><td>4024 B</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>321.039 ns</td><td>1,568.32 ns</td><td>4056 B</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>3,223.046 ns</td><td>7,296.05 ns</td><td>40024 B</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>3,278.019 ns</td><td>15,276.89 ns</td><td>40056 B</td><td>40056 B</td></tr></tbody></table></figure> <p>Can you see it? Both benchmarks allocate absolutely the same amount of memory. This is suspicious because in <strong>&#x201C;benchmark #1&#x201D;</strong> we were allocating fixed size array for the entire input sequence which is a by the way a bare minimum of memory we could use to store the sequence, so any extra allocation (which definitely should happen in <strong>&#x201C;benchmark #2&#x201D;</strong>) should make a difference.</p> <h3>Unexpected discovery #2</h3> <p>To better understand what is happening let&#x2019;s see what is exactly returned by <code>Enumerable.Range</code> method:</p> <pre class="brush: csharp; highlight: [13]; title: ; notranslate">
public static partial class Enumerable
{
  // ...
  public static IEnumerable&lt;int&amp;gt; Range(
    int start, 
    int count)
  {
    long max = ((long)start) + count - 1;
    if (count == 0)
    {
      return Empty&lt;int&amp;gt;();
    }
    return new RangeIterator(start, count);
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1083657c17b84248ea59896823f605ea63ce78a6/src/System.Linq/src/System/Linq/Range.cs#L12">Enumerable.Range</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>It returns a new instance of <code>RangeIterator</code> class which implements internal <code>IPartition&lt;T&gt;</code> interface:</p> <pre class="brush: csharp; title: ; notranslate">
private sealed partial class RangeIterator 
  : IPartition&lt;int&amp;gt;
{
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/de38804d52f6b65f0f290b81383f01e6943a6d8f/src/System.Linq/src/System/Linq/Range.SpeedOpt.cs#L11">RangeIterator</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p> Which in turn extends <code>IIListProvider&lt;TElement&gt;</code> interface: </p> <pre class="brush: csharp; title: ; notranslate">
internal interface IPartition&lt;TElement&amp;gt; 
  : IIListProvider&lt;TElement&amp;gt;
{
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1083657c17b84248ea59896823f605ea63ce78a6/src/System.Linq/src/System/Linq/IPartition.cs#L10">IPartition&lt;T&gt;</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>So basically the benchmark executes <code>ToArray</code> and <code>ToList</code> methods from <code>RangeIterator</code> class because now <code>source</code> is convertible to <code>IIListProvider&lt;TElement&gt;</code>:</p> <pre class="brush: csharp; highlight: [9,18]; title: ; notranslate">
public static partial class Enumerable
{
  // ...
  public static TSource[] ToArray&lt;TSource&amp;gt;(
    this IEnumerable&lt;TSource&amp;gt; source)
  {
    // ...
    return source is IIListProvider&lt;TSource&amp;gt; arrayProvider
      ? arrayProvider.ToArray()
      : EnumerableHelpers.ToArray(source);
  }
  // ...
  public static List&lt;TSource&amp;gt; ToList&lt;TSource&amp;gt;(
    this IEnumerable&lt;TSource&amp;gt; source)
  {
    // ...
    return source is IIListProvider&lt;TSource&amp;gt; listProvider 
      ? listProvider.ToList() 
      : new List&lt;TSource&amp;gt;(source);
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L11">ToArray</a> and <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L23">ToList</a> were obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>Implementation of <code>RangeIterator</code> clearly reveals the reason for such small memory footprint &#x2013; both methods pre-allocate <code>int[]</code> and <code>List&lt;int&gt;</code>:</p> <pre class="brush: csharp; highlight: [6,18]; title: ; notranslate">
private sealed partial class RangeIterator : IPartition&lt;int&amp;gt;
{
  // ...
  public int[] ToArray()
  {
    int[] array = new int[_end - _start];
    int cur = _start;
    for (int i = 0; i != array.Length; ++i)
    {
      array[i] = cur;
      ++cur;
    }
    return array;
  }
  // ...
  public List&lt;int&amp;gt; ToList()
  {
    List&lt;int&amp;gt; list = new List&lt;int&amp;gt;(_end - _start);
    for (int cur = _start; cur != _end; cur++)
    {
      list.Add(cur);
    }
    return list;
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/de38804d52f6b65f0f290b81383f01e6943a6d8f/src/System.Linq/src/System/Linq/Range.SpeedOpt.cs#L11">RangeIterator</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>This benchmark demonstrates one very important moment &#x2013; you never know where optimization is. </p> <h2>Benchmark #3</h2> <p>Let&#x2019;s modify the benchmark to use compiler generated iterator:</p> <pre class="brush: csharp; first-line: 9; highlight: [13]; title: ; notranslate">
// ...
[GlobalSetup]
public void Setup()
{
  this.data = this.GetEnumerable();
}

private IEnumerable&lt;int&amp;gt; GetEnumerable()
{
  for (var i = 0; i &lt; this.N; ++i)
  {
    yield return i;
  }
}
// ...
</pre> <p>Executing this new benchmark on my machine produces the following results: </p> <figure class="wp-block-table"><table class><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>185.7 ns</td><td>0.0610</td><td>&#x2013;</td><td>256 B</td></tr><tr><td>ToList</td><td>10</td><td>142.7 ns</td><td>0.0610</td><td>&#x2013;</td><td>256 B</td></tr><tr><td>ToArray</td><td>100</td><td>804.8 ns</td><td>0.2842</td><td>&#x2013;</td><td>1192 B</td></tr><tr><td>ToList</td><td>100</td><td>761.6 ns</td><td>0.2918</td><td>&#x2013;</td><td>1224 B</td></tr><tr><td>ToArray</td><td>1000</td><td>5,890.1 ns</td><td>2.0370</td><td>&#x2013;</td><td>8536 B</td></tr><tr><td>ToList</td><td>1000</td><td>5,770.2 ns</td><td>2.0218</td><td>&#x2013;</td><td>8464 B</td></tr><tr><td>ToArray</td><td>10000</td><td>56,033.2 ns</td><td>25.2686</td><td>&#x2013;</td><td>106224 B</td></tr><tr><td>ToList</td><td>10000</td><td>59,923.0 ns</td><td>31.1890</td><td>10.3760</td><td>131440 B</td></tr></tbody></table></figure> <p>These results looks much more realistic. However there is no absolute winner here but rather a sign to continue our journey (there is no obvious explanation of such a significant difference in <strong>Allocated</strong> column in last benchmark). </p> <p>Because compiler generated iterator doesn&#x2019;t implement neither <code>ICollection&lt;T&gt;</code> nor <code>IListProvider&lt;T&gt;</code> interfaces we now can be sure these results are produced by this piece of <code>EnumerableHelpers.ToArray</code> method:</p> <pre class="brush: csharp; highlight: [8,9,10]; title: ; notranslate">
internal static partial class EnumerableHelpers
{
  // ...
  internal static T[] ToArray&lt;T&amp;gt;(
    IEnumerable&lt;T&amp;gt; source)
  {
    // ...
    var builder = new LargeArrayBuilder&lt;T&amp;gt;(initialize: true);
    builder.AddRange(source);
    return builder.ToArray();
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs#L93">EnumerableHelpers.ToArray</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>&#x2026; and this piece of <code>List&lt;T&gt;</code> constructor:</p> <pre class="brush: csharp; highlight: [10,11,12,13,14,15,16,17,18]; title: ; notranslate">
public List(IEnumerable&lt;T&amp;gt; collection)
{
  // ...
  if (collection is ICollection&lt;T&amp;gt; c)
  {
    // ...
  }
  else
  {
    _size = 0;
    _items = s_emptyArray;
    using (IEnumerator&lt;T&amp;gt; en = collection!.GetEnumerator())
    {
      while (en.MoveNext())
      {
        Add(en.Current);
      }
    }
  }
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>To better understand results of last benchmark we need to find out how exactly <code>LargeArrayBuilder&lt;T&gt;</code> and <code>List&lt;T&gt;</code> allocate memory.</p> <h3>How LargeArrayBuilder&lt;T&gt; allocate?</h3> <p><code>LargeArrayBuilder&lt;T&gt;</code> is an internal struct used to create dynamically sized arrays. On the high-level what it does is it allocates multiple fixed sized arrays to store input items and then combines them into single array. This high-level overview is mostly enough to understand the big picture but in our case details are important. </p> <p>The <code>EnumerableHelpers.ToArray</code> method invokes the following <code>LargeArrayBuilder&lt;T&gt;</code> methods:</p> <ul><li><code>LargeArrayBuilder(initialize: true)</code></li><li><code>LargeArrayBuilder&lt;T&gt;.AddRange(source)</code></li><li><code>LargeArrayBuilder&lt;T&gt;.ToArray()</code></li></ul> <p>Let&#x2019;s see what each of these invocations does.</p> <h4>LargeArrayBuilder(initialize: true)</h4> <p>All instances of <code>LargeArrayBuilder&lt;T&gt;</code> structure are initialized with some maximum capacity value. This value limits the amount of memory instance can consume. In our case new instance is initialized with <code>int.MaxValue</code> value:</p> <pre class="brush: csharp; highlight: [15,22,23]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  private const int StartingCapacity = 4;
  private const int ResizeLimit = 8;
  // ...
  private readonly int _maxCapacity;  
  private T[] _first;   
  private ArrayBuilder&lt;T[]&amp;gt; _buffers; 
  private T[] _current;               
  private int _index;
  private int _count;
  // ...
  public LargeArrayBuilder(bool initialize)
    : this(maxCapacity: int.MaxValue)
  {
  }
  
  public LargeArrayBuilder(int maxCapacity)
    : this()
  {
    _first = _current = Array.Empty&lt;T&amp;gt;();
    _maxCapacity = maxCapacity;
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L30">LargeArrayBuilder&lt;T&gt;</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>Beside maximum capacity <code>LargeArrayBuider&lt;T&gt;</code> struct has a bunch of private fields and constants. </p> <p>Let&#x2019;s see what each of them does:</p> <figure class="wp-block-table"><table class><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><strong>ResizeLimit</strong></td><td>Integer constant, has value of 8.</td></tr><tr><td><strong>StartingCapacity</strong></td><td>Integer constant, has value of 4.</td></tr><tr><td><strong>_maxCapacity</strong> </td><td>The maximum capacity builder can have. </td></tr><tr><td><strong>_first</strong> </td><td>The first buffer items are stored in. Resized until <code>ResizeLimit</code>. </td></tr><tr><td><strong>_buffers</strong> </td><td>After <code>ResizeLimit * 2</code>, previously filled out buffers are stored here. </td></tr><tr><td><strong>_current</strong> </td><td>Currently filling buffer. If <code>_count &lt;= ResizeLimit</code>, this is <code>_first</code>. </td></tr><tr><td><strong>_index</strong> </td><td>Index into the current buffer. </td></tr><tr><td><strong>_count</strong> </td><td>Count of all of the items in this builder. </td></tr></tbody></table></figure> <h4>LargeArrayBuilder&lt;T&gt;.AddRange(source)</h4> <p>The next stop is <code>LargeArrayBuilder&lt;T&gt;.AddRange</code> method. This method iterates over input sequence and stores items in current buffer (aliased as <code>destination</code> (line: 8)): </p> <pre class="brush: csharp; highlight: [8,14,16]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  public void AddRange(IEnumerable&lt;T&amp;gt; items)
  {
    using (IEnumerator&lt;T&amp;gt; enumerator = items.GetEnumerator())
    {
      T[] destination = _current;
      int index = _index;
      while (enumerator.MoveNext())
      {
        T item = enumerator.Current;
                    
        if ((uint)index &amp;gt;= (uint)destination.Length)
        {
          AddWithBufferAllocation(item, ref destination, ref index);
        }
        else
        {
          destination[index] = item;
        }
                    
        index++;
      }
      _count += index - _index;
      _index = index;
    }
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L30">LargeArrayBuilder&lt;T&gt;.AddRange</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>When current buffer is filled out (line: 14) control is passed to <code>LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</code> method (line: 16): </p> <pre class="brush: csharp; highlight: [9,11]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  private void AddWithBufferAllocation(
    T item, 
    ref T[] destination, 
    ref int index)
  {
    _count += index - _index;
    _index = index;
    AllocateBuffer();
    // ...
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>This method increases count of items stored in builder by number of items filled in the current buffer (line: 9) and calls <code>LargeArrayBuilder&lt;T&gt;.AllocateBuffer</code> method (line: 11): </p> <pre class="brush: csharp; highlight: [9,10,11,12,13,14,15,22,26,27,29]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  private void AllocateBuffer()
  {
    if ((uint)_count &lt; (uint)ResizeLimit)
    {  
      int nextCapacity = Math.Min(
        _count == 0 ? StartingCapacity : _count * 2,
        _maxCapacity);

      _current = new T[nextCapacity];
      Array.Copy(_first, 0, _current, 0, _count);

      _first = _current;
    }
    else
    {
      int nextCapacity;
      if (_count == ResizeLimit)
      {
        nextCapacity = ResizeLimit;
      }
      else
      {
        _buffers.Add(_current);
        nextCapacity = Math.Min(_count, _maxCapacity - _count);
      }
      _current = new T[nextCapacity];
      _index = 0;
    }
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AllocateBuffer</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>The <code>LargeArrayBuilder&lt;T&gt;.AllocateBuffer</code> method is responsible for allocating a new buffer. However, what exactly this method does depends on the current count of items stored in builder:</p> <ul><li>When adding <strong>1st</strong> item (<code>_count == 0</code>) it allocates buffer of <code>StartingCapacity</code> size (which is 4) and stores it in <code>_first</code> and <code>_current</code> fields. This buffer is used to store first 4 items (lines: 9-15).</li><li>When adding <strong>5th</strong> item (<code>_count == 4</code>) it allocates buffer of <code>StartingCapacity * 2</code> (which is 8) size and stores it in <code>_first</code> and <code>_current</code> fields. The items from previous buffer are copied into new buffer. This buffer is used to store first 8 items (lines: 9-15).</li><li>When adding <strong>9th</strong> item (<code>_count == 8</code>) it allocates buffer of <code>ResizeLimit</code> size (which is 8) and stores it in <code>_current</code> field while leaving previous buffer in the <code>_first</code> field. This new buffer is used to store next 8 items (lines: 22, 29).</li><li>When adding <strong>more </strong>items (<code>_count &gt; 8</code>) they are stored in <code>_current</code> buffer. When <code>_current</code> buffer becomes full it is pushed into <code>_buffers</code> list and new buffer of <code>_count</code> size is allocated. This buffer is stored in <code>_current</code> field and used to store next <code>_count</code> items (lines: 26-27, 29).</li></ul> <p>On return <code>LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</code> aliases current buffer (line: 11) and current index (line: 12) as <code>destination</code> and <code>index</code> and stores new item in current buffer (line: 13):</p> <pre class="brush: csharp; highlight: [11,12,13]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  private void AddWithBufferAllocation(
    T item, 
    ref T[] destination, 
    ref int index)
  {
    // ...
    AllocateBuffer();
    destination = _current;
    index = _index;
    _current[index] = item;
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>This way execution continues until the end of input sequence. </p> <p>Looks a bit complicated? Let&#x2019;s take a small example to see how this works for a sequence of 20 items:</p> <figure class="wp-block-table"><table class><thead><tr><th>Item #</th><th>Trace</th><th>_count</th><th>_first</th><th>_current</th><th>_buffers</th></tr></thead><tbody><tr><td>1</td><td><em>4 items buffer allocated (new T1[4])1 item stored in T1[0]</em>_<br><em>3 items to store</em></td><td>0</td><td>T1[4]</td><td>T1[4]</td><td>(empty) </td></tr><tr><td>2-4</td><td><em>Storing items in T1[1]-T1[3]</em></td><td>1-4</td><td>&#x2013;</td><td>&#x2013;</td><td>&#x2013;</td></tr><tr><td>5</td><td><em>8 items buffer allocated (new T2[8])4 items copied from T1[0-3] to T2[0-3]1 item stored in T2[4]</em>_<br><em>3 items to store</em></td><td>4</td><td>T2[8]</td><td>T2[8]</td><td>(empty) </td></tr><tr><td>6-8</td><td><em>Storing items in T2[5]-T2[7]</em></td><td>5-8</td><td>&#x2013;</td><td>&#x2013;</td><td>&#x2013;</td></tr><tr><td>9</td><td><em>8 items buffer allocated (new T3[8])1 item stored in T3[0]_<p>7 items to store</p></em></td><td>8</td><td>T2[8]</td><td>T3[8]</td><td>(empty)</td></tr><tr><td>10-16</td><td><em>Storing items in T3[1]-T3[7]</em> </td><td>9-16</td><td>&#x2013;</td><td>&#x2013;</td><td>&#x2013;</td></tr><tr><td>17</td><td><em>16 items buffer allocated (new T4[16])1 buffer stored (T3)1 item stored in T4[0]_<p>15 items to store</p></em></td><td>16</td><td>T2[8]</td><td>T4[16]</td><td>(T3[8])</td></tr><tr><td>18-20</td><td><em>Storing items in T4[1]-T4[3] </em></td><td>17-20</td><td>&#x2013;</td><td>&#x2013;</td><td>&#x2013;</td></tr><tr><td>20</td><td><em>12 items to store</em></td><td>20</td><td>T2[8] </td><td>T4[16] </td><td>(T3[8]) </td></tr></tbody><tfoot><tr><td><strong>Total</strong></td><td><strong>4 buffers allocated</strong><br><strong>1 buffers stored<br>36 item allocated</strong></td><td></td><td></td><td></td><td> </td></tr></tfoot></table></figure> <p>As you can see storing sequence of 20 items requires <code>LargeArrayBuilder&lt;T&gt;</code> to allocate memory for 36 items (almost twice as more!). At first glance this may look quite inefficient, however before blaming <code>LargeArrayBuilder&lt;T&gt;</code> in inefficiency you should note that <strong>it will allocate the same 36 items for any input sequence of 17 to 32 items inclusively</strong>.</p> <p>Now the questions is &#x2013; How many items it will allocate for sequences of 100, 1000 or 10000 items? </p> <p>We obviously can&#x2019;t draw a table for such large sequences (we can but this isn&#x2019;t a productive way of doing things) but we can calculate this as sum of capacities of all allocated buffers. </p> <p>We already know how <code>LargeArrayBuilder&lt;T&gt;</code> allocates new buffers, so we can express last current buffer capacity <em>(hereinafter C)</em> as function of input sequence length <em>(hereinafter S)</em>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=C+%3D+f%28S%29+%5Crightarrow+%5Cbegin%7Bcases%7D+4%2C+%26+S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+8%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+8+%5Ctimes+2%5E%7Bn+-+1%7D%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C = f(S) \rightarrow \begin{cases} 4, &amp; S \geq 1 \text{ and } S \leq 4 \\ 8, &amp;S &gt; 4 \text{ and } S \leq 8 \\ 8 \times 2^{n - 1}, &amp;S &gt; 8 \end{cases}" class="latex"> </p> <p>Third case represents capacity as <em>n-th</em> term of <a href="https://en.wikipedia.org/wiki/Geometric_progression">geometric progression</a> where <em>8 </em>is a <em>scale factory</em> and <em>2 </em>is a <em>common ratio</em>. Such representation is possible because when <code>_count</code> exceeds <code>ResizeLimit</code> value (which is 8) new buffer&#x2019;s capacity is chosen to be equal to <code>_count</code> value which leads to a doubling of the capacity of each subsequent buffer allocation. This allows us to represent all possible capacity values as geometric progression.</p> <p>Allocating same amount of items as we have already stored leads to another interesting effect &#x2013; capacity of the last current buffer (<em>hereinafter </em><img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" class="latex">) should be enough to store at least half of the input sequence:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=C_l+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l \geq S \div 2" class="latex"> </p> <p>Replacing <img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" class="latex"> with a formula for <em>n-th</em> term:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=8+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="8 \times 2^{n - 1} \geq S \div 2" class="latex"> </p> <p>Now we can express <em>n</em> &#x2013; a position term representing capacity of last current buffer which also equals to count of buffers allocated after <code>_count</code> exceeds <code>ResizeLimit</code>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cdfrac%7B%5Cln%28S+%5Cdiv+16%29%7D%7B%5Cln%282%29%7D+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1" class="latex"> </p> <p>Here is a step by step explanation (feel free to skip is solutions is obvious to you):</p> <div class="wp-block-group note"><div class="wp-block-group__inner-container">
<div class="wp-block-group note-section"><div class="wp-block-group__inner-container">
<p><strong>Equation</strong></p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=8+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="8 \times 2^{n - 1} \geq S \div 2" class="latex"> </p>
</div></div> <div class="wp-block-group note-section"><div class="wp-block-group__inner-container">
<p><strong>Solution</strong></p> <p class="has-text-align-left">Divide both sides by <em>8</em>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=2%5E%7Bn+-+1%7D+%3D+S+%5Cdiv+16&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="2^{n - 1} = S \div 16" class="latex"></p> <p>Then take <img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}" class="latex"> of both sides:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D%282%5E%7Bn+-+1%7D%29+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}(2^{n - 1}) = \log_{2}(S \div 16)" class="latex"></p> <p>Now use the property of logarithms (<a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs/x2ec2f6f830c9fb89:log-prop/a/properties-of-logarithms">power rule</a>) to simplify the left side:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%28n+-+1%29+%5Ctimes+%5Clog_%7B2%7D%282%29+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="(n - 1) \times \log_{2}(2) = \log_{2}(S \div 16)" class="latex"></p> <p>Because <img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D%282%29+%3D+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}(2) = 1" class="latex">, remove it:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=n+-+1+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n - 1 = \log_{2}(S \div 16)" class="latex"></p> <p>Increment both sides by <em>1</em>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \log_{2}(S \div 16) + 1" class="latex"> </p> <p>And <a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs/x2ec2f6f830c9fb89:change-of-base/a/logarithm-change-of-base-rule-intro">change logarithm base</a> from <em>2</em> to <em>e</em>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cdfrac%7B%5Cln%28S+%5Cdiv+16%29%7D%7B%5Cln%282%29%7D+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1" class="latex"></p>
</div></div> </div></div> <p>Now we need to address a very important moment &#x2013; because allocated buffer store multiple items the above formula should return the same <em>n</em> for a range of sequence lengths (i.e. it should return the same result for sequence of 9 to 16 items).</p> <p>Such behavior can be achieved by <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions">ceiling</a> rational parts or the equation:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cbigg%5Clceil%5Cdfrac%7B%5Cln%28%5Clceil+S+%5Cdiv+16+%5Crceil%29%7D%7B%5Cln%282%29%7D%5Cbigg%5Crceil+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \bigg\lceil\dfrac{\ln(\lceil S \div 16 \rceil)}{\ln(2)}\bigg\rceil + 1" class="latex"></p> <p>Using <em>n</em> we now can express <strong>total count of buffers allocated</strong>, <strong>total count of items allocated</strong> and <strong>total count of buffers stored</strong> values:</p> <p><strong>Total count of buffers allocated</strong></p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bbuffers+allocated%7D+%3D+%5Cbegin%7Bcases%7D+1%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+2%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+2+%2B+n%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{buffers allocated} = \begin{cases} 1, &amp;S \geq 1 \text{ and } S \leq 4 \\ 2, &amp;S &gt; 4 \text{ and } S \leq 8 \\ 2 + n, &amp;S &gt; 8 \end{cases}" class="latex"> </p> <blockquote class="wp-block-quote"><p>The case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+8&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S &gt; 8" class="latex"> is how many buffers was allocated after 8th item plus number of previously allocated buffers.</p><cite>Author&#x2019;s note</cite></blockquote> <p><strong>Total count of items allocated</strong></p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bitems+allocated%7D+%3D+%5Cbegin%7Bcases%7D+4%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+12%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+12+%2B+%28-8+%5Ctimes+%281-2%5En%29%29%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{items allocated} = \begin{cases} 4, &amp;S \geq 1 \text{ and } S \leq 4 \\ 12, &amp;S &gt; 4 \text{ and } S \leq 8 \\ 12 + (-8 \times (1-2^n)), &amp;S &gt; 8 \end{cases}" class="latex"> </p> <blockquote class="wp-block-quote"><p>The case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+8&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S &gt; 8" class="latex"> is a <a href="https://en.wikipedia.org/wiki/Geometric_progression#Geometric_series">sum of geometric progression</a> plus count of previously allocated items.</p><cite>Author&#x2019;s note</cite></blockquote> <p><strong>Total count of buffers stored</strong></p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bbuffers+stored%7D+%3D+%5Cbegin%7Bcases%7D+0%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+16+%5C%5C+n+-+1%2C+%26S+%3E+16+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{buffers stored} = \begin{cases} 0, &amp;S \geq 1 \text{ and } S \leq 16 \\ n - 1, &amp;S &gt; 16 \end{cases}" class="latex"> </p> <blockquote class="wp-block-quote"><p>The last case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+16&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S &gt; 16" class="latex"> is <em>how many buffers was allocated</em> after 8th item minus currently active buffer.</p><cite>Author&#x2019;s note</cite></blockquote> <p>Here are the calculations for benchmark sequences:</p> <figure class="wp-block-table"><table class><thead><tr><th>Sequence length </th><th>Totalcount of buffers<p>allocated</p></th><th>Totalcount of items<p>allocated</p></th><th>Total<br>count of buffers stored</th></tr></thead><tbody><tr><td>10</td><td>3</td><td>20</td><td>0</td></tr><tr><td>100</td><td>6</td><td>132</td><td>3</td></tr><tr><td>1000</td><td>9</td><td>1028</td><td>6</td></tr><tr><td>10000</td><td>13</td><td>16388</td><td>10</td></tr></tbody></table></figure> <h4>LargeArrayBuilder&lt;T&gt;.ToArray()</h4> <p>The <code>LargeArrayBuilder&lt;T&gt;.ToArray</code> method is responsible for allocating final array (line: 7) and coping buffered items to it (line: 8). The copy part is delegated to <code>LargeArrayBuilder&lt;T&gt;.CopyTo</code> method:</p> <pre class="brush: csharp; highlight: [7,8]; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  public T[] ToArray()
  {
    // ...
    array = new T[_count];
    CopyTo(array, 0, _count);
    return array;
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L266">LargeArrayBuilder&lt;T&gt;.ToArray</a> and is obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p><code>LargeArrayBuilder&lt;T&gt;.CopyTo</code> method is very straightforward. It iterates over all allocated buffers and copies items to input array. Correct buffer is selected using <code>LargeArrayBuilder&lt;T&gt;.GetBuffer</code> method: </p> <pre class="brush: csharp; title: ; notranslate">
internal struct LargeArrayBuilder&lt;T&amp;gt;
{
  // ...
  public void CopyTo(T[] array, int arrayIndex, int count)
  {
    for (int i = 0; count &amp;gt; 0; i++)
    {
      T[] buffer = GetBuffer(index: i);
      int toCopy = Math.Min(count, buffer.Length);
      Array.Copy(buffer, 0, array, arrayIndex, toCopy);
      count -= toCopy;
      arrayIndex += toCopy;
    }
  }
  // ...
  public T[] GetBuffer(int index)
  {
    return index == 0 
      ? _first
      : index &lt;= _buffers.Count 
        ? _buffers[index - 1] 
        : _current;
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L157">LargeArrayBuilder&lt;T&gt;.CopyTo</a> and <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L243">LargeArrayBuilder&lt;T&gt;.GetBuffer</a> were obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <h4>Summing up</h4> <p>Knowledge of how <code>LargeArrayBuilder&lt;T&gt;</code> allocates memory allows us to estimate how much memory will be required to build an array depending on input sequence length:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+T_%5Ctext%7Bestimated%7D+%3D+V_%5Ctext%7Bbuffers%7D+%2B+V_%5Ctext%7Bfinal+array%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26T_%5Ctext%7Bestimated%7D+%26%26-%5C+%5Ctext%7Bis+the+estimated+amount+of+memory+required+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Bbuffers%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+all+buffers%7D+%5C%5C+%26V_%5Ctext%7Bfinal+array%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+final+array%7D+%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} T_\text{estimated} = V_\text{buffers} + V_\text{final array} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{estimated} &amp;&amp;-\ \text{is the estimated amount of memory required in bytes} \\ &amp;V_\text{buffers} &amp;&amp;-\ \text{is the amount of memory required to hold all buffers} \\ &amp;V_\text{final array} &amp;&amp;-\ \text{is the amount of memory required to hold final array} \end{aligned} " class="latex"> </p> <p>Memory required to hold a single array instance is calculated as memory required to hold <code>System.Array</code> object plus memory required to hold all array elements:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7DV_%5Ctext%7Barray%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+N_%5Ctext%7Belements%7D+%5Ctimes+V_%7Belement%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26V_%5Ctext%7Bobject%7D+%26%26-%5C+%5Ctext%7Bis+the+size+of+object+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Belement%7D+%26%26-%5C+%5Ctext%7Bis+the+size+of+array+element+in+bytes%7D+%5C%5C+%26N_%5Ctext%7Belements%7D+%26%26-%5C+%5Ctext%7Bis+the+number+of+elements+in+the+array%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned}V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;V_\text{object} &amp;&amp;-\ \text{is the size of object in bytes} \\ &amp;V_\text{element} &amp;&amp;-\ \text{is the size of array element in bytes} \\ &amp;N_\text{elements} &amp;&amp;-\ \text{is the number of elements in the array}\end{aligned}" class="latex"> </p> <p>Hence, the amount of memory required to hold all buffers can be expressed through <strong>Total count of buffers allocated</strong> and<strong> Total count of items allocated</strong> values as:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Bbuffers%7D+%3D+T_%5Ctext%7Bbuffers+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{buffers} = T_\text{buffers allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}" class="latex"></p> <p>&#x2026; and amount of memory required to hold final array:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Bfinal+array%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+S+%5Ctimes+V_%5Ctext%7Belement%7D+%5C%5C%5C%5C%5C%5C+%5Ctext%7Bwhere%7D%5C+S+-%5C+%5Ctext%7Bis+the+length+of+the+input+sequence%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{final array} = V_\text{object} + S \times V_\text{element} \\\\\\ \text{where}\ S -\ \text{is the length of the input sequence}" class="latex"> </p> <p>So estimated amount of memory required to build an array can be expressed as:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7DT_%5Ctext%7Bestimated%7D+%26%3D+T_%5Ctext%7Bbuffers+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D%5C+%2B+%5C%5C+%26%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D%5C+%2B+%5C%5C+%26%2B++V_%5Ctext%7Bobject%7D+%2B+S+%5Ctimes+V_%5Ctext%7Belement%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned}T_\text{estimated} &amp;= T_\text{buffers allocated} \times V_\text{object}\ + \\ &amp;+ T_\text{items allocated} \times V_\text{element}\ + \\ &amp;+ V_\text{object} + S \times V_\text{element}\end{aligned}" class="latex"></p> <p>Considering the following values on 64 bit systems (in bytes): </p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+%26V_%5Ctext%7Bobject%7D+%26%26%3D+24+%5C%5C++%26V_%5Ctext%7Belement%7D+%26%26%3D+%5Ctext%7Bsizeof%28int%29%7D+%5Crightarrow+4+%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\ &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \end{aligned} " class="latex"></p> <p class="has-text-align-left">The above formula can be simplified to:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bestimated%7D+%3D+24+%5Ctimes+T_%5Ctext%7Bbuffers+allocated%7D+%2B+4+%5Ctimes+T_%5Ctext%7Bitems+allocated%7D+%2B+%284+%5Ctimes+S+%2B+24%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{estimated} = 24 \times T_\text{buffers allocated} + 4 \times T_\text{items allocated} + (4 \times S + 24)" class="latex"> </p> <p>Beside memory allocated by instance of <code>LargeArrayBuilder&lt;T&gt;</code> benchmark results also include memory allocated by compiler generated enumerator (40 bytes on x64 system) and memory allocated by <code>ArrayBuilder&lt;T&gt;</code> structure (<code>_buffers</code> field). Because we don&#x2019;t know how <code>ArrayBuilder&lt;T&gt;</code> allocates we can treat it&#x2019;s allocations as estimation error, however because we know amount of memory consumed by compiler generated enumerator we should subtract its size from the benchmark results:</p> <figure class="wp-block-table"><table class><thead><tr><th>Sequence length </th><th>Total count of buffers allocated</th><th>Total count of items allocated</th><th>Total bytes<br>estimated</th><th>Total bytes<br>allocated (iterator adjusted) </th><th>Estimation error %</th></tr></thead><tbody><tr><td>10</td><td>3</td><td>20</td><td>216</td><td>216</td><td>0</td></tr><tr><td>100</td><td>6</td><td>132</td><td>1096</td><td>1152</td><td>0.0486</td></tr><tr><td>1000</td><td>9</td><td>1028</td><td>8352</td><td>8496</td><td>0.0169</td></tr><tr><td>10000</td><td>13</td><td>16388</td><td>105888</td><td>106184</td><td>0.0027</td></tr></tbody></table></figure> <h3>How List&lt;T&gt; allocates?</h3> <p>When new instance of <code>List&lt;T&gt;</code> is created from the <code>IEnumerable&lt;T&gt;</code> (which isn&#x2019;t <code>ICollection&lt;T&gt;</code>) all items from input sequence are sequentially added to empty <code>List&lt;T&gt;</code> instance (lines: 16-21):</p> <pre class="brush: csharp; highlight: [16,17,18,19,20,21]; title: ; notranslate">
public class List&lt;T&amp;gt;
{
  // ...
  public List(IEnumerable&lt;T&amp;gt; collection)
  {
    // ...
    if (collection is ICollection&lt;T&amp;gt; c)
    {
      // ...
    }
    else
    {
      _size = 0;
      _items = s_emptyArray;
      using (IEnumerator&lt;T&amp;gt; en = collection!.GetEnumerator())
      {
        while (en.MoveNext())
        {
          Add(en.Current);
        }
      }
    }
  }
  // ...
}
</pre> <p class="has-small-font-size">* <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>Items are added using <code>List&lt;T&gt;.Add</code> method:</p> <pre class="brush: csharp; highlight: [9,16]; title: ; notranslate">
public class List&lt;T&amp;gt;
{
  // ...
  public void Add(T item)
  {
    _version++;
    T[] array = _items;
    int size = _size;
    if ((uint)size &lt; (uint)array.Length)
    {
      _size = size + 1;
      array[size] = item;
    }
    else
    {
      AddWithResize(item);
    }
  }  
  // ...
}
</pre> <p class="has-small-font-size"> * <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L203">List&lt;T&gt;.Add</a> was obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p>This method checks if there is enough capacity in the internal array to store new item (line: 9) and if not it switches execution to <code>List&lt;T&gt;.AddWithResize</code> method (line: 16): </p> <pre class="brush: csharp; highlight: [17,18]; title: ; notranslate">
public class List&lt;T&amp;gt;
{
  // ...
  private void AddWithResize(T item)
  {
    int size = _size;
    EnsureCapacity(size + 1);
    _size = size + 1;
    _items[size] = item;
  }
  // ...
  private void EnsureCapacity(int min)
  {
    if (_items.Length &lt; min)
    {
      int newCapacity = _items.Length == 0 
        ? DefaultCapacity 
        : _items.Length * 2;
      if ((uint)newCapacity &amp;gt; Array.MaxArrayLength) 
        newCapacity = Array.MaxArrayLength;
      if (newCapacity &lt; min) 
        newCapacity = min;
      Capacity = newCapacity;
    } 
  }
  // ...
}
</pre> <p class="has-small-font-size"> * <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L221">List&lt;T&gt;.AddWithResize</a> and <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L406">List&lt;T&gt;.EnsureCapacity</a> were obtained from&#xA0;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p> <p><code>List&lt;T&gt;.AddWithResize</code> works in pair with <code>List&lt;T&gt;.EnsureCapacity</code> method: the latter ensure there will be enough space to store one more item by recalculating internal array capacity by either setting it to <code>List&lt;T&gt;.DefaultCapacity</code> (which is 4 items) in case when current internal array is empty array (line: 17) or by doubling current capacity value (line: 18). </p> <blockquote class="wp-block-quote"><p>Internal array is reallocated inside of <code>List&lt;T&gt;.Capacity</code> property setter. Besides array allocation it also copies items from old array to the new one. </p><cite>Author&#x2019;s note</cite></blockquote> <p>Looks quite simple. Right? I am sure it is, but still let&#x2019;s take a small example and see how this works for a sequence of 20 items: </p> <figure class="wp-block-table"><table class><thead><tr><th>Item #</th><th>Trace</th><th>Capacity</th></tr></thead><tbody><tr><td>1</td><td><em>4 items array allocated (T1[4])1 item stored in T1[0]&#x2013;<p>3 items to store</p></em></td><td>4</td></tr><tr><td>2-4</td><td><em>Storing items in T1[1]-T1[3]</em></td><td>&#x2013;</td></tr><tr><td>5</td><td><em>8 items array allocated (T2[8])4 items copied from T1[0-3] to T2[0-3]1 item stored in T2[4]&#x2013;<p>3 items to store</p></em></td><td>8</td></tr><tr><td>6-8</td><td><em>Storing items in T2[5]-T2[7] </em></td><td></td></tr><tr><td>9</td><td><em>16 items array allocated (T3[16])8 items copied from T2[0-7] to T3[0-7]1 item stored in T3[8]&#x2013;<p>7 items to store</p></em></td><td>16</td></tr><tr><td>10-16</td><td><em>Storing items in T3[9]-T2[15] </em></td><td>&#x2013;</td></tr><tr><td>17</td><td><em>32 items array allocated (T4[32])16 items copied from T3[0-15] to T4[0-15]1 item stored in T4[16]&#x2013;<p>15 items to store</p></em></td><td>32</td></tr><tr><td>18-20</td><td><em>Storing items in T4[17]-T4[19] </em></td><td>&#x2013;</td></tr></tbody><tfoot><tr><td><strong>Total</strong></td><td><strong>4 arrays allocated<br>60 items allocated</strong></td><td></td></tr></tfoot></table></figure> <p>So <code>List&lt;T&gt;</code> allocates <strong>60 items</strong> in order to store 20 items. It is much more than <code>LargeArrayBuilder&lt;T&gt;</code>, which allocates 36 items for the same input. Before making any decisions let&#x2019;s calculate how many internal arrays and items are allocated for sequences of 10, 100, 1000 and 10000 items. </p> <p>This can be easily done because as you might already noticed &#x2013; <code>List&lt;T&gt;</code> capacity is always doubled&#x2026; which means it&#x2019;s value can be expressed through geometric progression where <code>List&lt;T&gt;</code>&#x2018;s default capacity <em>4</em> is a <em>scale factor</em> and <em>2</em> is a <em>common ratio</em>:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=4%2C+4+%5Ctimes+2%2C+4+%5Ctimes+2%5E2%2C+4+%5Ctimes+2%5E3%2C+...%2C+etc&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4, 4 \times 2, 4 \times 2^2, 4 \times 2^3, ..., etc" class="latex"> </p> <p>The <em>n</em> term of the progressions is calculated as: </p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=C_n+%3D+4+%5Ctimes+2%5E%7Bn+-+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_n = 4 \times 2^{n - 1}" class="latex"> </p> <p>Because <code>List&lt;T&gt;</code>&#x2018;s internal array should be able to store all items stored in previous internal array we can say that last internal array capacity (<em>hereinafter </em><img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" class="latex">) should be at least enough to hold all sequence items:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=C_l+%5Cgeq+S&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l \geq S" class="latex"></p> <p>Replacing <img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" class="latex"> with a formula for <em>n-th</em> term:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=4+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4 \times 2^{n - 1} \geq S" class="latex"> </p> <p> The <em>n</em> is then expressed as:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=4+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Crightarrow+n+%3D+%5Cbigg%5Clceil%5Cdfrac%7B%5Cln%28%5Clceil+S+%5Cdiv+4+%5Crceil%29%7D%7B%5Cln%282%29%7D%5Cbigg%5Crceil+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4 \times 2^{n - 1} \geq S \rightarrow n = \bigg\lceil\dfrac{\ln(\lceil S \div 4 \rceil)}{\ln(2)}\bigg\rceil + 1" class="latex"> </p> <blockquote class="wp-block-quote"><p>I won&#x2019;t repeat the solution here. It is absolutely the same as we did for <code>LargeArrayBuilder&lt;T&gt;</code>.</p><cite>Author&#x2019;s note</cite></blockquote> <p>Using <em>n</em> we now can express <strong>total count of array allocated</strong> and <strong>total count of items allocated</strong> values: </p> <p><strong>Total count of arrays allocated</strong> is equal to:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Barrays+allocated%7D+%3D+n&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{arrays allocated} = n" class="latex"></p> <p><strong>Total count of items allocated</strong> is equal to:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bitems+allocated%7D+%3D+-4+%5Ctimes+%281-2%5En%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{items allocated} = -4 \times (1-2^n)" class="latex"></p> <p>Here are the calculations for benchmark sequences: </p> <figure class="wp-block-table"><table class><thead><tr><th> Sequence length </th><th>Total count of arrays allocated </th><th>Total count of items allocated </th></tr></thead><tbody><tr><td>10</td><td>3</td><td>28</td></tr><tr><td>100</td><td>6</td><td>252</td></tr><tr><td>1000</td><td>9</td><td>2044</td></tr><tr><td>10000</td><td>13</td><td>32764</td></tr></tbody></table></figure> <p>We also can calculate <strong>exactly</strong> how much memory will be required to create <code>List&lt;T&gt;</code> depending on the input sequence length:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+T_%5Ctext%7Bexact%7D+%3D+V_%5Ctext%7Barrays%7D+%2B+V_%5Ctext%7BList+of+T%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26T_%5Ctext%7Bexact%7D+%26%26-%5C+%5Ctext%7Bis+the+exact+amount+of+memory+required+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Barrays%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+all+arrays%7D+%5C%5C+%26V_%5Ctext%7BList+of+T%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+consumed+by+empty+List+of+T+object%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} T_\text{exact} = V_\text{arrays} + V_\text{List of T} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{exact} &amp;&amp;-\ \text{is the exact amount of memory required in bytes} \\ &amp;V_\text{arrays} &amp;&amp;-\ \text{is the amount of memory required to hold all arrays} \\ &amp;V_\text{List of T} &amp;&amp;-\ \text{is the amount of memory consumed by empty List of T object}\end{aligned}" class="latex"> </p> <p>We already know how to calculate memory required to hold a single array instance:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Barray%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+N_%5Ctext%7Belements%7D+%5Ctimes+V_%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element}" class="latex"> </p> <p>Hence, the amount of memory required to hold all arrays can be expressed through <strong>Total count of allocated arrays</strong> and<strong> Total count of allocated items</strong> values as:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Barrays%7D+%3D+T_%5Ctext%7Barrays+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{arrays} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}" class="latex"></p> <p>Hence, exact amount of memory required is:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bexact%7D+%3D+T_%5Ctext%7Barrays+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D+%2B+V_%5Ctext%7BList+of+T%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{exact} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element} + V_\text{List of T}" class="latex"></p> <p>Considering the following values on 64 bit systems (in bytes): </p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+%26V_%5Ctext%7Bobject%7D+%26%26%3D+24+%5C%5C++%26V_%5Ctext%7Belement%7D+%26%26%3D+%5Ctext%7Bsizeof%28int%29%7D+%5Crightarrow+4+%5C%5C+%26V_%5Ctext%7BList+of+T%7D+%26%26%3D+32%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\ &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \\ &amp;V_\text{List of T} &amp;&amp;= 32\end{aligned} " class="latex"></p> <p class="has-text-align-left">The above formula can be simplified to:</p> <p class="has-text-align-center"><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bexact%7D+%3D+24+%5Ctimes+T_%5Ctext%7Barrays+allocated%7D+%2B+4+%5Ctimes+T_%5Ctext%7Bitems+allocated%7D+%2B+32&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{exact} = 24 \times T_\text{arrays allocated} + 4 \times T_\text{items allocated} + 32" class="latex"> </p> <blockquote class="wp-block-quote"><p>You might remember (or not) that in the first <a href="https://olegkarasik.wordpress.com/2018/06/24/what-is-wrong-with-this-code/">What is wrong with this code?</a> post we have counted the size of empty <code>List&lt;T&gt;</code> as 40 bytes.</p><p>This was 100% correct for previous version of .NET Core. In .NET Core 3.0 most of the collection classes have their <code>_syncRoot</code> field removed (here is a <a href="https://github.com/dotnet/corefx/commit/4d6cde1be300d1fb8b3aec2356d18f1f3d071913#diff-81a5ab9c227534a88af5dc319cc9774d">PR</a>) which resulted in smaller collection sizes.</p><cite>Author&#x2019;s note</cite></blockquote> <p>Beside memory allocated by instance of <code>List&lt;T&gt;</code> benchmark results also include memory allocated by it&#x2019;s enumerator (40 bytes on x64 system) which we should subtract from the benchmark results:</p> <figure class="wp-block-table"><table class><thead><tr><th>Sequence length </th><th>Total count of arrays allocated</th><th>Total count of items allocated</th><th>Total bytes allocated (exact)</th><th>Total bytes allocated (iterator adjusted) </th></tr></thead><tbody><tr><td>10</td><td>3</td><td>28</td><td>216</td><td>216</td></tr><tr><td>100</td><td>6</td><td>252</td><td>1184</td><td>1184</td></tr><tr><td>1000</td><td>9</td><td>2044</td><td>8424</td><td>8424</td></tr><tr><td>10000</td><td>13</td><td>32764</td><td>131400</td><td>131400</td></tr></tbody></table></figure> <h3>Unexpected discovery #3</h3> <p>Now when understand how both <code>LargeArrayBuilder&lt;T&gt;</code> and <code>List&lt;T&gt;</code> allocate we can compare how many items they allocate for the same amount of input elements:</p> <figure class="wp-block-table"><table class><thead><tr><th>Sequence length </th><th>Total count of items allocated (<code>List&lt;T&gt;</code>)</th><th>Total count of items allocated + count of items in final array (<code>LargeArrayBuilder&lt;T&gt;</code>)</th></tr></thead><tbody><tr><td>10</td><td>28</td><td>20 + 10 = 30</td></tr><tr><td>100</td><td>252</td><td>132 + 100 = 232</td></tr><tr><td>1000</td><td>2044</td><td>1028 + 1000 = 2028</td></tr><tr><td>10000</td><td>32764</td><td>16388 + 10000 = 26388</td></tr></tbody></table></figure> <p>This data explains the difference we saw in <strong>Allocated </strong>column for last benchmark &#x2013; in that case <code>List&lt;T&gt;</code> allocated 6,376 items more than <code>LargeArrayBuilder&lt;T&gt;</code>.</p> <h2>Conclusion</h2> <p>If you are reading these lines then first of all &#x2013; Thank you for reading this huge post. I hope you enjoyed it. </p> <p>Here is a small reward in form of short summary:</p> <p><strong>Result #1</strong></p> <p>In cases when <code>source</code> is <code>ICollection&lt;T&gt;</code> both <code>ToArray</code> and <code>ToList</code> methods demonstrate almost the same performance characteristics because internally they execute almost identical code. </p> <p><strong>Result #2</strong></p> <p>In cases when input sequence is a product of multiple iterators the performance of both <code>ToArray</code> and <code>ToList</code> methods would depend on the optimizations implemented by those iterators and in some cases can differ significantly. </p> <p><strong>Result #3</strong></p> <p>In cases when input sequence is an enumerable both <code>ToArray</code> and <code>ToList</code> methods demonstrate very close performance characteristics in terms of speed. However for large sequences <code>ToArray</code> method could has smaller memory footprint. At the same time it is important to understand &#x2013; because <code>ToArray</code> causes allocation of multiple independent arrays it could cause memory fragmentation (and even object promotion) because GC wouldn&#x2019;t be able to clean these arrays until the <code>ToArray</code> operation is done. It is hard to say how critical these differences are but it is always good to know about them.</p> <h2>Bonus</h2> <p>Did you know that <code>ArrayBuilder&lt;T&gt;</code> class used inside of <code>LargeArrayBuilder&lt;T&gt;</code> class has the same allocation strategy as <code>List&lt;T&gt;</code>? &#x1F642;</p> <div class="entry-author-wrapper"> <div class="entry-author author-avatar-show"> <p class="author-bio"> Tech Lead at ISsoft / part of Coherent Solutions / in Minsk, Belarus. I do .NET for living and try to write code I am not be ashamed of :) <a class="author-link" href="https://olegkarasik.wordpress.com/author/olegkarasik/"> View all posts by Oleg Karasik </a> </p> </div> <div class="site-posted-on"> <strong>Published</strong> <time class="entry-date published">July 23, 2019</time><time class="updated">September 30, 2019</time> </div> </div> <p id="secondary" class="widget-area"> <aside id="grofile-5" class="widget widget-grofile grofile"> <img src="https://secure.gravatar.com/avatar/cd812e62189665bb730b718468660f32?s=320" class="grofile-thumbnail no-grav" alt="Oleg Karasik"> <p><a href="http://gravatar.com/olegkarasik" class="grofile-full-link"> View Full Profile &#x2192; </a></p> </aside><aside id="custom_html-7" class="widget_text widget widget_custom_html"><div class="textwidget custom-html-widget"><a href="https://www.issoft.by">ISsoft Solutions</a> <br> <a href="https://www.coherentsolutions.com">Coherent Solutions</a></div></aside><aside id="categories-5" class="widget widget_categories"> </aside><aside id="blog_subscription-3" class="widget widget_blog_subscription jetpack_subscription_widget"> </aside></p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>