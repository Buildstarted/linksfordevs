<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Life, part 31 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Life, part 31 - linksfor.dev(s)"/>
    <meta property="og:description" content="Today we will finish off our implementation of Hensel&#x2019;s QuickLife algorithm, rewritten in C#. Code for this episode is here. Last time we saw that adding change tracking is an enormous win, b&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://ericlippert.com/2020/08/13/life-part-31/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Life, part 31</title>
<div class="readable">
        <h1>Life, part 31</h1>
            <div>Reading time: 19-24 minutes</div>
        <div>Posted here: 13 Aug 2020</div>
        <p><a href="https://ericlippert.com/2020/08/13/life-part-31/">https://ericlippert.com/2020/08/13/life-part-31/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p>Today we will finish off our implementation of Hensel’s QuickLife algorithm, rewritten in C#. Code for this episode is <a href="https://github.com/ericlippert/ConwaysLife/tree/episode31">here</a>.</p>
<p><a href="https://ericlippert.com/2020/08/05/life-part-30/">Last time</a> we saw that adding change tracking is an enormous win, but we still have not got an O(changes) solution in time or an O(living) solution in space. What we really want to do is (1) avoid doing any work at all on stable Quad4s; only spend processor time on the active ones, and (2) deallocate all-dead Quad4s, and (3) grow the set of active Quad4s when activity reaches the current borders.</p>
<p>We need more state bits, but fortunately we only need a small number; so small that I’m not even going to bit twiddle them. (The original Java implementation did, but it also used some of those bits for concerns such as optimizing the display logic.) Recall that we are tracking 32 regions of the 8 Quad3s in a Quad4 to determine if they are active, stable or dead. It should come as no surprise that we’re going to do the same thing for a Quad4, and that once again we’re going to maintain state for both the even and odd cycles:</p>
<pre>enum Quad4State
{
  Active,
  Stable,
  Dead
}</pre>
<p>And then in Quad4:</p>
<pre>public Quad4State State { get; set; } 
public Quad4State EvenState { get; set; }
public Quad4State OddState { get; set; }
public bool StayActiveNextStep { get; set; }</pre>
<p>The idea here is:</p>
<ul>
<li>All Quad4s are at all times in exactly one of three buckets: active, stable and dead. Which bucket is represented by the State property.</li>
<li>If a Quad4 is active then it is processed on each tick.</li>
<li>If a Quad4 is stable then we draw it but do not process it on each tick.</li>
<li>If a Quad4 is dead then we neither process nor draw it, and eventually we deallocate it. (We do not want to deallocate too aggressively in case it comes back to life in a few ticks.)</li>
</ul>
<p>How then do we determine when an active Quad4 becomes stable or dead?</p>
<ul>
<li>If the “stay active” flag is set, it stays active no matter what.</li>
<li>The odd and even cycles each get a vote on whether an active Quad4 should become stable or dead.</li>
<li>If both vote for dead, it becomes dead.</li>
<li>If one votes for stable and the other votes for stable or dead, it becomes stable. (Exercise: under what circumstances is a Quad4 dead on the odd cycles but stable on the even?)</li>
<li>If one or both vote for active, it stays active.</li>
</ul>
<p>How do we determine if a stable (or dead but not yet deallocated) Quad4 becomes active? That’s straightforward: if an active Quad4 has an active edge that abuts a stable Quad4, the stable one becomes active. Or, if there is no Quad4 there at all, we allocate a new one and make it active; this is how we achieve our goal of a dynamically growing board.</p>
<p>You might be wondering why we included a “stay active” flag. There were lots of things about this algorithm that I found difficult to understand at first, but this took the longest for me to figure out, oddly enough.</p>
<p>This flag means “there was activity on the edge of a neighbouring Quad4 recently”. There are two things that could go wrong in that situation that we need to prevent. First, we could have an active Quad4 that is about to become stable or dead, but it has activity on a border that should cause it to remain active for processing. Second, we could have a stable (or dead) Quad4 that has just been marked as active because there is activity on a bordering Quad4, and we need to ensure that it stays active even though it wants to go back to being stable (or dead).</p>
<hr>
<p>The easiest task to perform is to keep each Quad4 in one of three buckets. The original implementation did so by ensuring that every Quad4 was on exactly one of three double-linked lists, and I see no reason to change that. I have, however, encapsulated the linking and unlinking into a helper class:</p>
<pre>interface IDoubleLink&lt;T&gt; where T : class
{
  T Prev { get; set; }
  T Next { get; set; }
}

sealed class DoubleLinkList&lt;T&gt; : IEnumerable&lt;T&gt; 
  where T : class, IDoubleLink&lt;T&gt;
{
  public int Count { get; private set; }
  public void Add(T item) { ... }
  public void Remove(T item) { ... }
  public void Clear() { ... }
}</pre>
<p>I won’t go through the implementation; it is more or less the standard double-linked list implementation you know from studying for boring technical interviews. The only unusual thing about it is that I’ve ensured that you can remove the current item from a list safely even while the list is being enumerated, because we will need to do that.</p>
<p>All the Quad4-level state manipulation will be done by our main class; we’ll add some lists to it:</p>
<pre>sealed class QuickLife : ILife, IReport
{
<span>  private readonly DoubleLinkList&lt;Quad4&gt; active = new DoubleLinkList&lt;Quad4&gt;();</span>
  private readonly DoubleLinkList&lt;Quad4&gt; stable = new DoubleLinkList&lt;Quad4&gt;();
  private readonly DoubleLinkList&lt;Quad4&gt; dead = new DoubleLinkList&lt;Quad4&gt;();
  private Dictionary&lt;(short, short), Quad4&gt; quad4s;
  private int generation;</pre>
<p>I’ll skip the initialization code and whatnot.</p>
<p>We already have a method which allocates Quad4s and ensures their north/south, east/west, northwest/southeast references are initialized. We will need a few more helper functions to encapsulate some operations such as: make an existing Quad4 active, and if it does not exist, create it. Or, make an active Quad4 into a stable Quad4. They’re for the most part just updating lists and state flags:</p>
<pre>private Quad4 EnsureActive(Quad4 q, int x, int y)
{
  if (q == null)
    return AllocateQuad4(x, y);
  MakeActive(q);
  return q;
}
private void MakeActive(Quad4 q)
{
  q.StayActiveNextStep = true;
  if (q.State == Active) 
    return;
  else if (q.State == Dead)
    dead.Remove(q);
  else
    stable.Remove(q);
  active.Add(q);
  q.State = Active;
}
private void MakeDead(Quad4 q)
{
  Debug.Assert(q.State == Active);
  active.Remove(q);
  dead.Add(q);
  q.State = Dead;
}
private void MakeStable(Quad4 q)
{
  Debug.Assert(q.State == Active);
  active.Remove(q);
  stable.Add(q);
  q.State = Stable;
}</pre>
<p>Nothing surprising there, except that as I mentioned before, when you force an already-active Quad4 to be active, it sets the “stay active for at least one more tick” flag.</p>
<p>There is one more bit of list management mechanism we should consider before getting into the business logic: when and how do dead Quad4s get removed from the dead list and deallocated? The how is straightforward: run down the dead list, orphan all of the Quad4s by de-linking them from every living object, and the garbage collector will eventually get to them:</p>
<pre>private void RemoveDead()
{
  foreach(Quad4 q in dead)
  {
    if (q.S != null) 
      q.S.N = null;
    ... similarly  for N, E, W, SE, NW
    quad4s.Remove((q.X, q.Y));
  }
  dead.Clear();
}</pre>
<p>This orphans the entire dead list; the original implementation had a more sophisticated implementation where it would keep around the most recently dead on the assumption that they were the ones most likely to come back.</p>
<p>We have no reason to believe that this algorithm’s performance is going to be gated on spending a lot of time deleting dead nodes, so we’ll make an extremely simple policy; every 128 ticks we’ll check to see if there are more than 100 Quad4s on the dead list.</p>
<pre>private bool ShouldRemoveDead =&gt; 
  (generation &amp; 0x7f) == 0 &amp;&amp; dead.Count &gt; 100;
public void Step()
{
  if (ShouldRemoveDead) 
    RemoveDead();
  if (IsOdd)
    StepOdd();
  else
    StepEven();
  generation += 1;
}</pre>
<p>All right, that’s the mechanism stuff. By occasionally pruning away all-dead Quad4s we attain O(living) space usage. But how do we actually make this thing both fast and able to dynamically add new Quad4s on demand?</p>
<p>In keeping with the pattern of practice so far, we’ll write all the code twice, once for the even cycle and once, slightly different, for the odd cycle. I’ll only show the even cycle here.</p>
<p>Remember our original O(cells) prototype stepping algorithm:</p>
<pre>private void StepEven()
{
  foreach (Quad4 q in quad4s)
    q.StepEven();
}</pre>
<p>We want to (1) make this into an O(changes) algorithm, (2) detect stable or dead Quad4s currently on the active list, and (3) expand the board by adding new Quad4s when the active region reaches the current edge. We also have (4) a small piece of bookkeeping from earlier to deal with:</p>
<pre>private void StepEven()
{
  foreach (Quad4 q in active)      // (1) O(changes)
  {
    if (!RemoveStableEvenQuad4(q)) // (2) remove and skip stable/dead
    {
      q.StepEven();
      MakeOddNeighborsActive(q);   // (3) expand
    }
    q.StayActiveNextStep = false;  // (4) clear flag
  }
}</pre>
<p>The first one is straightforward; we now only loop over the not-stable, not-dead Quad4s, so this is O(changes), and moreover, remember that we consider a Quad4 to be stable if both its even and odd generations are stable, so we are effectively skipping all computations of Quad4s that contain only still Lifes and period-two oscillators, which is a huge win.</p>
<p>The fourth one is also straightforward: if the “stay active for at least one step” flag was on, well, we made it through one step, so it can go off. If it was already off, it still is.</p>
<p>The interesting work comes in removing stable Quad4s, and expanding the board on the active edge. To do the former, we will need some more helpers that answer questions about the Quad4 and its neighbors; this is a method of Quad4:</p>
<pre>public bool EvenQuad4OrNeighborsActive =&gt;
  EvenQuad4Active ||
  (S != null &amp;&amp; S.EvenNorthEdgeActive) ||
  (E != null &amp;&amp; E.EvenWestEdgeActive) ||
  (SE != null &amp;&amp; SE.EvenNorthwestCornerActive);</pre>
<p>This is the Quad4 analogue of our earlier method that tells you if any of a 10×10 region is active; this one tells you if an 18×18 region is active, and for the same reason: because that region entirely surrounds the new shifted-to-the-southeast Quad4 we’re computing. We also have the analogous methods to determine if that region is all stable or all dead; I’ll omit showing them.</p>
<p>Let’s look at our “remove a stable/dead Quad4 from the active list” method. There is some slightly subtle stuff going on here. First, if the Quad4 definitely can be skipped for this generation because it is stable or dead, we return true. However, that does not guarantee that the Quad4 was removed from the active list! Second, remember that our strategy is to have both the even and odd cycles “vote” on what should happen:</p>
<pre>private bool RemoveStableEvenQuad4(Quad4 q)
{
  if (q.EvenQuad4OrNeighborsActive)
  {
    q.EvenState = Active;
    q.OddState = Active;
    return false;
  }</pre>
<p>If anything in the 18×18 region containing this Quad4 or its relevant neighbouring Quad4s are active, we need to stay active. We set the votes of both even and odd cycle back to active if they were different.</p>
<p>If nothing is active then it must be stable or dead. Is this 18×18 region dead? (Remember, we only mark it as dead if it is both dead <em>and</em> stable.)</p>
<pre>  if (q.EvenQuad4AndNeighborsAreDead)
  { 
    q.EvenState = Dead;
    q.SetOddQuad4AllRegionsDead();
    if (!q.StayActiveNextStep &amp;&amp; q.OddState == Dead)
      MakeDead(q);
  }</pre>
<p>Let’s go through each line here in the consequence of the if:</p>
<ul>
<li>Everything in an 18×18 region is dead and stable. The even cycle votes for death.</li>
<li>We know that an 18×18 region is all dead and stable; that region <em>entirely</em> surrounds the odd Quad4. We therefore know that the odd Quad4 will be all dead on the next tick if it is not already, so we get aggressive and set all its “region dead” bits now.</li>
<li>If we’re forcing this Quad4 to stay active then it stays active; however, even is still voting for death! We’ll get another chance to kill this Quad4 on the next tick.</li>
<li>By that same logic, if the odd cycle voted for death on the previous tick but the Quad4 stayed active for some reason then the odd cycle is still voting for death now. If that’s true then <em>both</em> cycles are voting for death and the Quad4 gets put on the dead list.</li>
</ul>
<p>We then have nearly identical logic for stability; the only difference is that if one cycle votes for stability, it suffices for the other cycle to vote for stability <em>or</em> death:</p>
<pre>  else
  {
    q.EvenState = Stable;
    q.SetOddQuad4AllRegionsStable();
    if (!q.StayActiveNextStep &amp;&amp; q.OddState != Active)
      MakeStable(q);
  }
  return true;
}</pre>
<p>And finally: how do we expand into new space? That is super easy, barely an inconvenience. If we have just processed an active Quad4 on the even cycle then we’ve created a new odd Quad4 and in doing so we’ve set the activity bits for the 16 regions in the odd Quad4. If the south 16×2 edge of the odd Quad4 is active then the Quad4 to the south must be activated, and so on:</p>
<pre>private void MakeOddNeighborsActive(Quad4 q)
{
  if (q.OddSouthEdgeActive)
    EnsureActive(q.S, q.X, q.Y - 1);
  if (q.OddEastEdgeActive)
    EnsureActive(q.E, q.X + 1, q.Y);
  if (c.OddSoutheastCornerActive)
    EnsureActive(q.SE, q.X + 1, q.Y - 1); 
}</pre>
<p>Once again we are taking advantage of the fact that the even and odd generations are offset by one cell; we only have to expand the board on two sides of each Quad4 during each tick, instead of all four. When we’re completing an even cycle we check for expansion to the south and east for the upcoming odd cycle; when we’re completing an odd cycle we check for expansion to the north and west for the upcoming even cycle.</p>
<p>It’s a little hard to wrap your head around, but it all works. This “staggered” property looked like it was going to be a pain when we first encountered it, but it is surprisingly useful; that insight is one of the really smart things about this algorithm.</p>
<p>There is a small amount of additional state management code I’ve got to put here and there but we’ve hit all the high points; see the source code for the exact changes if you are curious.</p>
<hr>
<p>And that is that! Let’s take it for a spin and run our usual 5000 generations of “acorn”.</p>
<pre>Algorithm           time(ms) size  Mcells/s bits/cell O-time
Naïve (Optimized):   4000     8      82     8/cell     cells
Abrash (Original)     550     8     596     8/cell     cells
Stafford              180     8    1820     5/cell     change
Sparse array         4000    64      ?   &gt;128/living   change
Proto-QuickLife 1     770     8     426     4/cell     cells
Proto-QuickLife 2     160     8    2050     4/cell     cells
QuickLife              65    20      ?      5/living*  change
</pre>
<p>WOW!</p>
<p>We have an O(changes) in time and O(living) in space algorithm that maintains a sparse array of Quad4s that gives us a 20-quad to play with, AND it is almost three times faster than Stafford’s algorithm on our benchmark!</p>
<p>Our memory usage is still pretty efficient; we are spending zero memory on “all dead” Quad4s with all dead neighbours. We’ve added more state to each Quad4, so now for active and stable Quad4s we’re spending around five bits per cell; same as Stafford’s algorithm. (Though as I noted in my follow-up, he did find ways to get “maintain a count of living neighbours” algorithms down to far fewer bits per cell.) I added an asterisk to the table above because of course an active or stable Quad4 will contain only 50% or fewer living cells, so this isn’t quite right, but you get the idea.</p>
<p>Again, it is difficult to know how to characterize “cells per second” for sparse array approaches where we have an enormous board that is mostly empty space that costs zero to process, so I’ve omitted that metric.</p>
<hr>
<p>If you ran the code on your own machine you probably noticed that I added counters to the user interface to give live updates of the size of the active, stable and dead lists. Here’s a graph of the first 6700 generations of acorn (click on the image for a larger version.)</p>
<p><a href="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png"><img loading="lazy" data-attachment-id="7797" data-permalink="https://ericlippert.com/2020/08/13/life-part-31/2020-07-25-3/" data-orig-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png" data-orig-size="752,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="2020-07-25 (3)" data-image-description="" data-medium-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=300" data-large-file="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=584" src="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=584&amp;h=312" alt="" width="584" height="312" srcset="https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=584&amp;h=312 584w, https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=150&amp;h=80 150w, https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png?w=300&amp;h=160 300w, https://ericlippert.files.wordpress.com/2020/08/2020-07-25-3.png 752w" sizes="(max-width: 584px) 100vw, 584px"></a></p>
<p>You can really see how the pattern evolves from this peek into the workings of the algorithm!</p>
<ul>
<li>We start with a small number of active Quad4s; soon small regions of stability start to appear as the pattern spreads out and leaves still Lifes and period-two oscillators in its wake.</li>
<li>The number of dead Quad4s remains very small right until the first glider escapes; from that moment on we have one or more gliders shooting off to infinity. In previous implementations they hit the wall of death, but now they are creating new active Quad4s in their bow shocks, and leaving dead Quad4s in their wakes.</li>
<li>The stable count steadily grows as the active region is a smaller and smaller percentage of the total. Around the 5000th generation everything except the escaped gliders is stable, and we end up with around 100 stable Quad4s and 20 active Quad4s for the gliders.</li>
<li>The action of our trivial little “garbage collector” is apparent here; we throw away the trash only when there are at least 100 dead Quad4s in the list and we are on a generation divisible by 128, so it is unsurprising that we have a sawtooth that throws away a little over 100 dead Quad4s every 128 cycles.</li>
<li>The blue line is proportional to time taken per cycle, because we only process active Quad4s.</li>
<li>The sum of all three lines is proportional to total memory used.</li>
</ul>
<hr>
<p>That finishes off our deep dive into Alan Hensel’s QuickLife algorithm. I was quite intimidated by this algorithm when I first read the source code, but once you name every operation and reorganize the code into functional areas it all becomes quite clear. I’m glad I dug into it and I learned a lot.</p>
<hr>
<p><strong>Coming up on FAIC:</strong></p>
<p>We’ve seen a lot of varied ways to solve the problem of simulating Life, and there are a pile more in my file folder of old articles from computer magazines that we’re not going to get to in this series. Having done this exploration into many of them and skimmed a lot more, two things come to mind.</p>
<p>First, <strong>so far they all feel kind of the same to me.</strong> There is some sort of regular array of data, and though I might layer object-oriented features on top of it to make the logic easier to follow or better encapsulated, <strong>fundamentally we’re doing procedural work here.</strong> We can be more or less smart about what work we can avoid or precompute, and thereby eliminate or move around the costs, but the ideas are more or less the same.</p>
<p>Second, <strong>every optimization we’ve done increases the amount of redundancy, mutability, bit-twiddliness, and general difficulty of understanding the algorithm</strong>.</p>
<p>Gosper’s algorithm stands in marked contrast.</p>
<ul>
<li>There is no “array of cells” <em>at all</em></li>
<li><span>The attack on the problem is purely functional programming; there is very little state mutation.</span></li>
<li>There is no redundancy. In the Abrash, Stafford and Hensel algorithms we had ever-increasing amounts of redundant state that had to be carefully kept in sync with the board state. In Gosper’s algorithm, there is board state and nothing else.</li>
<li><span>No attempt whatsoever is made to make individual cells smaller in memory, but it can represent grids a trillion cells on a side with a reasonable amount of memory.</span></li>
<li><span> It can compute trillions of ticks per second on quadrillion-cell grids on machines that only do billions of operations per second.</span></li>
<li>Though there are plenty of tricky details to consider in the actual implementation, the core algorithm is utterly simple and elegant. The gear that does the optimization of the algorithm uses off-the-shelf parts and completely standard, familiar functional programming techniques. There is no mucking around with fiddly region change tracking, or change lists, or bit sets, or any of those mechanisms.</li>
<li>And extra bonus, the algorithm makes “zoom in or out arbitrarily far” in the UI super easy, which is nice for large boards.</li>
</ul>
<p><strong>This all sounds impossible.</strong><span> It is not an exaggeration to say that learning about this algorithm changed the way I think about the power of functional programming and data abstraction, and I’ve been meaning to write a blog about it for literally over a decade.</span></p>
<p>It will take us several episodes to get through it:</p>
<ul>
<li><strong>Next time on FAIC</strong> we’ll look at the core data structure. We’ll see how we can compress large boards down to a small amount of space.</li>
<li>Then we’ll closely examine the “update the UI” algorithm and see how we can get a nice new feature.</li>
<li>After that we’ll build the “step forward one generation algorithm” and do some experiments with it.</li>
<li>Finally, we’ll discover the key insight that makes Gosper’s algorithm work: you can <em>enormously</em> compress time if you make an extremely modest addition of extra space.</li>
<li>We will finish off this series with an answer to a question I’ve been posing for some time now: are there patterns that grow quadratically?</li>
</ul>
			</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>