<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Candidate Features For C# 9 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Candidate Features For C# 9</h1><div><div id="div2" class="PaddingLeft5" xmlns="http://www.w3.org/1999/xhtml"><p>The long road to C# 9 has already begun and this is the first article in the world about the C# 9 Candidate features. Once you have completed reading this article, you will hopefully be better prepared for the new C# challenges you will meet in the future.</p><p>The article is based on,</p><h2>Records and Pattern-based With-Expression</h2><p>I have been waiting for a long time for this feature. Records is a lightweight immutable type. They are nominally typed, and they might have (methods, properties, operators, etc) and allow you to compare structural equality! Also, the record properties are read-only by default.</p><p> Records can be Value Type or Reference Type.</p><p><strong>Example</strong></p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Point3D(</span><span class="keyword">double</span><span>&nbsp;X,&nbsp;</span><span class="keyword">double</span><span>&nbsp;Y,&nbsp;</span><span class="keyword">double</span><span>&nbsp;Z);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Demo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;CreatePoint()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;var&nbsp;p&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Point3D(1.0,&nbsp;1.0,&nbsp;1.0);&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><p>The code above is converted to,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Point3D&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">private</span><span>&nbsp;</span><span class="keyword">readonly</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;&lt;X&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">private</span><span>&nbsp;</span><span class="keyword">readonly</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;&lt;Y&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">private</span><span>&nbsp;</span><span class="keyword">readonly</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;&lt;Z&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;X&nbsp;{</span><span class="keyword">get</span><span>&nbsp;{</span><span class="keyword">return</span><span>&nbsp;&lt;X&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;Y{</span><span class="keyword">get</span><span>{</span><span class="keyword">return</span><span>&nbsp;&lt;Y&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">double</span><span>&nbsp;Z{</span><span class="keyword">get</span><span>{</span><span class="keyword">return</span><span>&nbsp;&lt;Z&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;Point3D(</span><span class="keyword">double</span><span>&nbsp;X,&nbsp;</span><span class="keyword">double</span><span>&nbsp;Y,&nbsp;</span><span class="keyword">double</span><span>&nbsp;Z)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&lt;X&gt;k__BackingField&nbsp;=&nbsp;X;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&lt;Y&gt;k__BackingField&nbsp;=&nbsp;Y;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&lt;Z&gt;k__BackingField&nbsp;=&nbsp;Z;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">bool</span><span>&nbsp;Equals(Point3D&nbsp;value)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;X&nbsp;==&nbsp;value.X&nbsp;&amp;&amp;&nbsp;Y&nbsp;==&nbsp;value.Y&nbsp;&amp;&amp;&nbsp;Z&nbsp;==&nbsp;value.Z;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">override</span><span>&nbsp;</span><span class="keyword">bool</span><span>&nbsp;Equals(</span><span class="keyword">object</span><span>&nbsp;value)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;Point3D&nbsp;value2;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;(value2&nbsp;=&nbsp;(value&nbsp;</span><span class="keyword">as</span><span>&nbsp;Point3D))&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>&nbsp;&amp;&amp;&nbsp;Equals(value2);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">override</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;GetHashCode()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;((1717635750&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;&nbsp;EqualityComparer&lt;</span><span class="keyword">double</span><span>&gt;.Default.GetHashCode(X))&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;EqualityComparer&lt;</span><span class="keyword">double</span><span>&gt;.Default.GetHashCode(Y))&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;&nbsp;EqualityComparer&lt;</span><span class="keyword">double</span><span>&gt;.Default.GetHashCode(Z);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>Using&nbsp;Records:&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Demo&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;CreatePoint()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;Point3D&nbsp;point3D&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Point3D(1.0,&nbsp;1.0,&nbsp;1.0);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><p>Records proposal is introduced with the new proposed feature "with-expression", and you can use them together like the following,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>var&nbsp;newPoint3D&nbsp;=&nbsp;point3D.With(x:&nbsp;42);&nbsp; &nbsp;</span></span></li></ol></div><p>The created new point (newPoint3D) just like the existing one (point3D), but with the value of X changed to 42.</p><p>This future is also working very well with pattern matching. I will cover this topic in a separate article.</p><h2>Records in F#</h2><p>Copy from F# MSDN example, type Point3D = {X: float; Y: float; Z: float}</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>let&nbsp;evaluatePoint&nbsp;(point:&nbsp;Point3D)&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>match&nbsp;point&nbsp;with&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span class="string">"Point&nbsp;is&nbsp;at&nbsp;the&nbsp;origin."</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;xVal;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span class="string">"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;x-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;xVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;yVal;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span class="string">"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;y-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;yVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;zVal&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span class="string">"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;z-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;zVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;xVal;&nbsp;Y&nbsp;=&nbsp;yVal;&nbsp;Z&nbsp;=&nbsp;zVal&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span class="string">"Point&nbsp;is&nbsp;at&nbsp;(%f,&nbsp;%f,&nbsp;%f)."</span><span>&nbsp;xVal&nbsp;yVal&nbsp;zVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;100.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;10.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;-1.0&nbsp;}&nbsp;&nbsp;&nbsp;</span></li></ol></div><p>The output of this code is as follows.</p><div><ul><li>Point is at the origin.</li><li>Point is on the x-axis. Value is 100.000000.</li><li>Point is at (10.000000, 0.000000, -1.000000).</li></ul></div><p>The first question which comes to my mind why do we need Records? Is it not better to use a struct?</p><p>To answer the questions, I have posted a quote from Reddit:</p><p>"Structs are a thing you have to have some discipline to implement. You don't have to make them immutable. You don't have to implement their value equality logic. You don't have to make them comparable. If you don't, you lose almost all of their benefits, but the compiler doesn't enforce any of these constraints.</p><p>Record types are implemented by the compiler, which means you have to meet all of those criteria and can't get them wrong.</p><p>So not only do they save a lot of boilerplate, they eliminate an entire class of potential bugs.</p><p>Moreover, this feature existed over a decade in F#, and other languages like (Scala, Kotlin) have a similar concept too.</p><p>Examples for other languages that support both constructors and records,</p><p><strong>F#</strong></p><div><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>type&nbsp;Greeter(name:&nbsp;</span><span class="keyword">string</span><span>)&nbsp;=&nbsp;member&nbsp;</span><span class="keyword">this</span><span>.SayHi()&nbsp;=&nbsp;printfn&nbsp;</span><span class="string">"Hi,&nbsp;%s"</span><span>&nbsp;name&nbsp;&nbsp;</span></span></li></ol></div></div><p><strong>Scala</strong></p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">class</span><span>&nbsp;Greeter(name:&nbsp;String)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;def&nbsp;SayHi()&nbsp;=&nbsp;println(<span class="string">"Hi,&nbsp;"</span><span>&nbsp;+&nbsp;name)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><p><strong>Kotlin</strong></p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">class</span><span>&nbsp;Greeter(val&nbsp;name:&nbsp;String)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;fun&nbsp;sayhi()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;println(<span class="string">"Hi,&nbsp;${name}"</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp; &nbsp;</span></li></ol></div><p>Meanwhile, we are still writing in C# the long code below,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Greeter</span></span></li><li class=""><span>{</span></li><li class="alt"><span>&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">readonly</span><span>&nbsp;</span><span class="keyword">string</span><span>&nbsp;_name;</span></span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;Greeter(</span><span class="keyword">string</span><span>&nbsp;name)</span></span></li><li class="alt"><span>&nbsp;{</span></li><li class=""><span>&nbsp;_name&nbsp;=&nbsp;name;</span></li><li class="alt"><span>&nbsp;}</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;Greet()</span></span></li><li class="alt"><span>&nbsp;{</span></li><li class=""><span>&nbsp;&nbsp;Console.WriteLine($&nbsp;<span class="string">"Hello,&nbsp;{_name}"</span><span>);</span></span></li><li class="alt"><span>&nbsp;}</span></li><li class=""><span>}</span></li></ol></div><p>When this feature is done, then we can reduce the C# code to,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Greeter(name:&nbsp;</span><span class="keyword">string</span><span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;Greet()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;Console.WriteLine($&nbsp;<span class="string">"Hello,&nbsp;{_name}"</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp; &nbsp;&nbsp;</span></li></ol></div><p>Less code! = I love it!</p><h2>Type Classes</h2><p>This feature is inspired from Haskell and it is one of my favorite features. As I said before, two years ago in my old article, C# is going to implement more functional programming concepts and this is one of those FP- concepts. In functional programming, Type Classes allow you to add a set of operations on a type, but not implement it. Since the implementation is done elsewhere, this is a form of polymorphism, but lots more flexible or ad-hoc than the classical kind in object-oriented programming languages.</p><p>Type classes and C# interfaces serve similar purposes, but the way they work is somewhat different, and in some cases, Type Classes are more straightforward to use because of working on fixed types rather than pieces of an inheritance hierarchy.</p><p>This feature was originally introduced together with “extending everything” feature, and you can combine them as shown below in Mads Torgersen example.</p><p>I have quoted some text from the official proposal:</p><p>"In general, a "shape" declaration is very much like an interface declaration, except that it,</p><div><ul><li>Can define almost any kind of member (including static members)</li><li>Can be implemented by an extension</li><li>Can be used as a type only in certain places."</li></ul></div><p>Haskell Type Class example.</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">class</span><span>&nbsp;Eq&nbsp;a&nbsp;where&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>(==)&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;Bool&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>(/=)&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;Bool&nbsp; &nbsp;</span></li></ol></div><p>"Eq" is the class name, and ==, /= are the operations in the class. A type "a" is an instance of the class "Eq".</p><p>Haskell example as a generic C# interface,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">interface</span><span>&nbsp;Eq&nbsp;&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">bool</span><span>&nbsp;Equal(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">bool</span><span>&nbsp;NotEqual(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><p>Haskell example as Type Classes in C# 9(shape is a new distinctive keyword for Type classes),</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>shape&nbsp;Eq&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">bool</span><span>&nbsp;Equal(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">bool</span><span>&nbsp;NotEqual(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp; &nbsp;</span></li></ol></div><p>Example to show the syntax similarity between interfaces and type classes,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">interface</span><span>&nbsp;Num&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;A&nbsp;Add(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;A&nbsp;Mult(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;A&nbsp;Neg(A&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">struct</span><span>&nbsp;NumInt&nbsp;:&nbsp;Num&lt;</span><span class="keyword">int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;Add(</span><span class="keyword">int</span><span>&nbsp;a,&nbsp;</span><span class="keyword">int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;Mult(</span><span class="keyword">int</span><span>&nbsp;a,&nbsp;</span><span class="keyword">int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;*&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;Neg(</span><span class="keyword">int</span><span>&nbsp;a)&nbsp;=&gt;&nbsp;-a;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp; &nbsp;&nbsp;</span></li></ol></div><p>With C# 9 Type Classes concept C#,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>shape&nbsp;Num&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;A&nbsp;Add(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;A&nbsp;Mult(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;A&nbsp;Neg(A&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>instance&nbsp;NumInt&nbsp;:&nbsp;Num&lt;<span class="keyword">int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">int</span><span>&nbsp;Add(</span><span class="keyword">int</span><span>&nbsp;a,&nbsp;</span><span class="keyword">int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">int</span><span>&nbsp;Mult(</span><span class="keyword">int</span><span>&nbsp;a,&nbsp;</span><span class="keyword">int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;*&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">int</span><span>&nbsp;Neg(</span><span class="keyword">int</span><span>&nbsp;a)&nbsp;=&gt;&nbsp;-a;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp; &nbsp;&nbsp;</span></li></ol></div><h2>Mads Torgersen Example</h2><p>Important information: a shape is not a type. Instead, the primary purpose of a shape is to be used as a generic constraint, limiting type arguments to have the right shape, while allowing the body of the generic declaration to make use of that shape,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;shape&nbsp;SGroup&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">static</span><span>&nbsp;T&nbsp;</span><span class="keyword">operator</span><span>&nbsp;+(T&nbsp;t1,&nbsp;T&nbsp;t2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">static</span><span>&nbsp;T&nbsp;Zero&nbsp;{</span><span class="keyword">get</span><span>;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol></div><p>This declaration says that a type can be an SGroup&lt;T&gt; if it implements a+ operator over T, and a Zero static property.</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;extension&nbsp;IntGroup&nbsp;of&nbsp;</span><span class="keyword">int</span><span>:&nbsp;SGroup&lt;</span><span class="keyword">int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">int</span><span>&nbsp;Zero&nbsp;=&gt;&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp; &nbsp;</span></li></ol></div><p>And the extension.</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;AddAll&lt;T&gt;(T[]&nbsp;ts)&nbsp;where&nbsp;T:&nbsp;SGroup&lt;T&gt;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;var&nbsp;result&nbsp;=&nbsp;T.Zero;&nbsp;<span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">foreach</span><span>&nbsp;(var&nbsp;t&nbsp;</span><span class="keyword">in</span><span>&nbsp;ts)&nbsp;{&nbsp;result&nbsp;+=&nbsp;t;&nbsp;}&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp; &nbsp;</span></li></ol></div><p>Let us call the AddAll method with some ints,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">int</span><span>[]&nbsp;numbers&nbsp;=&nbsp;{&nbsp;5,&nbsp;1,&nbsp;9,&nbsp;2,&nbsp;3,&nbsp;10,&nbsp;8,&nbsp;4,&nbsp;7,&nbsp;6&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>WriteLine(AddAll(numbers));&nbsp;<span>&nbsp;&nbsp;</span></span></li></ol></div><h2>Dictionary Literals</h2><p>Introduces a simpler syntax to create initialized Dictionary&lt;TKey,TValue&gt; objects without having to specify either the Dictionary type name or the type parameters. The type parameters for the dictionary are inferred using the existing rules used for array type inference.</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>var&nbsp;x&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Dictionary&nbsp;&lt;</span><span class="keyword">string</span><span>,</span><span class="keyword">int</span><span>&gt;&nbsp;()&nbsp;{&nbsp;{&nbsp;</span><span class="string">"foo"</span><span>,&nbsp;4&nbsp;},&nbsp;{&nbsp;</span><span class="string">"bar"</span><span>,&nbsp;5&nbsp;}};&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>var&nbsp;x&nbsp;=&nbsp;[<span class="string">"foo"</span><span>:4,&nbsp;</span><span class="string">"bar"</span><span>:&nbsp;5];&nbsp;&nbsp;</span></span></li></ol></div><p>This proposal makes the work with dictionaries in C# simpler and removing the redundant code. In addition, it is worth to mention that a similar dictionary-syntax is used in other programming languages like F# and Swift.</p><h2>Params Span&lt;T&gt;</h2><p>Allows the params syntax to use Span&lt;T&gt; this help to implement params parameter-passing without any heap allocation. This feature could make the use of params methods much more efficient.</p><p>The new Syntax could be like,</p><div><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;Foo(</span><span class="keyword">params</span><span>&nbsp;Span&lt;</span><span class="keyword">int</span><span>&gt;&nbsp;values);&nbsp; &nbsp;</span></span></li></ol></div></div><h2>Allow no-arg constructor and field initializers in struct declarations</h2><p>Until now no-arg constructor and field initializers in struct declarations are not allowed in C#. In C# 9, this limitation will be removed.</p><p><strong>StackOverflow example</strong></p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;Rational&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">long</span><span>&nbsp;numerator;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">private</span><span>&nbsp;</span><span class="keyword">long</span><span>&nbsp;denominator;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;Rational(</span><span class="keyword">long</span><span>&nbsp;num,&nbsp;</span><span class="keyword">long</span><span>&nbsp;denom)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;{&nbsp;<span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;Rational(</span><span class="keyword">long</span><span>&nbsp;num)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;numerator&nbsp;=&nbsp;num;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;denominator&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;<span class="keyword">public</span><span>&nbsp;Rational()&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;numerator&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;denominator&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp; &nbsp;</span></li></ol></div><p>Quoted Text from the official proposal,</p><p>"HaloFour commented on Nov 6, 2017</p><p>Proposal #99.</p><p>That proposal seeks to remove the language limitation which prevents declaring a default constructor. The CLR already fully supports structs with default constructors, and C# supports using them. They are entirely unrelated to constants and couldn't be related to constants given that the feature already exists at the CLR level and behaves differently."</p><h2>Native-Sized Number Types</h2><p>Introduces a new set of native types (nint, nuint, nfloat, etc) the ‘n’ for native. The design of the new data types is planned to allow a one C# source file to use 32 naturally- or 64-bit storage depending on the host platform type and the compilation settings.</p><p>The native type is depending on the OS,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>nint&nbsp;nativeInt&nbsp;=&nbsp;55;&nbsp;take&nbsp;4&nbsp;bytes&nbsp;when&nbsp;I&nbsp;compile&nbsp;</span><span class="keyword">in</span><span>&nbsp;32&nbsp;Bit&nbsp;host.&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>nint&nbsp;nativeInt&nbsp;=&nbsp;55;&nbsp;take&nbsp;8&nbsp;bytes&nbsp;when&nbsp;I&nbsp;compile&nbsp;<span class="keyword">in</span><span>&nbsp;64&nbsp;Bit&nbsp;host&nbsp;with&nbsp;x64&nbsp;compilation&nbsp;settings.&nbsp; &nbsp;</span></span></li></ol></div><p>A similar concept exists already in xamarin,</p><h2>Fixed Sized Buffers</h2><p>These provide a general-purpose and safe mechanism for declaring fixed sized buffers to the C# language.</p><p>“Motivation Today, users can create fixed-sized buffers in an unsafe-context. However, this requires the user to deal with pointers, manually perform bounds checks, and only supports a limited set of types (bool, byte, char, short, int, long, sbyte, ushort, uint, ulong, float, and double).”</p><p>This feature will make fixed-sized buffer safe as in the example below.</p><p>One would declare a safe fixed-sized buffer via the following,</p><div><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">fixed</span><span>&nbsp;DXGI_RGB&nbsp;GammaCurve[1025];&nbsp; &nbsp;</span></span></li></ol></div></div><p>The declaration would get translated into an internal representation by the compiler that is similar to the following,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>[FixedBuffer(</span><span class="keyword">typeof</span><span>(DXGI_RGB),&nbsp;1024)]&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span><span class="keyword">public</span><span>&nbsp;ConsoleApp1.&lt;Buffer&gt;e__FixedBuffer_1024&lt;DXGI_RGB&gt;&nbsp;GammaCurve;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>[CompilerGenerated,&nbsp;UnsafeValueType,&nbsp;StructLayout(LayoutKind.Sequential,&nbsp;Pack&nbsp;=&nbsp;0)]&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">struct</span><span>&nbsp;&lt;Buffer&gt;e__FixedBuffer_1024&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;<span class="keyword">private</span><span>&nbsp;T&nbsp;_e0;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">private</span><span>&nbsp;T&nbsp;_e1;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">private</span><span>&nbsp;T&nbsp;_e1024;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">ref</span><span>&nbsp;T&nbsp;</span><span class="keyword">this</span><span>[</span><span class="keyword">int</span><span>&nbsp;index]&nbsp;=&gt;&nbsp;</span><span class="keyword">ref</span><span>&nbsp;(</span><span class="keyword">uint</span><span>)index&nbsp;&lt;=&nbsp;1024u&nbsp;?&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;<span class="keyword">ref</span><span>&nbsp;RefAdd&lt;T&gt;(</span><span class="keyword">ref</span><span>&nbsp;_e0,&nbsp;index):&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;<span class="keyword">throw</span><span>&nbsp;</span><span class="keyword">new</span><span>&nbsp;IndexOutOfRange();&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li></ol></div><h2>Uft8 string literals</h2><p>It is about defining a new type of UTF8String which will be like,</p><div><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span>System.UTF8String&nbsp;myUTF8string&nbsp;=</span><span class="string">"Test&nbsp;String"</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li></ol></div></div><p><strong>based(T)</strong></p><p>The problem,</p><div class="dp-highlighter"><ol start="1" class="dp-c"><li class="alt"><span><span class="keyword">interface</span><span>&nbsp;I1&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;M(</span><span class="keyword">int</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">interface</span><span>&nbsp;I2&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;M(</span><span class="keyword">short</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span><span class="keyword">interface</span><span>&nbsp;I3&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">override</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;I1.M(</span><span class="keyword">int</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class=""><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span><span class="keyword">interface</span><span>&nbsp;I4&nbsp;:&nbsp;I3&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">void</span><span>&nbsp;M2()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">base</span><span>(I3).M(0)&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class=""><span>}&nbsp;&nbsp;</span></li></ol></div><p>"The tricky part here is that both M(short) and M(int) are applicable to M(0), but lookup rules also say that if we find an applicable member in a more derived interface, we ignore members from the less derived interfaces. Combined with the rule that overrides are not found during lookup, when looking in I3 the first thing we find is I2.M, which is applicable, meaning that I1.M does not appear in the list of applicable members.</p><p>Since we concluded in the previous meeting that an implementation must exist in the target type, and I2.M is the only applicable member, the call base(I3).M(0) as written is an error, because I2.M does not have an implementation in I3."</p><p>More Information,</p><div><ul><li><em>https://github.com/dotnet/csharplang/issues/2337</em></li><li><em>https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-02-27.md</em></li></ul></div><h2>Summary</h2><p>You have read the first C# 9 Candidate features. As you have seen, many new features are inspired from other programming languages or programming paradigms, and not self-innovation, but the good thing is that the most of candidate features are well accepted among the community.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>