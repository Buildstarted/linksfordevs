<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Cryptologie - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Cryptologie - linksfor.dev(s)"/>
    <meta property="article:author" content="david wong"/>
    <meta property="og:description" content="Hey ! I&#x27;m David, a security engineer at Facebook. This is my blog about cryptography and security and other related topics that I find interesting."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.cryptologie.net/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Cryptologie</title>
<div class="readable">
        <h1>Cryptologie</h1>
            <div>by david wong</div>
            <div>Reading time: 34-43 minutes</div>
        <div>Posted here: 21 Feb 2020</div>
        <p><a href="https://www.cryptologie.net/">https://www.cryptologie.net/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<article>

<p>Writing about real world cryptography, it seems like what I end up writing a lot about is protocols and how they solve origin/identity authentication.</p>
<p>Don't get me wrong, confidentiality has interesting problems to (e.g. how to bring confidentiality to a blockchain), but authentication is most of what applied cryptography is about, for realz.</p>
<p>Do I need to convince you?</p>
<p>If you think about it, most protocols are about finding ways to provide authentication to different scenarios. And that's why they can get complicated!</p>
<p>I'll take my life for example, here is the authentication problems and solutions that I use:</p>
<ul>
<li><strong>insecure → one-side authenticated</strong>. Every day I use HTTPS, which uses the web public-key infrastructure (web PKI) to allow my browser to authenticate any websites on the web. It's a mess, but that's how you scale machine-to-machine authentication nowadays.</li>
<li><strong>one-side authenticated → mutually-authenticated</strong>. Whenever I log into a website, over a secure HTTPS connection, this is what happens. A machine asks me to present some password (in clear, or oblivious via an asymmetric password-authenticated key exchange), or maybe a one-time password (via TOTP), or maybe I'll have to press my thumb on a yubikey (FIDO 2), or maybe I'll have to do a combination of several things (MFA). These are usually machine authenticating humans-type of flow.</li>
<li><strong>insecure → mutually-authenticated</strong>. Whenever I talk to someone on Signal, or connect to a new WiFi, or pair a bluetooth device (like my phone with a car), I go from an insecure connection to a mutually-authenticated connection. There is a bit more nuance here, as sometimes I'll authenticate a machine (a WiFi access point for example) and sometimes I'll authenticate a human (end-to-end encryption). So different techniques work best depending on the type of peer you're trying to talk to.</li>
</ul>
<p>In the end, I think these are the main three big categories of origin authentication.
Can you think of a better classification?</p>
<a href="https://www.cryptologie.net/article/494/authentication-what-the-fuck-part-ii/#comments"> comment on this story</a>
</article>
<article>

<p>There is a whole field of authentication in cryptography that is often under-discussed (at least in my opinion).</p>
<p>See, we often like to talk about how key exchanges can also be authenticated, by mean of public-key infrastructures (e.g. HTTPS) or by pre-exchanging secrets (e.g. <a href="https://www.cryptologie.net/article/490/how-symmetric-password-authenticated-key-exchanges-work-spake/">my previous post on sPAKE</a>), but we seldom talk about <strong>post-handshake authentication</strong>.</p>
<p>Post-handshake authentication is the idea that you can connect to something (often a hardware device) insecurely, and then "augment" the connection via some information provided in a special <strong>out-of-band</strong> channel.</p>
<p>But enough blabla, let me give you a real-world example: you link your phone with your car and are then asked to compare a few digits (this pairing method is called "numeric comparison" in the bluetooth spec). Here:</p>
<ul>
<li><strong>Out-of-band channel</strong>. you are in your car, looking at your screen, this is your out-of-band channel. It provides integrity (you know you can trust the numbers displayed on the screen) but do not necessarily provide confidentiality (someone could look at the screen through your window).</li>
<li><strong>Short authenticated string (SAS)</strong>. The same digits displayed on the car's screen and on your phone are the SAS! If they match you know that the connection is secure.</li>
</ul>
<p>This SAS thing is <strong>extremely practical and usable</strong>, as it works without having to provision devices with long secrets, or having the user compare long strings of unintelligible characters.</p>
<p>How to do this? You're probably thinking "easy!". An indeed it seems like we could just do a key exchange, and then pass the output in some KDF to create this SAS.</p>
<p><strong>NOPE</strong>. </p>
<p>This has been <a href="https://moderncrypto.org/mail-archive/curves/2017/000896.html">discussed</a> <a href="https://vnhacker.blogspot.com/2016/08/the-internet-of-broken-protocols.html">long-and-large</a> on <a href="https://research.kudelskisecurity.com/2017/04/25/should-ecdh-keys-be-validated/">the internet</a>: with key exchange protocols like X25519 it <strong>doesn't work</strong>.
The reason is that X25519 does not have <strong>contributory behavior</strong>: I can send you a public key that will lead to a predictable shared secret. In other words: your public key does not <strong>contribute</strong> (or very little) to the output of the algorithm.</p>
<p>The correct™ solution here is to give more than just the key exchange output to your KDF: give it your protocol transcript. All the messages sent and received. This puts any man-in-the-middle attempts in the protocol to a stop. (And the lesson is that you shouldn't naively customize a key exchange protocol, it can lead to real world failures.)</p>
<p>The next question is, what's more to SAS-based protocols? After all, <a href="http://secu.famillepasini.ch/files/2009/phd/pasini_phd_thesis.pdf">Sylvain Pasini wrote a 300-page thesis on the subject</a>. I'll answer that in my next post.</p>
<a href="https://www.cryptologie.net/article/493/what-are-short-authenticated-strings-sas/#comments"> comment on this story</a>
</article>
<article>

<p>have you heard of <strong>sPAKE</strong> (or <strong>bPAKE</strong>)?</p>
<p>a sPAKE is first and foremost a <strong>PAKE</strong>, which stands for <strong>Password-Authenticated Key Exchange</strong>.
This simply means that authentication in the key exchange is provided via the knowledge of a password.
The s (resp. b) in front means symmetric (resp. balanced). This indicates that both sides know the password.</p>
<p><img alt="Alice and Bob trying to use a sPAKE to authenticate a key exchange" src="https://www.cryptologie.net/upload/Screen_Shot_2020-02-09_at_5.21_.17_PM_.png"></p>
<p>Other PAKEs where only one side knows the password exist, these are called aPAKE for asymmetric (or augmented) PAKEs.
Yes I know the nomenclature is a bit confusing :)</p>
<p>The most promising sPAKE scheme currently seems to be <strong>SPAKE2</strong>, which is <a href="https://tools.ietf.org/html/draft-irtf-cfrg-spake2-09">in the process of being standardized here</a>.
There are other sPAKEs, like Dragonfly which is used in WPA3, but they don't seem to provide as strong properties as SPAKE2.</p>
<p>The trick to a symmetric PAKE is to use the password to blind the key exchange's ephemeral keypairs.</p>
<p><img alt="The first part of a sPAKE with SPAKE2" src="https://www.cryptologie.net/upload/Screen_Shot_2020-02-09_at_5.22_.49_PM_.png"></p>
<p>Note that we can't use the password as is, instead we:</p>
<ul>
<li>Pass the password into a memory-hard hash function like Argon2 to obtain <code>w</code>. Can you guess why we do this? (leave a comment if you do!)</li>
<li>Convert it to a group element. To do this we simply consider <code>w</code> a scalar and do a scalar multiplication with a generator of our subgroup (<code>M</code> or <code>N</code> depending if you're the client or the server, can you guess why we use <a href="https://eprint.iacr.org/2019/1194.pdf">different generators</a>?)</li>
</ul>
<blockquote>
<p>NOTE: If you know BLS or OPAQUE, you might be wondering why we don't use a "hash-to-curve" algorithm, this is because we don't need to obtain a group element with an unknown discrete logarithm in SPAKE2.</p>
</blockquote>
<p>Once the blinded (with the password) public keys have been exchanged, both sides can compute a shared group element:</p>
<ul>
<li>Alice computes <code>K = h × alice_private_key × (S - w × N)</code></li>
<li>Bob computes <code>K = h × bob_private_key × (T - w × M)</code></li>
</ul>
<p>Spend a bit of your time to understand these equations.
What happens is that both Alice and Bob first unblind the public key they've received, then perform a key exchange with it, then multiply it with the value <code>h</code>. What's this value <code>h</code>? The cofactor, or simply put: the other annoying subgroup.</p>
<p>Finally Alice and Bob <strong>hash the whole transcript</strong>, which is the concatenation of:</p>
<ul>
<li>Alice's identity.</li>
<li>Bob's identity.</li>
<li>The message Bob sent <code>S</code>.</li>
<li>The message Alice sent <code>T</code>.</li>
<li>The shared group element <code>K</code>.</li>
<li>The hardened password <code>w</code>.</li>
</ul>
<p>The hash of this transcript gives us two things:</p>
<ul>
<li>A <strong>shared secret</strong> !</li>
<li>A key that is further expanded (via a KDF) to obtain two authentication keys.</li>
</ul>
<p><img alt="The key derivation of sPAKE" src="https://www.cryptologie.net/upload/Screen_Shot_2020-02-09_at_5.55_.57_PM_.png"></p>
<p>These authentication keys sole purpose is to provide <strong>key confirmation</strong> in the last round-trip of messages.
That is to say at this point, if we don't do anything, we don't know if either Alice or Bob truly managed to compute the shared secret.</p>
<p>Key confirmation is pretty simple, both sides just have to compute an authentication tag with one of the authentication key produced over the transcript.</p>
<p>The final protocol looks a bit dense, but you should be able to decipher it if you've read this far.</p>
<p><img alt="Whole SPAKE2 protocol" src="https://www.cryptologie.net/upload/Screen_Shot_2020-02-09_at_5.56_.36_PM_.png"></p>
<a href="https://www.cryptologie.net/article/490/how-symmetric-password-authenticated-key-exchanges-work-spake/#comments"> 1 comment </a>
</article>
<article>

<p>Authentication is an overloaded word in cryptography.</p>
<p>In the context of <strong>cryptographic primitives</strong> like message authentication codes (MACs) and authenticated encryption with associated data (AEAD), authentication really refers to authenticity or integrity. And as the <a href="https://dictionary.cambridge.org/us/dictionary/english/authenticity">Cambridge dictionary</a> says:</p>
<blockquote>
<p><strong>Authenticity</strong>. the quality of being real or true.<br>
The poems are supposed to be by Sappho, but they are actually of doubtful authenticity.<br>
The authenticity of her story is beyond doubt.</p>
</blockquote>
<p>The proof is in the pudding. When talking about the security properties of primitives like MACs, cryptography talks about <strong>unforgeability</strong>, which does relate to authenticity.</p>
<p>So whenever you hear things like "<em>is this payload authenticated with HMAC?</em>", think authenticity, think integrity.</p>
<p>In the context of <strong>protocols</strong> though (e.g. TLS) authentication refers to <strong>identification</strong>: the concept of <strong>proving who you are</strong>.</p>
<p>So whenever you hear things like "<em>Is the server authenticated?</em>", think "identities are being proven".</p>
<p>This dual sense really annoys me, but in the end this ambiguity is encompassed in the definition of authentication:</p>
<blockquote>
<p>the process or action of proving or showing something to be true, genuine, or valid.</p>
</blockquote>
<p><a href="https://twitter.com/dfaranha/status/1221558605259988994">Diego F. Aranha</a> proposes a clever way to disambiguate the two:</p>
<ul>
<li><strong>origin/entity authentication</strong>. You're proving that an entity really is who they say they are.</li>
<li><strong>message authentication</strong>. You're proving that a message is genuine.</li>
</ul>
<p>Note that an argument against this distinction is the following: to authenticate a message, you need a key. This key comes from somewhere (it's your context, or your "who"). So when you authenticate a message, you are really authenticating the context. This falls short in scenarios where for example you trust the root hash of a merkle tree, which authenticates all of its leaves.</p>
<p>The bottom line is, authentication is about proving that something is what it is supposed to be. And that thing can be a person, or a message, or maybe even something else.</p>
<p>This is not all. In the security world people are confused with authorization vs authentication :)</p>
<a href="https://www.cryptologie.net/article/489/authentication-what-the-fuck/#comments"> comment on this story</a>
</article>
<article>

<p>I've been following the Messaging Layer Security (MLS) standardization a bit.
I really appreciate what the people are doing there, and what they are trying to solve.
I think <strong>group messaging</strong> is currently a huge <strong>mess</strong>, as every application I have seen/audited seemed to invent a new way to implement group chat.
A common standard and guidelines would greatly help.</p>
<p>MLS' goal is to provide a solution to end-to-end encryption for group chats. A solution that <strong>scales</strong>.</p>
<p>If you don't know how the MLS protocol works, I advise you to read <a href="https://mrosenberg.pub/cryptography/2019/07/10/molasses.html">Michael Rosenberg's blog post</a> or to watch the Real World Crypto talk on the subject (might not be available at the moment).</p>
<p>Thinking about the standard, I have two questions:</p>
<ol>
<li><strong>Does a group chat loses any notion of privacy/confidentiality after it gets too large?</strong> For example, if you are in a Hong Kong group trying to organize a protest and there are more than 1,000 people in the group, what are the odds that one of them is a <a href="https://www.youtube.com/watch?v=_s5R9cFdRmg">cop</a>?</li>
<li>Would a group chat protocol targeting groups with small numbers of participant (let's say 50 at most) be able to provide <strong>better security insurances efficiently</strong>?</li>
</ol>
<hr>
<p>For example, here are two security properties (taken from <a href="https://oaklandsok.github.io/papers/unger2014.pdf">SoK: Secure Messaging</a>) that MLS does not provide:</p>
<blockquote>
<p><strong>Speaker Consistency</strong>: All participants agree on the sequence of messages sent by each participant.</p>
</blockquote>
<p>This means that if Alice (who is part of a group chat with Bob and Eve) colludes with the server, she can send "I like cats" to Bob and "I like dogs" to Eve.</p>
<blockquote>
<p><strong>Global Transcript</strong>: All participants see all messages in the same order. Note that this implies speaker consistency</p>
</blockquote>
<p>This means that if Alice sends the following messages:</p>
<ul>
<li>you must decide</li>
<li>your path </li>
</ul>
<p>a server could re-order these messages so that Bob would see them in the same order, but Eve would see:</p>
<ul>
<li>your path</li>
<li>you must decide</li>
</ul>
<p><img alt="yoda" src="https://www.cryptologie.net/upload/baby-yoda-3.jpg"></p>
<hr>
<p>I have the following open questions:</p>
<ul>
<li>Are these attacks important to protect against?</li>
<li>Is there an efficient protocol to prevent these attacks for groups of reasonable size?</li>
<li>If we cannot prevent them, can we detect them and warm the users?</li>
<li>If we are willing to change the protocol when going from 2 participants to 3 participants, would be willing to change the protocol when going from N to N+1 participants (where N is the number of participants threshold where confidentiality/privacy fades away)?</li>
</ul>
<a href="https://www.cryptologie.net/article/488/messaging-layer-security-a-few-thoughts/#comments"> 2 comments </a>
</article>
<article>

<ul>
<li><strong>1981 - <a href="https://tools.ietf.org/html/rfc788">RFC 788 - Simple Mail Transfer Protocol</a> (SMTP) is published, the standard for email is born.</strong></li>
</ul>
<hr>
<p>This is were everything starts, we now have an open peer-to-peer protocol that everyone on the internet can use to communicate.</p>
<hr>
<ul>
<li>1991<ul>
<li>The US government introduces the 1991 Senate Bill 266, which attempts to allow "the Government to obtain the plain text contents of voice, data, and other communications when appropriately authorized by law" from "providers of electronic communications services and manufacturers of electronic communications service equipment". The bill fails to pass into law.</li>
<li><strong>Pretty Good Privacy (PGP) - released by Phil Zimmermann.</strong></li>
</ul>
</li>
<li>1993 - The US Government launches a criminal investigation against Phil Zimmermann for sharing a cryptographic tool to the world (at the time crypto exporting laws are a thing).</li>
<li>1995 - Zimmermann publishes PGP's source code in a book via MIT Press, dodging the criminal investigation by using the first ammendment's protection of books.</li>
</ul>
<hr>
<p>That's it, PGP is out there, people now have a weapon to fight government surveillance. As Zimmermann puts it:</p>
<blockquote>
<p>PGP empowers people to take their privacy into their own hands. There's a growing social need for it. That's why I wrote it.</p>
</blockquote>
<hr>
<ul>
<li>1995 - The RSA Data Security company proposes S/MIME as an alternative to PGP.</li>
<li>1996<ul>
<li>criminal investigation against Zimmermann and PGP is dropped.</li>
<li>PGP Inc is founded by Zimmermann, PGP becomes licensed-software.</li>
<li><a href="https://www.ietf.org/rfc/rfc1991.txt">RFC 1991 - PGP Message Exchange Formats</a></li>
</ul>
</li>
<li>1997 <ul>
<li><strong>GNU Privacy Guard (GPG)</strong> - version 0.0.0 released by Werner Koch.</li>
<li>PGP 5 is released.<blockquote>
<p>The original agreement between Viacrypt and the Zimmermann team had been that Viacrypt would have even-numbered versions and Zimmermann odd-numbered versions. Viacrypt, thus, created a new version (based on PGP 2) that they called PGP 4. To remove confusion about how it could be that PGP 3 was the successor to PGP 4, PGP 3 was renamed and released as PGP 5 in May 1997</p>
</blockquote>
</li>
</ul>
</li>
<li>1997 - PGP Inc is acquired by Network Associates</li>
<li>1998 - <a href="https://www.ietf.org/rfc/rfc2440.txt">RFC 2440 - OpenPGP Message Format</a><blockquote>
<p>OpenPGP - This is a definition for security software that uses PGP 5.x as a basis.</p>
</blockquote>
</li>
<li>1999<ul>
<li>GPG version 1.0 released </li>
<li><strong><a href="https://xmpp.org/">Extensible Messaging and Presence Protocol (XMPP)</a></strong> is developed by the open source community. XMPP is a federated chat protocol (users can run their own servers) that does not have end-to-end encryption and requires communications to be synchronous (both users have to be online).</li>
</ul>
</li>
<li>2002 - PGP Corporation is formed by ex-PGP members and the PGP license/assets are bought back from Network Associates</li>
<li><strong>2004 - Off-The-Record (OTR) is introduced by Nikita Borisov, Ian Avrum Goldberg, and Eric A. Brewer as an extension of the XMPP chat protocol in "<a href="https://otr.cypherpunks.ca/otr-wpes.pdf">Off-the-Record Communication, or, Why Not To Use PGP</a>"</strong><blockquote>
<p>We argue that [...] the encryption must provide perfect forward secrecy to protect from future compromises [...] the authentication mechanism must offer repudiation, so that the communications remain personal and unverifiable to third parties</p>
</blockquote>
</li>
</ul>
<hr>
<p>We now have an interesting development: messaging (which is seen as a different way of communication for most people) is getting the same security treatment as email.</p>
<hr>
<ul>
<li>2006 - GPG version 2.0 released</li>
<li>2007 - <a href="https://www.ietf.org/rfc/rfc4880.txt">RFC 4880 - OpenPGP Message Format</a></li>
<li>2010 - Symantec purchases the rights for PGP for $300 million.</li>
<li>2011 - <a href="https://en.wikipedia.org/wiki/Cryptocat">Cryptocat</a> is released.</li>
<li><strong>2013 - The TextSecure (now Signal) application is introduced, built on top of the TextSecure protocol with Axolotl (now the Signal protocol with the double ratchet) as an evolution of OTR and SCIMP. It provides asynchronous communication unlike other messaging protocols, closing the gap between messaging and email.</strong></li>
<li>2014<ul>
<li><a href="https://matrix.org/">Matrix</a> is introduced as a modern alternative to XMPP.</li>
<li><a href="https://blog.cryptographyengineering.com/2014/08/13/whats-matter-with-pgp/">Matthew Green - What’s the matter with PGP?</a></li>
</ul>
</li>
</ul>
<hr>
<p>PGP becomes increasingly criticized, as Matt Green puts it in 2014:</p>
<blockquote>
<p>It’s time for PGP to die.</p>
</blockquote>
<hr>
<ul>
<li>2015<ul>
<li>XMPP gets end-to-end encryption with the <a href="https://en.wikipedia.org/wiki/OMEMO">OMEMO</a> extension (which re-uses the Signal protocol)</li>
<li><a href="http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf">SoK: Secure Messaging</a></li>
<li><a href="https://moxie.org/blog/gpg-and-me/">Moxie - GPG and me</a></li>
</ul>
</li>
<li>2016<ul>
<li><a href="https://blog.filippo.io/giving-up-on-long-term-pgp/">Filippo Valsorda - I'm giving up on PGP</a><blockquote>
<p>All in all, I should be the perfect user for PGP. Competent, enthusiast, embedded in a similar community. But it just didn't work.</p>
</blockquote>
</li>
<li>WhatsApp now uses the Signal protocol, adding end-to-end encryption for its billions of users.</li>
</ul>
</li>
</ul>
<hr>
<p>Another unexpected development: security professionals are now giving up on encrypted emails, and are moving to secure messaging.
Is messaging going to replace email, even though it feels like a different mean of communication?</p>
<p>Moxie's quotes are quite interesting:</p>
<blockquote>
<p>In the 1990s, I was excited about the future, and I dreamed of a world where everyone would install GPG. Now I’m still excited about the future, but I dream of a world where I can uninstall it. </p>
</blockquote>
<blockquote>
<p>In addition to the design philosophy, the technology itself is also a product of that era. As Matthew Green has noted, “poking through an OpenPGP implementation is like visiting a museum of 1990s crypto.” The protocol reflects layers of cruft built up over the 20 years that it took for cryptography (and software engineering) to really come of age, and the fundamental architecture of PGP also leaves no room for now critical concepts like forward secrecy. </p>
</blockquote>
<blockquote>
<p>In 1997, at the dawn of the internet’s potential, the working hypothesis for privacy enhancing technology was simple: we’d develop really flexible power tools for ourselves, and then teach everyone to be like us. Everyone sending messages to each other would just need to understand the basic principles of cryptography. [...] </p>
</blockquote>
<blockquote>
<p>The GnuPG man page is over sixteen thousand words long; for comparison, the novel Fahrenheit 451 is only 40k words. [...] </p>
</blockquote>
<blockquote>
<p>Worse, it turns out that nobody else found all this stuff to be fascinating. Even though GPG has been around for almost 20 years, there are only ~50,000 keys in the “strong set,” and less than 4 million keys have ever been published to the SKS keyserver pool ever. By today’s standards, that’s a shockingly small user base for a month of activity, much less 20 years.</p>
</blockquote>
<hr>
<ul>
<li>2018<ul>
<li>the first draft of <strong>Messaging Layer Security (MLS)</strong> is published, a standard for end-to-end encrypted group chat protocols.</li>
<li><a href="https://efail.de/">EFAIL</a> releases damaging vulnerabilities against most popular PGP and S/Mime implementations.<blockquote>
<p>In a nutshell, EFAIL abuses active content of HTML emails, for example externally loaded images or styles, to exfiltrate plaintext through requested URLs. To create these exfiltration channels, the attacker first needs access to the encrypted emails, for example, by eavesdropping on network traffic, compromising email accounts, email servers, backup systems or client computers. The emails could even have been collected years ago.</p>
</blockquote>
</li>
</ul>
</li>
<li>2019 - <a href="https://latacora.micro.blog/2019/07/16/the-pgp-problem.html">Latacora - The PGP Problem</a><blockquote>
<p>Why do people keep telling me to use PGP? The answer is that they shouldn’t be telling you that, because PGP is bad and needs to go away.</p>
</blockquote>
</li>
</ul>
<hr>
<p>EFAIL is the straw that broke the camel's back. PGP is officially dead.</p>
<hr>
<ul>
<li>2019<ul>
<li>Matrix is out of beta and working on making end-to-end encryption the default.</li>
<li>Moxie gives a <a href="https://peertube.co.uk/videos/watch/12be5396-2a25-4ec8-a92a-674b1cb6b270">controversial talk at CCC</a> arguing that advancements in security, privacy, censorship resistance, etc. are incompatible with slow moving decentralized protocols. Today, most serious end-to-end encrypted messaging apps use the Signal protocol (Signal, Facebook Messenger, WhatsApp, Skype, etc.)</li>
<li>XMPP's response: <a href="https://blog.jabberhead.tk/2019/12/29/re-the-ecosystem-is-moving/">Re: the ecosystem is moving</a></li>
<li>Matrix's response: <a href="https://matrix.org/blog/2020/01/02/on-privacy-versus-freedom/">On privacy versus freedom</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>did you like this? This will part of a book on cryptography! <a href="https://www.manning.com/books/real-world-cryptography?a_aid=Realworldcrypto&amp;a_bid=ad500e09">Check it out here</a>.</p>
</blockquote>
<a href="https://www.cryptologie.net/article/487/a-history-of-end-to-end-encryption-and-the-death-of-pgp/#comments"> 4 comments </a>
</article>
<article>

<p>That title is a mouthful! But so is the field.</p>
<p>Let me introduce the problem: Alice owns a private key which can sign transactions. The problem is that she has a lot of money, and she is scared that someone will target her to steal all of her funds.</p>
<p>Cryptography offers some solutions to avoid this being a key management problem.</p>
<p>The first one is called <strong>Shamir Secret Sharing (SSS)</strong>, which is simply about splitting the signing private key into n shares.
Alice can then split the shares among her friends. When Alice wants to sign a transaction, she would then have to ask her friends to give her back the shares, that she can use to recreate the signing private key. Note that SSS has many many variants, for example VSSS allows participants to <strong>verify</strong> that malicious shares are not being used, and PSSS allows participants to <strong>proactively</strong> rotate their shares.</p>
<p><img alt="sss" src="https://www.cryptologie.net/upload/Screen_Shot_2019-12-25_at_9.21_.21_AM_.png"></p>
<p>This is not great though, as there is a small timeframe in which Alice is the single point of failure again (the moment she holds all the shares).</p>
<p>A logical next step is to <strong>change the system</strong>, so that Alice cannot sign a transaction by herself.
A <strong>multi-signature</strong> system (or <strong>multisig</strong>) would require n participants to sign the same transaction and send the n signatures to the system.
This is much better, except for the fact that n signatures means that the transaction size increases linearly with the number of signers required.</p>
<p><img alt="recap" src="https://www.cryptologie.net/upload/Screen_Shot_2019-12-25_at_9.23_.26_AM_.png"></p>
<p>We can do better: a multi-signature system with <strong>aggregated signatures</strong>. Signature schemes like <strong>BLS</strong> allow you to compress the n signatures in a single signature. Note that it is currently much slower than popular signature schemes like ECDSA and EdDSA, so there must be a trade off between speed and size.</p>
<p>We can do even better though!</p>
<p>So far one still has to maintain a set of n public keys so that a signature can be verified. <strong>Distributed Key Generation (DKG)</strong> allows a set of participant to collaborate on the construction of a key pair, and on signing operations.
This is very similar to SSS, except that there is never a single point of failure. This makes DKG a <strong>Multi-Party Computation (MPC)</strong> algorithm.</p>
<p>The BLS signature scheme can also aggregate public keys into a single key that will verify their aggregated signatures, which allows the construction of a DKG scheme as well.</p>
<p>Interestingly, you can do this with schnorr signatures too! The following diagram explains a simplified version of the scheme:</p>
<p><img alt="schnorr dkg" src="https://www.cryptologie.net/upload/Screen_Shot_2019-12-25_at_9.12_.32_AM_.png"></p>
<p>Note two things:</p>
<ul>
<li>All these schemes can be augmented to become <strong>threshold schemes</strong>: we don't need n signatures from the n signers anymore, but only a threshold m of n. (Having said that, when people talk about <strong>threshold signatures</strong>, they often mean the threshold version of DKG.) This way if someone loses their keys, or is on holiday, we can still sign.</li>
<li>Most of these schemes assume that all participants are honest and by default don't tolerate malicious participants. More complicated schemes made to tolerate malicious participants exist.</li>
</ul>
<p>Unfortunately all of this is pretty new, and as an active field of study no standard has been decided on one algorithm so far.</p>
<p>That's the difference!</p>
<p>One last thing: there's been some recent ideas to use <strong>zero knowledge proofs (ZKP)</strong> to do what aggregated signatures do but for multiple messages (because all the previous solutions all signed the same message). The idea is to release a proof that you have verified all the signatures associated to a set of messages. If the zero knowledge proof is shorter than all the signatures, it did its job!</p>
<blockquote>
<p>did you like this? This will part of a book on cryptography! <a href="https://www.manning.com/books/real-world-cryptography?a_aid=Realworldcrypto&amp;a_bid=ad500e09">Check it out here</a>.</p>
</blockquote>
<p>EDIT: thanks to <a href="https://www.reddit.com/r/crypto/comments/edqrky/difference_between_shamir_secret_sharing_sss_vs/fbl62rb/">Dowhile and bascule</a> for pointing errors in the post.</p>
<a href="https://www.cryptologie.net/article/486/difference-between-shamir-secret-sharing-sss-vs-multisig-vs-aggregated-signatures-bls-vs-distributed-key-generation-dkg-vs-threshold-signatures/#comments"> 3 comments </a>
</article>
<article>

<p>I am now half-way in the writing of my book (I wrote 8 chapters out of 16) and I am already exhausted.
It doesn't help that I started writing right before accepting a new position for a very challenging (and interesting) project.
But here I am, half-way there, and I think I'm onto something. I can't wait to get there and look at the finished project as a real paper book :)</p>
<p>To give you some insight into this process, let me share some thoughts.</p>
<p><strong>Writing is hard</strong>. I have realized that I need at least a full day to write something. It does take time to get into the zone, and writing in the morning before work just doesn't work for me (and writing after work is even worse). As <a href="https://research.kudelskisecurity.com/2017/10/16/the-making-of-serious-cryptography/">JP Aumasson put it (about his process of writing Serious Cryptography)</a>:</p>
<blockquote>
<p>I quickly realized that I didn’t know everything about crypto. The book isn’t just a dump of my own knowledge, but rather the fruit of hours of research—sometimes a single page would take me hours of reading before writing a single word.</p>
</blockquote>
<p>So when I don't have a full day ahead of me, I use my limited time to read articles and do research in topics that I don't fully understand. This is useful, and I make more progress during the week end once I have time to write.</p>
<p><strong>Revising is hard</strong>. If writing a chapter takes some effort <code>X</code>, revising a chapter takes effort <code>X^3</code> . After each chapter, several people at Manning, and in my circle, provide feedback. At the same time, I realize that there's much more I want to write about subject Y and I start pilling up articles and papers that I want to read before I revise the chapter. I end up spending a TON of effort revising and re-visiting chapters.</p>
<p><strong>Getting feedback is hard</strong>. I am lucky, I know a lot of people with different levels of knowledge in cryptography. This is very useful when I want to test how different audiences read different chapters. Unfortunately people are good at providing good feedback, and bad at providing bad feedback. And only the bad feedback ends up being useful feedback. If you want to help, [the first chapters are free to read](<a href="https://www.manning.com/books/real-world-cryptography?a_aid=Realworldcrypto&amp;a_bid=ad500e09">https://www.manning.com/books/real-world-cryptography?a_aid=Realworldcrypto&amp;a_bid=ad500e09</a>
) and I'm ready to buy you a beer for some constructive negative feedback.</p>
<p><strong>Laying out a chapter is hard</strong>. Writing a blog is relatively easy. It's short, self-contained, and often something I've been thinking about for weeks, months, before I put it into writing. Writing a chapter for a book is more like writing a paper: you want it to be perfect. Knowing a lot about the subject makes this even more difficult: you know you can make something great and not achieving that would be disappointing. One strategy that I wish I would have more time to spend on is the following one: </p>
<ul>
<li>create a presentation about the subject of a chapter</li>
<li>give the presentation and observe what diagrams need revisiting and what parts are hard for an audience to understand</li>
<li>after many iterations put the slides into writing</li>
</ul>
<p>I'm convinced this is the right approach, but I am not sure how I could optimize for this. If you're in SF and wants me to give you a presentation on one of the chapter of the book, leave a comment here :)</p>
<a href="https://www.cryptologie.net/article/485/writing-a-book-is-hard/#comments"> 2 comments </a>
</article>
<article>

<p>There are several cryptocurrencies that are doing really interesting things, Algorand is one of them.
Their breakthrough was to make a leader-based BFT algorithm work in a permissionless setting (and I believe they are the first ones who managed to do this).
At the center of their system lies a <strong>cryptography sortition</strong> algorithm. It's quite interesting, so I made a video to explain it!</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/XfP862hCrDM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<p>PS: I've been doing these videos for a while, and I still don't have a cool intro, so if you want to make me a cool intro please do :D</p>
<a href="https://www.cryptologie.net/article/484/algorands-cryptographic-sortition/#comments"> 1 comment </a>
</article>
<article>

<p>My colleague <strong>Mesut</strong> asked me if using random identifiers of 128-bit would be enough to avoid collisions.</p>
<p>I've been asked similar questions, and every time my answer goes something like this: </p>
<blockquote>
<p>you need to calculate <strong>the number of outputs</strong> you need to generate in order to get good odds of finding collisions. If that number is impressively large, then it's fine.</p>
</blockquote>
<p>The <strong>birthday bound</strong> is often used to calculate this. If you crypto, you must have heard of something like this:</p>
<blockquote>
<p>with the SHA-256 hash function, you need to generate at least 2<sup>128</sup> hashes in order to have more than 50% chance of finding collisions.</p>
</blockquote>
<p>And you know that usually, you can just divide the exponent of your domain space by two to find out how much output you need to generate to reach such a collision.</p>
<p>Now, this figure is a bit <strong>deceiving</strong> when it comes to <strong>real world cryptography</strong>. This is because we probably don't want to define "<strong>OK, this is bad</strong>" as someone reaching the point of having 50% chance of finding a collision. Rather, we want to say:</p>
<blockquote>
<p>someone reaching <strong>one in a billion</strong> chance (or something much lower) to find a collision would be bad.</p>
</blockquote>
<p>In addition, what does it mean for us? How many identifiers are we going to generate per second? How much time are we willing to keep this thing secure?</p>
<p>To truly answer this question, one needs to plug in the correct numbers and play with the birthday bound formula. Since this is not the first time I had to do this, I thought to myself "why don't I create an app for this?" and <a href="https://www.davidwong.fr/whatsmybirthday">voila</a>.</p>
<p><img alt="birthday bound" src="https://www.cryptologie.net/upload/Screen_Shot_2019-09-20_at_10.50_.46_PM_.png"></p>
<p><a href="https://www.davidwong.fr/whatsmybirthday">You can play with it here</a>.</p>
<p>Thanks to my tool, I can now answer Mesut's question:</p>
<blockquote>
<p>If you generate one million identifiers per second, in 26 years you will have one in a billion chance to generate a collision. Is this enough?
If this is not adversary-controlled, or it is rate-limited, you will probably not generate millions of identifiers per second though, but rather thousands, in this case it will take 265 centuries to get these odds.</p>
</blockquote>
<a href="https://www.cryptologie.net/article/483/whats-my-birthday/#comments"> 3 comments </a>
</article>
<article>

<p>Manning Publications reached out to me last year with an opportunity for a book. I had been thinking of a book for quite some time, as I felt that the landscape lacked a book targeted to developers, students and engineers who did not want to learn about the history of cryptography, or have to sort through too many technical details and mathematic formulas, and wanted an up to date survey of modern applied cryptography. In addition, I love diagrams. I don’t understand why most books underuse them. When you think of AES-CTR what do you think about? I bet the excellent diagrams from Wikipedia just flash in your mind. </p>
<p>The book <strong>Real World Cryptography</strong> was released today in <a href="https://www.manning.com/books/real-world-cryptography?a_aid=Realworldcrypto&amp;a_bid=ad500e09">pre-access</a>. This means you’ll be able to read new chapters as I write them, and be able to provide feedback on topics you wished I would include and questions you wish I would answer. </p>
<a href="https://www.cryptologie.net/article/481/my-book-real-world-cryptography-is-out-in-pre-access/#comments"> 4 comments </a>
</article>
<article>

<p><img alt="libra" src="https://www.cryptologie.net/upload/libra.jpg"></p>
<p>At 2am this morning <a href="https://libra.org/en-US/">Libra</a> was released.</p>
<p>and it seems to have broken the internet (sorry about that ^.^")</p>
<p>I've never worked on something this big, and I'm overwhelmed by all this reception. This is honestly pretty surreal from where I'm standing.</p>
<p>Libra is a <strong>cryptocurrency</strong>, which is on-par with other state-of-the-art blockchains. Meaning that it attempts to solve a lot of the problems Bitcoin originally had:</p>
<ul>
<li><strong>Energy Waste</strong>. The biggest reproach that people have on Bitcoin, is that it wastes a lot of our electricity. Indeed, because of the <strong>proof of work</strong> mechanism people constantly use machines to hash useless data in order to find new blocks. Newer cryptocurrencies, including Libra, make use of <strong>Byzantine Fault Tolerance (BFT) consensus protocols</strong>, which are pretty green by definition.</li>
<li><strong>Efficiency</strong>. Bitcoin is notably slow, with a block being mined every 10 minutes, and a minimum confirmation time of one hour. BFT allows us to "mine" a new block every 3 seconds (in reality it can even go much faster).</li>
<li><strong>Safety</strong>. Another problem with Bitcoin (or proof of work-based cryptocurrencies) is that it forks, constantly, and then re-organize itself around the "main chain". This is why one must wait several blocks to confirm that their transaction has been included. This concept is not great at all, as we've seen with Ethereum Classic which was forked (not so long ago) with more than <a href="https://blog.coinbase.com/ethereum-classic-etc-is-currently-being-51-attacked-33be13ce32de">100 block in the past</a>! BFT protocols never fork once they commit a block. What you see on the chain, is the final chain always. This is why it is so fast (and so sexy).</li>
<li><strong>Stability</strong>. This one is pretty self-explanatory. Bitcoin's price has been anything but stable. Gamblers actually strive on that. But for a global currency to be useful, it has to keep a certain rate for people to use it safely. Libra uses a reserve of <strong>real assets</strong> to back the currency. This is the most conservative way to achieve stability, and it is probably the most contentious point about Libra, but one needs to remember that this is all in order to achieve stability. Stability is required if we want this to be useful for everyone.</li>
<li><strong>Adoption</strong>. This final point is the most important in my opinion, and this is the reason I've joined Facebook on this journey. Adoption is the largest problem to all cryptocurrencies right now, even though you hear about them in the news very few people use them to actually transact (and most people use them to speculate instead). The mere size of the association (which is planned to reach 100 members from all around the world) and the user-base of Facebook is going to be a big factor in adoption. That's the most exciting thing about the project.</li>
</ul>
<p>On top of that, it is probably one of the most interesting projects in cryptography right now. The codebase is in Rust, it uses the Noise Protocol Framework, it will include BLS signatures and formally verified smart contracts. And there's a bunch of other exciting stuff to discover!</p>
<p>If you're interested you should definitely check the many papers we've published:</p>
<ul>
<li>start here: <a href="https://libra.org/en-US/white-paper/">the overview white paper is here</a></li>
<li>then read this: <a href="https://developers.libra.org/docs/the-libra-blockchain-paper">the technical deep dive on the project</a></li>
<li>and: <a href="https://developers.libra.org/docs/state-machine-replication-paper">the consensus protocol</a></li>
<li>and finally <a href="https://developers.libra.org/docs/move-paper">the Move paper (the smart contract language)</a></li>
<li>there are <a href="https://libra.org/en-US/vision/#whitepaper">more papers to read</a></li>
</ul>
<p>I've read many comments about this project, and here's how I would summarize my point of view: this is a crazy and world-scale project. There are not many projects with such an impact, and we'll have to be very careful about how we walk towards that goal. How will it change the world? Like a lot of global projects, it will have its ups and downs, but I believe that this is a positive net worth project for the world (if it works). We're in a unique position to change the status quo for the better. It's going to be exciting :)</p>
<p>If you're having trouble understanding why this could work, think about it this way. You currently can't transact money easily as soon as you're crossing a border, and actually, for a lot of countries (like the US) even intra-border money transfers are a pain. Currently the best banks in the world are probably Monzo and Revolut, and they're not available everywhere. Why? Because the banking system is very complex. By using a cryptocurrency, you are skipping decades of progress and setting up a <strong>interoperable</strong> network. Any banks and custody wallets can now use this network. You literally get the same thing you would get with your normal bank (same privacy, same usability, etc.) except that now banks themselves have access to a cheap and global network. The cherry on top is that normal users can bypass banks and use it directly, and you can monitor the total amount of money on the network. No more random printing of money.</p>
<p>A friend compared this project to nuclear energy: you can debate about it long and large, but there's no doubt it has advanced humanity. I feel the same way about this one. This is a clear improvement. </p>
<a href="https://www.cryptologie.net/article/480/libra-a-usable-cryptocurrency/#comments"> 2 comments </a>
</article>
<article>

<p>I've started writing a book on applied cryptography at the beginning of 2019, and I will soon release a <strong>pre-access version</strong>. I will talk about that soon on this blog!</p>
<p><img alt="Alice and Bob" src="https://www.cryptologie.net/upload/alice_and_bob.png"></p>
<small>(picture taken from the book)</small>
<hr>
<p>The book's audience is for students, developers, product managers, engineers, security consultants, curious people, etc. It tries to avoid the history of cryptography (which seems to be unavoidable in any book about cryptography these days), and shy away from mathematical formulas. Instead, it relies heavily on diagrams! A lot of them! As such, it is a broad introduction to what is useful in cryptography and how one can use the different primitives if seen as <strong>black boxes</strong>. It attempts to also serve the right amount of details, to satisfy the reader's curiosity. I'm hopping for it to be a good book for quickly getting introduced to different concepts going from TLS to PAKE. It will also include more modern topics like post-quantum cryptography and cryptocurrencies.</p>
<p>I don't think there's anything like this yet. the classic <strong>Applied Cryptography</strong> is quite old now and did not do much to encourage best practices or discourage rolling your own. The excellent <strong>Serious Cryptography</strong> is more technical and has more depth than what I'm aiming for. My book will rather be something in between, or something that would (hopefully) look like <a href="https://blog.cryptographyengineering.com/">Matthew Green's blog</a> if it was a book (minus a lot of the humor, because I suck at making jokes).</p>
<p>More to come!</p>
<a href="https://www.cryptologie.net/article/479/a-book-in-preparation/#comments"> comment on this story</a>
</article>
<article>

<p>Have you ever wondered why byzantine agreement protocols seem to all start with the assumptions that less than a third of the participants can be malicious?</p>
<p>This axiom is useful down the line when you want to prove <strong>safety</strong>, or in other words that <strong>your protocol can't fork</strong>. I made a diagram to show that, an instance of the protocol that forks (2 proposals have been committed with 2f+1 votes from the participants) is absurd.</p>
<p><img alt="2f+1 byzantine agreement" src="https://www.cryptologie.net/upload/Screen_Shot_2019-05-11_at_9.54_.07_AM_.png"></p>
<a href="https://www.cryptologie.net/article/478/why-2f1/#comments"> comment on this story</a>
</article>
<article>

<p>As I'm transitioning to the Blockchain team of Facebook, I decided it would be a good time to give this place a bit of a refresh :)</p>
<p>I've started blogging here in 2013:</p>
<p><img alt="2013" src="https://www.cryptologie.net/upload/Screen_Shot_2019-04-14_at_1.08_.50_PM_.png"></p>
<p>I quickly found out a layout I liked and sticked with it. In 2014 it looked like this:</p>
<p><img alt="2014" src="https://www.cryptologie.net/upload/Screen_Shot_2019-04-14_at_1.10_.36_PM_.png"></p>
<p>In 2018 it looked a bit different:</p>
<p><img alt="2018" src="https://www.cryptologie.net/upload/Screen_Shot_2019-04-14_at_12.59_.23_PM_.png"></p>
<p>And finally the new re-design which should be brighter: </p>
<p><img alt="2019" src="https://www.cryptologie.net/upload/Screen_Shot_2019-04-14_at_12.57_.37_PM_.png"></p>
<p>Hope you like it :)</p>
<a href="https://www.cryptologie.net/article/477/new-job-new-design/#comments"> 1 comment </a>
</article>

</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>