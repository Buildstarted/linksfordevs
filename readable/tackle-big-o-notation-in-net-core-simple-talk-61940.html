<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Tackle Big-O Notation in .NET Core - Simple Talk - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Tackle Big-O Notation in .NET Core - Simple Talk - linksfor.dev(s)"/>
    <meta property="article:author" content="Camilo Reyes"/>
    <meta property="og:description" content="Every computer science student must learn about Big-O Notation, a way to conceptualize algorithm complexity that directly relates to performance of the algorithm. In this article, Camilo Reyes demonstrates how to apply Big-O algorithms to .NET Core applications."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.red-gate.com/simple-talk/dotnet/net-development/tackle-big-o-notation-in-net-core/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Tackle Big-O Notation in .NET Core - Simple Talk</title>
<div class="readable">
        <h1>Tackle Big-O Notation in .NET Core - Simple Talk</h1>
            <div>by Camilo Reyes</div>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 21 May 2020</div>
        <p><a href="https://www.red-gate.com/simple-talk/dotnet/net-development/tackle-big-o-notation-in-net-core/">https://www.red-gate.com/simple-talk/dotnet/net-development/tackle-big-o-notation-in-net-core/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>Every computer science student must learn about Big-O Notation, a way to conceptualize algorithm complexity that directly relates to performance of the algorithm. In this article, Camilo Reyes demonstrates how to apply Big-O algorithms to .NET Core applications.</p><div>
				<p>Performance sensitive code is often overlooked in business apps. This is because high-performance code might not affect outcomes. Concerns with execution times are ignorable if the code finishes in a reasonable time. Apps either meet expectations or not, and performance issues can go undetected. Devs, for the most part, care about business outcomes and performance is the outlier. When response times cross an arbitrary line, everything flips to less than desirable or unacceptable.</p>
<p>Luckily, the Big-O notation attempts to approach this problem in a general way. This focuses both on outcomes and the algorithm. Big-O notation attempts to conceptualize algorithm complexity without laborious performance tuning.</p>
<p>In this take, I’ll delve into Big-O notation and how to apply this in .NET. I’ll begin with theory found in intro to computer programing courses. Then, dive into examples based on real-world code. In the end, this guides through the creative process of writing algorithms that use sound theory.</p>
<p>I’ll stick with proven tools such as <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">.NET Core 3.1.100</a>, the recommended LTS version for now. Code samples can run in the latest version of Visual Studio 2019. I’ll add <code>BenchmarkDotNet</code> to the project to verify execution times. This makes undetectable performance issues visible. You can download the sample code from <a href="https://github.com/beautifulcoder/TackleBigONetCore">GitHub</a>.</p>
<p>Feel free to follow along, to fire up a new project with the CLI do:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		
<!-- [Format Time: 0.0003 seconds] -->

<p>Be sure to do this inside of a project folder such as <em>TackleBigONetCore</em>. This same step is possible in Visual Studio. Because I do not wish to put you through a click hunt, I’ll stick to the CLI.</p>
<p>Then, be sure to add the benchmark tool:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb14b096390812" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>dotnet </span><span>add </span><span>package </span><span>BenchmarkDotNet</span><span> </span><span>--</span><span>version</span><span> </span>0<span>.</span>12<span>.</span>0</p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Before I lay down a single line of code, it is best to start with theory.</p>
<h2>What Is Big-O Notation?</h2>
<p>The Big-O notation measures the worst-case complexity of an algorithm. The algorithm works on data input of any size. For a given <em>n</em>, it answers the question: “What happens as n approaches infinity?” This helps to analyze the effectiveness of an algorithm which can be measured in time and space. Think of time as the execution time, and space as the input dataset size which consumes memory.</p>
<p>The algorithmic analysis gets summed up using Big-O notation, for example, O(1) for constant time. There are three main ways to do an analysis:</p>
<ul>
<li>O(1): For <em>constant time</em> because it does not change based on input space</li>
<li>O(n): For <em>linear time</em> because it assumes n operations in the worst-case scenario</li>
<li>O(n<sup>2</sup>): For <em>quadratic time</em> which shows exponential time degradation in the worst-case scenario</li>
<li>O(n<sup>3</sup>): For <em>cubic time</em>, like O(n<sup>2</sup>) with exponentially greater time complexity</li>
</ul>
<p>I’ll come back to each one as code samples get fleshed out. For now, think of algorithm complexity as a function like f(n). Input size n represents the number of inputs, f(n)<sub>time</sub> represents the time it takes, and f(n)<sub>space</sub> shows memory usage. Big-O notation comes with rules to help programmers analyze f(n). In academia, there are a lot of rules one might encounter, but I’ll focus on the most relevant:</p>
<ul>
<li><em>Coefficient rule</em>: For any constant k &gt; 0, if kf(n) then the result is O(g(n)). This rule eliminates coefficients that multiply results from input size. This is because as n approaches infinity, coefficients become negligible.</li>
<li><em>Sum rule</em>: If f(n) is O(h(n)), and g(n) is O(p(n)), then f(n) + g(n) is O(h(n) + p(n)). In practice the sum rule adds up two algorithms that are similar in time and space. For example, f(n) + f(n) can be 2f(n) from which applies the coefficient rule.</li>
<li><em>Product rule</em>: If f(n) is O(h(n)), and g(n) is O(p(n)), then f(n)g(n) is O(h(n)p(n)). For algorithms similar in time and space, the product rule may result in O(n) = n<sup>2</sup>. For example, nested loops that multiply which results in quadratic time.</li>
</ul>
<p>The following shows common Big-O notations from an algorithmic analysis:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/word-image-19.png" data-lazy-load=""></p>
<p>I recommend committing these complexities to memory in your mind’s eye. As I venture through each Big-O complexity, keep this chart in mind. This helps to visualize implications as time and space exponentiate with each complexity.</p>
<p>With all this Big-O theory out of the way, time to put this to good use.</p>
<h2>Lab Rats</h2>
<p>For this project, I’ll create a contrived use case of lab rats racing three at a time in several mazes. The goal is to imagine a data model useful for algorithmic analysis. Each Big-O complexity corresponds with each dataset.</p>
<p>This can go anywhere in the project. Because the emphasis is on benchmark analysis, I’ll put this inside a <em>BigOBenchmarks </em>class.</p>
<p>First, create a maze that has lab rats going three at a time:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb14f232189162" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p></div>
				</td>
						<td><div><p><span>class</span><span> </span><span>Maze</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>MazeNumber</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>Difficulty</span><span> </span><span>Difficulty</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>LabRat1</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>LabRat2</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>LabRat3</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>}</span></p><p><span>enum</span><span> </span><span>Difficulty</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>Easy</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>Medium</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>Hard</span></p><p><span>}</span></p><p><span>Now </span><span>for</span><span> </span><span>many </span><span>lab </span><span>rats </span><span>in</span><span> </span><span>each </span><span>maze</span><span>:</span></p><p><span>class</span><span> </span><span>LabRat</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>TrackingId</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>Color</span><span> </span><span>Color</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>}</span></p><p><span>enum</span><span> </span><span>Color</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>Black</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>White</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>Gray</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->

<p>Lastly, this encapsulates race data:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb152703365644" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>class</span><span> </span><span>Race</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>MazeNumber</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>Participant</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>FinishTime</span><span> </span><span>FinishTime</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span></p><p><span>}</span></p><p><span>enum</span><span> </span><span>FinishTime</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>Fast</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>Average</span><span>,</span></p><p><span>&nbsp;&nbsp;</span><span>Slow</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->

<p>This completes the domain, there are many mazes, with many lab rats in groups of three, with many races. The rest of the <em>BigOBenchmarks</em> class looks like this:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb154891426191" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></div>
				</td>
						<td><div><p><span>public</span><span> </span><span>class</span><span> </span><span>BigOBenchmarks</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>private</span><span> </span><span>const</span><span> </span><span>int</span><span> </span><span>N</span><span> </span><span>=</span><span> </span><span>999</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly</span><span> </span><span>IList</span><span>&lt;</span><span>LabRat</span><span>&gt;</span><span> </span><span>labRats</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly</span><span> </span><span>IList</span><span>&lt;</span><span>Maze</span><span>&gt;</span><span> </span><span>mazes</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly</span><span> </span><span>IList</span><span>&lt;</span><span>Race</span><span>&gt;</span><span> </span><span>races</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>BigOBenchmarks</span><span>(</span><span>)</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;</span><span>[</span><span>Benchmark</span><span>]</span></p><p><span>&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>DummyBenchmark</span><span>(</span><span>)</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>0</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>}</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->

<p>Leave the constructor empty for now, as this is where you initialize benchmark data. I’ll come back to each benchmark method. For now, be sure to return a value. This way the compiler does not optimize the whole benchmark method out. Methods decorated with <code>Benchmark</code> are part of the benchmark result. The <code>Benchmark</code> attribute is in this namespace:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb156435705535" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>For this analysis, I’m keeping data input size N set to about a thousand. Because lab rats go three at a time, this leaves around three hundred mazes.</p>
<p>To flesh out <em>BenchmarkDotNet</em> so that benchmarks execute, crack open <em>Program</em> in the console project and add this:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb158497147166" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>BenchmarkRunner</span><span>.</span><span>Run</span><span>&lt;</span><span>BigOBenchmarks</span><span>&gt;</span><span>(</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Be sure to include the namespace:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb15a502321659" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>The project runs with <code>dotnet watch run -c Release. BenchmarkDotNet</code> works on Release because Debug can be one hundred times slower. Running this in watch mode makes it to where benchmarks run at each save. Next, time to look at each Big-O complexity based on data.</p>
<h2>Big-O O(n) Linear Time</h2>
<p>Knock out <em>DummyBenchmark</em> as I’ll need room for meaningful benchmarks. Say I want to pluck a single lab rat from the dataset. Start by initializing the data in the constructor:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb15c060412747" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>labRats</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>LabRat</span><span>&gt;</span><span>(</span><span>N</span><span>)</span><span>;</span></p><p><span>for</span><span> </span><span>(</span><span>var</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>labRats</span><span>.</span><span>Add</span><span>(</span><span>new</span><span> </span><span>LabRat</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>TrackingId</span><span> </span><span>=</span><span> </span><span>i</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Color</span><span> </span><span>=</span><span> </span><span>(</span><span>Color</span><span>)</span><span>(</span><span>i</span><span> </span><span>%</span><span> </span><span>3</span><span>)</span></p><p><span>&nbsp;&nbsp;</span><span>}</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->

<p><a id="post-87199-_heading=h.gjdgxs"></a> Note the use of N as a constructor parameter when I initialize this list of lab rats. This sets the <em>Capacity</em> in the internal data structure. If the data input size is known, I recommend letting .NET know too. With the data in place, the traditional way to pluck a single item in .NET is using <code>First</code><strong>. </strong>Be sure to add <code>System.Linq</code> to the using statements:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb15e191200071" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>labRats</span><span>.</span><span>First</span><span>(</span><span>d</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>d</span><span>.</span><span>TrackingId</span><span> </span><span>==</span><span> </span><span>N</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span>;</span></p><p><span>return</span><span> </span><span>(</span><span>int</span><span>)</span><span>result</span><span>.</span><span>Color</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0002 seconds] -->

<p>Be sure to place this inside a benchmark method to verify what’s happening. To the untrained eye, this may seem like a simple operation without dings in performance. But it is O(n) or linear time complexity. This is because Big-O assumes the <em>worst-case scenario</em>, and this means looping through a whole dataset. In .NET, <code>First</code> picks the first match that exists, but Big-O must assume worst-case. In a worst-case scenario, the first match goes at the end. This frees the programmer from analysis paralysis when studying algorithms. By assuming worst-case, there is less cognitive load when thinking about algorithmic complexity.</p>
<p>Benchmark results are as follows:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/Bigo.png" data-lazy-load="" alt="" width="858" height="89"></p>
<p>This runs on avg for 15 microseconds given a sample size of about a thousand. The key takeaway is how this executes in microseconds. Because Big-O is either <em>exponentially</em> better or worse it will run in different time units. For this reason, I recommend executing one benchmark at a time for better results.</p>
<h2>Big-O O(n<sup>2</sup>) Quadratic Time</h2>
<p>This time I’ll need a set of mazes, go back in the <code>BigOBenchmarks</code> constructor and initialize maze data:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb161966098026" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>mazes</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>Maze</span><span>&gt;</span><span>(</span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span>)</span><span>;</span></p><p><span>for</span><span> </span><span>(</span><span>var</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>mazes</span><span>.</span><span>Add</span><span>(</span><span>new</span><span> </span><span>Maze</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>MazeNumber</span><span> </span><span>=</span><span> </span><span>i</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Difficulty</span><span> </span><span>=</span><span> </span><span>(</span><span>Difficulty</span><span>)</span><span>(</span><span>i</span><span> </span><span>%</span><span> </span><span>3</span><span>)</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>LabRat1</span><span> </span><span>=</span><span> </span><span>i</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>LabRat2</span><span> </span><span>=</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>LabRat3</span><span> </span><span>=</span><span> </span><span>i</span><span> </span><span>+</span><span> </span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span> </span><span>*</span><span> </span><span>2</span></p><p><span>&nbsp;&nbsp;</span><span>}</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->

<p>Maze data is but a third of lab rat data in space complexity. As data input size approaches infinity, this difference becomes <em>negligible</em>. This is because both datasets share similar time and space complexities.</p>
<p>Say, for example, I want to pluck a lab rat and check which maze difficulty it finished. A solution is:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb163363922541" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>foreach</span><span> </span><span>(</span><span>var</span><span> </span><span>maze </span><span>in</span><span> </span><span>mazes</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>var</span><span> </span><span>rat</span><span> </span><span>=</span><span> </span><span>labRats</span><span>.</span><span>First</span><span>(</span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>r</span><span>.</span><span>TrackingId</span><span> </span><span>==</span><span> </span><span>N</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>result</span><span> </span><span>=</span><span> </span><span>maze</span><span>.</span><span>LabRat3</span><span> </span><span>==</span><span> </span><span>rat</span><span>.</span><span>TrackingId</span><span> </span><span>?</span><span> </span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>(</span><span>int</span><span>)</span><span>maze</span><span>.</span><span>Difficulty</span><span> </span><span>:</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p><p><span>return</span><span> </span><span>result</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->

<p>Be sure to put this in a benchmark, and one takeaway is the nested loops. Because of the product rule, this makes the complexity O(n<sup>2</sup>). The outer loop goes through each maze, and the inner loop plucks a lab rat via iteration. Conceptually, nested loops on input data size n have a <em>multiplicative</em> effect. If the outer loop has n items, it permutates through all items in both loops. If, for example, there are 100 items, nested loops iterate 100×100 for a grand total of 10,000.</p>
<p>These are the results:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/BigO1.png" data-lazy-load="" alt="" width="860" height="89"></p>
<p>This time results are in milliseconds. Remember the chart I showed earlier? It shows this same exponential degradation. As complexity grows in Big-O, there are performance implications to the algorithm.</p>
<p>One way to tackle Big-O complexity is with a lookup table like <code>IDictionary&lt;&gt;</code>. Instead of having to iterate through lab rats, it is possible to pick one. A lookup table does a one-to-one mapping with a given key. Lookup mapping has a constant time complexity regardless of input data size. This reduces complexity back down to O(n).</p>
<p>Add a lookup table with a .NET dictionary to the benchmark class as a private instance variable:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb165084687315" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>private</span><span> </span><span>readonly</span><span> </span><span>IDictionary</span><span>&lt;</span><span>int</span><span>,</span><span> </span><span>LabRat</span><span>&gt;</span><span> </span><span>labRatLookup</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Because <code>First</code> was doing matches against the id, the lookup table uses this as the key. Initialize the lookup dictionary in the class constructor:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb167594442487" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>labRatLookup</span><span> </span><span>=</span><span> </span><span>labRats</span><span>.</span><span>ToDictionary</span><span>(</span><span>l</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>l</span><span>.</span><span>TrackingId</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Now, run another benchmark with this algorithm:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb169992254764" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>foreach</span><span> </span><span>(</span><span>var</span><span> </span><span>maze </span><span>in</span><span> </span><span>mazes</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>var</span><span> </span><span>rat</span><span> </span><span>=</span><span> </span><span>labRatLookup</span><span>[</span><span>N</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>result</span><span> </span><span>=</span><span> </span><span>maze</span><span>.</span><span>LabRat3</span><span> </span><span>==</span><span> </span><span>rat</span><span>.</span><span>TrackingId</span><span> </span><span>?</span><span> </span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>(</span><span>int</span><span>)</span><span>maze</span><span>.</span><span>Difficulty</span><span> </span><span>:</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p><p><span>return</span><span> </span><span>result</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0003 seconds] -->

<p>Both solutions are identical, minus the nested loop and complexity. The lookup table uses the same id <code>First</code> once used. So, this does not affect the outcome of the algorithm.</p>
<p>Benchmark results are now:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/Bigo3.png" data-lazy-load="" alt="" width="855" height="88"></p>
<h2>Big-O O(n<sup>3</sup>) Cubic Time</h2>
<p>Welcome to the fray, algorithms of this complexity tend to choke on modest size datasets. The time complexity is higher relative to the data input size.</p>
<p>In the constructor, initialize rat race data:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb16b626794116" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>races</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>Race</span><span>&gt;</span><span>(</span><span>N</span><span>)</span><span>;</span></p><p><span>for</span><span> </span><span>(</span><span>var</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>N</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>races</span><span>.</span><span>Add</span><span>(</span><span>new</span><span> </span><span>Race</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>MazeNumber</span><span> </span><span>=</span><span> </span><span>i</span><span> </span><span>%</span><span> </span><span>(</span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span>)</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Participant</span><span> </span><span>=</span><span> </span><span>i</span><span>,</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>FinishTime</span><span> </span><span>=</span><span> </span><span>(</span><span>FinishTime</span><span>)</span><span>(</span><span>i</span><span> </span><span>%</span><span> </span><span>3</span><span>)</span></p><p><span>&nbsp;&nbsp;</span><span>}</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->

<p>This time find race finish time by cross-referencing all other data points:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb170748679038" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>foreach</span><span> </span><span>(</span><span>var</span><span> </span><span>maze </span><span>in</span><span> </span><span>mazes</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>foreach</span><span> </span><span>(</span><span>var</span><span> </span><span>rat </span><span>in</span><span> </span><span>labRats</span><span>)</span></p><p><span>&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>race</span><span> </span><span>=</span><span> </span><span>races</span><span>.</span><span>Where</span><span>(</span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>r</span><span>.</span><span>MazeNumber</span><span> </span><span>==</span><span> </span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span> </span><span>-</span><span> </span><span>1</span><span>)</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>result</span><span> </span><span>=</span><span> </span><span>maze</span><span>.</span><span>MazeNumber</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>MazeNumber</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&amp;&amp;</span><span> </span><span>rat</span><span>.</span><span>TrackingId</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>Participant</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>?</span><span> </span><span>(</span><span>int</span><span>)</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>FinishTime</span><span> </span><span>:</span><span> </span><span>result</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>}</span></p><p><span>}</span></p><p><span>return</span><span> </span><span>result</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0006 seconds] -->

<p>In .NET, <code>Where</code> returns any items that match the predicate. This also means looping through the entire dataset. Given the product rule with three nested loops, this spikes complexity to O(n<sup>3</sup>).</p>
<p>Benchmarks results are as follows:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/Bigo4.png" data-lazy-load="" alt="" width="856" height="88"></p>
<p>Wow, this breaks the second barrier, execution times are dismal. Because customers don’t like to wait, this gets into unacceptable levels. Note data input size is in the hundreds, which is not that big at all. As data input size increases, count on this getting exponentially slower.</p>
<p>One way to tackle this much complexity in .NET is with <code>ILookup&lt;&gt;</code>. This <code>Where</code> throws a kink because it can return any number of items. What’s good is this returns arrays of constant size because lab rats go in groups of three. This makes the algorithm 3f(n), applying the coefficient rule, this brings it to constant time.</p>
<p>Declare this lookup table as a private instance variable in the class:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb173700879358" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>private</span><span> </span><span>readonly</span><span> </span><span>ILookup</span><span>&lt;</span><span>int</span><span>,</span><span> </span><span>Race</span><span>&gt;</span><span> </span><span>raceLookup</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Then, initialize race lookup data in the constructor:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb175716027924" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>raceLookup</span><span> </span><span>=</span><span> </span><span>races</span><span>.</span><span>ToLookup</span><span>(</span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>r</span><span>.</span><span>MazeNumber</span><span>,</span><span> </span><span>r</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>r</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>This makes <code>MazeNumber</code> the key from which we get the array with three items. This is the same predicate found in the where clause. By preserving the where clause in the key, it keeps the outcome the same. The lab rat lookup can go in here too to further optimize complexity. Now tweak the algorithm as follows:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb177323834073" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span></p><p><span>foreach</span><span> </span><span>(</span><span>var</span><span> </span><span>maze </span><span>in</span><span> </span><span>mazes</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;</span><span>var</span><span> </span><span>race</span><span> </span><span>=</span><span> </span><span>raceLookup</span><span>[</span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>var</span><span> </span><span>rat</span><span> </span><span>=</span><span> </span><span>labRatLookup</span><span>[</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>Participant</span><span>]</span><span>;</span></p><p><span>&nbsp;&nbsp;</span><span>result</span><span> </span><span>=</span><span> </span><span>maze</span><span>.</span><span>MazeNumber</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>MazeNumber</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&amp;&amp;</span><span> </span><span>rat</span><span>.</span><span>TrackingId</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>Participant</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>?</span><span> </span><span>(</span><span>int</span><span>)</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>FinishTime</span><span> </span><span>:</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p><p><span>return</span><span> </span><span>result</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0005 seconds] -->

<p>Note there are two lookups side-by-side, one for races and one for rats. Because time and space complexities are similar, applying the sum rule, this gets a 2f(n). Big-O rules <em>combine</em>, so, applying the coefficient rule keeps lookups at constant time. Because this loops through mazes, the complexity is O(n).</p>
<p>I want to hear a drumroll please, time to check benchmarks results:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/Bigo5.png" data-lazy-load="" alt="" width="864" height="87"></p>
<p>This brings execution time back down to microseconds and way within an acceptable range. Note the exponential gains from more than a second to tens of microseconds. Going from cubic time down to linear time does make an astronomical difference. For business apps, this kind of performance is “good enough.” Any further optimization is likely too pedantic for the working programmer.</p>
<h2>Big-O O(1) Constant Time</h2>
<p>The keen reader may notice lookup tables dominate complexity gains, so why not get rid of looping? Should be interesting to see how this stacks up given the theory. Lookup tables are constant time because of this <em>one-to-one</em> relationship. The computer has an easier time with this because it knows where to find this in memory. When a lookup returns many items, the coefficient rule keeps complexity constant if the array is of constant size.</p>
<p>To eliminate looping, what is missing is a maze lookup:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb17a896354270" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>private</span><span> </span><span>readonly</span><span> </span><span>IDictionary</span><span>&lt;</span><span>int</span><span>,</span><span> </span><span>Maze</span><span>&gt;</span><span> </span><span>mazeLookup</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Go in the constructor and add:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb17c932517808" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>mazeLookup</span><span> </span><span>=</span><span> </span><span>mazes</span><span>.</span><span>ToDictionary</span><span>(</span><span>l</span><span> </span><span>=</span><span>&gt;</span><span> </span><span>l</span><span>.</span><span>MazeNumber</span><span>)</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0001 seconds] -->

<p>Then, tweak the algorithm so it no longer loops:</p>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-5ec6196fcb17e677587360" data-settings=" minimize scroll-always">
		
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="hide">
					
				</td>
						<td><div><p><span>var</span><span> </span><span>race</span><span> </span><span>=</span><span> </span><span>raceLookup</span><span>[</span><span>N</span><span> </span><span>/</span><span> </span><span>3</span><span> </span><span>-</span><span> </span><span>1</span><span>]</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span></p><p><span>var</span><span> </span><span>rat</span><span> </span><span>=</span><span> </span><span>labRatLookup</span><span>[</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>Participant</span><span>]</span><span>;</span></p><p><span>var</span><span> </span><span>maze</span><span> </span><span>=</span><span> </span><span>mazeLookup</span><span>[</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>MazeNumber</span><span>]</span><span>;</span></p><p><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>maze</span><span>.</span><span>MazeNumber</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>MazeNumber</span></p><p><span>&nbsp;&nbsp;</span><span>&amp;&amp;</span><span> </span><span>rat</span><span>.</span><span>TrackingId</span><span> </span><span>==</span><span> </span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>Participant</span></p><p><span>&nbsp;&nbsp;</span><span>?</span><span> </span><span>(</span><span>int</span><span>)</span><span>race</span><span>[</span><span>2</span><span>]</span><span>.</span><span>FinishTime</span><span> </span><span>:</span><span> </span><span>0</span><span>;</span></p><p><span>return</span><span> </span><span>result</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->

<p>Below are the results:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPAAAPLy8v///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/Bigo6.png" data-lazy-load="" alt="" width="860" height="89"></p>
<p>Success, performance should remain the same regardless of data input size. This execution time breaks into the nanosecond range. This is exponentially faster than anything I’ve shown before. This follows Big-O theory with good precision, so it is trustworthy.</p>
<p>A similar feat is possible with caching but with some gotchas. Caching large chunks of data and then looping does nothing for performance. When the cache lives outside memory and over the network in another box, large datasets must be deserialized, which spike complexity. This is one reason why caching is not a performance silver bullet. It’s only by caching a narrow slice with a one-to-one lookup that any real gains come in.</p>
<h2>Conclusion</h2>
<p>Big-O notation has a nice way to encapsulate algorithmic complexity. As algorithm complexity grows performance exponentially degrades. Looping spikes complexity and nested loops exponentiate this complexity. .NET provides lookup tables to quell this complexity such as <code>IDictionary&lt;&gt;</code>, and <code>ILookup&lt;&gt;</code>. Reducing complexity to constant time is the best optimization possible.</p>

			</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>