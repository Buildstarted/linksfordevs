<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Garbage collection in Python: things you need to know -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Garbage collection in Python: things you need to know</h1>
    <div class="markdown"><p>This article describes garbage collection (GC) in Python 3.6.</p><p>Usually, you do not need to worry about memory management. When objects are no longer needed, Python automatically reclaims memory from them. However, understanding how GC works can help you write better and faster Python programs.</p><h2>Memory management</h2><p>Unlike many other languages, Python does not necessarily release the memory back to the Operating System. Instead, it has a dedicated object allocator for objects smaller than 512 bytes, which keeps some chunks of already allocated memory for further use in the future. The amount of memory that Python holds depends on the usage patterns. In some cases, all allocated memory could be released only when Python process terminates.</p><p>If a long-running Python process takes more memory over time, it does not necessarily mean that you have memory leaks. If you are interested in Python&apos;s memory model, you can read my article on <a href="https://rushter.com/blog/python-memory-managment/">memory management</a>.</p><h2>Garbage collection algorithms</h2><p>Standard CPython&apos;s garbage collector has two components, the <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> collector and the generational <strong>garbage collector</strong>, known as <a href="https://docs.python.org/3.6/library/gc.html">gc module</a>.</p><p>The <strong>reference counting</strong> algorithm is incredibly efficient and straightforward, but it cannot detect reference cycles. That is why Python has a supplemental algorithm called generational cyclic GC, that specifically deals with reference cycles.</p><p>The reference counting module is fundamental to Python and can&apos;t be disabled, whereas the cyclic GC is optional and can be invoked manually.</p><h2>Reference counting</h2><p>Reference counting is a simple technique in which objects are deallocated when there is no reference to them in a program.</p><p>Every variable in Python is a reference (a pointer) to an object and not the actual value itself. For example, the assignment statement just adds a new reference to the right-hand side.</p><p>To keep track of references, every object (even integer) has an extra field called reference count that is increased or decreased when a pointer to the object is created or deleted. See <a href="https://docs.python.org/3.6/c-api/intro.html#objects-types-and-reference-counts">Objects, Types and Reference Counts</a> section, for a detailed explanation.</p><h4>Examples, where the reference count increases:</h4><ul><li>assignment operator</li><li>argument passing</li><li>appending an object to a list (object&apos;s reference count will be increased).</li></ul><p>If reference counting field reaches zero, CPython automatically calls the object-specific deallocation function. If an object contains references to other objects, then their reference count is decremented too. Thus other objects may be deallocated in turn. For example, when a list is deleted the reference count for all its items is decreased.</p><p>Variables, which are declared outside of functions, classes, and blocks are called globals. Usually, such variables live until the end of the Python&apos;s process. Thus, the reference count of objects, which are referred by global variables, never drops to 0.</p><p>Variables, which are defined inside blocks (e.g., in a function or class) have a local scope (i.e., they are local to its block). If Python interpreter exits from the block, it destroys all references created inside the block.</p><p>You can always check the number of current references using <code>sys.getrefcount</code> function.</p><p>Here is a simple example:</p><div class="codehilite"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 2 references, 1 from the foo var and 1 from getrefcount</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="c1"># 4 references</span> <span class="c1"># from the foo var, function argument, getrefcount and Python&apos;s function stack</span> <span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="c1"># 2 references, the function scope is destroyed</span>
<span class="k">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</pre></div><p>The main reason why CPython uses reference counting is historical. There are a lot of debates nowadays about the weaknesses of such technique. Some people claim that modern garbage collection algorithms can be more efficient without reference counting at all. The reference counting algorithm has a lot of issues, such as circular references, thread locking and memory and performance overhead.</p><p>The main advantage of such approach is that the objects can be immediately destroyed after they are no longer needed.</p><h2>Generational garbage collector</h2><p>Why do we need additional garbage collector when we have reference counting?</p><p>Unfortunately, classical reference counting has a fundamental problem &#x2014; it cannot detect reference cycles. A reference cycle occurs when one or more objects are referencing each other.</p><p>Here are two examples:<img alt="Python circular reference managemenent" class="ui centered image" src="https://rushter.com/static/uploads/img/circularref.svg"></p><p>As we can see, the &apos;lst&apos; object is pointing to itself, moreover, <code>object 1</code> and <code>object 2</code> are pointing to each other. The reference count for such objects is always at least 1.</p><p>To get a better idea you can play with a simple Python example:</p><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">gc</span> <span class="c1"># We are using ctypes to access our unreachable objects by memory address.</span>
<span class="k">class</span> <span class="nc">PyObject</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span> <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;refcnt&quot;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">)]</span> <span class="n">gc</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span> <span class="c1"># Disable generational gc</span> <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="c1"># Store address of the list</span>
<span class="n">lst_address</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="c1"># Destroy the lst reference</span>
<span class="k">del</span> <span class="n">lst</span> <span class="n">object_1</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">object_2</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">object_1</span><span class="p">[</span><span class="s1">&apos;obj2&apos;</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_2</span>
<span class="n">object_2</span><span class="p">[</span><span class="s1">&apos;obj1&apos;</span><span class="p">]</span> <span class="o">=</span> <span class="n">object_1</span> <span class="n">obj_address</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">object_1</span><span class="p">)</span> <span class="c1"># Destroy references</span>
<span class="k">del</span> <span class="n">object_1</span><span class="p">,</span> <span class="n">object_2</span> <span class="c1"># Uncomment if you want to manually run garbage collection process </span>
<span class="c1"># gc.collect()</span> <span class="c1"># Check the reference count</span>
<span class="k">print</span><span class="p">(</span><span class="n">PyObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">obj_address</span><span class="p">)</span><span class="o">.</span><span class="n">refcnt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">PyObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">lst_address</span><span class="p">)</span><span class="o">.</span><span class="n">refcnt</span><span class="p">)</span>
</pre></div><p>In the example above, the <code>del</code> statement removes the references to our objects (i.e., decreases reference count by 1). After Python executes the <code>del</code> statement, our objects are no longer accessible from Python code. However, such objects are still sitting in the memory, that&apos;s because they are still referencing each other and the reference count of each object is 1. You can visually explore such relations using <a href="https://mg.pov.lt/objgraph/">objgraph</a> module.</p><p>To resolve this issue, the additional cycle-detecting algorithm was introduced in Python 1.5. The <a href="https://docs.python.org/3.6/library/gc.html">gc module</a> is responsible for this and exists only for dealing with such a problem.</p><p>Reference cycles can only occur in container objects (i.e., in objects that can contain other objects), such as lists, dictionaries, classes, tuples. Garbage collector does not track all immutable types except for a tuple. Tuples and dictionaries containing only immutable objects can also be untracked depending on certain conditions. Thus, the reference counting technique handles all non-circular references.</p><h3>When does the generational GC trigger</h3><p>Unlike the reference counting, the cyclic GC does not work in real-time and runs periodically. To reduce the frequency of GC calls and pauses CPython uses various heuristics.</p><p>The GC classifies container objects into three generations. Every new object starts in the first generation. If an object survives a garbage collection round, it moves to the older (higher) generation. Lower generations are collected more often than higher. Because most of the newly created objects die young, it improves GC performance and reduces the GC pause time.</p><p>In order to decide when to run, each generation has an individual counter and threshold. The counter stores the number of object allocations minus deallocations since the last collection. Every time you allocate a new container object, CPython checks whenever the counter of the first generation exceeds the threshold value. If so Python initiates the &#x441;ollection process.</p><p>If we have two or more generations that currently exceed the threshold, GC chooses the oldest one. That is because oldest generations are also collecting all previous (younger) generations. To reduce performance degradation for long-living objects the third generation has <a href="https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94">additional requirements</a> in order to be chosen.</p><p>The standard threshold values are set to (700, 10, 10) respectively, but you can always check them using the <code>gc.get_threshold</code> function.</p><h3>How to find reference cycles</h3><p>It is hard to explain the reference cycle detection algorithm in a few paragraphs. But basically, GC iterates over each container object and temporarily removes all references to container objects it references. After full iteration, all objects which reference count lower than two are unreachable from Python&apos;s code and thus can be collected.</p><p>To fully understand the cycle-finding algorithm I recommend you to read an <a href="http://arctrix.com/nas/python/gc/">original proposal from Neil Schemenauer</a> and <a href="https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Modules/gcmodule.c#L902">collect</a> function from CPython&apos;s source code. Also, the <a href="https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons">Quora answers</a> and <a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/">The Garbage Collector blog post</a> can be helpful.</p><p>Note that, the problem with finalizers, which was described in the original proposal, has been fixed since Python 3.4. You can read about it in the <a href="http://legacy.python.org/dev/peps/pep-0442/">PEP 442</a>.</p><h2>Performance tips</h2><p>Cycles can easily happen in real life. Typically you encounter them in graphs, linked lists or in structures, in which you need to keep track of relations between objects. If your program has an intensive workload and requires low latency, you need to avoid reference cycles as possible.</p><p>To avoid circular references in your code, you can use weak references, that are implemented in the <code>weakref</code> module. Unlike the usual references, the <code>weakref.ref</code> doesn&apos;t increase the reference count and returns <code>None</code> if an object was destroyed.</p><p>In some cases, it is useful to disable GC and use it manually. The automatic collection can be disabled by calling <code>gc.disable()</code>. To manually run the collection process, you need to use <code>gc.collect()</code>.</p><h2>How to find and debug reference cycles</h2><p>Debugging reference cycles can be very frustrating especially when you use a lot of third-party libraries.</p><p>The standard <a href="https://docs.python.org/3.6/library/gc.html">gc module</a> provides a lot of useful helpers that can help in debugging. If you set debugging flags to <code>DEBUG_SAVEALL</code>, all unreachable objects found will be appended to <code>gc.garbage</code> list.</p><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">gc</span> <span class="n">gc</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">DEBUG_SAVEALL</span><span class="p">)</span> <span class="k">print</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">get_count</span><span class="p">())</span>
<span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="n">list_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="k">del</span> <span class="n">lst</span>
<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">gc</span><span class="o">.</span><span class="n">garbage</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">assert</span> <span class="n">list_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div><p>Once you have identified a problematic spot in your code you can visually explore object&apos;s relations using <a href="https://mg.pov.lt/objgraph/">objgraph</a>.<img alt="Python reference count graph" class="ui centered image" src="https://rushter.com/static/uploads/img/reference_count.svg"></p><h3>Conclusion</h3><p>Most of the garbage collection is done by reference counting algorithm, which we cannot tune at all. So, be aware of implementation specifics, but don&apos;t worry about potential GC problems prematurely.</p><p>Hopefully, you have learned something new. If you have any questions left, I will be glad to answer them in the comments below.</p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>