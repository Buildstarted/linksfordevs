<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building a BASIC Interpreter, &#x27;80s style - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Building a BASIC Interpreter, &#x27;80s style - linksfor.dev(s)"/>
    <meta property="article:author" content="Kerri Shotts"/>
    <meta property="og:description" content="It&#x2019;s funny the rabbit holes one ends up. One of my personal projects for several years has been the creation (exploration, really) of a &#x201C;fake emulator&#x201D; &#x2014; that is, an emulator for a computer that ne..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style--79a9d703"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Building a BASIC Interpreter, &#x27;80s style</title>
<div class="readable">
        <h1>Building a BASIC Interpreter, &#x27;80s style</h1>
            <div>by Kerri Shotts</div>
            <div>Reading time: 14-17 minutes</div>
        <div>Posted here: 11 Aug 2020</div>
        <p><a href="https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style--79a9d703">https://able.bio/kerrishotts/building-a-basic-interpreter-80s-style--79a9d703</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>It’s funny the rabbit holes one ends up. One of my personal projects for several years has been the creation (exploration, really) of a “fake emulator” — that is, an emulator for a computer that never existed all written in JavaScript. Instead, the machine would pay homage to the eight and sixteen bit machines of the 1980s and ‘90s.</p>
<p>I like to do things the hard way, though: this machine would also be based on a novel instruction set as well. The instruction set would be similar to that of the era, but also be a little easier to use. And so, <a href="https://github.com/kerrishotts/retroputer" rel="noopener nofollow noreferrer">Retroputer</a> was born. Over several years, the implementation has been built out and improved, although it’ll probably never be “complete” (it’s a personal exploration, after all).</p>
<p>Then @bbcmicrobot became a thing, and I wanted to be able to do a similar thing for Retroputer. My JS development skills are mostly in the arena of the front-end, and so this would be a cool way to get some more back-end skills. One problem: Retroputer could only understand its own assembly language. It had no BASIC support yet.</p>
<p>And so here I am, building a BASIC interpreter, ‘80s style — that is, entirely in assembly language, just like it used to be done. And I thought I’d share that journey, since it’s not often we delve into areas so far from our typical abstractions. My daily driver (JavaScript) makes a lot of things trivial and sometimes those things feel magical. Understanding the lowest levels of the process can often help with understanding those abstractions.</p>
<p>And so… let’s begin.</p>
<h2 id="parsing-in-low-level-assembly-language">Parsing in Low-Level Assembly Language</h2>
<p>When I wrote the assembler for Retroputer, I was able to use a really nice tool called Pegjs. This made quick work of the assembler’s custom syntax, but was unfortunately there’s nothing like it for Retroputer ASM.</p>
<p>Which means we have to do it the hard way.</p>
<p>Parsing actually occurs in multiple phases. A language that uses a compiler parses the code into an abstract syntax tree (or similar concept), and can then use that tree to generate the resulting native code. A consequence of this is that the program must be syntactically correct in order for the compilation to be successful.</p>
<p>Some interpreters today also have this concept because it’s often useful to generate the intermediate AST and execute from there than it is to execute from the original source.</p>
<p>But for a BASIC interpreter in a machine with limited resources, the most resource-effective way to parse is to do it in multiple phases — some of which occurs at run time. This means, however, that syntax errors often can’t be detected until the program is run and the area of code with the error is encountered.</p>
<p>The three phases of Retroputer BASIC parsing are as follows:</p>
<ol>
<li>Line Transformation</li>
<li>Tokenization</li>
<li>Runtime Syntax Checking</li>
</ol>
<p>The first two steps occur as the user enters a program (or loads one). The last one occurs while the program is running. Essentially, the first two build out the rough scaffolding of an airplane, but with no guarantee of flight. The last step is essentially acting as a test pilot — hoping you’ll get off the ground, but not knowing until you try.</p>
<p>Thankfully Retroputer BASIC doesn’t come with such dire consequences for raising an error during runtime.</p>
<p><em><strong>Note:</strong></em> Source code (in progress) for Retroputer BASIC is <a href="https://github.com/kerrishotts/retroputer/tree/master/asm/kernel/basic" rel="noopener nofollow noreferrer">available on GitHub</a>.</p>
<h2 id="line-transformation">Line Transformation</h2>
<p>This is the easiest part of the entire process. Essentially, the line that the user enters is converted to uppercase so that later processes are easier (and faster). BASIC is not sensitive to case, and so we can use that to our advantage.</p>
<pre><code>print 2+2
' becomes:
PRINT 2+2
</code></pre>
<p>Doing this in JavaScript is easy, right?</p>
<pre><code><span>theLine</span> = theLine.toUpperCase()
</code></pre>
<p>But in assembly language, we have to be more detailed about how things get done. We need to read in a character, convert it to uppercase, and then store it somewhere.</p>
<pre><code>           <span>ld</span>  <span>y,</span>  <span>0</span>                
<span>_loop:</span>     <span>ld</span>  <span>al,</span> <span>[d,</span> <span>x,</span> <span>y]</span>        
           <span>cmp</span> <span>al,</span> <span>97</span>               
           <span>brs</span> <span>n</span>   <span>_continue</span>        
           <span>cmp</span> <span>al,</span> <span>123</span>              
           <span>brs</span> <span>!n</span>  <span>_continue</span>        
           <span>and</span> <span>al,</span> <span>0b1101_1111</span>      
           <span>st</span>  <span>[d,</span> <span>x,</span> <span>y],</span> <span>al</span>        
<span>_continue:</span> <span>inc</span> <span>y</span>                    
           <span>cmp</span> <span>al,</span> <span>0</span>                
           <span>brs</span> <span>!z</span> <span>_loop</span>             
</code></pre>
<p>The above doesn’t quite match the same semantics as the JavaScript version. One important difference is that we now use Unicode to work with text, and so converting input from lowercase to uppercase can often be more difficult — and maybe impossible (depending on the language). Retroputer lives in the world of ASCII (rather, it’s own variation, named RetSCII), meaning that all supported characters are encoded into eight bits. This is woefully inadequate for many languages, but also true to the period.</p>
<p>It also means that we can use a nice feature of ASCII to convert from lowercase to uppercase. It turns out that uppercase “A” is represented with <code>65</code> in ASCII, and lowercase “a” is represented with <code>97</code>. If you’re familiar with your powers-of-two, that difference should catch your eye.</p>
<p>So it turns out that lowercase letters are represented with a number that’s exactly 32 above the uppercase letter. Once we know something’s in range, all we need to do is subtract 32!</p>
<p>That works, but we could just do some bit twiddling. For Retroputer this wouldn’t actually be any faster than subtraction, but avoiding subtraction means we don’t have to worry about the carry/borrow flag during arithmetic. It turns out we can use a bitwise <code>and</code> to turn off the bit for the 32 place value instead.</p>
<pre><code><span>and</span> <span>al,</span> <span>0b1101_1111</span>         

<span>clr</span> <span>c</span>                       
<span>sub</span> <span>al,</span> <span>32</span>                  
</code></pre>
<p>But there’s a catch: not <em>everything</em> can be converted to uppercase. If the user has included a string literal, for example, we have to be more careful. After all, we don’t want Retroputer BASIC to scream at the user all the time, right? (Although many computers of the era didn’t have lowercase capability, Retroputer doesn’t share that same limitation.)</p>
<p>For example:</p>
<pre><code>print "Hello, World!"
' should become:
PRINT "Hello, World!"
' and not
PRINT "HELLO, WORLD!"
</code></pre>
<p>This means we need to keep track of whether or not we’re in the middle of a string literal. In BASIC, there’s only one signifier for this: the double quote. If we check if a character is a double quote, we can set a flag, and depending on the flag’s value, we can perform an uppercase operation or leave things alone.</p>
<p>It turns out that in JavaScript there’s no built-in to accomplish this, but we can build one:</p>
<pre><code><span>const</span> <span>len = theLine.length;</span>
<span>let</span> <span>insideString = false;</span>
<span>for</span> <span>(let i = 0; i &lt; len; i++) {</span>
    <span>const</span> <span>ch = theLine[i];</span>
    <span>if</span> <span>(ch === `"`) insideString = !insideString;</span>
    <span>if</span> <span>(!insideString) {</span>
        <span>const</span> <span>newCh = ch.toUpperCase();</span>
        <span>if</span> <span>(ch !== newCh) theLine[i] = newCh;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>Now the logic of the JS more closely matches that of the assembly version, although we’re taking advantage of JS’s unicode support a bit more.</p>
<p>The assembly version looks like this:</p>
<pre><code>           <span>ld</span>  <span>y,</span>  <span>0</span>                
           <span>ld</span>  <span>bl,</span> <span>0</span>                
<span>_loop:</span>     <span>ld</span>  <span>al,</span> <span>[d,</span> <span>x,</span> <span>y]</span>        
           <span>cmp</span> <span>al,</span> <span>34</span>               
           <span>brs</span> <span>!z</span>  <span>check_char</span>       
           <span>xor</span> <span>bl,</span> <span>0xFF</span>             
<span>_check_char:</span>
           <span>cmp</span> <span>bl,</span> <span>0xFF</span>             
           <span>brs</span> <span>z</span>   <span>_continue</span>        
           <span>cmp</span> <span>al,</span> <span>97</span>               
           <span>brs</span> <span>n</span>   <span>_continue</span>        
           <span>cmp</span> <span>al,</span> <span>123</span>              
           <span>brs</span> <span>!n</span>  <span>_continue</span>        
           <span>and</span> <span>al,</span> <span>0b1101_1111</span>      
           <span>st</span>  <span>[d,</span> <span>x,</span> <span>y],</span> <span>al</span>        
<span>_continue:</span> <span>inc</span> <span>y</span>                    
           <span>cmp</span> <span>al,</span> <span>0</span>                
           <span>brs</span> <span>!z</span> <span>_loop</span>             
</code></pre>
<p>So far all we’ve done is transform the input text to uppercase, but there’s one extra benefit here in the way we’ve had to track if we’re inside a string. We can do one round of syntax checking here!</p>
<p>If, at the end of the process we find that <code>inString</code> is still true (<code>bl = 0xFF</code>), we can trigger an error, because it means that there’s an unterminated string literal somewhere in the line.</p>
<p><em><strong>Side note:</strong></em> It turns out many BASICs are quite lenient when it comes to terminating quotes for strings. One of many things I learned while building my own interpreter. Even so, it doesn’t feel right to me, and so Retroputer BASIC doesn’t permit it.</p>
<h2 id="tokenization">Tokenization</h2>
<p>The next phase of parsing involves converting an entered line into something more efficient for Retroputer BASIC to execute. This is as close to the concept of an abstract syntax tree that we’ll get here — the result will definitely not be a tree. But it will be something that we can quickly evaluate during runtime.</p>
<p>One common feature of early microcomputers was a very limited memory capacity. Retroputer has more memory than most machines of the time had by default, but it still has much less than modern machines. As such, long BASIC programs could easily consume far too much memory if they were stored as the user typed them.</p>
<p>To save space, keywords are <em>tokenized</em> as the program is entered into memory. This process converts keywords into single-byte tokens. Keywords are always at least two bytes long, and so this savings can add up. It also means that we can use a lookup table during execution to call the appropriate assembly language routines.</p>
<p>Retroputer BASIC goes a little further than most BASICs of the time, though. It will also convert numbers to binary representations, mark strings, calculate variable references, and more. This wastes some space, to be honest, but the performance benefits (and ease of execution) help outweigh this.</p>
<p>So, there’s a few steps involved here:</p>
<ol>
<li>
<p>Tokenize numbers</p>
<p>Numbers are converted to their binary form to avoid having to convert them each time they are encountered. For numbers encountered only once, this isn’t a huge performance benefit, but in a tight loop, this is beneficial since the number is already in a form the computer can understand.</p>
</li>
<li>
<p>Mark strings</p>
<p>Because memory is limited, if there’s a string in the code that can be used as-is, it makes sense to do so. For example, <code>PRINT “Hello, World”</code> can print “Hello, World” directly from the program line, rather than allocating new space, copying the string, and then printing it.</p>
<p>To make it easy to skip strings during execution, we also store the length of the string itself.</p>
</li>
<li>
<p>Search keyword table</p>
<p>Anything that’s not a number or a string might be a keyword — so we need to take a look through the list of keywords. This is trivial in JavaScript, but it’s not so easy in assembly language!</p>
<p>Once a keyword is found, the associated token is stored in program memory (instead of the entire keyword itself). This can result in significant storage savings, especially when <code>PRINT</code> can be reduced to a single byte!</p>
</li>
<li>
<p>Calculate variable pointers</p>
<p>Retroputer BASIC variable names are only significant to the first two characters (currently). This makes it trivial to look up a variable in an array with a fairly simple mathematical expression. Even so, this calculation takes time, and so it’d be nice if we didn’t have to do it every time we encountered the variable.</p>
<p>Retroputer BASIC will calculate this index and store it alongside the variable name. In addition to the variable name, it also stores the length of the variable to speed up runtime execution. This consumes a good amount of space, and so wouldn’t have been a good solution on computers with limited memory, but it works for Retroputer BASIC.</p>
</li>
</ol>
<p>I won’t go into the assembly language for this step in this post. I’ll save that for a future post. Rest assured, though, <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/tokenizer.asm#L154" rel="noopener nofollow noreferrer">it takes a <em>lot</em> of code</a>.</p>
<h2 id="runtime-syntax-checking">Runtime Syntax Checking</h2>
<p>Last, but definitely not least, is checking syntax at runtime. This is reasonably trivial to do once you have a tokenized representation of the code.</p>
<p>First, as part of the <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/exec.asm#L140" rel="noopener nofollow noreferrer">execution phase</a>, BASIC checks if it is currently looking at a token. All tokens have the high bit set (so they have a value of 128 or higher). If a token is found, we can determine what subroutine to call simply by looking it up in a <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/stmt-tokens.asm#L2" rel="noopener nofollow noreferrer">vector table</a>. This also makes it trivial to render syntax errors — some keywords make no sense as statements, and so the vector table just points to the routine that generates a syntax error.</p>
<p>Once a statement’s token handler is called, the handler takes over additional parsing responsibilities. It can use <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/parser.asm" rel="noopener nofollow noreferrer"><code>gettok</code>, <code>gettok-raw</code>, <code>peektok</code></a>, etc., to get and advance past tokens. If the token is something the routine didn’t expect, the routine just returns an error code. This is where both syntax and type errors are caught.</p>
<p>Should a statement need to <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/eval.asm#L209" rel="noopener nofollow noreferrer">evaluate</a> an expression, another phase of parsing is performed. During expression parsing another <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/expr-tokens.asm#L3" rel="noopener nofollow noreferrer">vector lookup </a>table is used, which means we can catch keywords that don’t make sense inside a mathematical expression and raise the appropriate errors. For example, if you tried to enter <code>PRINT 2+CLS</code>, you’d get a syntax error at the <code>CLS</code> portion (<code>CLS</code> is a keyword that is short for “clear screen”).</p>
<p><em><strong>Note:</strong></em> We can also determine operator precedence and number of required parameters for functions from this table. This is important for actually evaluating the expression, but we also use these to catch cases where the user may not have supplied enough arguments.</p>
<p>Because the token directly maps to an entry in a vector lookup table, execution can proceed pretty quickly with minimal effort. The work of parsing each kind of statement is left to the handler itself, and generally this isn’t too much of a problem. <a href="https://github.com/kerrishotts/retroputer/blob/master/asm/kernel/basic/handlers/stmt.asm#L731" rel="noopener nofollow noreferrer"><code>PRINT</code></a> and <code>INPUT</code> are probably the most complex to parse, but every step is taken a token at a time.</p>
<p>Because a lot of checking isn’t done until runtime, it does mean that you can have partial results before an error occurs. For example:</p>
<pre><code>PRINT "Hello";CLS
Hello
?Syntax Error
</code></pre>
<p>It also means that should your program leave the screen in a state where you can’t actually see text, you could be up a tree in terms of recovering. The syntax error is printed, but if you can’t see it… well, what are you going to do?</p>
<p>There’s definitely downsides to this kind of syntax checking, but it also makes for a reasonably simple interpreter as well.</p>
<h2 id="next-time">Next Time</h2>
<p>Next time we’ll talk go into a little more detail about how the second parsing phase works, and how much easier it would be in JavaScript with modern abstractions and standard libraries. But every step in this process gives me an even greater appreciation for our modern conveniences, and just <em>how much work</em> is going on below the surface.</p>
<h3 id="edit-history%3A">Edit History:</h3>
<ul>
<li>8 July 2020: Updated vector table links to new auto-generated token files.</li>
</ul>
<p>‌</p>
                    </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>