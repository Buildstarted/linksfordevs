<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Expose top-level nullability information from reflection &#xB7; Issue #29723 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Expose top-level nullability information from reflection · Issue #29723 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>With C# 8, developers will be able to express whether a given reference type can be null:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">M</span>(<span class="pl-k">string</span>? <span class="pl-smi">nullable</span>, <span class="pl-k">string</span><span class="pl-smi">notNull</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-k">string</span>?&gt; <span class="pl-smi">nonNullCollectionOfPotentiallyNullEntries</span>);</pre></div><p>(Please note that existing code that wasn't compiled using C# 8 and nullable turned on is considered to be unknown.)</p><p>This information isn't only useful for the compiler but also attractive for reflection-based tools to provide a better experience. For example:</p><ul><li><p><strong>MVC</strong></p><ul><li>Provides a way to automatically deserialize inputs to controller methods ("model binding")</li><li>Would like to provide model validation so that the existing pattern would allow code to bail early</li><li>Without it, customers would have to apply a custom attribute, such as <code>[Required]</code>, or resort to additional null-checks</li><li>Only needs top-level annotations, i.e. <code>string?</code> but not nested, such as <code>IEnumerable&lt;string?&gt;</code></li></ul></li><li><p><strong>EF</strong></p><ul><li>Provides a way to generate database schemas from user classes ("code first")</li><li>Would like use nullable information to infer whether columns should be null or non-null (they already do that for nullable value types).</li><li>Without it, customers would have to apply a custom attribute to repeat that information.</li><li>Also only needs top-level annotations</li></ul></li></ul><p>The nullable information is persisted in metadata using custom attributes. In principle, any interested party can already read the custom attributes without additional work from the BCL. However, this is not ideal because the encoding is somewhat non-trivial:</p><ul><li><strong>Custom attribute might be generated</strong>. The custom attribute might have been generated (meaning is embedded in the user's assembly) or might use the <a href="https://github.com/dotnet/corefx/issues/36222">to-be-provided attribute</a>.</li><li><strong>Encoded as a byte array</strong>. The tri-state is encoded as a linearized version of the constructed generic type.</li><li><strong>Compressed</strong>. Right now, each member will have the attribute when nullability is turned on but this causes metadata bloat. We're working on a proposal that allows the containing member, type, or assembly to state a default to reduce the number of attribute applications.</li></ul><p>Exposing nullability in reflection for nested generics isn't straight forward. We can't just expose an additional property on <code>Type</code> because at runtime there is no difference between <code>string</code> (unknown), <code>string?</code> (nullable), and <code>string</code> (non-null). So we'd have to expose some sort of API that allows consumers to walk the type structure and getting information. Given that we have other cases with similar issues, such as <code>dynamic</code> and tuple names, we might want to generalize this. For .NET Core 3.0 we're likely running out of time to design a complex API like this.</p><p>However, the 80% scenario is just answering the question whether the given return value or parameter can be null <em>as a whole</em>. This simplifies the design tremendously as it only requires exposing APIs on the <code>MethodInfo</code>, <code>ParameterInfo</code>, <code>FieldInfo</code>, <code>PropertyInfo</code>, and <code>EventInfo</code>. Even if we were to provide the more complete API, these simple APIs would still be useful as they would be much easier to use.</p><h3>Unifying nullable-value types and nullable-reference types</h3><p>It was suggested that these APIs also return <code>NullableState.MaybeNull</code> for nullable value types, which seems desirable indeed. Boxing a nullable value type causes the non-nullable representation to be boxed. Which also means you can always cast a boxed non-nullable value type to its nullable representation. Since the reflection API surface is exclusively around <code>object</code> it seems logical to unify these two models. For customers that want to differentiate the two, they can trivially check the top-level type to see whether it's a reference type or not.</p><h3>API proposal</h3><p>The APIs are declared virtual so that derived reflection models can implement them in the appropriate way (for example, the metadata reader might read attributes in a better way which can make these cheaper to compute).</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">namespace</span><span class="pl-en">System</span>.<span class="pl-en">Reflection</span>
{
    <span class="pl-k">public</span><span class="pl-k">enum</span><span class="pl-en">NullableState</span>
    {
        <span class="pl-en">Unknown</span>,
        <span class="pl-en">NotNull</span>,
        <span class="pl-en">MaybeNull</span>
    }

    <span class="pl-k">public</span><span class="pl-k">partial</span><span class="pl-k">class</span><span class="pl-en">FieldInfo</span>
    {
        <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">NullableState</span><span class="pl-en">GetNullableState</span>()        
    }

    <span class="pl-k">public</span><span class="pl-k">partial</span><span class="pl-k">class</span><span class="pl-en">PropertyInfo</span>
    {
        <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">NullableState</span><span class="pl-en">GetNullableState</span>()        
    }

    <span class="pl-k">public</span><span class="pl-k">partial</span><span class="pl-k">class</span><span class="pl-en">EventInfo</span>
    {
        <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">NullableState</span><span class="pl-en">GetNullableState</span>()        
    }

    <span class="pl-k">public</span><span class="pl-k">partial</span><span class="pl-k">class</span><span class="pl-en">MethodBase</span>
    {
        <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">NullableState</span><span class="pl-en">GetReturnTypeNullableState</span>()        
    }

    <span class="pl-k">public</span><span class="pl-k">partial</span><span class="pl-k">class</span><span class="pl-en">ParameterInfo</span>
    {
        <span class="pl-k">public</span><span class="pl-k">virtual</span><span class="pl-en">NullableState</span><span class="pl-en">GetNullableState</span>()        
    }
}</pre></div><h3>Sample usage</h3><p>Below is a somewhat contrived usage for a serializer:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span><span class="pl-k">void</span><span class="pl-en">DeserializePropertyValue</span>(<span class="pl-en">PropertInfo</span><span class="pl-smi">p</span>, <span class="pl-k">object</span><span class="pl-smi">instance</span>, <span class="pl-k">object</span>? <span class="pl-smi">value</span>)
{
    <span class="pl-k">if</span> (<span class="pl-smi">value</span><span class="pl-k">==</span><span class="pl-c1">null</span>)
    {
        <span class="pl-k">var</span><span class="pl-smi">nullableState</span><span class="pl-k">=</span><span class="pl-smi">p</span>.<span class="pl-en">GetNullableState</span>();
        <span class="pl-k">var</span><span class="pl-smi">allowsNull</span><span class="pl-k">=</span><span class="pl-smi">nullableState</span><span class="pl-k">!=</span><span class="pl-smi">NullableState</span>.<span class="pl-smi">NotNull</span>;
        <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">allowsNull</span>)
            <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">MySerializerException</span>(<span class="pl-s"><span class="pl-pds">$"</span>Property '{<span class="pl-smi">p</span>.<span class="pl-en">GetType</span>().<span class="pl-smi">Name</span>}.{<span class="pl-smi">p</span>.<span class="pl-smi">Name</span>}'' cannot be set to null.<span class="pl-pds">"</span></span>);
    }

    <span class="pl-smi">p</span>.<span class="pl-en">SetValue</span>(<span class="pl-smi">instance</span>, <span class="pl-smi">value</span>);
}</pre></div><p><a class="team-mention js-team-mention" data-error-text="Failed to load team members" data-id="3189199" data-permission-text="Team members are private" data-url="/orgs/dotnet/teams/nullablefc/members" data-hovercard-type="team" data-hovercard-url="/orgs/dotnet/teams/nullablefc/hovercard" href="https://github.com/orgs/dotnet/teams/nullablefc">@dotnet/nullablefc</a><a class="team-mention js-team-mention" data-error-text="Failed to load team members" data-id="1965444" data-permission-text="Team members are private" data-url="/orgs/dotnet/teams/ldm/members" data-hovercard-type="team" data-hovercard-url="/orgs/dotnet/teams/ldm/hovercard" href="https://github.com/orgs/dotnet/teams/ldm">@dotnet/ldm</a><a class="team-mention js-team-mention" data-error-text="Failed to load team members" data-id="2251580" data-permission-text="Team members are private" data-url="/orgs/dotnet/teams/fxdc/members" data-hovercard-type="team" data-hovercard-url="/orgs/dotnet/teams/fxdc/hovercard" href="https://github.com/orgs/dotnet/teams/fxdc">@dotnet/fxdc</a><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/rynowak/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/rynowak">@rynowak</a><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/divega/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/divega">@divega</a><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/ajcvickers/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/ajcvickers">@ajcvickers</a><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/roji/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/roji">@roji</a><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/steveharter/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/steveharter">@steveharter</a></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>