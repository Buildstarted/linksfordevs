<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building a self-contained game in C# under 8 kilobytes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Building a self-contained game in C# under 8 kilobytes</h1><div><div class="ac ae af ag ah do aj ak"><p id="a05a" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">As someone who grew up in the times of 1.44 MB floppy disks and 56 kbit modems, I’ve always liked small programs. I could fit many small programs on a floppy disk I carried with me. If a program couldn’t fit on my floppy disk, I started thinking about why — does it have a lot of graphics? Is there music? Can the program do many complex things? Or is it simply <em class="gk">bloated</em>?</p><figure class="gm gn go gp gq gr da db paragraph-image"><figcaption class="cd eu hi hj hk dc da db hl hm by et">Photo by <a href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">Brett Jordan</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">Unsplash</a></figcaption></figure><p id="e5b8" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">These days, disk space became so cheap (and huge flashdrives so ubiquitous) that people gave up on optimizing for size.</p><p id="6d2e" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">One place where size still matters is transfers: when transferring a program over a wire, megabytes equate to seconds. A fast 100 MBit connection can only push through 12 megabytes per second in the best case. If on the other end of the wire is a person waiting for a download to finish, the difference between five seconds and one second can have meaningful impact on their experience.</p><p id="c62b" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The person could be exposed to the transfer times either directly (user is downloading a program over network), or indirectly (a serverless service is getting deployed to respond to a web request).</p><p id="4982" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">People typically perceive anything faster than 0.1 seconds as instant, 3.0 seconds is about the limit for user’s flow to stay uninterrupted, and you would have a hard time to keep the user engaged after 10 seconds.</p><blockquote class="hr"><p class="dr b ib ic cd">While smaller is not essential anymore, it’s still <em class="id">better</em>.</p></blockquote><p id="b3c8" class="fw fx ar bz fy b fz ie gb if gd ig gf ih gh ii gj dj">This article came out as an experiment to find out just how small a useful self-contained C# executable can be. Can C# apps hit the sizes where users would consider the download times <em class="gk">instant</em>? Would it enable C# to be used in places where it isn’t used right now?</p><h2 id="3991" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">What exactly is “self-contained”?</h2><p id="ef96" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">A self-contained application is an application that includes everything that’s necessary for it to run on a vanilla installation of the operating system.</p><p id="e5e5" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The C# compiler belongs to a group of compilers targeting a virtual machine (Java and Kotlin being another notable members of the group): the output of the C# compiler is an executable that requires some sort of virtual machine (VM) to execute. One can’t just install a barebone operating system and expect to be able to run programs produced by the C# compiler on it.</p><p id="1dfb" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">At least on Windows, it used to be the case that one could rely on a machine-wide installation of the .NET Framework to run the outputs of the C# compiler. Nowadays there are many Windows SKUs that no longer carry the framework with it (IoT, Nano Server, ARM64,…). .NET Framework also doesn’t support the latest enhancements to the C# language. It’s kind of on its way out.</p><p id="8336" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">For a C# app to be self-contained, it needs to include the runtime and all the class libraries it uses. It’s a lot of stuff to fit into the 8 kB that we budget for!</p><h2 id="9ed4" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">The 8 kB game</h2><p id="5233" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">We’re going to build a clone of the Snake game. Here’s the finished product:</p><figure class="gm gn go gp gq gr da db paragraph-image"><p id="80a2" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">If you’re not interested in the game mechanics, feel free to skip over to the interesting parts where we shrink the game from 65 <strong class="fy je">megabytes</strong> to 8 <strong class="fy je">kilobytes</strong> in 9 steps (scroll down to where you see graphs).</p><p id="5f48" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The game will run in text mode and we’ll use the box drawing characters to draw the snake. I’m sure Vulcan or DirectX would be a lot more fun, but we’ll get by with <code class="hc jf jg jh ji b">System.Console</code>.</p><h2 id="bbad" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">A no-allocation game</h2><p id="f785" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">We’re going to build a no-allocation game — and by no-allocation I don’t mean the “don’t allocate in the game loop” that is common among C# game devs. I mean “the <code class="hc jf jg jh ji b">new</code> keyword with reference types is forbidden in the entire codebase”. The reasons for that will become apparent at the final stretch of shrinking the game.</p><p id="821b" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">With such restriction in place, one might wonder if there’s any point in using C# after all: without the <code class="hc jf jg jh ji b">new</code> keyword, we won’t be using the garbage collector, we can’t throw exceptions, etc. — a language like C would work just as well.</p><p id="6a0e" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">One reason to use C# is “because we can”. The other reason is testability and code sharing — while the game as a whole is no-allocation, it doesn’t mean that parts of it couldn’t be reused in a different project that doesn’t have such constrains. For example, parts of the game could be included from an xUnit project to get unit test coverage. If one chooses C to build the game, things have to stay constrained by what C can do even when the code is reused from elsewhere. But since C# provides a good mix of high level and low level constructs, we can follow the “<em class="gk">high level by default, low level when necessary</em>” philosophy.</p><p id="453e" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">To reach the 8 kB deployment size, the low level part will be necessary.</p><h2 id="1ab9" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">The game structure</h2><p id="3ced" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">Let’s start with a <code class="hc jf jg jh ji b">struct</code> that represents the frame buffer. Frame buffer is a component that holds the pixels (or in this case <em class="gk">characters</em>) to be drawn to the screen.</p><figure class="gm gn go gp gq gr"><p id="d820" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We provide methods to set individual pixels, clear the frame buffer, and to render the contents of the frame buffer into <code class="hc jf jg jh ji b">System.Console</code>. The rendering step special cases a couple characters so that we get colorful output without having to keep track of color for each pixel of the frame buffer.</p><p id="b586" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">One interesting thing to call out is the <code class="hc jf jg jh ji b">fixed char _chars[Area]</code> field: this is the C# syntax to declare a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/fixed-size-buffers" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">fixed array</a>. A fixed array is an array whose individual elements are a part of the struct. You can think of it as a shortcut for a set of fields <code class="hc jf jg jh ji b">char _char_0, _char_1, _char_2, _char_3,... _char_Area</code> that one can access as an array. The size of this array needs to be a compile time constant so that the size of the entire struct is fixed.</p><p id="effa" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We can’t go overboard with the size of a fixed array because being a part of a struct, the array needs to live on the stack and stacks tend to be limited to a small number of bytes (1 MB per thread, typically). But 40 * 20 * 2 bytes (width * height * sizeof(char)) should be fine.</p><p id="abe1" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Next thing we need is a random number generator. The one that comes with .NET is a reference type (for good reasons!) and we forbid ourselves the <code class="hc jf jg jh ji b">new</code> keyword — we can’t use it. A simple <code class="hc jf jg jh ji b">struct</code> will do:</p><figure class="gm gn go gp gq gr"><p id="5d2f" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This random number generator is not great, but we don’t need anything sophisticated.</p><p id="34e6" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Now we only need something that wraps the snake logic. Time for a <code class="hc jf jg jh ji b">Snake</code> struct:</p><figure class="gm gn go gp gq gr"><p id="6915" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The state that a snake needs to track is:</p><ul class=""><li id="1b24" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj jk jl jm">the coordinates of each pixel that represents the snake’s body,</li><li id="5fe9" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">the current length of the snake,</li><li id="bae6" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">the current direction of the snake,</li><li id="bdf7" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">past direction of the snake (in case we need to draw the “bend” character instead of a straight line)</li></ul><p id="e56f" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The snake provides methods to <code class="hc jf jg jh ji b">Extend</code> the length of snake by one (returns false if the snake is already at full length), to <code class="hc jf jg jh ji b">HitTest</code> a pixel with the snake’s body, to <code class="hc jf jg jh ji b">Draw</code> the snake into a <code class="hc jf jg jh ji b">FrameBuffer</code> and to <code class="hc jf jg jh ji b">Update</code> the snake’s position as a response to a game tick (returns false if the snake ate itself). There’s also a property to set the current <code class="hc jf jg jh ji b">Course</code> of the snake.</p><p id="52a4" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We use the same fixed array trick that we used in the frame buffer to keep the snake no-allocation. It means the maximum length of the snake has to be a compile time constant.</p><p id="6d47" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The last thing we need is the game loop:</p><figure class="gm gn go gp gq gr"><p id="2f36" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We use the random number generator to generate a random position and direction of the snake, we randomly place the food on the game surface, making sure it doesn’t overlap the snake, and start the game loop.</p><p id="33e1" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Within the game loop we ask the snake to update its position and check whether it ate itself. We then draw the snake, check the keyboard for input, hit-test the snake with the food, and render everything to the console.</p><p id="14bb" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">That’s pretty much it. Let’s see where we are in terms of size.</p><h2 id="f0ae" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">The default size of a .NET Core 3.0 Snake</h2><p id="dc07" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">I’ve placed the game in <a href="https://github.com/MichalStrehovsky/SeeSharpSnake" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">a GitHub repo</a> so that you can follow along. The project file will produce the game in different configurations depending on the <code class="hc jf jg jh ji b">Mode</code> property passed to <code class="hc jf jg jh ji b">publish</code>. To produce the default configuration with CoreCLR, run:</p><pre class="gm gn go gp gq js jt ju"><span id="3b62" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release</span></pre><p id="4936" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This will produce a single EXE file that has whopping 65 MB. The produced EXE includes the game, the .NET Runtime, and the base class libraries that are the standard part of .NET. You might say “still better than Electron” and call it good, but let’s see if we can do better.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="d181" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">IL Linker</h2><p id="b691" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">IL Linker is a tool that shipped with .NET Core 3.0 — the tool removes unused code from your app by scanning the entire program and removing assemblies that are unreferenced. To use it with the project, pass a <code class="hc jf jg jh ji b">PublishTrimmed</code> property to publish. Like so:</p><pre class="gm gn go gp gq js jt ju"><span id="46c6" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:PublishTrimmed=true</span></pre><p id="fcf3" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">With this setting, the game shrinks to 25 MB. It’s a nice 60% reduction, but far from our 10 kB goal.</p><p id="99fe" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">IL Linker has more aggressive settings that are not publicly exposed and they could bring this down further, but in the end, we’re going to be limited by the size of the CoreCLR runtime itself — coreclr.dll — at 5.3 MB. We might have reached a dead end on the road to a 8 kB game.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="0905" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Slight detour: Mono</h2><p id="e7d9" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj"><a href="https://www.mono-project.com/" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">Mono</a> is another .NET runtime that for many is the synonym for Xamarin. To build a single executable with the C# snake, we can use the mkbundle tool that comes with Mono:</p><pre class="gm gn go gp gq js jt ju"><span id="b3c9" class="ij ik ar bz ji b eu jv jw r jx">mkbundle SeeSharpSnake.dll --simple -o SeeSharpSnake.exe</span></pre><p id="3d66" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This will produce a 12.3 MB executable that depends on mono-2.0-sgen.dll that itself has 5.9 MB — so we’re looking at 18.2 MB in total. When trying to launch it, I hit “Error mapping file: mono_file_map_error failed”, but I’m going to trust that except for this bug, things would work with Mono and the result would be 18.2 MB.</p><p id="6376" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Unlike CoreCLR, Mono also depends on the Visual C++ runtime redistributable library that is not available in a default Windows installation: to keep the goal of the app being self-contained, we need to carry this library with the app. This increases the footprint of the application by another megabyte or so.</p><p id="1c99" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We would likely be able to make things smaller by adding IL Linker to the mix, but we’re going to hit the same problem as with CoreCLR — the size of the runtime (mono-2.0-sgen.dll) is 5.9 MB (plus the size of the C++ runtime libraries on top of it), and represents the floor of where any possible IL-level optimization could bring us.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="e0e4" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Can we take the runtime out?</h2><p id="176c" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">It is clear that to get anywhere near the 8 kB goal, we need to take the runtime out of the app. The only .NET runtime where this is possible is <a href="https://github.com/dotnet/corert" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">CoreRT</a>. While it’s common to call CoreRT a “runtime”, it’s closer to being a “runtime library”. It’s not a virtual machine like CoreCLR or Mono — the CoreRT’s runtime is just a set of functions that support ahead of time generated native code produced by CoreRT’s ahead of time compiler.</p><p id="f1cf" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">CoreRT comes with <em class="gk">libraries</em> that make CoreRT look like any other .NET runtime: there’s a library that adds GC, library that adds support for reflection, library that adds a JIT, library that adds an interpreter, etc. But all of those libraries are <em class="gk">optional</em> (and that includes the GC).</p><p id="f3b2" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">More on how CoreRT differs from CoreCLR and Mono is in <a class="bi cv hn ho hp hq" target="_blank" rel="noopener" href="/@MStrehovsky/fight-the-global-warming-compile-your-c-apps-ahead-of-time-9997e953645b">this article</a>. When I was reading about the runtime of the <a href="https://theartofmachinery.com/2017/06/04/what_is_the_d_runtime.html" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">D language</a>, it reminded me of CoreRT a lot. The article is an interesting read too.</p><p id="44c6" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s see where we’re with the default CoreRT configuration:</p><pre class="gm gn go gp gq js jt ju"><span id="062f" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:Mode=CoreRT</span></pre><p id="b110" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This comes down to 4.7 MB. It’s the smallest so far, but still not good enough.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="2d7e" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Turning on moderate size savings in CoreRT</h2><p id="bd26" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">The CoreRT ahead of time compiler offers a <a href="http://aka.ms/OptimizeCoreRT" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">vast number</a> of settings that affect code generation. By default, the compiler tries to maximize the generated code speed and compatibility with other .NET runtimes at the expense of the size of the generated executable.</p><p id="1dcd" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The compiler has a built-in linker that removes unused code. The “CoreRT-Moderate” setting that we define in the Snake project relaxes one of the restrictions on removing unused code that allows more removal. We also ask the compiler to trade program speed for some extra bytes. Most .NET programs would work just fine in this mode.</p><pre class="gm gn go gp gq js jt ju"><span id="e557" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-Moderate</span></pre><p id="69f9" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We’re now at 4.3 MB.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="0fa1" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Turning on high savings in CoreRT</h2><p id="c50d" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">I’ve grouped a couple more compilation options into a “high savings” mode. This mode is going to remove support for things that many apps would notice, but Snake (being the low level thing that it is) won’t.</p><p id="93e1" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We are going to remove:</p><ul class=""><li id="7cdb" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj jk jl jm">Stack trace data for framework implementation details</li><li id="176f" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">Exception messages in framework-thrown exceptions</li><li id="2707" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">Support for non-English locales</li><li id="0c6d" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">EventSource instrumentation</li></ul><pre class="gm gn go gp gq js jt ju"><span id="b386" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-High</span></pre><p id="3ae9" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We’ve reached 3.0 MB. This is 5% of what we started with, but CoreRT has one more trick up its sleeve.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="fb46" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Disabling reflection</h2><p id="27a3" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">Substantial part of the CoreRT runtime libraries is dedicated to the implementation of the .NET reflection surface area. Because CoreRT is an ahead-of-time-compiled runtime-library-based .NET implementation, it doesn’t need most of the data structures a typical VM-based runtime (like CoreCLR and Mono) needs. This data includes things like names of types, methods, signatures, base types, etc. CoreRT embeds this data because programs using .NET reflection need it, but not because it’s needed for the runtime to operate. I call this data “the reflection tax”, because that’s what it is for the runtime.</p><p id="f27b" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">CoreRT supports a <a href="https://github.com/dotnet/corert/blob/master/Documentation/using-corert/reflection-free-mode.md" class="bi cv hn ho hp hq" target="_blank" rel="noopener nofollow">reflection-free mode</a> that avoids this tax. You might feel that a lot of .NET code wouldn’t work without reflection and you might be right, but a surprising amount of things do work: Gui.cs, System.IO.Pipelines, or even a basic WinForms app. Snake will definitely work, so let’s turn this mode on:</p><pre class="gm gn go gp gq js jt ju"><span id="d695" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-ReflectionFree</span></pre><p id="8c97" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We’re now at 1.2 MB. The reflection tax is a pretty heavy tax!</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="bcdb" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Getting our hands dirty</h2><p id="51a5" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">Now we’ve reached the end of what’s possible with the .NET SDK and we need to get our hands dirty. What we’re going to do now is starting to be ridiculous and I wouldn’t expect anyone else to do this. We’re going to rely on the implementation details of the CoreRT compiler and runtime.</p><p id="860e" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">As we saw earlier, CoreRT is a set of runtime libraries coupled with an ahead of time compiler. What if we replace the runtime libraries with a minimal reimplementation? We’ve decided not to use the garbage collector and that makes this job much more feasible.</p><p id="1ecd" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s start with the easy things:</p><figure class="gm gn go gp gq gr"><p id="f15a" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">There — we just reimplemented <code class="hc jf jg jh ji b">Thread.Sleep</code> and <code class="hc jf jg jh ji b">Environment.TickCount64</code> (for Windows) while avoiding all dependencies on the existing runtime library.</p><p id="bdaa" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s do the same for the subset of <code class="hc jf jg jh ji b">System.Console</code> that the game uses:</p><figure class="gm gn go gp gq gr"><p id="91c2" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s rebuild the game with this replacement framework:</p><pre class="gm gn go gp gq js jt ju"><span id="bdab" class="ij ik ar bz ji b eu jv jw r jx">dotnet publish -r win-x64 -c Release /p:Mode=CoreRT-ReflectionFree /p:IncludePal=true</span></pre><p id="bf87" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Unsurprisingly, this didn’t save us much. The APIs we’re replacing are already relatively lightweight, and rewriting them only gains a couple kilobytes that are not worth mentioning. But this is an important stepping stone to the last step in our journey.</p><h2 id="318d" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Replacing all runtime libraries</h2><p id="41b9" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">The remaining 1.2 MB of code and data in the Snake game is there to support things we don’t see, but are there — ready in case we need them. There’s the garbage collector, support for exception handling, the code to format and print stack traces to the console when an unhandled exception happens, and many other things that are “under the hood”.</p><p id="fde6" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The compiler could detect that none of this is needed and avoid generating them, but what we’re trying to do is so weird that it’s not worth adding compiler features to support it. The way to avoid it is to simply provide an alternative runtime library.</p><p id="e6dd" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s start with redefining a minimal version of the base types:</p><figure class="gm gn go gp gq gr"><p id="4de7" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">At this point let’s forgo the project file and dotnet CLI and launch the individual tools directly. We start by launching the C# compiler (CSC). I recommend launching these commands from the “x64 Native Tools Command Prompt for VS 2019” — it’s in your Start menu if you have Visual Studio installed. The right version of tools is on the PATH in that window.</p><p id="77ea" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The <code class="hc jf jg jh ji b">/noconfig</code>, <code class="hc jf jg jh ji b">/nostdlib</code>, and <code class="hc jf jg jh ji b">/runtimemetadataversion</code> are the magic switches needed to compile something that defines <code class="hc jf jg jh ji b">System.Object</code>. I chose the <code class="hc jf jg jh ji b">.ilexe</code> file extension instead of <code class="hc jf jg jh ji b">.exe</code> because <code class="hc jf jg jh ji b">.exe</code> will be used for the finished product.</p><pre class="gm gn go gp gq js jt ju"><span id="d982" class="ij ik ar bz ji b eu jv jw r jx">csc.exe /debug /O /noconfig /nostdlib /runtimemetadataversion:v4.0.30319 MiniBCL.cs Game\FrameBuffer.cs Game\Random.cs Game\Game.cs Game\Snake.cs Pal\Thread.Windows.cs Pal\Environment.Windows.cs Pal\Console.Windows.cs /out:zerosnake.ilexe /langversion:latest /unsafe</span></pre><p id="9213" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This will successfully compile the IL bytecode version of the game with the C# compiler. We still need some sort of runtime to execute it.</p><p id="2182" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s try to feed this to the CoreRT ahead of time compiler to generate native code from the IL. If you followed the steps above, you’ll find ilc.exe, the CoreRT ahead of time compiler, in your NuGet package cache (somewhere like %USERPROFILE%\.nuget\packages\runtime.win-x64.microsoft.dotnet.ilcompiler\1.0.0-alpha-27402–01\Tools).</p><pre class="gm gn go gp gq js jt ju"><span id="681e" class="ij ik ar bz ji b eu jv jw r jx">ilc.exe zerosnake.ilexe -o zerosnake.obj --systemmodule zerosnake --Os -g</span></pre><p id="22ed" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This is going to crash with “Expected type ‘Internal.Runtime.CompilerHelpers.StartupCodeHelpers’ not found in module ‘zerosnake’”. Turns out that besides the obvious minimum that a managed developer would expect, there’s also a minimum that the CoreRT compiler needs to compile the input.</p><p id="e3b6" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s skip to the chase and add what’s needed:</p><figure class="gm gn go gp gq gr"><p id="3bf7" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Let’s rebuild the IL bytecode with this newly added code and re-rerun ILC.</p><pre class="gm gn go gp gq js jt ju"><span id="1a4d" class="ij ik ar bz ji b eu jv jw r jx">csc.exe /debug /O /noconfig /nostdlib /runtimemetadataversion:v4.0.30319 MiniRuntime.cs MiniBCL.cs Game\FrameBuffer.cs Game\Random.cs Game\Game.cs Game\Snake.cs Pal\Thread.Windows.cs Pal\Environment.Windows.cs Pal\Console.Windows.cs /out:zerosnake.ilexe /langversion:latest /unsafe</span><span id="577c" class="ij ik ar bz ji b eu ka kb kc kd ke jw r jx">ilc.exe zerosnake.ilexe -o zerosnake.obj --systemmodule zerosnake --Os -g</span></pre><p id="43ff" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Now we have zerosnake.obj — a standard object file that is no different from object files produced by other native compilers such as C or C++. The last step is linking it. We’ll use the link.exe tool that should be on the PATH of our “x64 Native Tools Command Prompt” (you might need to install the C/C++ development tools in Visual Studio).</p><pre class="gm gn go gp gq js jt ju"><span id="d58c" class="ij ik ar bz ji b eu jv jw r jx">link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main</span></pre><p id="7e0c" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The <code class="hc jf jg jh ji b">__managed__Main</code> symbol name is a contract with the compiler — it’s the name of the managed entrypoint of the program that ILC created.</p><p id="56c3" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">But it doesn’t work:</p><pre class="gm gn go gp gq js jt ju"><span id="a7cf" class="ij ik ar bz ji b eu jv jw r jx">error LNK2001: unresolved external symbol RhpPInvoke<br>error LNK2001: unresolved external symbol SetConsoleTextAttribute<br>error LNK2001: unresolved external symbol WriteConsoleW<br>error LNK2001: unresolved external symbol GetStdHandle<br>...<br>fatal error LNK1120: 17 unresolved externals</span></pre><p id="d0f8" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Some of these symbols look familiar — the linker doesn’t know where to look for the Windows APIs we call. Let’s add the import libraries for those:</p><pre class="gm gn go gp gq js jt ju"><span id="0934" class="ij ik ar bz ji b eu jv jw r jx">link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main kernel32.lib ucrt.lib</span></pre><p id="6050" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This looks better — only 4 unresolved symbols:</p><pre class="gm gn go gp gq js jt ju"><span id="9266" class="ij ik ar bz ji b eu jv jw r jx">error LNK2001: unresolved external symbol RhpPInvoke<br>error LNK2001: unresolved external symbol RhpPInvokeReturn<br>error LNK2001: unresolved external symbol RhpReversePInvoke2<br>error LNK2001: unresolved external symbol RhpReversePInvokeReturn2<br>fatal error LNK1120: 4 unresolved externals</span></pre><p id="3139" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The remaining missing symbols are helpers that the compiler expects to find in the runtime library. The fact they’re missing is only discovered at the time of linking because these helpers are typically implemented in assembly and the compiler only refers to them by their symbolic name (as opposed to other compiler-required types and methods we provided above).</p><p id="c172" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The helpers set up and tear down the stack frames when native code calls into managed code, and managed code calls into native code. This is necessary for the GC to operate. Since we don’t have a GC, let’s stub them out with a piece of C# and another magical attribute that the compiler understands.</p><figure class="gm gn go gp gq gr"><p id="0c85" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">After rebuilding the C# source code with these modifications and re-running ILC, the linking will finally succeed.</p><p id="e13d" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We’re now at 27 kilobytes and the game still works!</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="c5e8" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Messing with the linker</h2><p id="af0e" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">The remaining kilobytes can be shaved off by using tricks native developers use to shrink their native apps.</p><p id="5c33" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">We’re going to:</p><ul class=""><li id="ca8d" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj jk jl jm">Disable incremental linking</li><li id="a7c5" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">Strip relocation information</li><li id="3f5b" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">Merge similar sections within the executable</li><li id="2c58" class="fw fx ar bz fy b fz jn gb jo gd jp gf jq gh jr gj jk jl jm">Set internal alignment within the executable to a small value</li></ul><pre class="gm gn go gp gq js jt ju"><span id="2c0b" class="ij ik ar bz ji b eu jv jw r jx">link.exe /debug:full /subsystem:console zerosnake.obj /entry:__managed__Main kernel32.lib ucrt.lib /merge:.modules=.rdata /merge:.pdata=.rdata /incremental:no /DYNAMICBASE:NO /filealign:16 /align:16</span></pre><p id="9c2f" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Success! 8176 bytes!</p><p id="55f0" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">The game still works, and interestingly, it’s still fully debuggable — feel free to open the EXE in Visual Studio (File -&gt; Open Solution), open one of the C# files that are part of the game, set a breakpoint in it, hit F5 to launch the EXE, and see the breakpoint getting hit. You can disable optimizations in ILC to make the executable even more debuggable — just drop the <code class="hc jf jg jh ji b">--Os</code> argument.</p><figure class="gm gn go gp gq gr da db paragraph-image"><h2 id="4c00" class="ij ik ar bz by il im in io ip iq ir is it iu iv iw">Can we make things smaller than that?</h2><p id="c00e" class="fw fx ar bz fy b fz ix gb iy gd iz gf ja gh jb gj dj">The executable still carries some data that is not essential — the ILC compiler just doesn’t expose command line options to disable their generation.</p><p id="5f9d" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">One of those data structures that gets generated but we don’t need is GC information for the individual methods. CoreRT has a precise garbage collector that requires each method to describe where references to GC heap are at each instruction of the method body. Since we don’t have a garbage collector in the Snake game, this data is unnecessary. Other runtimes (e.g. Mono) use a conservative garbage collector that doesn’t require this data (it simply assumes any piece of the stack and CPU registers could be a GC reference) — a conservative garbage collector trades GC performance for extra size savings. The precise garbage collector used in CoreRT can operate in conservative mode too, but it hasn’t been hooked up yet. It’s a potential future addition that we could then leverage to make things even smaller.</p><p id="016c" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Maybe one day we can make a simplified version of our game fit into a 512 byte boot sector. Until then, happy hacking!</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>