<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Relay Blazor client logs to Serilog in ASP.NET Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Relay Blazor client logs to Serilog in ASP.NET Core</h1>
    <div class="post-content"> <blockquote> <p><strong>TL;DR:</strong> <a href="https://github.com/nblumhardt/serilog-sinks-browserhttp"><em>Serilog.Sinks.BrowserHttp</em> and <em>Serilog.AspNetCore.Ingestion</em></a> together implement a client/server log relay for Blazor apps running Serilog, feeding events from the Blazor client into the ASP.NET Core server log stream.</p>
</blockquote> <p>Microsoft&#x2019;s new UI stack, Blazor, features in just about every summary of what&#x2019;s new in .NET Core 3. I&#x2019;m not planning to use &#x201C;server-side&#x201D; Blazor, although it&#x2019;s undeniably impressive (frameworks based on stateful client/server sessions tend to blow their complexity budget dealing with all the messy realities of deployment on the web). &#x201C;Client-side&#x201D; Blazor, which runs .NET code in the browser using WebAssembly, is more interesting to me.</p> <p>I&#x2019;ve made my peace with JavaScript, and I&#x2019;m happy in the polyglot web development world we mostly inhabit, but there are still times I&#x2019;d like to share C# modules between the browser and server. In Seq, for example, we have a substantial C# query parser and expression evaluator that we&#x2019;d love to be able to use client-side.</p> <p>Since WASM is here to stay, I&#x2019;m keeping an eye on client-side Blazor, and tinkering with a few ideas&#x2026;</p> <h3 id="spiking-out-some-core-serilog--blazor-scenarios">Spiking out some core Serilog + Blazor scenarios</h3> <p>There are two interesting scenarios I can see for Serilog in Blazor.</p> <p>The first is interaction with the browser console, which natively supports structured data in the form of JavaScript objects. For a WASM module to log structured data through the browser console, serialization or mashalling is required, and this isn&#x2019;t something that can or should be done for every argument to every log call. Serilog recognizes this distinction, and its <code class="language-plaintext highlighter-rouge">{@Property}</code> capturing syntax triggers serialization only when it&#x2019;s desirable; the <code class="language-plaintext highlighter-rouge">ToString()</code> representation of objects is sent to the browser console otherwise.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">user</span> <span class="p">=</span> <span class="k">new</span> <span class="p">{</span><span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;nblumhardt&quot;</span><span class="p">,</span> <span class="n">Id</span> <span class="p">=</span> <span class="m">42</span><span class="p">};</span>
<span class="n">Log</span><span class="p">.</span><span class="nf">Information</span><span class="p">(</span><span class="s">&quot;User {@User} logged in&quot;</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
</code></pre></div></div> <p>In Firefox this comes out rather nicely:</p> <p><img src="https://nblumhardt.com/img/2019-11-serilog-blazor/BrowserConsole.png" alt="Serilog events in the browser Console"></p> <p>I won&#x2019;t say much more about this feature, here, but you can <code class="language-plaintext highlighter-rouge">dotnet add package Serilog.Sinks.BrowserConsole</code> and <code class="language-plaintext highlighter-rouge">WriteTo.BrowserConsole()</code> to see this in action for yourself, and <a href="https://github.com/serilog/serilog-sinks-browserconsole">check out the code on GitHub</a>.</p> <p>The second interesting scenario is a natural extension of Blazor&#x2019;s essential value proposition: transparently send client-side log events through the server-side log stream, for easy collection and analysis.</p> <p>A quick spike, which I&#x2019;ll write about below, suggests it&#x2019;s a compelling and rather pleasant developer experience that&#x2019;s worth more investigation.</p> <h3 id="serilogsinksbrowserhttp-and-serilogaspnetcoreingestion"><em>Serilog.Sinks.BrowserHttp</em> and <em>Serilog.AspNetCore.Ingestion</em></h3> <p><em>Serilog.Sinks.BrowserHttp</em> is a client-side sink that <code class="language-plaintext highlighter-rouge">POST</code>s newline-delimited, JSON-encoded log events from the browser to an HTTP endpoint. This could be implemented by the app&#x2019;s origin server, by another web application entirely, or by a log server that can ingest HTTP payloads.</p> <p><em>Serilog.AspNetCore.Ingestion</em> implements a matching HTTP endpoint as middleware that can be plugged into any ASP.NET Core app running Serilog. Events received by the middleware are deserialized into Serilog <code class="language-plaintext highlighter-rouge">LogEvent</code>s, and written to the server&#x2019;s log pipeline. Events from the client are tagged with a property <code class="language-plaintext highlighter-rouge">Origin = &apos;Client&apos;</code> so that they can be robustly identified.</p> <p>The two packages can be used separately, but work nicely together. Here you can see a client-side button click event, running in Blazor, being logged directly to the server-side terminal, and a client-side error following immediately after:</p> <p><img src="https://nblumhardt.com/img/2019-11-serilog-blazor/ClientSideEventsFull.png" alt="Blazor client log events in the server Console"></p> <p>Having only one log stream to watch is nice, even at development time. (Yes, the time zone used for timestamps is <a href="https://github.com/nblumhardt/serilog-sinks-browserhttp/issues/3">currently inconsistent</a> &#x1F605;.)</p> <h4 id="creating-the-demo-solution">Creating the demo solution</h4> <blockquote> <p><strong>Just want to grab the code?</strong> It&#x2019;s in the <code class="language-plaintext highlighter-rouge">/samples</code> folder in <a href="https://github.com/nblumhardt/serilog-sinks-browserhttp/">the GitHub source repository</a> - have fun!</p>
</blockquote> <p>The easiest way to set up a Blazor client app with an ASP.NET Core server is using the <code class="language-plaintext highlighter-rouge">blazorwasm</code> template, installed along via the .NET Core 3.1 preview SDK.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet new blazorwasm --hosted
</code></pre></div></div> <p>This creates a solution file and three projects: <em>Client</em>, <em>Server</em>, and <em>Shared</em>. The <em>Server</em> project is a web app that hosts the <em>Client</em>. Check that everything is set up correctly using <code class="language-plaintext highlighter-rouge">dotnet run</code>.</p> <h4 id="setting-up-the-blazor-client">Setting up the Blazor client</h4> <p>In the <em>Client</em> project, install <em>Serilog.Sinks.BrowserHttp</em>. I&#x2019;m going to enable <em>Serilog.Sinks.BrowserConsole</em> in the example, so I&#x2019;ll install that package, too.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./Client
dotnet add package Serilog.Sinks.BrowserHttp
dotnet add package Serilog.Sinks.BrowserConsole
</code></pre></div></div> <p>Blazor apps start in <em>Program.cs</em>; here&#x2019;s a complete listing that shows how Serilog is configured:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Blazor.Hosting</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Serilog</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Serilog.Core</span><span class="p">;</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span> <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">levelSwitch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">LoggingLevelSwitch</span><span class="p">();</span> <span class="n">Log</span><span class="p">.</span><span class="n">Logger</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">LoggerConfiguration</span><span class="p">()</span> <span class="p">.</span><span class="n">MinimumLevel</span><span class="p">.</span><span class="nf">ControlledBy</span><span class="p">(</span><span class="n">levelSwitch</span><span class="p">)</span> <span class="p">.</span><span class="n">Enrich</span><span class="p">.</span><span class="nf">WithProperty</span><span class="p">(</span><span class="s">&quot;InstanceId&quot;</span><span class="p">,</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">().</span><span class="nf">ToString</span><span class="p">(</span><span class="s">&quot;n&quot;</span><span class="p">))</span> <span class="p">.</span><span class="n">WriteTo</span><span class="p">.</span><span class="nf">BrowserHttp</span><span class="p">(</span><span class="n">controlLevelSwitch</span><span class="p">:</span> <span class="n">levelSwitch</span><span class="p">)</span> <span class="p">.</span><span class="n">WriteTo</span><span class="p">.</span><span class="nf">BrowserConsole</span><span class="p">()</span> <span class="p">.</span><span class="nf">CreateLogger</span><span class="p">();</span> <span class="n">Log</span><span class="p">.</span><span class="nf">Information</span><span class="p">(</span><span class="s">&quot;Hello, browser!&quot;</span><span class="p">);</span> <span class="k">try</span> <span class="p">{</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="nf">Build</span><span class="p">().</span><span class="nf">Run</span><span class="p">();</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span> <span class="n">Log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s">&quot;An exception occurred while creating the WASM host&quot;</span><span class="p">);</span> <span class="k">throw</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">public</span> <span class="k">static</span> <span class="n">IWebAssemblyHostBuilder</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">BlazorWebAssemblyHost</span><span class="p">.</span><span class="nf">CreateDefaultBuilder</span><span class="p">()</span> <span class="p">.</span><span class="n">UseBlazorStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div></div> <p>You&#x2019;ll note that <code class="language-plaintext highlighter-rouge">WriteTo.BrowserHttp()</code> doesn&#x2019;t require a URL to be specified; it will default to <code class="language-plaintext highlighter-rouge">/ingest</code> on the origin server.</p> <p>A <code class="language-plaintext highlighter-rouge">LoggingLevelSwitch</code> is created, specified as controlling the minimum level of the Serilog pipeline, and passed through to <code class="language-plaintext highlighter-rouge">WriteTo.BrowserHttp()</code>. This allows the server to set the client&#x2019;s log level, avoiding wasted bandwidth. I think there&#x2019;s more to explore in this part of the integration (for example, using <code class="language-plaintext highlighter-rouge">LoggingFilterSwitch</code> from <em>Serilog.Filters.Expressions</em>, and configuring more fine-grained client log management from the server side).</p> <p>You&#x2019;ll also spot <code class="language-plaintext highlighter-rouge">Enrich.WithProperty(&quot;InstanceId&quot;, Guid.NewGuid().ToString(&quot;n&quot;))</code>, which makes it easy to zero in on logs from a single running instance of the Blazor app (i.e. a single browser tab) by tagging them with a unique identifier.</p> <p>Note that there&#x2019;s no <code class="language-plaintext highlighter-rouge">finally { Log.CloseAndFlush() }</code> at the end of <code class="language-plaintext highlighter-rouge">Main()</code>. This is because <code class="language-plaintext highlighter-rouge">IWebAssemblyHost.Run()</code> is non-blocking, and so <code class="language-plaintext highlighter-rouge">Main()</code> returns immediately.</p> <p>The sample template includes a page called <em>Counter.razor</em>. It&#x2019;s a nice place to add a simple logging statement so that some more logs can be triggered:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@page &quot;/counter&quot;
@using Serilog <span class="nt">&lt;h1&gt;</span>Counter<span class="nt">&lt;/h1&gt;</span> <span class="nt">&lt;p&gt;</span>Current count: @currentCount<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">&quot;btn btn-primary&quot;</span> <span class="err">@</span><span class="na">onclick=</span><span class="s">&quot;IncrementCount&quot;</span><span class="nt">&gt;</span>Click me<span class="nt">&lt;/button&gt;</span> @code { private int currentCount = 0; private static readonly ILogger Log = Serilog.Log.ForContext<span class="nt">&lt;Counter&gt;</span>();

    private void IncrementCount()
    {
        currentCount++;
        Log.Information(&quot;Incremented count to {CurrentCount}&quot;, currentCount);
    }
}
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Log.Information()</code> won&#x2019;t block the UI while the event is sent to the server: <code class="language-plaintext highlighter-rouge">WriteTo.BrowserHttp()</code> uses asynchronous, batched requests, to keep resource usage to a minimum.</p> <p>It&#x2019;s C#, JIT-compiled via WASM, and running in a browser&#x2026;.. but it&#x2019;s still the Serilog we know and love &#x1F601;.</p> <h4 id="enabling-ingestion-on-the-aspnet-core-server">Enabling ingestion on the ASP.NET Core server</h4> <p>Before enabling ingestion on the server side, you&#x2019;ll need to set up Serilog. The best way to do this, in my humble opinion &#x1F609;, is to follow the instructions in <a href="https://nblumhardt.com/2019/10/serilog-in-aspnetcore-3/"><em>Setting up Serilog in ASP.NET Core 3</em></a>. I&#x2019;ll assume that, just like the example in that article, you&#x2019;ll initialize <code class="language-plaintext highlighter-rouge">Log.Logger</code>, and call <code class="language-plaintext highlighter-rouge">WriteTo.Console()</code>.</p> <p>Next, to ingest logs from the Blazor client, add the <em>Serilog.AspNetCore.Ingestion</em> package:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./Server
dotnet add package Serilog.AspNetCore.Ingestion
</code></pre></div></div> <p>If you followed all of the instructions in the ASP.NET Core setup article, in <em>Startup.cs</em>, you&#x2019;ll have:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">UseSerilogRequestLogging</span><span class="p">();</span>
</code></pre></div></div> <p>The ingestion middleware should probably come before request logging, so that <code class="language-plaintext highlighter-rouge">POST</code>ed log payloads from the client don&#x2019;t trigger too much log noise. Add one more call, <code class="language-plaintext highlighter-rouge">app.UseSerilogIngestion()</code>, just above it, so your middleware pipelin has:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="nf">UseSerilogIngestion</span><span class="p">();</span> <span class="c1">// &lt;-- Add this line</span>
<span class="n">app</span><span class="p">.</span><span class="nf">UseSerilogRequestLogging</span><span class="p">();</span>
</code></pre></div></div> <p>And that&#x2019;s everything. If you run the <em>Server</em> project, you can open the <em>Counter</em> page in a web browser and click a few times.</p> <p><img src="https://nblumhardt.com/img/2019-11-serilog-blazor/ClientSideEvents.png" alt="Client log events in the server Console"></p> <p>The logs from the client will show up alongside the other events from the ASP.NET Core app. There isn&#x2019;t much to distinguish client from server logs in this default setup; you&#x2019;ll need to switch to JSON output, or pipe logs off to a log server (like <a href="https://datalust.co/seq">Seq</a>) to see the attached properties such as <code class="language-plaintext highlighter-rouge">InstanceId</code> and <code class="language-plaintext highlighter-rouge">Origin</code>.</p> <p>If things don&#x2019;t work as expected, calling <code class="language-plaintext highlighter-rouge">Serilog.Debugging.SelfLog.Enable(m =&gt; Console.Error.WriteLine(m))</code> when the Blazor app starts up should get some debugging information into the browser console.</p> <h4 id="whats-next">What&#x2019;s next?</h4> <p>I&#x2019;d love to have your questions, ideas, and contributions to https://github.com/nblumhardt/serilog-sinks-browserhttp. You&#x2019;ll notice that it&#x2019;s published from my personal GitHub account: I&#x2019;ll pitch moving this to the Serilog organization when it&#x2019;s a little more baked, since Blazor is positioned to become a foundational .NET technology, but for now I just wanted to put this out there &#x201C;as-is&#x201D; and gauge support. If you find it useful, please let me know!</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>