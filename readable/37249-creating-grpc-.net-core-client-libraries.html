<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating gRPC .NET Core Client libraries -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Creating gRPC .NET Core Client libraries</h1>
    <div class="entry-content"> <p>This week, <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/">.NET Core 3.0</a> and <a href="https://devblogs.microsoft.com/aspnet/asp-net-core-and-blazor-updates-in-net-core-3-0/">ASP.NET Core 3.0</a> launched and one of the headline features is the fact that we can now easily create gRPC server applications and clients to consume them.</p>
<p>I&#x2019;ve been playing with gRPC locally for a little while now and really enjoy the experience. I&#x2019;ve created a new talk called &#x201C;<a href="https://www.stevejgordon.co.uk/speaking/beyond-http-in-net-core-3-0-with-grpc-talk">Beyond HTTP in ASP.NET Core with gRPC</a>&#x201D; which covers the fundamentals of how to apply gRPC for client and server scenarios, including various streaming cases. As part of the talk I show some demos based on the code in my <a href="https://github.com/stevejgordon/gRPC-Demos">gRPC Demos repository on GitHub</a>.</p>
<p>Today, I&#x2019;ve updated those demos ready for the next presentation of my talk at Techorama NL, after watching <a href="https://twitter.com/condrong">Glenn Condron</a> showing off some of the final 3.0 features and gRPC support in Visual Studio 2019 (16.3) during <a href="https://www.dotnetconf.net">dotNetConf 2019</a>.</p>
<p>In this post, I want to demonstrate how we can quickly and easily create a shared class library which includes the auto-generated gRPC client code. We&#x2019;ll then reference that class library from our gRPC client applications.</p>
<h2>Quick gRPC Refresher</h2>
<p>gRPC is based on a service contract defined in a *.proto file. This uses <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a> as the Interface Definition Language for a gRPC service. Server code is then generated using the contract which we then implement. Similarly, client code can be auto-generated from the same proto file and consumed from client applications.</p>
<p>My early demos shared a single proto file across all projects in my solution. The proto file is included in a folder in the root of my repository called &#x2018;Proto&#x2019;.</p>
<p>To load this file, the server project references it in the csproj file as follows:</p> <p>This code includes the weather.proto file from the root of the repository and tells the gRPC tooling to generate the server code from it.</p>
<p>Each client project then also referenced the proto file as follows:</p> <p>In this case, code was auto-generated for a gRPC client of the service defined in the proto contract.</p>
<p>For a basic console application client, as used in my samples, the following packages were also referenced:</p> <p>The package references and proto file had to be referenced in each client project, of which there were four in my repository. This leads to some repetition across each project.</p>
<h2>Building a Shared Library for gRPC Clients</h2>
<p>For demo purposes, the approach I&#x2019;ve just described was fine. The proto file was accessible to all projects and referencing it directly was a simple solution.</p>
<p>In a more real-world scenario, though, a proto file may well live in a different repository than the client applications. In that case, a way to share the file within the build system would be useful. There are various ways one may look to achieve that at build time which we won&#x2019;t cover in this post. Instead, I&#x2019;d like to focus on the first stage of a quite elegant approach; creating a single shared library for use by all clients.</p>
<p>Inside Visual Studio, let&#x2019;s create a new Class Library project:</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/grpc-auto-gen-class-library-project.png" alt class="wp-image-1862" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/grpc-auto-gen-class-library-project.png 1024w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/grpc-auto-gen-class-library-project-300x208.png 300w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/grpc-auto-gen-class-library-project-768x533.png 768w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div> <p>I&#x2019;ve selected .NET Core here since I only need to target .NET Core 3.0 projects.</p>
<p>We can then use the Visual Studio tooling to add a Service Reference to our library.</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-service-reference-for-grpc-client.png" alt class="wp-image-1864" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-service-reference-for-grpc-client.png 597w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-service-reference-for-grpc-client-271x300.png 271w" sizes="(max-width: 597px) 100vw, 597px"></figure></div> <p>After selecting Service Reference from the Add menu, we are presented with a choice to add either an OpenAPI service reference or a gRPC service reference. We&#x2019;ll select the gRPC option.</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-new-grpc-service-reference-1024x233.png" alt class="wp-image-1865" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-new-grpc-service-reference-1024x233.png 1024w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-new-grpc-service-reference-300x68.png 300w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-new-grpc-service-reference-768x175.png 768w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-new-grpc-service-reference.png 1089w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div> <p>We can then supply the details for the service reference.&#xA0;</p>
<p>In this case, we can browse to an existing proto file on the filesystem. I chose the proto file from the root of my solution.</p>
<p>We have the option here to also reference a file from a URL.</p>
<p>Finally, we choose the classes we want generated. Our library will be for use by gRPC clients of our service, so we can select &#x201C;Client&#x201D;.</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/defining-a-service-reference-for-a-grpc-client.png" alt class="wp-image-1866" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/defining-a-service-reference-for-a-grpc-client.png 600w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/defining-a-service-reference-for-a-grpc-client-300x168.png 300w" sizes="(max-width: 600px) 100vw, 600px"></figure></div> <p>After the tooling completes the creation of the service reference, we can view the changes it made to the csproj file by double clicking on it.</p> <p>We can see that the tooling has included the selected protobuf file and requested the client code generation for this class library project.</p>
<p>It has also added the required gRPC and Google libraries needed to auto-generate the gRPC client code.</p>
<p>We now have a single library which will include the client code generated from the proto file.&#xA0;We can add a project reference to this client library from all client applications.</p>
<p>From a client we can right clicj on Dependencies and choose Add Reference:</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-reference-to-grpc-client-library.png" alt class="wp-image-1867" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-reference-to-grpc-client-library.png 506w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/add-reference-to-grpc-client-library-300x114.png 300w" sizes="(max-width: 506px) 100vw, 506px"></figure></div> <p>We then choose the newly created class library project which contains the code we want to reference.</p> <div class="wp-block-image"><figure class="aligncenter"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/select-grpc-client-library-project-reference.png" alt class="wp-image-1868" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/select-grpc-client-library-project-reference.png 781w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/select-grpc-client-library-project-reference-300x141.png 300w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/select-grpc-client-library-project-reference-768x362.png 768w" sizes="(max-width: 781px) 100vw, 781px"></figure></div> <p>Our client projects no longer need their own service reference to the proto file, nor do they need to reference all of the gRPC libraries manually. The auto-generated client code and libraries come from our project reference to the client library we have just created.</p>
<p>Here is an example of a simple application which acts as a gRPC client after updating it to use the shared class library project.</p> <p>It now has a single project reference to the shared class library and no specific mention of the proto file or gRPC libraries.</p>
<h2>Summary</h2>
<p>In this post, we&#x2019;ve seen how the Visual Studio tooling supports adding a service reference to a class library. We added a gRPC service reference and built the library which caused the auto-generated code to be created. We then referenced that shared library from all proejcts that need to act as a client of the gRPC service. This approach means that we reduce the number of direct references to a single proto file.&#xA0;</p>
<p>Whilst I won&#x2019;t cover it in this post, you can imagine how in a real-world scenario, we could go on to create a NuGet package for our client library and perhaps push it to an internal feed. We could even apply a package versioning strategy whenever the service contract changes.&#xA0;</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>