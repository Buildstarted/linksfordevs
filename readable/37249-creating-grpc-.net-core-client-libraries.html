<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating gRPC .NET Core Client Libraries -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Creating gRPC .NET Core Client Libraries</h1><div><div id="pryc-wp-acctp-original-content"><p>This week, <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/">.NET Core 3.0</a> and <a href="https://devblogs.microsoft.com/aspnet/asp-net-core-and-blazor-updates-in-net-core-3-0/" target="_blank" rel="noopener noreferrer">ASP.NET Core 3.0</a> launched and one of the headline features is the fact that we can now easily create gRPC server applications and clients to consume them.</p><p>I’ve been playing with gRPC locally for a little while now and really enjoy the experience. I’ve created a new talk called “<a href="https://www.stevejgordon.co.uk/speaking/beyond-http-in-net-core-3-0-with-grpc-talk">Beyond HTTP in ASP.NET Core with gRPC</a>” which covers the fundamentals of how to apply gRPC for client and server scenarios, including various streaming cases. As part of the talk I show some demos based on the code in my <a href="https://github.com/stevejgordon/gRPC-Demos" target="_blank" rel="noopener noreferrer">gRPC Demos repository on GitHub</a>.</p><p>Today, I’ve updated those demos ready for the next presentation of my talk at Techorama NL, after watching <a href="https://twitter.com/condrong" target="_blank" rel="noopener noreferrer">Glenn Condron</a> showing off some of the final 3.0 features and gRPC support in Visual Studio 2019 (16.3) during <a href="https://www.dotnetconf.net" target="_blank" rel="noopener noreferrer">dotNetConf 2019</a>.</p><p>In this post, I want to demonstrate how we can quickly and easily create a shared class library which includes the auto-generated gRPC client code. We’ll then reference that class library from our gRPC client applications.</p><p>This post is part of my <a href="https://www.stevejgordon.co.uk/grpc-with-asp-net-core-series">gRPC and ASP.NET Core</a> series.</p><h2>Quick gRPC Refresher</h2><p>gRPC is based on a service contract defined in a *.proto file. This uses <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener noreferrer">Protocol Buffers</a> as the Interface Definition Language for a gRPC service. Server code is then generated using the contract which we then implement. Similarly, client code can be auto-generated from the same proto file and consumed from client applications.</p><p>My early demos shared a single proto file across all projects in my solution. The proto file is included in a folder in the root of my repository called ‘Proto’.</p><p>To load this file, the server project references it in the csproj file as follows:</p><p>This code includes the weather.proto file from the root of the repository and tells the gRPC tooling to generate the server code from it.</p><p>Each client project then also referenced the proto file as follows:</p><p>In this case, code was auto-generated for a gRPC client of the service defined in the proto contract.</p><p>For a basic console application client, as used in my samples, the following packages were also referenced:</p><p>The package references and proto file had to be referenced in each client project, of which there were four in my repository. This leads to some repetition across each project.</p><h2>Building a Shared Library for gRPC Clients</h2><p>For demo purposes, the approach I’ve just described was fine. The proto file was accessible to all projects and referencing it directly was a simple solution.</p><p>In a more real-world scenario, though, a proto file may well live in a different repository than the client applications. In that case, a way to share the file within the build system would be useful. There are various ways one may look to achieve that at build time which we won’t cover in this post. Instead, I’d like to focus on the first stage of a quite elegant approach; creating a single shared library for use by all clients.</p><p>Inside Visual Studio, let’s create a new Class Library project:</p><p>I’ve selected .NET Core here since I only need to target .NET Core 3.0 projects.</p><p>We can then use the Visual Studio tooling to add a Service Reference to our library.</p><p>After selecting Service Reference from the Add menu, we are presented with a choice to add either an OpenAPI service reference or a gRPC service reference. We’ll select the gRPC option.</p><p>We can then supply the details for the service reference.&nbsp;</p><p>In this case, we can browse to an existing proto file on the filesystem. I chose the proto file from the root of my solution.</p><p>We have the option here to also reference a file from a URL.</p><p>Finally, we choose the classes we want generated. Our library will be for use by gRPC clients of our service, so we can select “Client”.</p><p>After the tooling completes the creation of the service reference, we can view the changes it made to the csproj file by double clicking on it.</p><p>We can see that the tooling has included the selected protobuf file and requested the client code generation for this class library project.</p><p>It has also added the required gRPC and Google libraries needed to auto-generate the gRPC client code.</p><p>We now have a single library which will include the client code generated from the proto file.&nbsp;We can add a project reference to this client library from all client applications.</p><p>From a client we can right clicj on Dependencies and choose Add Reference:</p><p>We then choose the newly created class library project which contains the code we want to reference.</p><p>Our client projects no longer need their own service reference to the proto file, nor do they need to reference all of the gRPC libraries manually. The auto-generated client code and libraries come from our project reference to the client library we have just created.</p><p>Here is an example of a simple application which acts as a gRPC client after updating it to use the shared class library project.</p><p>It now has a single project reference to the shared class library and no specific mention of the proto file or gRPC libraries.</p><h2>Summary</h2><p>In this post, we’ve seen how the Visual Studio tooling supports adding a service reference to a class library. We added a gRPC service reference and built the library which caused the auto-generated code to be created. We then referenced that shared library from all proejcts that need to act as a client of the gRPC service. This approach means that we reduce the number of direct references to a single proto file.&nbsp;</p><p>Whilst I won’t cover it in this post, you can imagine how in a real-world scenario, we could go on to create a NuGet package for our client library and perhaps push it to an internal feed. We could even apply a package versioning strategy whenever the service contract changes.&nbsp;</p><p>For more gRPC content, you can find all of my posts that are part of my <a href="https://www.stevejgordon.co.uk/grpc-with-asp-net-core-series">gRPC and ASP.NET Core</a> series.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>