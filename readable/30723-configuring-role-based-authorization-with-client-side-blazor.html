<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Configuring Role-based Authorization with client-side Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Configuring Role-based Authorization with client-side Blazor</h1><div><div class="post-content"><h2>Securing Your Blazor Apps (Part 3)</h2><hr><p>‌This is the third post in the series: Securing Your Blazor Apps. </p><p><strong>Part 1</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">Introduction to Authentication with server-side Blazor</a>‌<br>‌<strong>Part 2</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</a><br><strong>Part 3</strong> - Configuring Role-based Authorization with client-side Blazor (this post)<br><strong>Part 4</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-policy-based-authorization-with-blazor/">Configuring Policy-based Authorization with Blazor</a></p><hr><p>In parts 1 and 2 of this series I’ve shown how to create both server-side and client-side Blazor apps with authentication. In this post, I’m going to show you how to configure role-based authorization in a client-side Blazor application.</p><blockquote>All the code for this post is available on <a href="https://github.com/chrissainty/RoleBasedAuthWithBlazor">GitHub</a>.</blockquote><h2 id="what-is-role-based-authorization">What is role-based authorization?</h2><p>When it comes to authorization in ASP.NET Core we have two options, role-based and policy-based (there’s also claims-based but thats just a special type of policy-based). </p><p>Role-based authorization has been around for a while now and was originally introduced in ASP.NET (pre-Core). It’s a declarative way to restrict access to resources.</p><p>Developers can specify the name of the particular role a user must be a member of in order to access a certain resource. This is most commonly done using the <code>[Authorize]</code> attribute by specifying a role or list of roles - <code>[Authorize(Roles = “Admin”)]</code>. Users can be a member of a single role or multiple roles.</p><p>How roles are created and managed is dependent on the backing store used. As we’ve been using ASP.NET Core Identity in the series so far we’ll continue use it to manage and store our roles. </p><p>We’ll be building on top of the application we build in <a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">part 2</a> of this series. </p><h2 id="setting-up-roles-with-asp-net-core-identity">Setting up Roles with ASP.NET Core Identity</h2><p>We need to add the role specific services to our application. To do this, we need to update the code in the <code>ConfigureServices</code> method of the <code>Startup</code> class. </p><pre><code class="language-csharp">services.AddDefaultIdentity&lt;IdentityUser&gt;()
        .AddRoles&lt;IdentityRole&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
</code></pre><p>The <code>IdentityRole</code> type is the default role type provided by ASP.NET Core Identity. But you can provide a different type if it doesn’t fit your requirements.</p><p>Next, we’re going to seed our database with some roles - we’re going to add a <em>User </em>and <em>Admin</em> role. To do this we’re going to override the <code>OnModelCreating</code> method of the <code>ApplicationDbContext</code>.</p><pre><code class="language-csharp">public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions options) : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.Entity&lt;IdentityRole&gt;().HasData(new IdentityRole { Name = "User", NormalizedName = "USER", Id = Guid.NewGuid().ToString(), ConcurrencyStamp = Guid.NewGuid().ToString() });
        builder.Entity&lt;IdentityRole&gt;().HasData(new IdentityRole { Name = "Admin", NormalizedName = "ADMIN", Id = Guid.NewGuid().ToString(), ConcurrencyStamp = Guid.NewGuid().ToString() });
    }
}
</code></pre><p>Once this is done we need to generate a migration and then apply it to the database.</p><pre><code class="language-powershell">Add-Migration SeedRoles
Update-Database
</code></pre><h3 id="adding-users-to-roles">Adding users to roles</h3><p>Now we have some roles available, we’re going to update the action on the Accounts controller which creates new users. </p><p>We’re going to add all new users to the <em>User</em> role. Except if the new users email starts with <em>admin</em>. If it does, then we’re going to add them to <em>User</em> and <em>Admin</em> groups.</p><pre><code class="language-csharp">[HttpPost]
public async Task&lt;IActionResult&gt; Post([FromBody]RegisterModel model)
{
    var newUser = new IdentityUser { UserName = model.Email, Email = model.Email };

    var result = await _userManager.CreateAsync(newUser, model.Password);

    if (!result.Succeeded)
    {
        var errors = result.Errors.Select(x =&gt; x.Description);

        return BadRequest(new RegisterResult { Successful = false, Errors = errors });
    }

    // Add all new users to the User role
    await _userManager.AddToRoleAsync(newUser, "User");
    
    // Add new users whose email starts with 'admin' to the Admin role
    if (newUser.Email.StartsWith("admin"))
    {
        await _userManager.AddToRoleAsync(newUser, "Admin");
    }

    return Ok(new RegisterResult { Successful = true });
}
</code></pre><p>We’re now assigning users to roles at signup but we need to pass this information down to Blazor. To do this, we need to update the claims we are putting into our JSON Web Token.</p><h3 id="adding-roles-as-claims-to-the-jwt">Adding roles as claims to the JWT</h3><p>In the Login controller we’re going to update the <code>Login</code> method. Let’s remove the current line generating claims.</p><pre><code class="language-csharp">var claims = new[]
{
    new Claim(ClaimTypes.Name, login.Email)
};
</code></pre><p>And replace it with the following.</p><pre><code class="language-csharp">var user = await _signInManager.UserManager.FindByEmailAsync(login.Email);
var roles = await _signInManager.UserManager.GetRolesAsync(user);

var claims = new List&lt;Claim&gt;();

claims.Add(new Claim(ClaimTypes.Name, login.Email));

foreach (var role in roles)
{
    claims.Add(new Claim(ClaimTypes.Role, role));
}
</code></pre><p>We start off by getting the current user via the <code>UserManager</code>, which we then use to get their roles. The original <code>Name</code> claim is added with the users email, as before. If any roles are present we loop over them and each one is added as a <code>Role</code> claim.</p><p>It’s important to understand a quirk about role claims at this point. You may expect that if a user is in two roles then two role claims will be added to the JWT.</p><pre><code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role - "User"
http://schemas.microsoft.com/ws/2008/06/identity/claims/role - "Admin"
</code></pre><p>But that’s not what happens, what happens is that the two role claims get combined into an array.</p><pre><code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role - ["User", "Admin"]
</code></pre><p>This is important because on the client we are going to have to workout if we’re dealing with an array or a single value. If we’re dealing with an array then we will need to do some extra work to get the individual roles out. </p><p>We’re looking pretty good so far. We have new users being added to roles and once they have signed in we are returning those roles via the JWT. But how can we use roles inside of Blazor?</p><p>At this point in time there isn’t anything official to help us with roles, so we’ve got to deal with it manually. </p><p>In part 2 of the series we added the <code>ApiAuthenticationStateProvider</code> class, which has a method called <code>ParseClaimsFromJwt</code> that looks like this.</p><pre><code class="language-csharp">private IEnumerable&lt;Claim&gt; ParseClaimsFromJwt(string jwt)
{
    var claims = new List&lt;Claim&gt;();
    var payload = jwt.Split('.')[1];
    var jsonBytes = ParseBase64WithoutPadding(payload);
    var keyValuePairs = JsonSerializer.Parse&lt;Dictionary&lt;string, object&gt;&gt;(jsonBytes);

    keyValuePairs.TryGetValue(ClaimTypes.Role, out object roles);

    if (roles != null)
    {
        if (roles.ToString().Trim().StartsWith("["))
        {
            var parsedRoles = JsonSerializer.Parse&lt;string[]&gt;(roles.ToString());

            foreach (var parsedRole in parsedRoles)
            {
                claims.Add(new Claim(ClaimTypes.Role, parsedRole));
            }
        }
        else
        {
            claims.Add(new Claim(ClaimTypes.Role, roles.ToString()));
        }

        keyValuePairs.Remove(ClaimTypes.Role);
    }

    claims.AddRange(keyValuePairs.Select(kvp =&gt; new Claim(kvp.Key, kvp.Value.ToString())));

    return claims;
}

private byte[] ParseBase64WithoutPadding(string base64)
{
    switch (base64.Length % 4)
    {
        case 2: base64 += "=="; break;
        case 3: base64 += "="; break;
    }
    return Convert.FromBase64String(base64);
}
</code></pre><p>As we saw in part 2 it takes a JWT, decodes it, extracts the claims and returns them. But what we didn't cover was that I modified it to handle roles as a special case. </p><p>If a role claim is present then we check if the first character is a <code>[</code> indicating it’s a JSON array. If the character is found then <code>roles</code> is parsed again to extract the individual role names. We then loop through the role names and add each as a claim. If <code>roles</code> is not an array then its added as a single role claim.</p><p>I admit this is not the prettiest code and I’m sure it could be made much better but it serves our purpose for now.</p><p>We need to update the <code>MarkUserAsAuthenticated</code> method to call <code>ParseClaimsFromJwt</code>.</p><pre><code class="language-csharp">public void MarkUserAsAuthenticated(string token)
{
    var authenticatedUser = new ClaimsPrincipal(new ClaimsIdentity(ParseClaimsFromJwt(token), "jwt"));
    var authState = Task.FromResult(new AuthenticationState(authenticatedUser));
    
    NotifyAuthenticationStateChanged(authState);
}
</code></pre><p>Finally, we need to update the <code>Login</code> method on the <code>AuthService</code> to pass the token rather than the email when calling <code>MarkUserAsAuthenticated</code>.</p><pre><code class="language-csharp">public async Task&lt;LoginResult&gt; Login(LoginModel loginModel)
{
    var result = await _httpClient.PostJsonAsync&lt;LoginResult&gt;("api/Login", loginModel);

    if (result.Successful)
    {
        await _localStorage.SetItemAsync("authToken", result.Token);
        ((ApiAuthenticationStateProvider)_authenticationStateProvider).MarkUserAsAuthenticated(result.Token);
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", result.Token);

        return result;
    }

    return result;
}
</code></pre><p>We should now have the ability to apply role based authorization to our app. Let’s start at the API.</p><h3 id="applying-role-based-authorization-to-the-api">Applying role-based authorization to the API</h3><p>Let’s set the <code>WeatherForecast</code> action on the <code>SampleDataController</code> to only be accessible to authenticated users in the <em>Admin</em> role. We do this by using the <code>Authorize</code> attribute and specifying the roles that are allowed to access it. </p><pre><code class="language-csharp">[Authorize(Roles = "Admin")]
[HttpGet("[action]")]
public IEnumerable&lt;WeatherForecast&gt; WeatherForecasts()
{
    var rng = new Random();
    return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = rng.Next(-20, 55),
        Summary = Summaries[rng.Next(Summaries.Length)]
    });
}
</code></pre><p>If you create a new user in the <em>Admin</em> role and go to the Fetch Data page in the Blazor app you should still see everything load as expected. </p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.31.34.png" class="kg-image"></figure><p>But if you create a normal user and do the same, you should see the page stuck with a Loading… message. </p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.34.38.png" class="kg-image"></figure><p>Just for reference, as well as applying the <code>Authorize</code> attribute to actions you can also apply to it a controller. When applied at a controller level all actions on that controller are protected.</p><h3 id="applying-role-based-authorization-in-blazor">Applying role-based authorization in Blazor</h3><p>Blazor can also use the <code>Authorize</code> attribute to protect pages. This is achieved by using the <code>@attribute</code> directive to apply the <code>[Authorize]</code> attribute. You can also restrict access to parts of a page using the <code>AuthorizeView</code> component.</p><blockquote><strong>Warning</strong> - Any client-side checks can be bypassed as the user can potentially modify any of the code. This is true for any client-side technology, so make sure you <strong>always</strong> have checks on your API as well.</blockquote><p>As the forecast data is only available to Admin users let’s restrict access to that page using the <code>Authorize</code> attribute.</p><pre><code class="language-html">@page "/fetchdata"
@attribute [Authorize(Roles = "Admin")]
</code></pre><p>Now try logging into that page using your admin user. Everything should continue to work. Then try logging in as the standard user, you should now see a <em>Not authorized</em> message.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.37.28.png" class="kg-image"></figure><p>Let’s test out the <code>AuthorizeView</code> as well. On the home page (index.razor) add the following code.</p><pre><code class="language-html">&lt;AuthorizeView Roles="User"&gt;
    &lt;p&gt;You can only see this if you're in the User role.&lt;/p&gt;
&lt;/AuthorizeView&gt;

&lt;AuthorizeView Roles="Admin"&gt;
    &lt;p&gt;You can only see this if you're in the Admin role.&lt;/p&gt;
&lt;/AuthorizeView&gt;
</code></pre><p>Again, log in with your admin and user accounts. When you’re logged in as the admin user you should see both messages, as you’re in both roles.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.39.06.png" class="kg-image"></figure><p>When you’re logged in as a standard user you should only see the first message.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.38.19.png" class="kg-image"></figure><h2 id="summary">Summary</h2><p>In this post, we’ve looked at what role-based authorization is and how to use ASP.NET Core Identity to setup and mange roles. We then moved on to how to pass roles as claims using JSON Web Tokens from the API to the client. Then we worked through processing those role claims in Blazor and finally implemented some roles based authorization checks on both the API and Blazor.</p><p>I just want to reiterate that you cannot just rely on client-side authentication or authorization, the client can never be trusted. You must always perform authentication and authorization checks on the server as well.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>