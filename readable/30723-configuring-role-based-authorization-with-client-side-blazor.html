<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Configuring Role-based Authorization with client-side Blazor -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Configuring Role-based Authorization with client-side Blazor</h1>
    <div class="post-content"> <p>&#x200C;This is the third post in the series: Securing Your Blazor Apps. </p><p>Part 1 - <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">Introduction to Authentication with server-side Blazor</a>&#x200C;<br>&#x200C;Part 2 - <a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</a><br>Part 3 - Configuring Role-based Authorization with client-side Blazor (this post)</p><p>In parts 1 and 2 of this series I&#x2019;ve shown how to create both server-side and client-side Blazor apps with authentication. In this post, I&#x2019;m going to show you how to configure role-based authorization in a client-side Blazor application.</p><p>When it comes to authorization in ASP.NET Core we have two options, role-based and policy-based (there&#x2019;s also claims-based but thats just a special type of policy-based). </p><p>Role-based authorization has been around for a while now and was originally introduced in ASP.NET (pre-Core). It&#x2019;s a declarative way to restrict access to resources.</p><p>Developers can specify the name of the particular role a user must be a member of in order to access a certain resource. This is most commonly done using the <code>[Authorize]</code> attribute by specifying a role or list of roles - <code>[Authorize(Roles = &#x201C;Admin&#x201D;)]</code>. Users can be a member of a single role or multiple roles.</p><p>How roles are created and managed is dependent on the backing store used. As we&#x2019;ve been using ASP.NET Core Identity in the series so far we&#x2019;ll continue use it to manage and store our roles. </p><p>We&#x2019;ll be building on top of the application we build in <a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">part 2</a> of this series. </p><h2 id="setting-up-roles-with-asp-net-core-identity">Setting up Roles with ASP.NET Core Identity</h2><p>We need to add the role specific services to our application. To do this, we need to update the code in the <code>ConfigureServices</code> method of the <code>Startup</code> class. </p><pre><code class="language-csharp">services.AddDefaultIdentity&lt;IdentityUser&gt;()
        .AddRoles&lt;IdentityRole&gt;()
        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
</code></pre>
<p>The <code>IdentityRole</code> type is the default role type provided by ASP.NET Core Identity. But you can provide a different type if it doesn&#x2019;t fit your requirements.</p><p>Next, we&#x2019;re going to seed our database with some roles - we&#x2019;re going to add a <em>User </em>and <em>Admin</em> role. To do this we&#x2019;re going to override the <code>OnModelCreating</code> method of the <code>ApplicationDbContext</code>.</p><pre><code class="language-csharp">public class ApplicationDbContext : IdentityDbContext
{
    public ApplicationDbContext(DbContextOptions options) : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.Entity&lt;IdentityRole&gt;().HasData(new IdentityRole { Name = &quot;User&quot;, NormalizedName = &quot;USER&quot;, Id = Guid.NewGuid().ToString(), ConcurrencyStamp = Guid.NewGuid().ToString() });
        builder.Entity&lt;IdentityRole&gt;().HasData(new IdentityRole { Name = &quot;Admin&quot;, NormalizedName = &quot;ADMIN&quot;, Id = Guid.NewGuid().ToString(), ConcurrencyStamp = Guid.NewGuid().ToString() });
    }
}
</code></pre>
<p>Once this is done we need to generate a migration and then apply it to the database.</p><pre><code class="language-powershell">Add-Migration SeedRoles
Update-Database
</code></pre>
<h3 id="adding-users-to-roles">Adding users to roles</h3><p>Now we have some roles available, we&#x2019;re going to update the action on the Accounts controller which creates new users. </p><p>We&#x2019;re going to add all new users to the <em>User</em> role. Except if the new users email starts with <em>admin</em>. If it does, then we&#x2019;re going to add them to <em>User</em> and <em>Admin</em> groups.</p><pre><code class="language-csharp">[HttpPost]
public async Task&lt;IActionResult&gt; Post([FromBody]RegisterModel model)
{
    var newUser = new IdentityUser { UserName = model.Email, Email = model.Email };

    var result = await _userManager.CreateAsync(newUser, model.Password);

    if (!result.Succeeded)
    {
        var errors = result.Errors.Select(x =&gt; x.Description);

        return BadRequest(new RegisterResult { Successful = false, Errors = errors });
    }

    // Add all new users to the User role
    await _userManager.AddToRoleAsync(newUser, &quot;User&quot;);
    
    // Add new users whose email starts with &apos;admin&apos; to the Admin role
    if (newUser.Email.StartsWith(&quot;admin&quot;))
    {
        await _userManager.AddToRoleAsync(newUser, &quot;Admin&quot;);
    }

    return Ok(new RegisterResult { Successful = true });
}
</code></pre>
<p>We&#x2019;re now assigning users to roles at signup but we need to pass this information down to Blazor. To do this, we need to update the claims we are putting into our JSON Web Token.</p><h3 id="adding-roles-as-claims-to-the-jwt">Adding roles as claims to the JWT</h3><p>In the Login controller we&#x2019;re going to update the <code>Login</code> method. Let&#x2019;s remove the current line generating claims.</p><pre><code class="language-csharp">var claims = new[]
{
    new Claim(ClaimTypes.Name, login.Email)
};
</code></pre>
<p>And replace it with the following.</p><pre><code class="language-csharp">var user = await _signInManager.UserManager.FindByEmailAsync(login.Email);
var roles = await _signInManager.UserManager.GetRolesAsync(user);

var claims = new List&lt;Claim&gt;();

claims.Add(new Claim(ClaimTypes.Name, login.Email));

foreach (var role in roles)
{
    claims.Add(new Claim(ClaimTypes.Role, role));
}
</code></pre>
<p>We start off by getting the current user via the <code>UserManager</code>, which we then use to get their roles. The original <code>Name</code> claim is added with the users email, as before. If any roles are present we loop over them and each one is added as a <code>Role</code> claim.</p><p>It&#x2019;s important to understand a quirk about role claims at this point. You may expect that if a user is in two roles then two role claims will be added to the JWT.</p><pre><code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role - &quot;User&quot;
http://schemas.microsoft.com/ws/2008/06/identity/claims/role - &quot;Admin&quot;
</code></pre>
<p>But that&#x2019;s not what happens, what happens is that the two role claims get combined into an array.</p><pre><code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role - [&quot;User&quot;, &quot;Admin&quot;]
</code></pre>
<p>This is an important because on the client we are going to have to workout if we&#x2019;re dealing with an array or a single value. If we&#x2019;re dealing with an array then we will need to do some extra work to get the individual roles out. </p><p>We&#x2019;re looking pretty good so far. We have new users being added to roles and once they have signed in we are returning those roles via the JWT. But how can we use roles inside of Blazor?</p><p>At this point in time there isn&#x2019;t anything official to help us with roles, so we&#x2019;ve got to deal with it manually. </p><p>In the <code>ApiAuthenticationStateProvider</code> class we&#x2019;re going to add a couple of methods. </p><p>Full disclosure - these methods are stolen from <a href="https://github.com/SteveSandersonMS/presentation-2019-06-NDCOslo/tree/master/demos/MissionControl">Steve Sandersons Mission Control</a> demo app, which he showed at <a href="https://www.youtube.com/watch?v=uW-Kk7Qpv5U">NDC Oslo 2019</a>. </p><p>Although, I have made a few modifications.</p><pre><code class="language-csharp">private IEnumerable&lt;Claim&gt; ParseClaimsFromJwt(string jwt)
{
    var claims = new List&lt;Claim&gt;();
    var payload = jwt.Split(&apos;.&apos;)[1];
    var jsonBytes = ParseBase64WithoutPadding(payload);
    var keyValuePairs = JsonSerializer.Parse&lt;Dictionary&lt;string, object&gt;&gt;(jsonBytes);

    keyValuePairs.TryGetValue(ClaimTypes.Role, out object roles);

    if (roles != null)
    {
        if (roles.ToString().Trim().StartsWith(&quot;[&quot;))
        {
            var parsedRoles = JsonSerializer.Parse&lt;string[]&gt;(roles.ToString());

            foreach (var parsedRole in parsedRoles)
            {
                claims.Add(new Claim(ClaimTypes.Role, parsedRole));
            }
        }
        else
        {
            claims.Add(new Claim(ClaimTypes.Role, roles.ToString()));
        }

        keyValuePairs.Remove(ClaimTypes.Role);
    }

    claims.AddRange(keyValuePairs.Select(kvp =&gt; new Claim(kvp.Key, kvp.Value.ToString())));

    return claims;
}

private byte[] ParseBase64WithoutPadding(string base64)
{
    switch (base64.Length % 4)
    {
        case 2: base64 += &quot;==&quot;; break;
        case 3: base64 += &quot;=&quot;; break;
    }
    return Convert.FromBase64String(base64);
}
</code></pre>
<p><code>ParseClaimsFromJwt</code> is where all the magic happens. Originally it took the JWT, decoded it and extracted all of the claims, then returned them to the caller. But I have modified it to handle roles as a special case. </p><p>If a role claim is present then we check if the first character is a <code>[</code> indicating it&#x2019;s a JSON array. If the character is found then <code>roles</code> is parsed again to extract the individual role names. We then loop through the role names and add each as a claim. If <code>roles</code> is not an array then its added as a single role claim.</p><p>I admit this is not the prettiest code and I&#x2019;m sure it could be made much better but it serves our purpose for now.</p><p>We just need to call the <code>ParseClaimsFromJwt</code> method from both the <code>GetAuthenticationStateAsync</code> method and the <code>MarkUserAsAuthenticated</code> method.</p><pre><code class="language-csharp">public override async Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync()
{
    // Code omitted for brevity
    
    var identity = userInfo.IsAuthenticated ? new ClaimsIdentity(ParseClaimsFromJwt(savedToken), &quot;jwt&quot;) : new ClaimsIdentity();

    return new AuthenticationState(new ClaimsPrincipal(identity));
}
</code></pre>
<pre><code class="language-csharp">public void MarkUserAsAuthenticated(string token)
{
    var authenticatedUser = new ClaimsPrincipal(new ClaimsIdentity(ParseClaimsFromJwt(token), &quot;jwt&quot;));
    var authState = Task.FromResult(new AuthenticationState(authenticatedUser));
    
    NotifyAuthenticationStateChanged(authState);
}
</code></pre>
<p>We should now have the ability to apply role based authorization to our app. Let&#x2019;s start at the API.</p><p>Let&#x2019;s set the <code>WeatherForecast</code> action on the <code>SampleDataController</code> to only be accessible to authenticated users in the <em>Admin</em> role. We do this by using the <code>Authorize</code> attribute and specifying the roles that are allowed to access it. </p><pre><code class="language-csharp">[Authorize(Roles = &quot;Admin&quot;)]
[HttpGet(&quot;[action]&quot;)]
public IEnumerable&lt;WeatherForecast&gt; WeatherForecasts()
{
    var rng = new Random();
    return Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast
    {
        Date = DateTime.Now.AddDays(index),
        TemperatureC = rng.Next(-20, 55),
        Summary = Summaries[rng.Next(Summaries.Length)]
    });
}
</code></pre>
<p>If you create a new user in the <em>Admin</em> role and go to the Fetch Data page in the Blazor app you should still see everything load as expected. </p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.31.34.png" class="kg-image"></figure><p>But if you create a normal user and do the same, you should see the page stuck with a Loading&#x2026; message. </p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.34.38.png" class="kg-image"></figure><p>Just for reference, as well as applying the <code>Authorize</code> attribute to actions you can also apply to it a controller. When applied at a controller level all actions on that controller are protected.</p><p>Blazor can also use the <code>Authorize</code> attribute to protect pages. This is achieved by using the <code>@attribute</code> directive to apply the <code>[Authorize]</code> attribute. You can also restrict access to parts of a page using the <code>AuthorizeView</code> component.</p><blockquote><strong>Warning</strong> - Any client-side checks can be bypassed as the user can potentially modify any of the code. This is true for any client-side technology, so make sure you <strong>always</strong> have checks on your API as well.</blockquote><p>As the forecast data is only available to Admin users let&#x2019;s restrict access to that page using the <code>Authorize</code> attribute.</p><pre><code class="language-html">@page &quot;/fetchdata&quot;
@attribute [Authorize(Roles = &quot;Admin&quot;)]
</code></pre>
<p>Now try logging into that page using your admin user. Everything should continue to work. Then try logging in as the standard user, you should now see a <em>Not authorized</em> message.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.37.28.png" class="kg-image"></figure><p>Let&#x2019;s test out the <code>AuthorizeView</code> as well. On the home page (index.razor) add the following code.</p><pre><code class="language-html">&lt;AuthorizeView Roles=&quot;User&quot;&gt;
    &lt;p&gt;You can only see this if you&apos;re in the User role.&lt;/p&gt;
&lt;/AuthorizeView&gt;

&lt;AuthorizeView Roles=&quot;Admin&quot;&gt;
    &lt;p&gt;You can only see this if you&apos;re in the Admin role.&lt;/p&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p>Again, log in with your admin and user accounts. When you&#x2019;re logged in as the admin user you should see both messages, as you&#x2019;re in both roles.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.39.06.png" class="kg-image"></figure><p>When you&#x2019;re logged in as a standard user you should only see the first message.</p><figure class="kg-card kg-image-card"><img src="https://chrissainty.com/content/images/2019/07/Screenshot-2019-07-22-at-18.38.19.png" class="kg-image"></figure><p>In this post, we&#x2019;ve looked at what role-based authorization is and how to use ASP.NET Core Identity to setup and mange roles. We then moved on to how to pass roles as claims using JSON Web Tokens from the API to the client. Then we worked through processing those role claims in Blazor and finally implemented some roles based authorization checks on both the API and Blazor.</p><p>I just want to reiterate that you cannot just rely on client-side authentication or authorization, the client can never be trusted. You must always perform authentication and authorization checks on the server as well.</p> <div class="post-tags"> Tagged in: <a href="/blazor-client-side/">Blazor (client-side)</a> | <a href="/authorization/">Authorization</a> | <a href="/blazor/">Blazor</a> | <a href="/aspnet-core/">ASP.NET Core</a> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>