<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What&#x27;s in a Linux executable? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="What&#x27;s in a Linux executable? - linksfor.dev(s)"/>
    <meta property="og:description" content="Executables have been fascinating to me ever since I discovered, as a kid, that they were just files. If you renamed a .exe to something else, you could open it in notepad! And if you renamed something else to a .exe, you&#x27;d get a neat error dialog.&#xA;Clearly, something was different about these files. Seen from notepad, they were mostly gibberish, but there had to be order in that chaos. 12-year-old me knew that, although he didn&#x27;t quite know how or where to dig to make sense of it all."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/blog/2020/whats-in-a-linux-executable/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - What&#x27;s in a Linux executable?</title>
<div class="readable">
        <h1>What&#x27;s in a Linux executable?</h1>
            <div>Reading time: 33-42 minutes</div>
        <div>Posted here: 25 Jun 2020</div>
        <p><a href="https://fasterthanli.me/blog/2020/whats-in-a-linux-executable/">https://fasterthanli.me/blog/2020/whats-in-a-linux-executable/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          






          
    <p>Executables have been fascinating to me ever since I discovered, as a kid,
that they were just files. If you renamed a <code>.exe</code> to something else, you
could open it in notepad! And if you renamed something else to a <code>.exe</code>,
you'd get a neat error dialog.</p>
<p>Clearly, something was different about these files. Seen from notepad, they
were mostly gibberish, but there <em>had</em> to be order in that chaos. 12-year-old
me knew that, although he didn't quite know how or where to dig to make sense
of it all.</p>
<p>So, this series is dedicated to my past self. In it we'll attempt to
understand how Linux executables are organized, how they are executed, and
how to make a program that takes an executable fresh off the linker and
compresses it - just because we can.</p>
<p>Since the last big series, <a href="https://fasterthanli.me/blog/2019/making-our-own-ping/">Making our own ping</a>,
was all about Windows, this one will be focused on 64-bit Linux.</p>
<h2 id="but-first-let-me-write-assembly">But first, let me write assembly</h2>
<p>Throughout the course of this series, we're definitely going to want to emit
our own ELF files, but - just like we did when tackling Ethernet, IPv4 and
ICMP, we're first going to get our hands on a well-formed, fully-working Linux
executable, and then poke it with various sticks.</p>
<div>
    
<p>ELF stands for <strong>Executable and Linkable Format</strong>. It was first published
in 1983, as part of <a href="https://en.wikipedia.org/wiki/UNIX_System_V#SVR4">SysV 4</a>,
and it's still in use on Linux today, although new sections have been added.</p>
</div>
<p>I had to go back to <a href="https://fasterthanli.me/blog/2019/reading-files-the-hard-way-2/">Reading files the hard way - Part
2</a> to get a quick refresher on
nasm - the Netwide Assembler - so I wouldn't blame you if you had to, too.</p>
<p>In any case, here's the short version: here's some code to print “hi there”
to the standard output, followed by a newline:</p>
<pre><code>

        <span>global</span> _start

        <span>section</span> .text
<span>
_start:</span> <span>mov</span> <span>rdi</span>, <span>1</span>      
        <span>mov</span> <span>rsi</span>, msg
        <span>mov</span> <span>rdx</span>, <span>9</span>      
        <span>mov</span> <span>rax</span>, <span>1</span>      
        <span>syscall</span>

        <span>xor</span> <span>rdi</span>, <span>rdi</span>    
        <span>mov</span> <span>rax</span>, <span>60</span>     
        <span>syscall</span>
        
        <span>section</span> .data
<span>
msg:</span>    <span>db</span> <span>"hi there"</span>, <span>10</span>
</code></pre>
<p>As a reminder, <a href="https://filippo.io/linux-syscall-table/">Filippo's Searchable Linux Syscall
Table</a> is quite excellent.</p>
<p>We can build and link it quite easily:</p>
<pre><code><span>$</span><span> nasm -f elf64 hello.asm</span>
<span>$</span><span> ld hello.o -o hello</span>
<span>$</span><span> file hello</span>
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
<span>$</span><span> ./hello</span>
hi there
</code></pre>
<p>Good!</p>
<p>Now, our executable is about 8.68 KiB as-is. If we use <code>gzip -9</code> on it, we
can easily get that down to 372 B, so I'm kinda curious to see what's in
there, to be quite honest.</p>
<div>
    
<p>This is a /genuine/ curious, not a “oh god why” curious.</p>
<p>This series is <em>not</em> about lamenting the good old days when everything used
to fit on a floppy. It's not about how modern software is bloated and slow.
It's not about to go into a tangent about developers being “lazy” and it
“not being that hard if only someone tried”.</p>
<p>We are not developing something <em>practical</em> here, we are picking a challenge
purely for the sake of learning stuff.</p>
<p>If you need a chunky dose of nostalgia instead, feel free to check out <em>gestures
vaguely at almost all of the internet</em>.</p>
</div>
<p>If we look at an hex dump of <code>hello</code>, we see the <code>ELF</code> string early on, followed
by a bunch of binary data:</p>
<pre><code><span>$</span><span> xxd &lt; hello | head</span>
00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............
00000010: 0200 3e00 0100 0000 0010 4000 0000 0000  ..&gt;.......@.....
00000020: 4000 0000 0000 0000 3821 0000 0000 0000  @.......8!......
00000030: 0000 0000 4000 3800 0300 4000 0600 0500  ....@.8...@.....
00000040: 0100 0000 0400 0000 0000 0000 0000 0000  ................
00000050: 0000 4000 0000 0000 0000 4000 0000 0000  ..@.......@.....
00000060: e800 0000 0000 0000 e800 0000 0000 0000  ................
00000070: 0010 0000 0000 0000 0100 0000 0500 0000  ................
00000080: 0010 0000 0000 0000 0010 4000 0000 0000  ..........@.....
00000090: 0010 4000 0000 0000 2500 0000 0000 0000  ..@.....%.......
</code></pre>
<p>But we can pretty easily see that most of the file is made out of
null (zero) bytes:</p>
<pre><code><span>$</span><span> xxd &lt; hello | tail -60 | head</span>
00001f00: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f10: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f20: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f30: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f40: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f50: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f60: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f70: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f80: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f90: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>
<p>We can also find a section that contains a bunch of names, maybe they
have some sort of meaning?</p>
<pre><code><span>$</span><span> xxd &lt; hello | tail -32 | head</span>
000020c0: 0920 4000 0000 0000 0000 0000 0000 0000  . @.............
000020d0: 2b00 0000 1000 0200 1020 4000 0000 0000  +........ @.....
000020e0: 0000 0000 0000 0000 0068 656c 6c6f 2d6f  .........hello-o
000020f0: 7269 6769 6e61 6c2e 6173 6d00 6d73 6700  riginal.asm.msg.
00002100: 5f5f 6273 735f 7374 6172 7400 5f65 6461  __bss_start._eda
00002110: 7461 005f 656e 6400 002e 7379 6d74 6162  ta._end...symtab
00002120: 002e 7374 7274 6162 002e 7368 7374 7274  ..strtab..shstrt
00002130: 6162 002e 7465 7874 002e 6461 7461 0000  ab..text..data..
00002140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00002150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>
<p>Now, there's a whole <em>host</em> of tools that would let us poke this ELF file from
the comfort of a terminal. Ohh yes. A slew of them. Tools and tools as far as
the eye can see. But we shan't be using them today. Not today, matey.</p>
<p>Today, we parse things ourselves. Using the <code>nom</code> crate, which we used in the
<a href="https://fasterthanli.me/blog/2019/making-our-own-ping/">Making our own ping</a> series, and armed with
which I would be willing to parse darn near anything - <a href="https://github.com/gco/xee/blob/4fa3a6d609dd72b8493e52a68f316f7a02903276/XeePhotoshopLoader.m#L108-L136">even PSD</a>.</p>
<p>For that, though, we'll need a few pointers. The <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia page for
ELF</a> is not half
bad, but it's not the greatest overview - in part because it bothers itself
with 32-bit ELF, which we will, for the entire length of this series,
conveniently forget.</p>

<p>So, here's what a 64-bit ELF file header looks like:</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/elf64-header.png" alt=""></p>
<p>Now, I realize that's a lot to take in - a lot of this stuff doesn't make sense yet.</p>
<p>Before we start writing any code, let's do some basic exploration by hand. According
to that diagram, at offset <code>62</code> in the file, there's an “index of entry with section names”.
For our <code>hello</code> executable, that's…</p>
<pre><code><span>$</span><span> </span>
<span>$</span><span> xxd -s 62 -l 2 ./hello</span>
0000003e: 0500                                     ..
</code></pre>
<p>The bytes <code>05</code> and <code>00</code> - now, we're dealing with a little-endian file, so that means <code>0x0005</code>,
which is just <code>5</code>. So the <em>fifth</em> section header in the table contains section names.</p>
<p>At this point we have no idea what sections are, but I think it's safe to say
that the file is divided into them and that their beginning and size is stored
in those section headers.</p>
<p>The section header table starts at…</p>
<pre><code><span>$</span><span> </span>
<span>$</span><span> xxd -s 40 -l 8 -g 8 -e ./hello</span>
00000028: 0000000000002140
</code></pre>
<p><code>0x2140</code>, which is…</p>
<pre><code><span>$</span><span> <span>echo</span> $((0x2140))</span>
8512
</code></pre>
<div>
    
<p>Even though <code>xxd</code> itself doesn't support hexadecimal notation, we can
perform <a href="https://www.tldp.org/LDP/abs/html/arithexp.html">shell arithmetic</a> with <code>$((expr))</code>!</p>
</div>
<p>According to the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia page on ELF</a>,
every section header contains the offset in the file where the section data is stored… at offset 0x18!</p>
<p>Every section header has length 0x40, and we want the fifth one, so…</p>
<pre><code><span>$</span><span> xxd -s $((0x2140 + 0x40 * 5 + 0x18)) -l 8 -g 8 -e ./hello</span>
00002298: 0000000000002118                   .!......
</code></pre>
<p>That means that the data of the section that contains section names should be at <code>0x2118</code>. Let's check it out:</p>
<pre><code><span>$</span><span> xxd -s $((0x2118)) ./hello | head -4</span>
00002118: 002e 7379 6d74 6162 002e 7374 7274 6162  ..symtab..strtab
00002128: 002e 7368 7374 7274 6162 002e 7465 7874  ..shstrtab..text
00002138: 002e 6461 7461 0000 0000 0000 0000 0000  ..data..........
00002148: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</code></pre>
<p>…those are the strings we noticed earlier, when randomly paging through
the dump!</p>
<p>Well, that's one mystery solved. Onto the next hundred or so.</p>
<p>It was fun looking through the file by hand, and we learned to use <code>xxd</code> to
do exactly that (which might definitely come in handy in the nuclear winter
if a graphical hex viewer/editor isn't available), but we probably want
to start writing an actual parser now.</p>
<p>We'll name our library <code>delf</code>, for <code>demystify ELF</code></p>
<pre><code><span>$</span><span> cargo new --lib delf</span>
<span>$</span><span> <span>cd</span> delf</span>
<span>$</span><span> cargo add nom</span>
      Adding nom v5.1.0 to dependencies
</code></pre>
<p>For convenience, we'll add a parse module with an <code>Input</code> and <code>Result</code> type:</p>
<pre><code>

<span>mod</span> parse;
</code></pre>
<pre><code>
<span>pub</span> <span><span>type</span> <span>Input</span></span>&lt;<span>'a</span>&gt; = &amp;<span>'a</span> [<span>u8</span>];
<span>pub</span> <span><span>type</span> <span>Result</span></span>&lt;<span>'a</span>, O&gt; = nom::IResult&lt;Input&lt;<span>'a</span>&gt;, O, nom::error::VerboseError&lt;Input&lt;<span>'a</span>&gt;&gt;&gt;;
</code></pre>
<p>We can parse the first 16 bytes pretty trivially:</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/magic-through-padding.png" alt=""></p>
<p>Like I said earlier, we're not going to bother with big-endian ELFs, or 32-bit ELFs, so we
can hardcode a few values. Let's get started!</p>
<pre><code>

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>File</span></span> {
    
}

<span>impl</span> File {
    <span>const</span> MAGIC: &amp;<span>'static</span> [<span>u8</span>] = &amp;[<span>0x7f</span>, <span>0x45</span>, <span>0x4c</span>, <span>0x46</span>];

    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{
            bytes::complete::{tag, take},
            error::context,
            sequence::tuple,
        };
        <span>let</span> (i, _) = tuple((
            
            context(<span>"Magic"</span>, tag(Self::MAGIC)),
            context(<span>"Class"</span>, tag(&amp;[<span>0x2</span>])),
            context(<span>"Endianness"</span>, tag(&amp;[<span>0x1</span>])),
            context(<span>"Version"</span>, tag(&amp;[<span>0x1</span>])),
            context(<span>"OS ABI"</span>, tag(&amp;[<span>0x0</span>])),
            
            context(<span>"Padding"</span>, take(<span>8_usize</span>)),
        ))(i)?;
        <span>Ok</span>((i, <span>Self</span> {}))
    }
}
</code></pre>
<p>That looks reasonable. Let's make another crate to test the <code>delf</code> crate.
We'll name it “elk”, for “Executable &amp; Linker Kit”</p>
<pre><code><span>$</span><span> cargo new --bin elk</span>
<span>$</span><span> cargo add ../delf</span>
      Adding delf (unknown version) to dependencies
</code></pre>
<pre><code>

<span>use</span> std::{env, error::Error, fs};

<span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> Error&gt;&gt; {
    <span>let</span> input_path = env::args().skip(<span>1</span>).next().expect(<span>"usage: elk FILE"</span>);
    <span>let</span> input = fs::read(&amp;input_path)?;
    delf::File::parse(&amp;input[..]).map_err(|e| <span>format!</span>(<span>"{:?}"</span>, e))?;
    <span>println!</span>(<span>"input is a supported ELF file!"</span>);

    <span>Ok</span>(())
}
</code></pre>
<p>And take it for a spin:</p>
<pre><code><span>$</span><span> ./target/debug/elk /bin/<span>true</span></span>
input is a supported ELF file!
</code></pre>
<p>Good! Good start.</p>
<p>Now we'll have to deal with some enums</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/type-and-machine.png" alt=""></p>
<p>Let's start with the type - declaring an enum in Rust is simple enough.
We'll want to derive some useful traits - <code>Debug</code> for printing, <code>Clone</code> and
<code>Copy</code> so it has copy semantics (instead of transmitting ownership),
<code>PartialEq</code> and <code>Eq</code> to compare <code>Type</code> values for equality.</p>
<pre><code>

<span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span>pub</span> <span><span>enum</span> <span>Type</span></span> {
    <span>None</span>,
    Rel,
    Exec,
    Dyn,
    Core,
}
</code></pre>
<p>When reading our ELF file though, we won't get a <code>Type</code> - we'll get a <code>u16</code>.
And similarly, when we write out an ELF file, we'll also need a <code>u16</code>.</p>
<p>We could do the mapping ourselves, like so:</p>
<pre><code>

<span>impl</span> Type {
    to_u16(&amp;<span>self</span>) -&gt; <span>u16</span> {
        <span>match</span> <span>self</span> {
            Self::<span>None</span> =&gt; <span>0</span>,
            Self::Rel =&gt; <span>1</span>,
            Self::Exec =&gt; <span>2</span>,
            Self::Dyn =&gt; <span>3</span>,
            
        }
    }
}
</code></pre>
<p>Or we could just set the <em>representation</em> of the <code>Type</code> enum to <code>u16</code> - and
then we'd get that for free:</p>
<pre><code>

<span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span>#[repr(u16)]</span>
<span>pub</span> <span><span>enum</span> <span>Type</span></span> {
    <span>None</span> = <span>0x0</span>,
    Rel = <span>0x1</span>,
    Exec = <span>0x2</span>,
    Dyn = <span>0x3</span>,
    Core = <span>0x4</span>,
}
</code></pre>
<p>Now, we can use the <code>as</code> operator to cast our <code>Type</code> to <code>u16</code> - let's
write a quick test to validate our assumptions:</p>
<pre><code>

<span>#[cfg(test)]</span>
<span>mod</span> tests {
    <span>#[test]</span>
    <span><span>fn</span> <span>type_to_u16</span></span>() {
        <span>assert_eq!</span>(super::Type::Dyn <span>as</span> <span>u16</span>, <span>0x3</span>);
    }
}
</code></pre>
<p>And run it:</p>
<pre><code><span>$</span><span> </span>
<span>$</span><span> cargo t --lib</span>
    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running target/debug/deps/delf-d6fdd5529c793a0b

running 1 test
test tests::type_to_u16 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Splendid! Now there's the small matter of going the <em>other way</em> - converting
an <code>u16</code> to a <code>Type</code>. The problem here, of course, is that not all <code>u16</code> values
are valid <code>Type</code> values.</p>
<p>In fact, had we written <code>from_u16</code> ourselves, we would have had to deal
with this problem head-on:</p>
<pre><code>

<span>impl</span> Type {
    <span>pub</span> <span><span>fn</span> <span>from_u16</span></span>(x: <span>u16</span>) -&gt; <span>Self</span> {
        <span>match</span> x {
            <span>0</span> =&gt; Self::<span>None</span>,
            <span>1</span> =&gt; Self::Rel,
            <span>2</span> =&gt; Self::Exec,
            <span>3</span> =&gt; Self::Dyn,
            <span>4</span> =&gt; Self::Core,
        }
    }
}
</code></pre>
<p>The code above fails to compile, with reason:</p>
<pre><code><span>#</span><span> b = build, -q = quiet</span>
<span>$</span><span> cargo b -q</span>
error[E0004]: non-exhaustive patterns: `5u16..=std::u16::MAX` not covered
<span>  --&gt;</span><span> src/lib.rs:17:15</span>
   |
17 |         match x {
   |               ^ pattern `5u16..=std::u16::MAX` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
</code></pre>
<p>To deal with that possibility, we could return an <code>Option&lt;Self&gt;</code> instead:</p>
<pre><code>

<span>impl</span> Type {
    <span>pub</span> <span><span>fn</span> <span>from_u16</span></span>(x: <span>u16</span>) -&gt; <span>Option</span>&lt;<span>Self</span>&gt; {
        <span>match</span> x {
            <span>0</span> =&gt; <span>Some</span>(Self::<span>None</span>),
            <span>1</span> =&gt; <span>Some</span>(Self::Rel),
            <span>2</span> =&gt; <span>Some</span>(Self::Exec),
            <span>3</span> =&gt; <span>Some</span>(Self::Dyn),
            <span>4</span> =&gt; <span>Some</span>(Self::Core),
            _ =&gt; <span>None</span>,
        }
    }
}

<span>#[cfg(test)]</span>
<span>mod</span> tests {
    

    <span>#[test]</span>
    <span><span>fn</span> <span>type_from_u16</span></span>() {
        <span>assert_eq!</span>(super::Type::from_u16(<span>0x3</span>), <span>Some</span>(super::Type::Dyn));
        <span>assert_eq!</span>(super::Type::from_u16(<span>0xf00d</span>), <span>None</span>);
    }
}
</code></pre>
<p>And that works!</p>
<pre><code><span>$</span><span> cargo t --lib</span>
    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running target/debug/deps/delf-d6fdd5529c793a0b

running 2 tests
test tests::type_to_u16 ... ok
test tests::type_from_u16 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>…but it's kinda tedious. We already specify a <code>Type &lt;-&gt; u16</code> mapping, when we
first define the enum. Why should we <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">repeat ourselves</a>?</p>
<p>As it turns out.. <em>eyes light up in wonder</em> there is a crate for that!</p>
<p><a href="https://crates.io/crates/derive-try-from-primitive">derive-try-from-primitive</a>
solves exactly that problem. Let's give it a shot:</p>
<pre><code><span>$</span><span> cargo add derive-try-from-primitive</span>
      Adding derive-try-from-primitive v0.1.0 to dependencies
</code></pre>
<pre><code>

<span>#[derive(Debug, Clone, Copy, PartialEq, Eq, TryFromPrimitive)]</span>
<span>#[repr(u16)]</span>
<span>pub</span> <span><span>enum</span> <span>Type</span></span> {
    <span>None</span> = <span>0x0</span>,
    Rel = <span>0x1</span>,
    Exec = <span>0x2</span>,
    Dyn = <span>0x3</span>,
    Core = <span>0x4</span>,
}

<span>#[derive(Debug, Clone, Copy, PartialEq, Eq, TryFromPrimitive)]</span>
<span>#[repr(u16)]</span>
<span>pub</span> <span><span>enum</span> <span>Machine</span></span> {
    X86 = <span>0x03</span>,
    X86_64 = <span>0x3e</span>,
}

<span>#[cfg(test)]</span>
<span>mod</span> tests {
    <span>use</span> super::Machine;

    <span>#[test]</span>
    <span><span>fn</span> <span>try_enums</span></span>() {
        <span>assert_eq!</span>(Machine::X86_64 <span>as</span> <span>u16</span>, <span>0x3E</span>);
        <span>assert_eq!</span>(Machine::try_from(<span>0x3E</span>), <span>Some</span>(Machine::X86_64));
        <span>assert_eq!</span>(Machine::try_from(<span>0xFA</span>), <span>None</span>);
    }
}
</code></pre>
<p>Sure enough, it works as expected!</p>
<pre><code> cargo t --lib
    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running target/debug/deps/delf-763cd4a126f7abd9

running 1 test
test tests::try_enums ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Now, we can finally parse both the type and the machine. First let's add
them to the <code>File</code> struct:</p>
<pre><code>

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>File</span></span> {
    <span>pub</span> <span><span>type</span>: <span>Type</span></span>,
    <span>pub</span> machine: Machine,
}
</code></pre>
<p>But wait… isn't <code>type</code> a keyword?</p>
<pre><code><span>$</span><span> cargo b -q</span>
error: expected identifier, found keyword `type`
<span>  --&gt;</span><span> src/lib.rs:24:5</span>
   |
24 |     type: Type,
   |     ^^^^ expected identifier, found keyword
   |
help: you can escape reserved keywords to use them as identifiers
   |
24 |     r#type: Type,
   |     ^^^^^^
</code></pre>
<p>It is! We could use <code>typ</code> instead - but just this once, let's use the
escaped form instead, like the compiler suggests.</p>
<pre><code><span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>File</span></span> {
    <span>pub</span> r#<span><span>type</span>: <span>Type</span></span>,
    <span>pub</span> machine: Machine,
}
</code></pre>
<p>Better! Kinda awkward, but at least this compiles.</p>
<p>Let's parse:</p>
<pre><code>

<span>impl</span> File {
    

    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{
            bytes::complete::{tag, take},
            error::context,
            sequence::tuple,
            combinator::map,
            number::complete::le_u16,
        };
        

        <span>let</span> (i, (r#<span><span>type</span>, <span>machine</span></span>)) = tuple((
            context(<span>"Type"</span>, map(le_u16, |x| Type::try_from(x).unwrap())),
            context(<span>"Machine"</span>, map(le_u16, |x| Machine::try_from(x).unwrap())),
        ))(i)?;

        <span>let</span> res = <span>Self</span> { machine, r#<span><span>type</span> };</span>
        <span>Ok</span>((i, res))
    }
}
</code></pre>
<p>To try that, we'll switch back to our binary crate, <code>elk</code>, for a second,
and print the <code>File</code> struct, now that it has fields!</p>
<pre><code>

<span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> Error&gt;&gt; {
    <span>let</span> input_path = env::args().skip(<span>1</span>).next().expect(<span>"usage: elk FILE"</span>);
    <span>let</span> input = fs::read(&amp;input_path)?;

    <span>let</span> (_, file) = delf::File::parse(&amp;input[..]).map_err(|e| <span>format!</span>(<span>"{:?}"</span>, e))?;
    
    <span>println!</span>(<span>"{:#?}"</span>, file);

    <span>Ok</span>(())
}
</code></pre>
<pre><code><span>$</span><span> </span>
<span>$</span><span> cargo b -q</span>
<span>$</span><span> ./target/debug/elk /bin/<span>true</span></span>
File {
    type: Dyn,
    machine: X86_64,
}
</code></pre>
<p>Wonderful! What happens if we run it on a 32-bit ELF?</p>
<pre><code><span>$</span><span> ./target/debug/elk /usr/lib32/libc.so</span>
Error: "Error(VerboseError { errors: [([47, 42, 32, 71, 78, 85, 32, 108, 100, 32, 115, 99, 114, 105, 112, 116, 10, 32, 32, 32, 85, 115, 101, 32, 116, 104, 101, 32, 115, 104, 97, 114, 101, 100, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 98, 117, 116, 32, 115, 111, 109, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 105, 110, 10, 32, 32, 32, 116, 104, 101, 32, 115, 116, 97, 116, 105, 99, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 115, 111, 32, 116, 114, 121, 32, 116, 104, 97, 116, 32, 115, 101, 99, 111, 110, 100, 97, 114, 105, 108, 121, 46, 32, 32, 42, 47, 10, 79, 85, 84, 80, 85, 84, 95, 70, 79, 82, 77, 65, 84, 40, 101, 108, 102, 51, 50, 45, 105, 51, 56, 54, 41, 10, 71, 82, 79, 85, 80, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 46, 115, 111, 46, 54, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 95, 110, 111, 110, 115, 104, 97, 114, 101, 100, 46, 97, 32, 32, 65, 83, 95, 78, 69, 69, 68, 69, 68, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 100, 45, 108, 105, 110, 117, 120, 46, 115, 111, 46, 50, 32, 41, 32, 41, 10], Nom(Tag)), ([47, 42, 32, 71, 78, 85, 32, 108, 100, 32, 115, 99, 114, 105, 112, 116, 10, 32, 32, 32, 85, 115, 101, 32, 116, 104, 101, 32, 115, 104, 97, 114, 101, 100, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 98, 117, 116, 32, 115, 111, 109, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 105, 110, 10, 32, 32, 32, 116, 104, 101, 32, 115, 116, 97, 116, 105, 99, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 115, 111, 32, 116, 114, 121, 32, 116, 104, 97, 116, 32, 115, 101, 99, 111, 110, 100, 97, 114, 105, 108, 121, 46, 32, 32, 42, 47, 10, 79, 85, 84, 80, 85, 84, 95, 70, 79, 82, 77, 65, 84, 40, 101, 108, 102, 51, 50, 45, 105, 51, 56, 54, 41, 10, 71, 82, 79, 85, 80, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 46, 115, 111, 46, 54, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 95, 110, 111, 110, 115, 104, 97, 114, 101, 100, 46, 97, 32, 32, 65, 83, 95, 78, 69, 69, 68, 69, 68, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 100, 45, 108, 105, 110, 117, 120, 46, 115, 111, 46, 50, 32, 41, 32, 41, 10], Context("Magic"))] })"
</code></pre>
<p>Oh my.</p>
<p>That's too much output. And we'd rather see hexadecimal notation here, wouldn't we?</p>
<p>Let's make a quick helper:</p>
<pre><code>

<span>pub</span> <span><span>struct</span> <span>HexDump</span></span>&lt;<span>'a</span>&gt;(&amp;<span>'a</span> [<span>u8</span>]);

<span>use</span> std::fmt;
<span>impl</span>&lt;<span>'a</span>&gt; fmt::<span>Debug</span> <span>for</span> HexDump&lt;<span>'a</span>&gt; {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        <span>for</span> &amp;x <span>in</span> <span>self</span>.<span>0</span>.iter().take(<span>20</span>) {
            <span>write!</span>(f, <span>"{:02x} "</span>, x)?;
        }
        <span>Ok</span>(())
    }
}
</code></pre>
<p>And try it. Remember there are two failure modes in <code>nom</code>:</p>
<ul>
<li><code>nom::Err::Error</code> is recoverable. Maybe another branch will work
(if we're trying several parsers in a row), or maybe we just
need to get more input.</li>
<li><code>nom::Err::Failure</code> is unrecoverable - we've tried all the parsers,
more input won't help, something is just plain wrong.</li>
</ul>
<p>In either case, they just wrap a <code>nom::error::VerboseError</code>, which itself
can contain multiple <code>nom::error::ErrorKind</code>, along with the relevant input slice.</p>
<p>I know, I know - that's a lot! But thanks to <a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">pattern matching</a>, it's not so bad.</p>
<p>We can make a much better error printer in just a few lines. We'll add it
directly in <code>delf</code>, so that we don't have use <code>nom</code> types in <code>elk</code>:</p>
<pre><code>

<span>impl</span> File {
    <span>pub</span> <span><span>fn</span> <span>parse_or_print_error</span></span>(i: parse::Input) -&gt; <span>Option</span>&lt;<span>Self</span>&gt; {
        <span>match</span> Self::parse(i) {
            <span>Ok</span>((_, file)) =&gt; <span>Some</span>(file),
            <span>Err</span>(nom::Err::Failure(err)) | <span>Err</span>(nom::Err::Error(err)) =&gt; {
                eprintln!(<span>"Parsing failed:"</span>);
                <span>for</span> (input, err) <span>in</span> err.errors {
                    eprintln!(<span>"{:?} at:"</span>, err);
                    eprintln!(<span>" {:?}"</span>, HexDump(input));
                }
                <span>return</span> <span>None</span>;
            }
            <span>Err</span>(_) =&gt; <span>panic!</span>(<span>"unexpected nom error"</span>),
        }
    }
}
</code></pre>
<p>Now we can use it from <code>elk</code>:</p>
<pre><code>

<span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), <span>Box</span>&lt;<span>dyn</span> Error&gt;&gt; {
    

    <span>let</span> file = <span>match</span> delf::File::parse_or_print_error(&amp;input[..]) {
        <span>Some</span>(f) =&gt; f,
        <span>None</span> =&gt; std::process::exit(<span>1</span>),
    };
    <span>println!</span>(<span>"{:#?}"</span>, file);
}
</code></pre>
<pre><code><span>$</span><span> cargo b -q</span>
<span>$</span><span> ./target/debug/elk /usr/lib32/libc.so</span>
Parsing failed:
Nom(Tag) at:
 2f 2a 20 47 4e 55 20 6c 64 20 73 63 72 69 70 74 0a 20 20 20 
Context("Magic") at:
 2f 2a 20 47 4e 55 20 6c 64 20 73 63 72 69 70 74 0a 20 20 20 
</code></pre>
<p>Wonderful! Well. It could be improved a lot - for now we'll just add
the position of each error in the file, as a byte offset:</p>
<pre><code>

<span>impl</span> File {
    <span>pub</span> <span><span>fn</span> <span>parse_or_print_error</span></span>(i: parse::Input) -&gt; <span>Option</span>&lt;<span>Self</span>&gt; {
        <span>match</span> Self::parse(i) {
            <span>Ok</span>((_, file)) =&gt; <span>Some</span>(file),
            <span>Err</span>(nom::Err::Failure(err)) | <span>Err</span>(nom::Err::Error(err)) =&gt; {
                eprintln!(<span>"Parsing failed:"</span>);
                <span>for</span> (input, err) <span>in</span> err.errors {
                    
                    <span>use</span> nom::Offset;
                    <span>let</span> offset = i.offset(input);
                    eprintln!(<span>"{:?} at position {}:"</span>, err, offset);
                    eprintln!(<span>"{:&gt;08x}: {:?}"</span>, offset, HexDump(input));
                }
                <span>return</span> <span>None</span>;
            }
            <span>Err</span>(_) =&gt; <span>panic!</span>(<span>"unexpected nom error"</span>),
        }
    }
</code></pre>
<p>And here's the result:</p>
<pre><code><span>$</span><span> cargo b -q &amp;&amp; ./target/debug/elk /usr/lib32/libz.so</span>
Parsing failed:
Nom(Tag) at position 4:
00000004: 01 01 01 00 00 00 00 00 00 00 00 00 03 00 03 00 01 00 00 00 
Context("Class") at position 4:
00000004: 01 01 01 00 00 00 00 00 00 00 00 00 03 00 03 00 01 00 00 00 
</code></pre>
<div>
    
<p>We could get much, much nicer output, but let's not get distracted - there
is so much to do!</p>
<p>If you want to read more about error handling (and pretty printing!) with
<code>nom</code>, read <a href="https://fasterthanli.me/blog/2019/making-our-own-ping-9/">Making our own ping: Part 9</a>.</p>
</div>
<p>Let's not waste any more time and move forward with our parser. One thing
I don't like about our current parser is that it panics if it encounters
say, a value for <code>Machine</code> it doesn't support.</p>
<p>We're going to allow ourselves to panic in <code>elk</code> - the binary crate, our CLI
tool, but we'll avoid panicking in <code>delf</code> - the library crate. Luckily, we've
<a href="https://fasterthanli.me/blog/2019/making-our-own-ping-10/">already learned how to do that</a>.</p>
<p>In our case, we want to implement <code>parse</code> on the <code>Machine</code> type. It should
return a <code>parse::Result</code> - like any other parser, and if we find a variant
we don't support, we shall return one of the built-in nom error kinds, say…
<code>Alt</code>. Because what are <code>enums</code>, if not a miserable little pile of alternatives?</p>
<pre><code>

<span>impl</span> Machine {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>let</span> original_i = i;

        <span>use</span> nom::{
            error::{ErrorKind, ParseError, VerboseError},
            number::complete::le_u16,
            <span>Err</span>,
        };

        <span>let</span> (i, x) = le_u16(i)?;
        <span>match</span> Self::try_from(x) {
            <span>Some</span>(res) =&gt; <span>Ok</span>((i, res)),
            <span>None</span> =&gt; <span>Err</span>(Err::Failure(VerboseError::from_error_kind(
                original_i,
                ErrorKind::Alt,
            ))),
        }
    }
}
</code></pre>
<p>Okay. So.</p>
<p>That's a little bit on the verbose side. Also, there's no context! We won't know
<em>which</em> enum failed to parse. I'm sure we can do a bit better than that.</p>
<p>We've used the <code>map</code> combinator before, but it won't work here - <code>map</code> works when
<em>all outputs of the previous parser are valid</em>, whereas in our case, <code>try_from</code> can fail.</p>
<p>Luckily, there's another combinator, <code>map_res</code>, that fits our needs. It allows
us to return a <code>Result&lt;O2, E2&gt;</code> instead - where <code>O2</code> is the output of our mapping
function, and <code>E2</code> is the errors our mapping function can return.</p>
<pre><code>

<span>impl</span> Machine {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{combinator::map_res, error::ErrorKind, number::complete::le_u16};
        map_res(le_u16, |x| <span>match</span> Self::try_from(x) {
            <span>Some</span>(x) =&gt; <span>Ok</span>(x),
            <span>None</span> =&gt; <span>Err</span>(ErrorKind::Alt),
        })(i)
    }
}
</code></pre>
<p>Better! Now <code>nom</code> takes care of making a “verbose error”, and picks an <code>Err</code>
variant for us. It even annotates with the location, since <code>map_res</code> has a
reference to the input <em>before</em> <code>le_u16</code> even runs.</p>
<p>But we've got an anti-pattern on our hands - <code>try_from</code> returns an <code>Option&lt;T&gt;</code>,
and we're trying to turn it into a <code>Result&lt;T, E&gt;</code>. And as much as I like pattern
matching, there's a better tool for the job: <code>ok_or</code>.</p>
<p>Let's look at its prototype (keep in mind it's implemented on <code>Option&lt;T&gt;</code>):</p>
<pre><code>

<span>pub</span> <span><span>fn</span> <span>ok_or</span></span>&lt;E&gt;(<span>self</span>, err: E) -&gt; <span>Result</span>&lt;T, E&gt;
</code></pre>
<p>Wonderful! This means we can just write:</p>
<pre><code>
<span>impl</span> Machine {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{combinator::map_res, error::ErrorKind, number::complete::le_u16};
        map_res(le_u16, |x| Self::try_from(x).ok_or(ErrorKind::Alt))(i)
    }
}
</code></pre>
<p>We can even add some context now. It's all just combinators!</p>
<pre><code><span>impl</span> Machine {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{
            combinator::map_res,
            error::{context, ErrorKind},
            number::complete::le_u16,
        };
        context(
            <span>"Machine"</span>,
            map_res(le_u16, |x| Self::try_from(x).ok_or(ErrorKind::Alt)),
        )(i)
    }
}
</code></pre>
<p>And even though this impleementation is much more pleasant, I wouldn't want
it to write it by hand more than once, so.. let's make a macro!</p>
<p>We'll slap it in the <code>parse</code> module:</p>
<pre><code>



<span>#[macro_export]</span>
<span>macro_rules!</span> impl_parse_for_enum {
    ($<span><span>type</span>: <span>ident</span></span>, $number_parser: ident) =&gt; {
        <span>impl</span> $<span><span>type</span> {
            <span>pub</span></span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
                <span>use</span> nom::{
                    combinator::map_res,
                    error::{context, ErrorKind},
                    number::complete::$number_parser,
                };
                <span>let</span> parser = map_res($number_parser, |x| Self::try_from(x).ok_or(ErrorKind::Alt));
                context(<span>stringify!</span>($<span><span>type</span>), <span>parser</span></span>)(i)
            }
        }
    };
}
</code></pre>
<p>And now we can implement <code>parse</code> for both <code>Type</code> and <code>Machine</code>:</p>
<pre><code>



impl_parse_for_enum!(Type, le_u16);
impl_parse_for_enum!(Machine, le_u16);
</code></pre>
<p>And finally use those in our main parser:</p>
<pre><code><span>impl</span> File {
    <span>const</span> MAGIC: &amp;<span>'static</span> [<span>u8</span>] = &amp;[<span>0x7f</span>, <span>0x45</span>, <span>0x4c</span>, <span>0x46</span>];

    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        

        
        <span>let</span> (i, (r#<span><span>type</span>, <span>machine</span></span>)) = tuple((
            context(<span>"Type"</span>, map(le_u16, |x| Type::try_from(x).unwrap())),
            context(<span>"Machine"</span>, map(le_u16, |x| Machine::try_from(x).unwrap())),
        ))(i)?;

        
        <span>let</span> (i, (r#<span><span>type</span>, <span>machine</span></span>)) = tuple((Type::parse, Machine::parse))(i)?;

        <span>let</span> res = <span>Self</span> { machine, r#<span><span>type</span> };</span>
        <span>Ok</span>((i, res))
    }
}
</code></pre>
<p>Phew. I feel lighter already. Nothing like a good abstraction to clear the mind.</p>
<p>Does everything still work?</p>
<pre><code><span>$</span><span> cargo b -q &amp;&amp; ./target/debug/elk /bin/<span>true</span></span>
File {
    type: Dyn,
    machine: X86_64,
}
</code></pre>
<p>It does! Good, good.</p>
<p>I guess it's time to parse the rest of the ELF header.</p>
<p>Next up is the <code>entry point</code> - in ELF64, it's.. a 64-bit integer. Well, it's
more of a memory address. We'll want to print that in hexadecimal. So let's make
a wrapper type!</p>
<p>We might end up doing some arithmetic with those addresses, so we'll quickly
grab a crate to derive more traits: <code>derive_more</code>:</p>
<pre><code><span>$</span><span> cargo add derive_more</span>
      Adding derive_more v0.99.2 to dependencies
</code></pre>
<pre><code>

<span>use</span> derive_more::*;


<span>#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Add, Sub)]</span>
<span>pub</span> <span><span>struct</span> <span>Addr</span></span>(<span>pub</span> <span>u64</span>);

<span>impl</span> fmt::<span>Debug</span> <span>for</span> Addr {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        <span>write!</span>(f, <span>"{:08x}"</span>, <span>self</span>.<span>0</span>)
    }
}

<span>impl</span> fmt::Display <span>for</span> Addr {
    <span><span>fn</span> <span>fmt</span></span>(&amp;<span>self</span>, f: &amp;<span>mut</span> fmt::Formatter) -&gt; fmt::<span>Result</span> {
        fmt::<span>Debug</span>::fmt(<span>self</span>, f)
    }
}


<span>impl</span> <span>Into</span>&lt;<span>u64</span>&gt; <span>for</span> Addr {
    <span><span>fn</span> <span>into</span></span>(<span>self</span>) -&gt; <span>u64</span> {
        <span>self</span>.<span>0</span>
    }
}


<span>impl</span> <span>Into</span>&lt;<span>usize</span>&gt; <span>for</span> Addr {
    <span><span>fn</span> <span>into</span></span>(<span>self</span>) -&gt; <span>usize</span> {
        <span>self</span>.<span>0</span> <span>as</span> <span>usize</span>
    }
}


<span>impl</span> <span>From</span>&lt;<span>u64</span>&gt; <span>for</span> Addr {
    <span><span>fn</span> <span>from</span></span>(x: <span>u64</span>) -&gt; <span>Self</span> {
        <span>Self</span>(x)
    }
}

<span>impl</span> Addr {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        <span>use</span> nom::{combinator::map, number::complete::le_u64};
        map(le_u64, <span>From</span>::from)(i)
    }
}
</code></pre>
<p>Well, that was a mouthful. But it should be smooth sailing from now on!</p>
<p>We can add it to our <code>File</code> struct, and our parser:</p>
<pre><code>

<span>#[derive(Debug)]</span>
<span>pub</span> <span><span>struct</span> <span>File</span></span> {
    <span>pub</span> r#<span><span>type</span>: <span>Type</span></span>,
    <span>pub</span> machine: Machine,
    <span>pub</span> entry_point: Addr,
}

<span>impl</span> File {
    <span>pub</span> <span><span>fn</span> <span>parse</span></span>(i: parse::Input) -&gt; parse::<span>Result</span>&lt;<span>Self</span>&gt; {
        

        <span>use</span> nom::{combinator::verify, number::complete::le_u32};
        <span>let</span> (i, (r#<span><span>type</span>, <span>machine</span></span>)) = tuple((Type::parse, Machine::parse))(i)?;
        
        
        
        <span>let</span> (i, _) = context(<span>"Version (bis)"</span>, verify(le_u32, |&amp;x| x == <span>1</span>))(i)?;
        <span>let</span> (i, entry_point) = Addr::parse(i)?;

        <span>let</span> res = <span>Self</span> {
            machine,
            r#<span><span>type</span>,
            <span>entry_point</span></span>,
        };
        <span>Ok</span>((i, res))
    }
}
</code></pre>
<p>And then give <code>elk</code> a go! We don't need to change anything in it -
it refers to <code>delf</code> by path, and we've updated <code>delf</code>'s <code>File</code> to have a
new field, so we just need to build and run it again:</p>
<pre><code><span>$</span><span> cargo b -q &amp;&amp; ./target/debug/elk /bin/<span>true</span></span>
File {
    type: Dyn,
    machine: X86_64,
    entry_point: 00002130,
}
</code></pre>
<p>Nice! But what <em>does</em> <code>entry_point</code> mean anyway?</p>
<p>Our diagram said it's the “address at which program execution starts”.</p>
<p>For example, if we run it on our sample assembly program from above:</p>
<pre><code><span>$</span><span> cargo b -q &amp;&amp; ./target/debug/elk samples/hello</span>
File {
    type: Exec,
    machine: X86_64,
    entry_point: 00401000,
}
</code></pre>
<p>How can we verify our assumption? Well, we can debug our program!</p>
<p>When researching this article series, I went hunting for a good GDB GUI - and
I'm sorry to report that the state of GDB graphical user interfaces is… not
great. I mean, <a href="https://wiki.gnome.org/Apps/Nemiver">Nemiver</a> still runs, but
I didn't have to look very far to find several annoying bugs.</p>
<p>So, naturally, I went hunting on <a href="https://crates.io/">https://crates.io</a>, and found… <a href="https://crates.io/crates/ugdb">ugdb</a>! It's a TUI (text user interface), but it's nicer than the
built-in GDB TUI, has syntax highlighting, a cozy default pane layout. I like it
a lot!</p>
<p>To install it, simply run:</p>
<pre><code><span>$</span><span> </span>
<span>$</span><span> cargo install ugdb</span>
</code></pre>
<p>We can then load up <code>samples/hello</code> in <code>ugdb</code> simply with:</p>
<pre><code><span>$</span><span> ugdb ./samples/hello</span>
</code></pre>
<p>And be greeted with this:</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/ugdb-start.png" alt=""></p>
<p>Now, if we just use the <code>start</code> GDB command, our program will run entirely,
and we'll see its output in the right pane:</p>
<pre><code>(gdb) start
</code></pre>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/ugdb-whole-program.png" alt=""></p>
<p>But that's not very interesting. GDB will not break anywhere in our program by
default, because our program doesn't crash - it just makes two syscalls:
<code>write</code> and <code>exit</code>.</p>
<div>
    
<p>To quit GDB (and similarly, ugdb), use the <code>quit</code> command (or <code>q</code>, for short). If it asks
for a confirmation, reply with <code>y</code> (and press enter).</p>
</div>
<p>We can't set breakpoint on syscalls… but we can set catchpoints!</p>
<pre><code>(gdb) catch syscall
Catchpoint 1 (any syscall)
(gdb) start
</code></pre>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/ugdb-catchpoint.png" alt=""></p>
<p>Nice! GDB paused program execution right before the <code>write</code> syscall was executed.</p>
<p>We can already see in this screenshot that the beginning of <code>_start</code> - our entry point -
is at <code>0x401000</code>. Everything checks out so far!</p>
<p>Another way we could've checked this is to set a breakpoint <em>at address <code>0x401000</code></em>,
like so:</p>
<pre><code>(gdb) break *0x401000
Breakpoint 1 at 0x401000
(gdb) start
</code></pre>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/breakpoint-at-addr.png" alt=""></p>
<p>While in <code>ugdb</code>, we can use the <code>stepi</code> command (or <code>si</code> for short) to advance to
the next instruction.</p>
<p>Here's a quick video:</p>

<p>There's one thing that bothers me though - the disassembly shown in <code>ugdb</code> doesn't
really look like our source program. We wrote <code>mov rdi, 1</code>, not <code>mov $0x1, %edi</code>.</p>
<p>The explanation is simple: GDB is showing us AT&amp;T assembly syntax, whereas we got
used to Intel syntax. Luckily, we can adjust that by creating a <code>~/.gdbinit</code> file:</p>
<pre><code># in ~/.gdbinit
set disassembly-flavor intel
</code></pre>
<p>Now GDB (and ugdb) shows us disassembly in Intel syntax!</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/ugdb-intel.png" alt=""></p>
<p>Let's try doing all that on <code>/bin/true</code> - the entry point for it was <code>0x2130</code>, so,</p>
<pre><code>(gdb) break *0x2130
(gdb) start
Starting program: /usr/bin/true
Warning:
Cannot insert breakpoint 1.
Cannot access memory at address 0x2130
</code></pre>
<p>Oh. That's unfortunate. What address <em>does</em> <code>/bin/true</code> start at, then?
And how can we break at the entry point, if it's not <code>0x2130</code>?</p>
<p>Recent versions of <code>gdb</code> come with the <code>starti</code> command, which does exactly that.
We can use it to inspect at which address <code>/bin/true</code> actually starts:</p>
<p><img src="https://fasterthanli.me/img/whats-in-a-linux-executable/true-1.png" alt=""></p>
<p>Oh. <code>0x7ffff7fd4100</code>. Okay. Well, that's 140 terabytes. I sorta doubt <code>/bin/true</code>
needs that much memory to proceed, but uh…</p>
<p>Okay, forget <code>/bin/true</code> for a minute - let's make a C program that prints
the address of <code>main</code>. That should be the entry point, right?</p>
<pre><code>

<span>#<span>include</span> <span>&lt;stdio.h&gt;</span></span>

<span><span>int</span> <span>main</span><span>()</span> </span>{
    <span>printf</span>(<span>"main is at %p
"</span>, &amp;main);
}
</code></pre>
<pre><code><span>$</span><span> </span>
<span>$</span><span> gcc entry_point.c -o entry_point</span>
<span>$</span><span> ../target/debug/elk</span>
File {
    type: Dyn,
    machine: X86_64,
    entry_point: 00001040,
}
<span>$</span><span> ./entry_point</span>
main is at 0x562601e0f139
<span>$</span><span> ./entry_point</span>
main is at 0x56311bd0c139
<span>$</span><span> ./entry_point</span>
main is at 0x5588a0a39139
<span>$</span><span> ./entry_point</span>
main is at 0x559c3e3df139
<span>$</span><span> ./entry_point</span>
main is at 0x557578dc4139
<span>$</span><span> ./entry_point</span>
main is at 0x55c80e189139
</code></pre>
<p>Okay.</p>
<p>Uh.</p>
<p>Let's try gdb?</p>
<pre><code>(gdb) starti
Starting program /home/amos/ftl/elk/samples/entry_point

Program stopped.
0x0000000000401ac0 in _start ()
(gdb) c
Continuing.
main is at 0x401be5
[Inferior 1 (process 7394) exited normally]
(gdb) starti
Starting program: /home/amos/ftl/elk/samples/entry_point

Program stopped.
0x0000000000401ac0 in _start ()
(gdb) c
Continuing.
main is at 0x401be5
[Inferior 1 (process 7397) exited normally]
(gdb) starti
Starting program: /home/amos/ftl/elk/samples/entry_point

Program stopped.
0x0000000000401ac0 in _start ()
(gdb) c
Continuing.
main is at 0x401be5
[Inferior 1 (process 7398) exited normally]
</code></pre>
<p>Well.</p>
<p>That doesn't answer any of my questions.</p>
<p>If anything, I have <em>more</em> questions now.</p>
<ul>
<li>Why is the entry point stored in an ELF file sometimes the same one we see in GDB
and sometimes not?</li>
<li>Why is the entry point a valid offset into the ELF file and sometimes not?</li>
<li>Why is the entry point always the same in GDB but not when running the executable directly?</li>
</ul>
<p>Clearly, we have a lot more detective work to do…</p>
<div>
    
<p>The ELF binary file format is old, but still in use today! It contains
information about the Operating System's Application Binary Interface (OS
ABI) and the processor architecture (ie. the <code>Machine</code>), among other things.</p>
<p>It is easily parsed with <a href="https://crates.io/crates/nom">nom</a>. For Rust
<code>enum</code>s, we can use the
<a href="https://crates.io/crates/derive-try-from-primitive">derive-try-from-primitive</a>
crate to convert back and forth between the integer representation (<code>u8</code>, <code>u16</code>, <code>u32</code>) and the Rust enum variant.</p>
<p>The ELF header also contains the “entry point” for a program - where it should start executing. Although, when we run a program, we sometimes find a different address
being executed.</p>
<p>We can use <code>xxd</code> to visualize the contents of a binary file - it's a
“hexdump” (hexadecimal.. printer) tool. It accepts options such as: offset,
length, endianness, and how many bytes to group together when printing. It does
not understand hexadecimal offsets, but we can use shell arithmetic - <code>$(())</code> -
to do that.</p>
<p>GDB, the GNU debugger, will let us start a program and step through it, even
if doesn't have debug or source information - in that case, it will show us
<em>disassembly</em> of the program. We can even ask GDB to use Intel syntax when
showing assembly. <a href="https://crates.io/crates/ugdb">ugdb</a> is a nice text UI frontend
to GDB.</p>
</div>


          







          
          
<p>This article was made possible thanks to my patrons: Aurora, Brian, Chad Morrow, Corey, Fernando, Geert Depuydt, Geoff Cant,
Geoffroy Couprie, Henry Goffin, Ignacio Vergara, Jane Lusby, Jesús Higueras,
Jonathan Knapp, Justin Gerhardt, Jérémy Gtld, Lina Cambridge, Lucien
Greathouse, Makoto Nakashima, Mara Bos, Maximilian, Mayfield Reynolds, Michael
Alyn Miller, Nicolas Goy, o0Ignition0o, Pascal, Raphael Gaschignard, Romain
Ruetschi, Ryszard Sommefeldt, Sean Bryant, Sebastian Zimmer, Seth Stadick,
Someone, Stefano Probst, Ted Mielczarek, Zaki, and Тим Маринин.</p>
          
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>