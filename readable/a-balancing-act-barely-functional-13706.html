<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>A balancing act</h1>
        <p>
by Eric Torreborre <br/>Reading time: 12-15 minutes        </p>
        <p><a href="https://medium.com/barely-functional/a-balancing-act-c869e1f4fea4">https://medium.com/barely-functional/a-balancing-act-c869e1f4fea4</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@etorreborre_99063?source=post_page-----c869e1f4fea4----------------------"><img alt="Eric Torreborre" src="https://miro.medium.com/fit/c/96/96/1*1AGYyTcDpK_mrTcfKPtWgg.jpeg" width="48" height="48"></a></p></div></div></div></div><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*jWYUgj5tzvAdAyaMqnJ3pw.jpeg?q=20" width="634" height="423" role="presentation"></p><p><img width="634" height="423" role="presentation" src="https://miro.medium.com/max/634/1*jWYUgj5tzvAdAyaMqnJ3pw.jpeg"></p></div></div></div></figure><p id="97e5" data-selectable-paragraph="">It would be so nice to have a set of exact rules on how to design software. With Functional Programming we can get the impression that everything can be normalized, formalized, algebraized to the point where only one implementation remains. I don‚Äôt think this is the case though and our mental model should be the one of security experts. What is our ‚Äúthreat model‚Äù? What are the things that we are really trying to prevent? And what does it cost us? (that looks like a <a target="_blank" rel="noopener" href="https://medium.com/@AndreRodriguezKatzinger/security-vs-freedom-5536c37b716e">‚ÄúFreedom vs Security‚Äù</a> debate)</p><p id="7088" data-selectable-paragraph="">I want to illustrate this dilemma with three ongoing discussions that I am having with my colleagues at work:</p><ol><li id="2081" data-selectable-paragraph="">Part 1: what should be the interfaces between our components (we are using Haskell)?</li><li id="df8e" data-selectable-paragraph="">Part 2: should we throw exceptions?</li><li id="66d5" data-selectable-paragraph="">Part 3: should we use Template Haskell to remove boilerplate?</li></ol><p id="94e3" data-selectable-paragraph="">We are currently implementing an application in Haskell using ‚Äúrecords-of-functions‚Äù (this is known as the ‚Äú<a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" target="_blank" rel="noopener nofollow">Handle pattern</a>‚Äù). I have a strong preference for using this way of structuring Haskell applications because:</p><ul><li id="5081" data-selectable-paragraph="">The ‚ÄúMTL‚Äù approach using monad transformers does not give us easy ways to fully model a graph of components and to swap full parts of that graph</li><li id="d9a9" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501">I don‚Äôt recommend effect libraries anymore</a></li><li id="fbb8" data-selectable-paragraph="">I think that the <code><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" target="_blank" rel="noopener nofollow">ReaderT</a></code> design pattern is also too limited because it only allows us to switch leaves in our ‚Äúapplication graph‚Äù</li><li id="9a11" data-selectable-paragraph="">We have <a href="https://github.com/etorreborre/registry" target="_blank" rel="noopener nofollow">an easy way to assemble/re-assemble ‚Äúrecords-of-functions‚Äù</a> at our disposal</li><li id="2370" data-selectable-paragraph="">‚Äúrecords-of-functions‚Äù <strong>are very easy to understand</strong> and provide a natural interface/implementation separation which is really what we are after when building applications</li></ul><p id="3752" data-selectable-paragraph="">I want to stress that last point. I am not against sophisticated techniques: type systems, specification languages, verification tools. But when they get in the way of understanding our system they are not helping us. And if a fancy effect library gets in the way of refactoring the system so that we have less moving parts, it is <strong><em>not</em></strong> working for us. It is also all the more important in my current company where some non-Haskell experts need to be able to read the code and modify some parts of it to implement larger features.</p><p id="7c62" data-selectable-paragraph="">That still leaves some open questions:</p><ol><li id="1fc7" data-selectable-paragraph="">what kind of monad should we use as return types for those functions?</li><li id="ad48" data-selectable-paragraph="">passing down the dependencies (‚Äúhandles‚Äù) in the implementation is tedious and possibly error prone (you could accidentally pass a no-op implementation for example)</li></ol><p id="69f2" data-selectable-paragraph="">I will deal with the second point in part 3 of that post, let‚Äôs focus on point n.1 for now.</p><p id="2eda" data-selectable-paragraph="">My proposal for ‚Äúrecords-of-functions‚Äù is to use <code>IO</code> as the return type. This might be a shocking proposal for some functional programmers. Why do I want this? For two reasons:</p><ul><li id="8e72" data-selectable-paragraph="">simplicity of integration: a component having an <code>IO</code> interface can always interact with another component having an <code>IO</code> interface. No type juggling required here, easy refactorings</li><li id="6192" data-selectable-paragraph="">maximum encapsulation: a component using <code>IO</code> is basically telling you nothing about its implementation. This means that it is free to do things differently, like running some code concurrently or access a database instead of storing values in-memory and your code won‚Äôt be impacted</li></ul><p id="0c67" data-selectable-paragraph="">I‚Äôm really favouring composition and modularity here. But this doesn‚Äôt come for free. Interfacing with <code>IO</code> means that indeed <strong>anything</strong> can happen when using such a component, launching all the nukes you can think of: exceptions, reading the file system, maintaining global state. This is why this is a balancing act. We can‚Äôt win them all.</p><p id="7349" data-selectable-paragraph="">Let‚Äôs investigate some consequences of that choice. Actually I propose to return <code>IO</code> only when constructing a specific component, not when using it. For example here is a logging component</p><figure><div></div></figure><p id="5bfb" data-selectable-paragraph="">The data types just know about a type <code>m</code> but their constructors are more specific and require <code>IO</code>. Also note that in the implementation of <code>Authenticator</code> we only need to know about <code>Logger</code> using a <code>Monad</code>. No need for <code>IO</code> there.</p><p id="a463" data-selectable-paragraph="">You might wonder why not <code>MonadIO m</code> for the <code>Logger</code> constructor?</p><figure><div></div></figure><p id="4a3a" data-selectable-paragraph="">My question back to you is ‚ÄúWhy would you need it?‚Äù. Having <code>MonadIO</code> is only useful if we need to layer, later on, additional capabilities on top of that <code>IO</code> monad. But what could we really need? A few possibilities off the top of my head:</p><ol><li id="9bd1" data-selectable-paragraph=""><code>ExceptT</code> to add error management: jump to part 2 of this post where we deal with errors and exceptions</li><li id="1ea9" data-selectable-paragraph=""><code>ReaderT</code> to add a way to inject ‚Äú<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" target="_blank" rel="noopener nofollow">capabilities</a>‚Äù: we already have <a href="http://github.com/etorreborre/registry" target="_blank" rel="noopener nofollow">a way to inject capabilities</a></li><li id="9d63" data-selectable-paragraph=""><code>ReaderT</code> to get some context about the context of the caller, for example access a <code>RequestId</code>. More on that in a minute</li><li id="2433" data-selectable-paragraph=""><code>StateT</code> for testing. This way we can have ‚Äúpure‚Äù components for testing where the component state is managed through a state monad</li></ol><h2 id="2f6c" data-selectable-paragraph="">Pure testing</h2><p id="1617" data-selectable-paragraph="">Let‚Äôs talk about ‚Äúpure testing‚Äù for a moment. You will find many articles telling you that parametrizing your code with a monad <code>m</code> gives you the ability to replace that <code>m</code> with either <code>Identity</code> or <code>State</code> when testing in order to avoid using <code>IO</code>. I don‚Äôt find this to be a compelling argument because</p><ul><li id="e983" data-selectable-paragraph="">using mutation for testing is not necessarily harmful especially if those components already represent some effectful behaviour like <code>Database</code>, <code>Logging</code>, <code>S3Client</code>, ...</li><li id="a9fc" data-selectable-paragraph="">using <code>State</code> or <code>StateT</code> puts the burden on the client of the component to deal with state. It has to provide a valid initial state and eventually call <code>runState</code>. And if you have several components offering a <code>State</code> interface you have to find a way to run all those states together, providing a valid initial state for each of them even if some of those components are not particularly meaningful for the current test</li></ul><p id="d51b" data-selectable-paragraph="">On the contrary a mock offering an <code>IO</code> interface is can be used independently from anything else. For example you can implement a <code>Logger</code> component which will collect all the log messages in an <code>IORef</code> variable to do later checks.</p><figure><div></div></figure><p id="68e3" data-selectable-paragraph="">This example does not seem to have less boilerplate than a similar example using <code>State</code> however it can easily be extended if <code>Authenticator</code> needs new dependencies like <code>Time IO</code> in order to check that a user can only access a service from 9 to 5 independently from checking the logs. In the test above, if the time behaviour has no influence on the logging, we can just modify:</p><p id="2aba" data-selectable-paragraph=""><code>let authenticator = newAuthenticator logger newFixedTime</code></p><p id="5f22" data-selectable-paragraph="">We don‚Äôt have to create a special state construct unifying the state for the <code>Logger</code> and the state for <code>Time</code>.</p><p id="45a6" data-selectable-paragraph="">Bottom line: <em>we only need </em><code><em>IO</em></code><em> as the interface of our components.</em></p><p id="f740" data-selectable-paragraph="">Well‚Ä¶ almost, there is still the question of <code>RequestIds</code>.</p><h2 id="d8f7" data-selectable-paragraph="">Accessing a context</h2><p id="aa46" data-selectable-paragraph="">When implementing services we need, almost all the time, to track the origin of a given request. For auditing reasons, to trace calls times and diagnose performance issues, for debugging issues. This is an important requirement but also a minor one. What your service does in the first place is a lot more important!</p><p id="f042" data-selectable-paragraph="">Unfortunately this is one of those requirements that is very invasive. Tracing request ids means that <em>almost all of your code</em> needs to be ‚Äúrequest-id aware‚Äù. And there aren‚Äôt too many ways to do this:</p><ul><li id="eb3a" data-selectable-paragraph="">you explicitly require almost every function to use a <code>requestId</code> parameter</li><li id="49dd" data-selectable-paragraph="">you use <code>ReaderT RequestId IO</code> as a return type</li></ul><p id="64cd" data-selectable-paragraph="">Here is the dilemma. <em>Almost all</em> the functions need a <code>RequestId</code> but not <em>all</em> of them. This means that if we want to be precise in our software we need to have some component constructors with a <code>ReaderT RequestId IO</code> interface, and if we are even more specific, have only <em>some functions</em> of the interface return <code>ReaderT RequestId IO</code> while the other ones return <code>IO</code>.</p><p id="4244" data-selectable-paragraph="">This now makes the components harder to interoperate because you have to ‚Äúlift‚Äù <code>IO</code>operations into <code>ReaderT RequestId IO</code> and this also has a ‚Äúviral‚Äù effect meaning that <em>almost all</em> your functions will need to operate in that monad anyway.</p><p id="c95a" data-selectable-paragraph="">What is the alternative? You can define a type alias <code>type AppIO = ReaderT RequestId IO</code> and use it everywhere. That‚Äôs simple, we get back an easy way to integrate components. What is the downside? There are few places where no <code>RequestId</code> is available and you will have to provide a fake to make that code run. This seems harmless but that also means that your run the risk of forgetting to provide the proper <code>requestId</code> in places where it is available and must be propagated!</p><p id="5fc3" data-selectable-paragraph="">My choice here is again to go for simplicity:</p><ul><li id="07f2" data-selectable-paragraph="">use <code>AppIO</code> everywhere, for easy integration</li><li id="5424" data-selectable-paragraph="">carefully test the application to make sure that entry and exit points really get the proper <code>requestIds</code></li></ul><p id="f105" data-selectable-paragraph="">I am trading <strong>compiler-supported correctness of a minor feature of the service against massive convenience for all the rest of the application</strong>. I think this is worth it.</p><p id="675c" data-selectable-paragraph="">I have been sitting on a blog post on exceptions and error management for a long time now. I seem to be completely unable to deal with that subject in a concise and structured way, and that reflects the state of my mind about it!</p><p id="f254" data-selectable-paragraph="">That‚Äôs because this is a balancing act as well. Say we settle on using <code>ReaderT Request IO</code> for all of our components. How do we represent errors? Should some components return <code>EitherT DatabaseError (ReaderT RequestId IO)</code> as well? Should the<code>Database</code> component functions throw an exception when they can not connect to the database? Should we abstract the constructor of <code>Database</code> to <code>MonadError DatabaseError</code>?</p><p id="0088" data-selectable-paragraph="">Here is my proposal:</p><ol><li id="5336" data-selectable-paragraph="">use concrete error types in the interface of components when the <em>domain</em> is involved</li><li id="dff9" data-selectable-paragraph="">throw exceptions when there are ‚Äúoperational issues‚Äù</li><li id="1bdd" data-selectable-paragraph="">classify ‚Äúoperational issues‚Äù based on what the client can do, not what the implementation did</li><li id="21e9" data-selectable-paragraph="">document and test those exceptions</li></ol><h2 id="430f" data-selectable-paragraph="">Domain errors</h2><p id="eab7" data-selectable-paragraph="">Those are errors related to what a given component is supposed to provide in terms of added value:</p><ul><li id="bfd8" data-selectable-paragraph="">access a record in the database: was it found?</li><li id="3410" data-selectable-paragraph="">parse some text: are there some errors?</li><li id="3807" data-selectable-paragraph="">download a file: is the checksum ok?</li></ul><h2 id="d0b6" data-selectable-paragraph="">Operational issues</h2><p id="0847" data-selectable-paragraph="">Those errors cover the cases where the service cannot be delivered:</p><ul><li id="e2a9" data-selectable-paragraph="">a dependency does not respond: because it‚Äôs too slow, disconnected, overloaded</li><li id="7c9b" data-selectable-paragraph="">there is a developer bug: <code>maximum</code> has been called on an empty list</li><li id="2516" data-selectable-paragraph="">one invariant is broken: there should be some reference data in the database but it is missing</li></ul><p id="0518" data-selectable-paragraph="">There is generally not much we can do about those errors, some of them might be transient or can benefit from some form of ‚Äústate reset‚Äù and can be retried. The others can just be logged. I argue that representing those ‚Äúoperational errors‚Äù in the API is not particularly helpful:</p><ul><li id="fa97" data-selectable-paragraph="">they are likely to ‚Äúbubble-up‚Äù to the top of the application without any intermediate component being able to do anything anyway</li><li id="dbbd" data-selectable-paragraph="">we need a top-level strategy to handle exceptions anyway whether they are declared or not</li><li id="a2eb" data-selectable-paragraph="">if they are describing in types why they are failing: <code>BrokenDatabaseConnection</code>, <code>IncorrectConfiguration</code>, ... then they are exposing implementation details to user components which will have to be recompiled or modified if that implementation changes</li></ul><p id="7a7b" data-selectable-paragraph="">This is why the best thing we can do is roughly to classify those errors into: can be retried / cannot be retried and just carefully log any additional information for further investigation.</p><p id="3b14" data-selectable-paragraph="">But this is a balancing act because we lose some knowledge. Now it is harder to know when reading the interface of a component ‚Äúwhat can go wrong‚Äù. This is why we need to counteract by providing extensive documentation and testing. That‚Äôs the price to pay for the convenience of not having to model too much our exceptions.</p><p id="58b8" data-selectable-paragraph="">This is a minor point compared to the other 2 but still significant. The ‚ÄúHandler pattern‚Äù is nice because it proposes a very simple way to build and assemble Haskell applications. Unfortunately you have to manually pass down dependencies in the components implementations (cf the use of <code>Logger</code> in <code>Authenticator</code>). This is a bit tedious and possibly error-prone. Can we do better?</p><p id="3f30" data-selectable-paragraph="">Yes we can, we can declare a typeclass that offers the same interface as a component and provide a default instance for that typeclass using the component (using a <code>Reader</code>). This is described <a href="https://github.com/etorreborre/registry/blob/master/doc/boilerplate.md" target="_blank" rel="noopener nofollow">here</a>. This can also be automated by a bit of Template Haskell because that code is very mechanical and a machine can totally update the typeclass and the instance when a component is evolving.</p><p id="9cab" data-selectable-paragraph="">But this comes with a downside. Now you have some ‚Äúmagic‚Äù code. You have some Template Haskell which doesn‚Äôt tell you anything about what it is generating. You have to read the documentation, you have to enable <code>-ddump-splices</code> to see the generated code. This is not very newbie-friendly.</p><p id="97eb" data-selectable-paragraph="">I don‚Äôt have a strong preference here, I‚Äôm just happy to whatever consensus we can have on the team. I don‚Äôt mind passing components manually and I wouldn‚Äôt mind using a typeclass. Another option would be to use the Template Haskell once to generate the code, paste it and then modify it manually as a component evolves.</p><p id="f7af" data-selectable-paragraph="">Damn, we can not have it all,‚Ä¶ in the current state of the art. We can also imagine an enhanced compiler, or enhanced tools giving us ways to expand or regenerate Template Haskell code. This is interesting. This means that there are some situations where our constraints are in complete opposition with each other: we cannot both encapsulate <em>and</em> expose the implementation of a component. We have to make choices. But there maybe some cases where we can eat our cake and have it too!</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>