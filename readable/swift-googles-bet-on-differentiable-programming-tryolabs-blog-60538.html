<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Swift: Google&#x2019;s bet on differentiable programming | Tryolabs Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Swift: Google&#x2019;s bet on differentiable programming | Tryolabs Blog - linksfor.dev(s)"/>
    <meta property="og:description" content="Google&#x27;s plans on making Swift the first mainstream language with first-class language-integrated differentiable programming capabilities. What&#x27;s so cool about Swift?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://tryolabs.com/blog/2020/04/02/swift-googles-bet-on-differentiable-programming/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Swift: Google&#x2019;s bet on differentiable programming | Tryolabs Blog</title>
<div class="readable">
        <h1>Swift: Google&#x2019;s bet on differentiable programming | Tryolabs Blog</h1>
            <div>Reading time: 37-47 minutes</div>
        <div>Posted here: 09 Apr 2020</div>
        <p><a href="https://tryolabs.com/blog/2020/04/02/swift-googles-bet-on-differentiable-programming/">https://tryolabs.com/blog/2020/04/02/swift-googles-bet-on-differentiable-programming/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  <article>

    

    <section>
      

<p>Two years ago, a small team at Google started working on making Swift the first mainstream language with <strong>first-class language-integrated differentiable programming</strong> capabilities. The scope and initial results of the project have been remarkable, and general public usability is not very far off.</p>

<p>Despite this, the project hasn’t received a lot of interest in the machine learning community and remains unknown to most practitioners. This can be attributed in part to the choice of language, which has largely been met with confusion and indifference, as Swift has almost no presence in the data science ecosystem and has mainly been used for building iOS apps.</p>

<p>This is unfortunate though, as even a cursory glance at Google’s project will show that it’s a massive and ambitious undertaking, which could establish Swift as a key player in the area. Furthermore, even though we mainly work with Python at Tryolabs, we think that choosing Swift was a superb idea, and decided to write this <em>short™</em> post to help spread the word about Google’s plans.</p>

<p>But before we get into Swift and what the term <em>differentiable programming</em> actually means, we should first review the current state of affairs.</p>

<p><span> Due to the popularity of the post,</span>
    <span> we will be hosting a Swift for ML live webinar.</span>
    <span>Register to be notified when date &amp; time are confirmed.</span>
    <a href="#sign-up-form-swift" onmouseover="this.style.background='#74A534';" onmouseout="this.style.background='#9ACB00';">Be updated</a>
</p>

<h2 id="what-is-wrong-with-you-python">What is wrong with you, Python?!</h2>

<p>Python is by far the most used language in machine learning, and Google has a ton of machine learning libraries and tools written in it. So, why Swift? What’s wrong with Python?</p>

<p>To put it bluntly, Python is <strong>slow</strong>. Also, Python is <a href="https://wiki.python.org/moin/GlobalInterpreterLock">not great for parallelism</a>.</p>

<p>To get around these facts, most machine learning projects run their compute-intensive algorithms via libraries written in C/C++/Fortran/CUDA, and use Python to <em>glue</em> the different low-level operations together. For the most part, this has worked really well, but as with all abstractions, it can create some problems. Let’s go over some of those.</p>

<h3 id="external-binaries">External binaries</h3>

<p>Calling external binaries for every compute-intensive operation limits developers to working on a small portion of the algorithm’s surface area. Writing a custom way to perform convolutions, for example, becomes off limits unless the developer is willing to step down into a language like C. Most programmers choose not to do so, either because they have no experience with writing low level performant code, or because jumping back and forth between Python’s development environment and some low level language’s environment becomes too cumbersome to justify.</p>

<p>This leads to the unfortunate situation in which programmers are motivated to write the least amount of sophisticated code they can, and default to calling external library operations. This is the opposite of what’s desirable in an area as dynamic as machine learning, where so much is still not settled, and new ideas are very much needed.</p>

<h3 id="library-abstractions">Library abstractions</h3>

<p>Having your Python code call lower level code is not as easy as mapping Python’s functions to C functions. The unfortunate reality is that the creators of machine learning libraries have had to make certain development choices in the name of performance, and that has complicated matters a bit. For example, in <a href="https://www.tensorflow.org/api_docs/python/tf/Graph">Tensorflow graph mode</a>, which is the only performant mode in the library, your Python code doesn’t generally run when you think it would. Python actually acts as a sort of metaprogramming language for the underlying Tensorflow graph.</p>

<p>The development flow is as follows: the developer first defines the network using Python, then the TensorFlow backend uses this definition to build the network and compile it into a blob whose internals the developer can no longer access. After compilation, the network is finally ready to run, and the developer can start feeding it data for training/inference jobs. This way of working makes debugging quite hard, as you can’t use Python to dig into what’s happening inside your network as it runs. You can’t use something like <code>pdb</code>. Even if you wish to engage in good old print debugging, you’ll have to use <code>tf.print</code> and build a print node into your network, which has to connect to another node in your network, and be compiled before anything can be printed.</p>

<p>More straightforward solutions exist, though. In <a href="https://pytorch.org/">PyTorch</a>, your code runs imperatively as is expected in Python, and the only non transparent abstraction is that the operations that run on the GPU execute asynchronously. This is generally a non-issue as PyTorch is smart about this and waits for all the async calls that are dependencies of any user interactive operations to finish before ceding control. Still, this is something to keep in mind, especially with things such as benchmarking.</p>

<h3 id="industry-lag">Industry lag</h3>

<p>All these usability problems aren’t just making it more difficult to write code, they are unnecessarily causing the industry to <strong>lag behind academia</strong>. There have been several papers that tweak low level operations used in neural networks, introducing improvements in accuracy of a few percentage points in the process, and have still taken a long time for the industry to adopt.</p>

<p>One reason for this is that even though these algorithmic changes tend to be quite simple themselves, the tooling problems mentioned above make them extremely difficult to implement. Hence, they may not be deemed worth the effort for what often results in only a 1% improvement in accuracy. This is especially problematic for small machine learning dev shops that usually lack the economies of scale to justify paying for their implementation/integration.</p>

<p>Therefore, companies tend to ignore these improvements until they get added to a library like PyTorch or TensorFlow. This saves them the implementation and integration costs, but it also causes industry to lag behind academia by 1 or 2 years, as the library maintainers can’t be expected to immediately implement the findings of every new paper that is published.</p>

<p>One concrete example of this issue are <a href="https://arxiv.org/pdf/1703.06211.pdf">Deformable Convolutions</a>, which seem to improve the performance of most Convolutional Neural Networks (CNNs). An open source implementation appeared about 2 years ago. Nevertheless, the implementation was cumbersome to integrate into PyTorch/TensorFlow and the algorithm didn’t gain widespread use. Only just recently has PyTorch <a href="https://github.com/pytorch/vision/pull/1586">added support</a> for it, and as of yet I am not aware of there being an official TensorFlow version.</p>

<p>Now, let’s say this happens for several papers that each contribute a performance enhancement of 2%; the industry could be <strong>missing out on significant accuracy improvements</strong> of <em>1.02^n%</em> for no reason other than inadequate tooling. This is regrettable, considering the <em>n</em> could be quite high.</p>

<h3 id="speed">Speed</h3>

<p>Using Python + fast libraries can still be slow in some cases. Yes, for CNNs running classification on images, using Python and PyTorch/TensorFlow will be really fast. What’s more, there is probably not much performance to be gained by coding your whole network in CUDA, as most of the inference time is spent on big convolutions that are already running in well-optimized implementations. This isn’t always the case though.</p>

<p>Networks that consist of many <strong>small operations</strong> are often the most susceptible to taking <strong>performance hits</strong>, if they are not fully implemented in a low level language. As an example, in a <a href="https://www.fast.ai/2019/03/06/fastai-swift/">blogpost</a> in which he professes his love for using Swift for deep learning, <a href="https://www.fast.ai/">Fast.AI</a>’s <a href="http://twitter.com/jeremyphoward">Jeremy Howard</a> reports that despite using PyTorch’s great JIT compiler, he still couldn’t make a particular RNN work as fast as a version completely implemented in pure CUDA.</p>

<p>Furthermore, Python is not a very good language for cases where <strong>latency</strong> is important, nor for very <strong>low level tasks</strong> such as communicating with sensors. The way some companies choose to get around this is to start by developing their models in PyTorch/TensorFlow-Python. In this way, they take advantage of Python’s ease of use when experimenting with and training new models. After this, they <a href="https://twitter.com/elonmusk/status/1224182478501482497">rewrite their model in C++</a> for production purposes. I’m not sure if they rewrite it completely, or if they simply serialize it using PyTorch’s tracing functionality or TensorFlow’s graph mode, and then rewrite the Python code around it in C++. Either way, a lot of Python code would need to be rewritten, which oftentimes is too costly for small companies to do.</p>

<p>All these problems are well known. <a href="https://twitter.com/ylecun">Yann LeCun</a>, who is widely considered one of the godfathers of deep learning, has stated that there is a need for a new machine learning language. In a <a href="https://twitter.com/jeremyphoward/status/1097799892167122944">twitter thread</a> PyTorch co-creator Soumith Chintala and him discussed several languages as possible candidates, with Julia, Swift, and even improving Python being mentioned. On the other hand, Fast AI’s Jeremy Howard seems to be decidedly on the Swift train.</p>

<h2 id="google-accepts-the-challenge">Google accepts the challenge</h2>

<p>Lucky for us, Google’s <a href="https://www.tensorflow.org/swift">Swift for Tensorflow</a> (S4TF) team took the matter into their own hands. What’s even better, they have been remarkably transparent about the whole process. In an <a href="https://github.com/tensorflow/swift/blob/master/docs/WhySwiftForTensorFlow.md">extremely thorough document</a>, they detail the journey that got them to this decision, explaining what languages they considered for the task and why they ended up using Swift.</p>

<p>Most notably, they considered:</p>

<ul>
<li><p><a href="https://golang.org/">Go</a>: In the document, they state that Go relies too heavily on the dynamic dispatching that its interfaces provide, and that they would have had to make big changes to the language in order to implement the features they wanted. This goes against Go’s philosophy of being simple and having a small surface area. Conversely, Swift’s protocols &amp; extensions afford a lot of freedom in terms of how static you want your dispatch to be. Also, the language is quite complex (and <a href="https://forums.swift.org/t/function-builders/25167">getting more complex every day</a>), so making it a bit more complex to accommodate the features that Google wanted wouldn’t pose as big of a problem.</p></li>

<li><p>C++ &amp; <a href="https://www.rust-lang.org/">Rust</a>: Google’s targeted user base is people who are used to working in Python for the most part, and who are more interested in spending their time thinking about the model and the data rather than thinking about things like the careful management of memory allocation or ownership. Rust and C++ have a level of complexity and attention to low level detail that is generally not justifiable when doing data science/machine learning development.</p></li>

<li><p><a href="https://julialang.org/">Julia</a>: If you read any <a href="https://news.ycombinator.com/">HackerNews</a> or <a href="https://www.reddit.com/r/S4TF/">Reddit threads</a> about S4TF, the first comment usually is, “Why didn’t they choose Julia?”. In the previously mentioned document, Google mentions that Julia looked promising too, but they didn’t really provide a solid reason as to why they didn’t go for it. They mentioned that Swift has a much larger community than Julia, which is true, but Julia’s scientific and data science communities are much larger than Swift’s, and these are arguably the communities that would make more use of S4TF. Something to keep in mind is that Google’s team had more expertise in Swift, given that Swift’s creator <a href="https://twitter.com/clattner_llvm?lang=en">Chris Lattner</a> started the project, so this probably played a big part in the decision.</p></li>

<li><p>A new language: I think they said it best in the manifesto: “Creating a language is a ridiculous amount of work”. This would take too long, and machine learning is moving way too fast.</p></li>
</ul>

<h2 id="what-s-so-cool-about-swift-then">What’s so cool about Swift, then?</h2>

<p>In short, Swift allows you to program at a very high level, in an almost Pythonic way, while at the same time being really fast. A data scientist could use Swift in much the same way as they use Python, while someone working in an optimized machine learning library built in Swift could be more careful about how they manage their memory, and could even drop down to the pointer level of abstraction when idiomatic Swift is too restrictive.</p>

<p>Providing a detailed description of the language is probably overkill for the purpose of this article. The <a href="https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html">official documentation</a> already does a much better job than I ever could. Instead, I’ll describe a few things that I found to be cool about Swift as a new fan of the language, in hopes that this will entice people to try it. The following chapters will be an assortment of random cool things about Swift, in no particular order, and with no particular attention paid to their overall significance. After these, I’ll delve into differentiable programming and Google’s big plan for Swift.</p>

<h3 id="cool-thing-number-one">Cool thing number one</h3>

<p>It’s fast. This is the first thing I tested when I got started with Swift. I wrote a few short scripts to evaluate how well it would fare against Python and C. These tests are not particularly sophisticated, to be honest. They just fill an array with integers and then add them all up. This by itself is not a very thorough way of testing how fast idiomatic Swift is, but I was curious if Swift could <em>ever</em> be as fast as C, not if Swift would <em>always</em> be as fast as C.</p>

<p>For the first comparison, I went with Swift vs Python. I took some artistic liberties with curly brace placement in Swift so that each line is basically doing the same thing in both cases.</p>

<div><pre><code data-lang="swift"><span>import</span> <span>time</span>                    <span>|</span> <span>import</span> <span>Foundation</span>
                               <span>|</span>
result = []                    <span>|</span> <span>var</span> result = [Int]()
<span>for</span> it <span>in</span> range(<span>15</span>):           <span>|</span> <span>for</span> it <span>in</span> <span>0.</span>.&lt;<span>15</span> {
    start = time.time()        <span>|</span>     <span>let</span> start = CFAbsoluteTimeGetCurrent()
    <span>for</span> <span>_</span> <span>in</span> range(<span>3000</span>):      <span>|</span>     <span>for</span> <span>_</span> <span>in</span> <span>0.</span>.&lt;<span>3000</span> {
        result.append(it)      <span>|</span>         result.append(it)}
    sum_ = sum(result)         <span>|</span>     <span>let</span> sum = result.reduce(<span>0</span>, <span>+</span>)
    end = time.time()          <span>|</span>     <span>let</span> end = CFAbsoluteTimeGetCurrent()
    print(end <span>-</span> start, sum_)   <span>|</span>     print(end <span>-</span> start, sum)
    result = []                <span>|</span>     result = []}</code></pre></div>

<p>Although their syntax is very similar in this particular snippet, the Swift script proves to be 25 times faster than the Python one. Each outermost loop in the Python script completes in 360μs on average, vs 14μs for Swift. This is quite an improvement.</p>

<p>There are yet other interesting things to note. Namely, <code>+</code> is an operator as well as a function that gets passed to <code>reduce</code> (which I’ll elaborate on later), <code>CFAbsoluteTimeGetCurrent</code> reveals Swift’s quirks regarding legacy iOS namespaces, and the <code>..&lt;</code> range operator lets you choose if the range is inclusive, and on which end.</p>

<p>This test doesn’t really tell us how fast Swift can be, though. To find that out, we need to compare it to C. So, that’s what I did, and much to my disappointment, the initial results weren’t good. The version <a href="https://gist.github.com/joaqo/e019b00ba0dae567bf7d66ee971f7c9e">written in C</a> took an average of 1.5μs, which is ten times faster than our Swift code. Uh oh.</p>

<p>To be fair, this isn’t a terribly honest comparison. The Swift script is using a dynamic array, which is getting repeatedly reallocated in the heap as it increases in size. This also means it’s performing bound checking on each append. To corroborate this, we can go look at its definition. Swift standard types like int, float, and array are not hardcoded into the compiler, they are structs defined in the standard library. Thus, according to the array’s <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Array.swift#L1148">append definition</a>, we see there’s a lot going on. Knowing this, I evened the playing field by preallocating the array’s memory and using a pointer for filling the array. The resulting script is not much longer:</p>

<div><pre><code data-lang="swift"><span>import</span> <span>Foundation</span>

<span>// Preallocating memory</span>
<span>var</span> result = ContiguousArray&lt;Int<span>&gt;</span>(repeating: <span>0</span>, count: <span>3001</span>)
<span>for</span> it <span>in</span> <span>0.</span>.&lt;<span>15</span> {
    <span>let</span> start = CFAbsoluteTimeGetCurrent()

    <span>// Using a buffer pointer for assignment</span>
    result.withUnsafeMutableBufferPointer({ buffer <span>in</span>
        <span>for</span> i <span>in</span> <span>0.</span>.&lt;<span>3000</span> {
            buffer[i] = it
        }
    })
    <span>let</span> sum = result.reduce(<span>0</span>, <span>+</span>)
    <span>let</span> end = CFAbsoluteTimeGetCurrent()
    print(end <span>-</span> start, sum)</code></pre></div>

<p>This new code takes 3μs, so it’s now half as fast as C, which is already a good place to be in. Just for the sake of completeness, though, I continued profiling the code in order to find what the difference with the C version was. It turns out that the <code>reduce</code> method I was using is performing some <a href="https://github.com/apple/swift/blob/06f82a53b5da26b67a8fd9414d8f8877eca8a3e1/stdlib/public/core/SequenceAlgorithms.swift#L576">unnecessary indirection</a> with the usage of a <code>nextPartialResult</code> function, which is providing nonessential generalization. After rewriting it utilizing a pointer, I finally got it to C speed. However, this obviously defeats the purpose of using Swift, since at this point we are just writing more verbose and uglier C. Nevertheless, it’s good to know that you can get C speed if you really need it.</p>

<p>To sum up: you won’t get C speed with a Python amount of work, but you will get a great tradeoff between the two.</p>

<h3 id="cool-thing-número-dos">Cool thing número dos</h3>

<p>Swift has taken an interesting approach to function signatures. In their most basic form, they are relatively simple:</p>

<div><pre><code data-lang="swift"><span>func</span> <span>greet</span>(person: String, town: String) -&gt; String {
    <span>return</span> <span>"Hello </span><span>(</span>person<span>)</span><span>!  Glad you could visit from </span><span>(</span>town<span>)</span><span>."</span>
}

greet(person: <span>"Bill"</span>, town: <span>"Cupertino"</span>)</code></pre></div>

<p>The function signature consists of the parameter names followed by their types; nothing too fancy. The only unusual thing is that Swift requires you to provide the parameter names when calling the function, so you have to write <code>person</code> and <code>town</code> when calling <code>greet</code>, as evidenced by the last line of the snippet above.</p>

<p>Things get more interesting when we introduce something called <em>argument labels</em> into the mix.</p>

<div><pre><code data-lang="swift"><span>func</span> <span>greet</span>(<span>_</span> person: String, from town: String) -&gt; String {
    <span>return</span> <span>"Hello </span><span>(</span>person<span>)</span><span>!  Glad you could visit from </span><span>(</span>town<span>)</span><span>."</span>
}

greet(<span>"Bill"</span>, from: <span>"Cupertino"</span>)</code></pre></div>

<p>Argument labels are just what they sound like: they are labels for your function’s parameters, and they are declared before their respective parameter in the function’s signature. In the sample above <code>from</code> would be <code>town</code>’s argument label, and <code>_</code> would be <code>person</code>’s argument label. I used <code>_</code> for this last label because <code>_</code> is a special case in Swift that means, “don’t provide any argument name when calling this parameter.”</p>

<p>With argument labels, every parameter gets 2 different names: an argument label, which is used for calling the function, and a parameter name, which is used inside the function’s body definition. This may seem a bit arbitrary, but it makes your code easier to read.</p>

<p>If you look at the function signature above, it’s almost like reading English: “Greet person from town.” The function call is just as descriptive: “Greet Bill from Cupertino.” Without argument labels, things become a bit more ambiguous: “Greet person town.” We don’t know what <code>town</code> stands for. Is that the town we are in now? Is that the town in which we are going to meet the person? Or is it the town where the person is originally from? Without argument labels we would have to read the function’s body to know what’s happening, or resort to making the function name or the parameter names longer and more descriptive. This can get complicated if you have lots of parameters, and in my opinion tends to result in uglier code and needlessly long function names. Argument labels are prettier and scale better, and luckily, they are used extensively in Swift.</p>

<h3 id="the-third-of-the-cool-things">The third of the cool things</h3>

<p>Swift makes extensive use of closures. Therefore, it has some shortcuts to make their usage more ergonomic. This example taken from the language’s documentation highlights how concise and expressive these shortcuts can make Swift look.</p>

<p>Let’s take an array that we want to sort backwards:</p>

<div><pre><code data-lang="swift"><span>let</span> names = [<span>"Chris"</span>, <span>"Alex"</span>, <span>"Ewa"</span>, <span>"Barry"</span>, <span>"Daniella"</span>]</code></pre></div>

<p>The less idiomatic way of doing this would be to use Swift’s <code>sorted</code> method for arrays, and employ a custom function that tells it how to do pairwise order comparison on the array’s elements, like so:</p>

<div><pre><code data-lang="swift"><span>func</span> <span>backward</span>(<span>_</span> s1: String, <span>_</span> s2: String) -&gt; Bool {
    <span>return</span> s1 <span>&gt;</span> s2
}
<span>var</span> reversedNames = names.sorted(by: backward)</code></pre></div>

<p>The <code>backward</code> function compares two items at once, and returns true if they are in the desired order and false if they are not. The <code>sorted</code> array method expects such a function as an input in order to know how to sort the array. As a side note, here we can also see the usage of the <em>argument label</em> <code>by</code>, which is oh so beautifully terse.</p>

<p>If we resort to more idiomatic Swift, we find that there is a better way to do this using closures:</p>

<div><pre><code data-lang="swift">reversedNames = names.sorted(by: { s1, s2 <span>in</span> <span>return</span> s1 <span>&gt;</span> s2 } )</code></pre></div>

<p>The code between <code>{</code> <code>}</code> is a closure that is being defined and passed as an argument to<code>sorted</code> at the same time. If you’ve never heard of them, closures are just unnamed functions which capture their context. A good way to think about them is as Python lambdas on steroids. The keyword <code>in</code> in the closure is used to separate the closure’s arguments and its body. More intuitive keywords such as <code>:</code> were already taken for signature type definitions (the closure’s argument types get automatically inferred from <code>sorted</code>’s signature in this case, so they can be avoided), and we all know naming things is one of the hardest things to do in programming, so we are stuck with using the not so intuitive <code>in</code> keyword for this.</p>

<p>In any case, the code is already looking more concise.</p>

<p>We can, however, do better:</p>

<div><pre><code data-lang="swift">reversedNames = names.sorted(by: { s1, s2 <span>in</span> s1 <span>&gt;</span> s2 } )</code></pre></div>

<p>We removed the return statement here because, in Swift, single line closures implicitly return.</p>

<p>Still, we can go even deeper:</p>

<div><pre><code data-lang="swift">reversedNames = names.sorted(by: { $0 <span>&gt;</span> $1 } )</code></pre></div>

<p>Swift also has implicitly named positional parameters, so in the above case <code>$0</code> is the first argument, <code>$1</code> the second, <code>$2</code> would be the third, and so on. The code is already compact and easy to understand, but we can do better yet:</p>

<div><pre><code data-lang="swift">reversedNames = names.sorted(by: <span>&gt;</span>)</code></pre></div>

<p>In Swift, the <code>&gt;</code> operator is just a function named <code>&gt;</code>. Therefore, we can pass it to our <code>sorted</code> method, making our code extremely concise and readable.</p>

<p>This also applies to operators like <code>+=</code>,<code>-=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, and <code>=</code>, and you’ll find their <a href="https://github.com/apple/swift/blob/06f82a53b5da26b67a8fd9414d8f8877eca8a3e1/stdlib/public/core/Integers.swift#L133">definition</a> in the standard library. The difference between these functions/operators and normal functions is that the former have been explicitly declared as operators using the <code>infix</code>, <code>prefix</code> or <code>suffix</code> keywords in the standard library. For instance, the <code>+=</code> function is defined as an operator on <a href="https://github.com/apple/swift/blob/1ed846d8525679d2811418a5ba29405200f6e85a/stdlib/public/core/Policy.swift#L468">this line</a> of the Swift standard library. You can see that the operator conforms to several different protocols such as <code>Array</code> and <code>String</code>, as many different types have their own implementation of the <code>+=</code> function.</p>

<p>Of further interest is that we can define our own custom operators. One great example of this is in the <a href="https://github.com/BradLarson/GPUImage2">GPUImage2</a> library. The library allows users to load a picture, modify it with a sequence of transformations, and then output it in some way. Naturally, the definition of these sequences of transformations shows up repeatedly in the library, so the library’s creator decided to define a new operator called <code>--&gt;</code> that would be used to chain these transformations together:</p>

<div><pre><code data-lang="swift"><span>func</span> <span>--&gt;</span>(source:T, destination:T) -&gt; T {
    source.addTarget(destination)
    <span>return</span> destination
}

<span>infix</span> <span>operator</span> <span>--&gt;</span> : AdditionPrecedence</code></pre></div>

<p>In the slightly simplified code above, the <code>--&gt;</code> function is first declared, and then defined as an <code>infix</code> operator. Infix just means that to use the operator, you must place it between its two arguments. This allows you to write code such as the following:</p>

<div><pre><code data-lang="swift"><span>let</span> testImage = UIImage(named:<span>"WID-small.jpg"</span>)<span>!</span>
<span>let</span> toonFilter = SmoothToonFilter()
<span>let</span> luminanceFilter = Luminance()

<span>let</span> filteredImage = testImage.filterWithPipeline{input, output <span>in</span>
    input <span>--&gt;</span> toonFilter <span>--&gt;</span> luminanceFilter <span>--&gt;</span> output  <span>// Interesting part</span>
}</code></pre></div>

<p>The above is shorter and easier to understand than a bunch of chained methods, or a series of<code>source.addTarget(...)</code> functions.</p>

<h3 id="the-fourth-of-the-cool-things">The fourth of the cool things</h3>

<p>Previously, I mentioned that the basic Swift types were structs defined in the standard library, and not hardcoded into the compiler as they usually are in other languages. One reason this is useful is that it lets us use a Swift feature called <code>extension</code>, which allows us to add new functionality to any type, including the basic types. Here is how this can play out:</p>

<div><pre><code data-lang="swift"><span>extension</span> <span>Double</span> {
    <span>var</span> radians: Double {
        <span>return</span> <span>self</span> <span>*</span> (Double.pi <span>/</span> <span>180</span>)
    }
}

<span>360.</span>radians <span>// -&gt; 6.28319</span></code></pre></div>

<p>Though not particularly useful, this example shows how extensible the language is, as it lets you do things such as typing any number into a Swift interpreter, and call any custom method you want on it.</p>

<h3 id="last-one">Last one</h3>

<p>On top of having a compiler, Swift also has an interpreter and support for <a href="https://jupyter.org/">Jupyter Notebooks</a>. The interpreter is particularly great for learning the language, as it allows you to type <code>swift</code> at your command prompt and start trying out code right away, much in the same way you would with Python. On the other hand, the integration with Jupyter Notebooks is awesome for visualizing data, performing data exploration, and writing reports. Finally, when you want to run production code, you can compile it and take advantage of the great optimization <a href="https://llvm.org/">LLVM</a> provides.</p>

<h2 id="google-s-master-plan">Google’s master plan</h2>

<p>I mentioned quite a few features in the paragraphs above, but there’s one feature that stands apart from the others: Jupyter support is very new, and was in fact added by the S4TF team. This is noteworthy because it gives us an idea of what Google’s state of mind is when working on this project: they don’t just want to create a library for Swift, they want to deeply improve the Swift language itself, along with its tooling, and then build a new Tensorflow library using this improved version of the language.</p>

<p>This point is illustrated best by observing where the S4TF team has been spending most of its time. The majority of the work they’ve done has been on Apple’s Swift compiler repository itself. More specifically, most of the work Google has been doing lies in a <a href="https://github.com/apple/swift/tree/tensorflow">dev branch</a> inside the Swift compiler repo. Google is adding new features to the Swift language, first creating and testing them in their own branch and then merging them into Apple’s master branch. This means that the standard Swift language running on iOS devices all around the world will eventually incorporate these improvements.</p>

<p>Now, on to the juicy part: What are the features that Google is building into Swift?</p>

<p>Let’s start with the big one.</p>

<h2 id="differentiable-programming">Differentiable programming</h2>

<p>Lately, there’s been a lot of hype surrounding differentiable programming. Tesla’s director of AI, Andrej Karpathy, <a href="https://medium.com/@karpathy/software-2-0-a64152b37c35">has called it Software 2.0</a>, while Yan LeCun <a href="https://www.facebook.com/yann.lecun/posts/10155003011462143">has proclaimed</a>: “Deep Learning est mort. Vive Differentiable Programming.” Others claim there will be a need for the creation of a whole new set of new tools, such as a new Git, new IDEs, and of course new programming languages. Wink wink.</p>

<p>So, what is differentiable programming?</p>

<p>In a nutshell, differentiable programming is a programming paradigm in which your program itself can be differentiated. This allows you to set a certain objective you want to optimize, have your program automatically calculate the gradient of itself with regards to this objective, and then fine-tune itself in the direction of this gradient. This is exactly what you do when you train a neural network.</p>

<p>The most compelling thing about having a program tune itself is that it allows us to create the sorts of programs we seem to be completely incapable of programming by ourselves. An interesting way to think about this is that your program using its gradients to tune itself for a certain task is <a href="https://twitter.com/karpathy/status/893576281375219712">better at programming than you are</a>. These past few years have shown that this is indeed true for an ever increasing number of cases, with no clear end to that growth in sight.</p>

<h3 id="a-differentiable-language">A differentiable language</h3>

<p>After that really long introduction, it’s finally time to introduce Google’s vision of how native differentiable programming will look in Swift:</p>

<div><pre><code data-lang="swift"><span>func</span> <span>cube</span>(<span>_</span> x: Float) -&gt; Float {
    <span>return</span> x <span>*</span> x <span>*</span> x
}

<span>let</span> cube<span>𝛁</span> = gradient(of: cube)
cube(<span>2</span>)   <span>// 8.0</span>
cube<span>𝛁</span>(<span>2</span>)  <span>// 12.0</span></code></pre></div>

<p>Here we start by defining a simple function named <code>cube</code>, which returns the cube of its input. Next comes the exciting part: we create the derivative function of our original function, merely by calling <code>gradient</code> on it. There are no libraries or external code being used here, <code>gradient</code> is simply a new function that is being introduced by the S4TF team into the Swift language. This function takes advantage of the changes the team made to Swift’s core, in order to automatically calculate gradient functions.</p>

<p>This is Swift’s big new feature. You can take arbitrary Swift code and, as long as it’s differentiable, automatically calculate its gradient. The code above has no imports or weird dependencies, it’s just plain Swift. If you’ve ever used PyTorch, TensorFlow, or any of the other big machine learning libraries, they all support this feature, but only if you’re using their particular library specific operations. What’s more, working with gradients in these Python libraries is not as lightweight, transparent, or well integrated as it is in plain Swift.</p>

<p>This is a massive new feature of the language and, as far as I can tell, Swift is the first mainstream language that has native support for such a thing.</p>

<p>To further illustrate how this would look in the real world, the following script is a more thorough example of this new feature, applied to a standard machine learning training workflow:</p>

<div><pre><code data-lang="swift"><span>struct</span> <span>Perceptron</span>: @memberwise Differentiable {
    <span>var</span> weight: SIMD2&lt;Float<span>&gt;</span> = .random(<span>in</span>: <span>-</span><span>1.</span>.&lt;<span>1</span>)
    <span>var</span> bias: Float = <span>0</span>

    @differentiable
    <span>func</span> <span>callAsFunction</span>(<span>_</span> input: SIMD2&lt;Float<span>&gt;</span>) -&gt; Float {
        (weight <span>*</span> input).sum() <span>+</span> bias
    }
}

<span>var</span> model = Perceptron()
<span>let</span> andGateData: [(x: SIMD2&lt;Float<span>&gt;</span>, y: Float)] = [
    (x: [<span>0</span>, <span>0</span>], y: <span>0</span>),
    (x: [<span>0</span>, <span>1</span>], y: <span>0</span>),
    (x: [<span>1</span>, <span>0</span>], y: <span>0</span>),
    (x: [<span>1</span>, <span>1</span>], y: <span>1</span>),
]
<span>for</span> <span>_</span> <span>in</span> <span>0.</span>.&lt;<span>100</span> {
    <span>let</span> (loss, <span>𝛁</span>loss) = valueWithGradient(at: model) { model -&gt; Float <span>in</span>
        <span>var</span> loss: Float = <span>0</span>
        <span>for</span> (x, y) <span>in</span> andGateData {
            <span>let</span> <span>ŷ</span> = model(x)
            <span>let</span> error = y <span>-</span> <span>ŷ</span>
            loss = loss <span>+</span> error <span>*</span> error <span>/</span> <span>2</span>
        }
        <span>return</span> loss
    }
    print(loss)
    model.weight <span>-=</span> <span>𝛁</span>loss.weight <span>*</span> <span>0.02</span>
    model.bias <span>-=</span> <span>𝛁</span>loss.bias <span>*</span> <span>0.02</span>
}</code></pre></div>

<p>Again, the above code is all plain Swift with no external dependencies. In this snippet, we see that Google has introduced two new Swift features: <code>callAsFunction</code> and <code>valueWithGradient</code>. The first one is quite simple, it lets us instantiate classes and structs, and then call them as if they were functions. Here the <code>Perceptron</code> struct gets instantiated as <code>model</code>, and then <code>model</code> gets called as a function in <code>let ŷ = model(x)</code>. When you do this, <code>callAsFunction</code> is the method actually being called. If you’ve ever used Keras or PyTorch models, you know that this is quite a common way of handling models/layers. While these two libraries use Python’s <code>__call__</code> method to implement their <code>call</code> and <code>forward</code> methods, respectively, Swift had no such feature, and thus Google had to add it.</p>

<p>The other interesting new feature in the above script is <code>valueWithGradient</code>. This function returns the resulting value and gradient of a function or closure, evaluated at a particular point. In the case above, the closure we define and use as input for <code>valueWithGradient</code> is actually our loss function. This loss function takes our model as an input, so when we say that <code>valueWithGradient</code> will evaluate our function at a particular point, we mean that it will evaluate our loss function with our model in a particular weight configuration. After we have calculated the aforementioned value and gradient, we print the value (which is our loss), and update our model’s weights using the gradients. Repeat this a hundred times and we have a trained model. You’ll notice that we can access <code>andGateData</code> inside our loss function, which is an example of Swift closures being able to capture their enclosing context.</p>

<h3 id="differentiating-external-code">Differentiating external code</h3>

<p>Another fantastic feature is that not only can we differentiate Swift operations, but we can also differentiate operations in external, non-Swift libraries, if we manually tell Swift what their derivatives are. This means you can use a C library with a very fast implementation of some operation not currently present in Swift, import it into your project, code the derivative, and then use this operation in your big neural network and have things like backpropagation work seamlessly.</p>

<p>What’s more, making this happen is really simple:</p>

<div><pre><code data-lang="swift"><span>import</span> <span>Glibc</span>  <span>// we import pow and log from here</span>

<span>func</span> <span>powerOf2</span>(<span>_</span> x: Float) -&gt; Float {
    <span>return</span> pow(<span>2</span>, x)
}

@derivative(of: powerOf2)
<span>func</span> <span>dPowerOf2d</span>(<span>_</span> x: Float) -&gt; (value: Float, pullback: (Float) -&gt; Float) {
    <span>let</span> d = powerOf2(x) <span>*</span> log(<span>2</span>)
    <span>return</span> (value: d, pullback: { v <span>in</span> v <span>*</span> d })
}

powerOf2(<span>3</span>),               <span>// 8</span>
gradient(of: powerOf2)(<span>3</span>)  <span>// 5.545</span></code></pre></div>

<p>Glibc is a C library, so the Swift compiler doesn’t know what the derivatives of its operations are. We can give the compiler this information by using <code>@derivative</code> and then use these external operations along with our native operations to form big differentiable networks very easily. In the example, we import <code>pow</code> and <code>log</code> from Glibc and use them to create a <code>powerOf2</code> function and its derivative.</p>

<p>The current incarnation of the new TensorFlow library for Swift is being built using this feature. The library imports all of its operations from the C API of the TF Eager library, but instead of plugging into TensorFlow’s automatic differentiation system, it <a href="https://github.com/tensorflow/swift-apis/blob/27c9f333960512668e805c2472e693cfc2a601c6/Sources/TensorFlow/Operators/NN.swift#L135">specifies the derivative of each basic operation</a> and lets Swift handle it. This isn’t required for all operations, though, as many are compositions of more basic operations, and therefore Swift can automatically infer their derivatives. Basing the current version of the library on TF Eager does, however, have one big downside: TF Eager is really slow, and therefore the Swift version is too. This seems to be a temporary problem which is getting fixed with the incorporation of <a href="https://www.tensorflow.org/xla">XLA</a> (through x10) and <a href="https://blog.tensorflow.org/2019/04/mlir-new-intermediate-representation.html">MLIR</a>.</p>

<p>Having said this, using this temporary solution is allowing Google’s devs to work on the Swift TensorFlow API, which is really starting to take shape. This is how a simple model training job looks:</p>

<div><pre><code data-lang="swift"><span>import</span> <span>TensorFlow</span>

<span>let</span> hiddenSize: Int = <span>10</span>
<span>struct</span> <span>IrisModel</span>: Layer {
    <span>var</span> layer1 = Dense&lt;Float<span>&gt;</span>(inputSize: <span>4</span>, outputSize: hiddenSize, activation: relu)
    <span>var</span> layer2 = Dense&lt;Float<span>&gt;</span>(inputSize: hiddenSize, outputSize: hiddenSize, activation: relu)
    <span>var</span> layer3 = Dense&lt;Float<span>&gt;</span>(inputSize: hiddenSize, outputSize: <span>3</span>)

    @differentiable
    <span>func</span> <span>callAsFunction</span>(<span>_</span> input: Tensor&lt;Float<span>&gt;</span>) -&gt; Tensor&lt;Float<span>&gt;</span> {
        <span>return</span> input.sequenced(through: layer1, layer2, layer3)
    }
}

<span>var</span> model = IrisModel()
<span>let</span> optimizer = SGD(<span>for</span>: model, learningRate: <span>0.01</span>)
<span>let</span> (loss, grads) = valueWithGradient(at: model) { model -&gt; Tensor&lt;Float<span>&gt;</span> <span>in</span>
    <span>let</span> logits = model(firstTrainFeatures)
    <span>return</span> softmaxCrossEntropy(logits: logits, labels: firstTrainLabels)
}
print(<span>"Current loss: </span><span>(</span>loss<span>)</span><span>"</span>)</code></pre></div>

<p>As you can tell, it’s very similar to the no-import model training script we previously saw. It has a very PyTorch-like design, which is great.</p>

<h3 id="python-interoperability">Python interoperability</h3>

<p>One issue that Swift will have to deal with is that its current machine learning and data science ecosystems are still in their infancy. Fortunately, Google is addressing this issue with the inclusion of Python interoperability in Swift. The idea is to make it possible to write Python code inside Swift code, and in this way have access to the huge quantity of great Python libraries.</p>

<p>A typical use case for this would be to train a model in Swift and use Python’s matplotlib to plot it:</p>

<div><pre><code data-lang="swift"><span>import</span> <span>Python</span>
print(Python.version)

<span>let</span> np = Python.<span>import</span>(<span>"numpy"</span>)
<span>let</span> plt = Python.<span>import</span>(<span>"matplotlib.pyplot"</span>)

<span>// let time = np.arange(0, 10, 0.01)</span>
<span>let</span> time = Array(stride(from: <span>0</span>, through: <span>10</span>, by: <span>0.01</span>)).makeNumpyArray()
<span>let</span> amplitude = np.exp(<span>-</span><span>0.1</span> <span>*</span> time)
<span>let</span> position = amplitude <span>*</span> np.sin(<span>3</span> <span>*</span> time)

plt.figure(figsize: [<span>15</span>, <span>10</span>])

plt.plot(time, position)
plt.plot(time, amplitude)
plt.plot(time, <span>-</span>amplitude)

plt.xlabel(<span>"Time (s)"</span>)
plt.ylabel(<span>"Position (m)"</span>)
plt.title(<span>"Oscillations"</span>)

plt.show()</code></pre></div>

<p>It looks like plain old Python with the addition of <code>let</code> and <code>var</code> statements. This is a code sample provided by Google. The only modification I made was to comment out one Python line and rewrite it in Swift, to be able to see how well they interface together. It’s not as clean as doing it all in Python, since I had to use <code>makeNumpyArray()</code> and <code>Array()</code> but it works, which is awesome.</p>

<p>Google managed to pull this off by introducing the <code>PythonObject</code> type, which can represent any object in Python. The Python interop project is contained in a single Swift library, so the S4TF team only needed to make a few additions to the Swift language itself, such as <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md">the addition</a> of some improvements to accommodate for Python’s extreme dynamism. With regards to how much Python it supports, I’ve yet to find out how they expect to manage more idiomatic Python elements such as <code>with</code> statements, and I am sure there are some other corner cases to be considered as well, but still, this is already an amazing feature as-is.</p>

<p>While on the subject of Swift’s integration with other languages, one of my initial interests in Swift was to determine how well it would fare with a real-time computer vision task. For this reason, I ended up looking for a Swift version of <a href="https://opencv.org/">OpenCV</a>, and through FastAI’s forum I ended up finding a promising OpenCV wrapper called <a href="https://github.com/vvmnnnkv/SwiftCV">SwiftCV</a>. This library is peculiar, though: OpenCV is built in C++ (and has just deprecated its C API), and Swift doesn’t currently support C++ <a href="https://forums.swift.org/t/manifesto-interoperability-between-swift-and-c/33874">(though it is coming)</a>. Hence, SwiftCV has had to resort to wrapping OpenCV’s code in a C compatible subset of C++ code, and then importing it as C. Only after this could they wrap it in Swift.</p>

<p>I decided to add video support to SwiftCV, as I needed it and the project didn’t have it at the time. I also wanted to test Swift’s C interop capabilities in a more complex situation than what the tutorials describe. Therefore, I submitted <a href="https://github.com/vvmnnnkv/SwiftCV/pull/5">this pull request</a>, which is a useful self-contained example of how Swift’s interop with C++ through a C wrapper looks. The process was painless, even for a Swift beginner such as myself, so props to the Swift devs for that.</p>

<h2 id="current-state-of-the-project">Current state of the project</h2>

<p>Even after all the praise I have showered the S4TF project with, I have to admit that it is still not ready for general production usage. The new APIs <a href="https://github.com/apple/swift/commit/7041e2716f41113e14ad19aeaf510ea77c778cc5">are still changing</a>, performance of the new TensorFlow library is still not great, and even though its data science ecosystem is growing, it’s still in its infancy. On top of that, Linux support is still flaky, with only Ubuntu being officially supported at the moment. With all that in mind, there is a lot of work going into ensuring all of these issues are promptly fixed.</p>

<p>Google is working hard on performance gains, including the recent <a href="https://github.com/tensorflow/swift-apis/pull/719">addition of x10</a> and the efforts being made on getting MLIR up to par. Also, there are several projects aimed at replicating a lot of the Python data science ecosystem in Swift that originated at Google, such as <a href="https://github.com/KarthikRIyer/swiftplot">SwiftPlot</a>, the Pandas-like <a href="https://github.com/saeta/penguin">Penguin</a>, and the Scikit-learn-like <a href="https://github.com/param087/swiftML">swiftML</a>, to name a few.</p>

<p>What is most surprising, though, is that Apple is moving Swift in the same direction as Google is. On <a href="https://forums.swift.org/t/on-the-road-to-swift-6/32862">their roadmap</a> for Swift’s next major version, they’ve established growing the Swift software ecosystem on non-Apple platforms as their primary objective. This is reflected by Apple’s support for several projects like the <a href="https://swift.org/server/">Swift Server Work Group</a>, the numpy like <a href="https://swift.org/blog/numerics/">Numerics</a>, an official <a href="https://github.com/apple/sourcekit-lsp">language server</a> which runs on Linux, and the work being done to port Swift to Windows.</p>

<p>Furthermore, <a href="https://twitter.com/guggersylvain">Sylvain Gugger</a> from Fast.ai is currently building a <a href="https://github.com/fastai/swiftai">Swift version of FastAI</a>, and Jeremy Howard has included lessons in Swift to their massively popular online course. Also, the first <a href="https://twitter.com/eaplatanios/status/1229856859408011264">academic papers</a> built on <a href="https://github.com/eaplatanios/swift-rl">S4TF based libraries</a> are starting to get published!</p>

<h2 id="conclusion">Conclusion</h2>

<p>In my personal opinion, while Swift has a huge chance of becoming a key player in the machine learning ecosystem, there are still risks. The biggest risk being that, in spite of its flaws, Python really is good enough for a huge portion of machine learning tasks. The inertia might be too large for many people who are already comfortable with Python and see no reason to switch over to another language. Additionally, there is the issue of Google having a well-deserved reputation for dropping large projects, and <a href="https://twitter.com/rxwei/status/1185412505775927296">some</a>-<a href="https://twitter.com/clattner_llvm/status/1221824735484362754">key</a>-<a href="https://twitter.com/eugene_burmako/status/1229825664032763904">departures</a> from the S4TF project are <a href="https://twitter.com/clattner_llvm/status/1222032740897284097">leaving people worried</a>.</p>

<p>Having provided these disclaimers, I still think that Swift is a great language, and the new additions are so innovative that it’s bound to eventually find its place in the machine learning community. Therefore, if you want to contribute to a project with enormous growth potential, now is a great time to start. Things are still not very established, there are a lot of tools that still need creating, and a small personal project now could become a huge community project in the future as the Swift machine learning ecosystem continues to grow.</p>






    </section>

    

    
    <hr>

    

    <div id="subscribe-form">
  
  
  

  

  <p><span>No spam, ever. We'll never share your email address and you can opt out at any time.</span>
</p></div>


    
  </article>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>