<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How SNES emulators got a few pixels from complete perfection - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How SNES emulators got a few pixels from complete perfection - linksfor.dev(s)"/>
    <meta property="article:author" content="byuu&#xA;        -  4/1/2020, 4:45 AM"/>
    <meta property="og:description" content="Bsnes needs your help to decode some three-decades-old PPU chips."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How SNES emulators got a few pixels from complete perfection</title>
<div class="readable">
        <h1>How SNES emulators got a few pixels from complete perfection</h1>
            <div>by byuu&#xA;        -  4/1/2020, 4:45 AM</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 02 Apr 2020</div>
        <p><a href="https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/">https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    <header>
      <h4>
      We're looking for perfection, not action    —
</h4>
      
      <h2 itemprop="description">Bsnes needs your help to decode some three-decades-old PPU chips.</h2>
      <section>

  
  


  
</section>    </header>

    <section>
      <div itemprop="articleBody">
        
<figure>
  <img src="https://cdn.arstechnica.net/wp-content/uploads/2020/03/bsnes-xray-cart-800x450.jpg" alt="We're so close to having an emulator that can perfectly recreate every single function of real SNES hardware and software.">
      <figcaption><p><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/bsnes-xray-cart.jpg" data-height="563" data-width="1000">Enlarge</a> <span>/</span> We're so close to having an emulator that can perfectly recreate every single function of real SNES hardware and software.</p><p>Aurich Lawson</p></figcaption>  </figure>

  




<!-- cache hit 1051:single/related:dbe4613475e9b326988d1cd5f1229f76 --><!-- empty -->
<p>As the lead coder of <em>bsnes</em>, I've been attempting to perfect Super Nintendo emulation <a href="https://arstechnica.com/gaming/2011/08/accuracy-takes-power-one-mans-3ghz-quest-to-build-a-perfect-snes-emulator/">for the past 15 years</a>. We are now at a point where that goal is in sight, but there we face one last challenge: accurate cycle timing of the SNES video processors. Getting that final bit of emulation accuracy will require a community effort that I hope some of you can help with. But first, let me recap how far we've come.</p>
<h2>Where we are</h2>
<p>Today, SNES emulation is in a very good place. Barring unusual peripherals that are resistant to emulation (such as <a href="https://tcrf.net/Lasabirdie:_Get_in_the_Hole">a light-sensor based golf club</a>, an <a href="https://www.destructoid.com/the-fitness-nut-in-me-wishes-i-had-this-snes-exercise-bike-501569.phtml">exercise bike</a>, or a dial-up modem <a href="http://niwanetwork.org/wiki/JRA-PAT">used to place real-money bets on live horse races</a> in Japan), every officially licensed SNES title is fully playable, and no game is known to have any glaring issues.</p>
<p>SNES emulation has gotten so precise that I've even taken to splitting my emulator into two versions: <a href="https://byuu.org/higan">higan</a>, which focuses on absolute accuracy and hardware documentation; and <a href="https://byuu.org/bsnes">bsnes</a>, which focuses on performance, features, and ease of use.</p>
<p>Some amazing things have come out of SNES emulation recently, including:</p>
<ul>
<li><a href="https://www.tested.com/tech/gaming/44376-16_bit-time-capsule-how-emulator-bsnes-makes-a-case-for-software-preservation/">Low-level emulation of all SNES coprocessors</a></li>
<li><a href="https://arstechnica.com/gaming/2019/04/hd-emulation-mod-makes-mode-7-snes-games-look-like-new/">HD mode 7 support</a></li>
<li><a href="https://arstechnica.com/gaming/2019/08/blast-processing-in-2019-how-an-snes-emulator-solved-overclocking/">Slowdown removal</a></li>
<li><a href="https://www.resetera.com/threads/you-can-now-play-snes-games-in-widescreen.117351/">Widescreen support</a></li>
<li><a href="http://www.zeldix.net/c3-msu-1-hacking">MSU1 for CD-audio and FMV</a></li>
<li><a href="https://byuu.net/input/run-ahead">Run-ahead for latency reduction</a></li>
<li><a href="https://byuu.net/audio/dynamic-rate-control">Dynamic rate control for perfect audio-video synchronization</a></li>
</ul>
<p>... and much more!</p>
<p>So that's it, right? Kudos on a job well done, thanks for all the fish? Well... not quite.</p>
<p>Today, we enjoy cycle-level accuracy for nearly every component of the SNES. The sole exception is the PPUs (picture processing units), which are used to generate the video frames sent to your screen. We <i>mostly</i> know how the PPUs work, but we have to make guesses for some functionality that result in less than total perfection.</p>
<p>The remaining issues are relatively small ones, in the grand scheme of things. If you're not interested in the pursuit of one hundred percent faithful emulation perfection for its own sake, I am not going to be able to convince you of the need for improving SNES PPU emulation further. As with any goal in life, the closer we get to perfection, the smaller the returns.</p>
<p>I can tell you why this is important to <i>me</i>: it's my life's work, and I don't want to have to say I came <i>this close</i> to finishing without getting the last piece of it right. I'm getting older, and I won't be around forever. I want this final piece solved so that I can feel confident in my retirement that the SNES has been faithfully and completely preserved through emulation. No stone was left unturned, no area left unfinished. I want to say that it's <i>done.</i></p>
<p>If you're still intrigued, read on for a deep dive into the background of the problem and my proposed solutions.</p>
<h2>Modeling the SNES design</h2>
<p>Let's start by taking a look at the components that make up the SNES:</p>
<figure><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snes-system-diagram.png" data-height="802" data-width="991" alt="Super NES system diagram."><img alt="Super NES system diagram." src="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snes-system-diagram-640x518.png" width="640" height="518" srcset="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snes-system-diagram.png 2x"></a><figcaption><p><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snes-system-diagram.png" data-height="802" data-width="991">Enlarge</a> <span>/</span> Super NES system diagram.</p></figcaption></figure>
<p>The arrows indicate the direction that the various processors in the SNES can communicate with one another, and the dotted lines represent memory chip connections.</p>
<p>The key thing to take away right now is to note that the video and audio output are sent directly from the PPU and DSP specifically. That means they function like “black boxes” where we don’t have any visibility into what happens inside. This will be important later on.</p>
<h3>Correctness</h3>
<p>Imagine you are emulating a CPU's "multiply" instruction, which takes two registers (variables), multiplies them together, and produces a result and some flags that represent the status of the result (such as <a href="https://en.wikipedia.org/wiki/Integer_overflow">overflow</a>).</p>
<p>We could devise a software program that multiplies every possible value from 0 to 255 as both the multiplier and multiplicand. Then we could output both the numeric and flag results of the multiplication. This would produce two 65,536-entry tables.</p>
<p>By analyzing these tables, we could determine exactly how and when the CPU results were set certain ways. Then we could modify our emulators so, when running the same test, we produce exactly the same tables at the same times.</p>
<p>Now let's say the CPU had 16-bit x 16-bit multiplications. Testing every possible value would generate 4 billion results, which is starting to push what is practical to test in a reasonable amount of time. If the CPU had 32-bit x 32-bit multiplications, it wouldn’t be practical to test all combinations of inputs before the heat death of the universe (with current technology, at least).</p>
<p>In cases like this, we would have to get more selective with our tests and try to determine exactly when flags might change, when results might overflow, and so forth. Otherwise we'd have tests that would never complete.</p>
<p>Multiplication is a fairly trivial operation, but this is the general process behind reverse engineering, and it extends to more complex operations such as how the SNES' horizontal blanking DMA (direct memory access) transfers work. We create tests that try to detect what happens on edge cases, then confirm that our emulation behaves identically to a real SNES.</p>
<h3>Oscillators and cycles</h3>
<p>The SNES contains two oscillators: a crystal clock that runs at ~21MHz, which controls the CPU and PPUs; and a ceramic resonator that runs at ~24MHz, which controls the SMP and DSP. Cartridge coprocessors will sometimes use the ~21MHz CPU oscillator and sometimes include their own oscillators that run at different frequencies.</p>
<figure><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescircuits.jpg" data-height="573" data-width="800" alt="Recreating this original Super Famicom circuit board purely in software is harder than it looks."><img alt="Recreating this original Super Famicom circuit board purely in software is harder than it looks." src="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescircuits-640x458.jpg" width="640" height="458" srcset="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescircuits.jpg 2x"></a><figcaption><p><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescircuits.jpg" data-height="573" data-width="800">Enlarge</a> <span>/</span> Recreating this original Super Famicom circuit board purely in software is harder than it looks.</p></figcaption></figure>
<p>A clock is the core timing element of any system, and the SNES is designed to perform various tasks at certain frequencies and times.</p>
<p>If you imagine a 100Hz clock, it is a device with a digital pin that transitions to logic high (+5 volts, for instance), and then back to logic low (0 volts, or ground) 100 times per second. So every second, the pin voltage will fluctuate 200 times total: 100 rising clock edges and 100 falling clock edges.</p>
<p>A clock cycle is generally treated as one full transition, so a 100Hz clock would generate 100 clock cycles per second. There are some systems that require distinguishing between rising and falling edges, and for those, we break this further down into half-cycles to denote each phase (high or low) of the clock signal.</p>
<p>The key goal of an authentic emulator is to perform tasks in exactly the same ways and at exactly the same times as the real hardware. It doesn't much matter specifically <i>how</i> the tasks are performed. All that matters is that the emulator, when given the same inputs, generates the same outputs with the same timing as real hardware.</p>
<h3>Timing</h3>
<p>Sometimes, operations happen over time. Take SNES CPU multiplication, for instance. Rather than pausing to wait for multiplication to complete, the SNES CPU calculates the multiplication result one bit at a time in the background over eight CPU opcode cycles. This allows your code to possibly do other things while waiting on the multiplication to complete.</p>
<p>Any commercially released software is likely to wait those eight cycles, because if you try to read the result before it's ready, you will get a partially computed result instead. Yet earlier SNES emulators gave correct results <i>immediately</i>, without waiting these extra cycles.</p>
<p>When hobbyists started creating and testing homebrew software via emulators, this discrepancy started to cause some problems. Some of this software, such as many early <i>Super Mario World</i> ROM hacks, only worked correctly on these earlier emulators, and not on real SNES hardware. That's because they were designed with the emulator's immediate (and inauthentic-to-real-hardware) multiplication results in mind.</p>
<p>As emulators improved, this old software broke, and we have had to subsequently offer compatibility options in our newer emulators in order to not lose this software to time. Yes, as surreal as it is to say, these days our emulators have to emulate other emulators! How meta!</p>
<p>The nice thing about the CPU multiplication delay is that it's very predictable: the eight computation cycles start immediately after requesting a multiplication. By writing code to read the results after every cycle, we were able to confirm that the SNES CPU was using the <a href="https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm">Booth</a><a href="https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm"> algorithm</a> for multiplication.</p>
<h3>Clock Synchronization</h3>
<p>Other operations are not so simple to model, since they happen asynchronously in the background. The SNES CPU's DRAM refresh is one such case.</p>
<p>During the rendering of every scanline, at a certain point, the entire SNES CPU freezes for a short duration as the contents of the RAM chip are refreshed. This is needed because, as a cost-cutting measure, the SNES used dynamic RAM (rather than static RAM) for its main CPU memory. Dynamic RAM must be periodically refreshed in order to preserve its contents over time.</p>
<figure><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescarts.jpg" data-height="1024" data-width="1024" alt="For a truly perfect emulator, just making ~3,500 commercially released SNES games playable isn't enough. Every function of the system has to be simulated with cycle-perfect accuracy, too."><img alt="For a truly perfect emulator, just making ~3,500 commercially released SNES games playable isn't enough. Every function of the system has to be simulated with cycle-perfect accuracy, too." src="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescarts-640x640.jpg" width="640" height="640" srcset="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescarts.jpg 2x"></a><figcaption><p><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/snescarts.jpg" data-height="1024" data-width="1024">Enlarge</a> <span>/</span> For a truly perfect emulator, just making ~3,500 commercially released SNES games playable isn't enough. Every function of the system has to be simulated with cycle-perfect accuracy, too.</p></figcaption></figure>
<p>The key insight to figuring out the precise timing of these operations was to take advantage of the SNES PPU’s horizontal and vertical counters. These counters advance and are reset after each horizontal and vertical blanking period. However, their precision is only a quarter of the SNES' CPU oscillator frequency; that is to say, the horizontal counter increments only once every four clock cycles.</p>
<p>By reading the counters multiple times, I was able to determine which quarter of a clock cycle the counter was aligned with. By combining that insight with a specially crafted function that could step by a precise, user-specified number of clock cycles, it became possible to perfectly align the SNES CPU to any exact clock cycle position I wanted.</p>
<p>By iterating over a range of clock cycles in a loop, I could determine exactly when certain operations (such as DRAM refresh, HDMA transfers, interrupt polling, etc.) would occur, and I was able to reproduce this precisely under emulation.</p>
<p>The SNES <a href="http://www.vgmpf.com/Wiki/index.php?title=S-SMP">SMP chip</a> has its own timers as well, and similar reverse engineering was successful against that processor as well. I could spend an entire article talking about the SMP TEST register alone, which allows coders to control the clock divider of the SMP and its timers, among other horrible things. Suffice it to say that, while it was not an easy or fast process, we were ultimately victorious.</p>
<h3>Collecting coprocessors</h3>
<figure><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/superfx.jpg" data-height="807" data-width="599" alt="The SuperFX chip is just one of many cartridge coprocessors that an SNES emulator has to handle correctly."><img alt="The SuperFX chip is just one of many cartridge coprocessors that an SNES emulator has to handle correctly." src="https://cdn.arstechnica.net/wp-content/uploads/2020/03/superfx-300x404.jpg" width="300" height="404" srcset="https://cdn.arstechnica.net/wp-content/uploads/2020/03/superfx.jpg 2x"></a><figcaption><p><a href="https://cdn.arstechnica.net/wp-content/uploads/2020/03/superfx.jpg" data-height="807" data-width="599">Enlarge</a> <span>/</span> The SuperFX chip is just one of many cartridge coprocessors that an SNES emulator has to handle correctly.</p></figcaption></figure><p>There were a whole host of SNES coprocessors used inside various game cartridges that needed to be tamed as well. From dedicated general-purpose CPUs like the <a href="https://arstechnica.com/gaming/2017/07/nintendo-could-have-supported-super-fx-long-before-the-snes-classic/">SuperFX</a> and <a href="https://arstechnica.com/gaming/2019/05/28-years-later-hacker-fixes-rampant-slowdown-on-snes-gradius-iii/">SA-1</a>, to digital signal processors like the DSP-1 and Cx4, to decompression accelerators like the S-DD1 and SPC7110, to real-time clocks from Sharp and Epson, and more...</p>
<p>That means an SNES emulator needs to be able to handle the instruction and pixel caches of the SuperFX; the memory bus conflict arbitrator of the SA-1 (which allowed the SNES CPU and SA-1 to share the same ROM and RAM chips simultaneously); the embedded firmware of the DSP-1 and Cx4; the prediction-based arithmetic coders of the S-DD1 and SPC7110; and the odd BCD (binary-coded decimal) edge cases of the real-time clocks. Slowly but surely, by applying the above techniques to determine correctness and timing, we were able to near-perfectly emulate all of these chips.</p>
<p>It actually took a massive effort and thousands of dollars to decap and extract the programming firmware from the digital signal processors used in various games. In one instance, emulation of the NEC uPD772x led to <a href="https://www.sfchronicle.com/bayarea/article/The-Silicon-Valley-quest-to-preserve-Stephen-12759775.php">code from higan being used to save the late professor Stephen Hawking's voice!</a></p>
<p>In another case, we had to reverse-engineer the entire instruction set of the Hitachi HG51B architecture, because this architecture was never publicly documented. In yet another, one game (<em>Hayazashi Nidan Morita Shougi 2</em>) ended up containing a full-blown 32-bit, 21MHz ARM6 CPU to accelerate its Japanese chess engine!</p>
<p>Preserving all of the SNES coprocessors alone was a multi-year journey full of challenges and surprises.</p>
<h3>Processing digital signal</h3>
<p>Not to be confused with the DSP-1 cartridge coprocessor, the Sony S-DSP (digital signal processor) chip is what generated the distinctive sound from the SNES. This chip combined eight voice channels with 4-bit ADPCM encoding to produce a 16-bit stereo signal.</p>
<p>On the surface, and per the system diagram from earlier, the DSP initially looks like a black box: you configure the voice channels and mixer settings and sit back as it generates sound to be sent to your speakers.</p>
<p>But one key feature allowed a developer by the name of blargg to fully reverse-engineer this chip: the echo buffer. The SNES DSP has a feature that mixes the outputs from previous samples together to produce an echo effect. This happens at the very end of the audio generation process (aside from one last final mute flag that can be applied to silence all audio output.)</p>
<p>By writing carefully cycle-timed code and monitoring those echo results, it became possible to discover the exact order of operations the SNES DSP would take to generate each sample and to produce cycle-accurate, bit-perfect audio.</p>


                  
              </div>

      
              <nav>Page: <span>1 <a href="https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/2/">2</a> <a href="https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/3/">3</a> <a href="https://arstechnica.com/gaming/2020/04/how-snes-emulators-got-a-few-pixels-from-complete-perfection/2/"><span>Next <span>→</span></span></a></span></nav>
      
    </section>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>