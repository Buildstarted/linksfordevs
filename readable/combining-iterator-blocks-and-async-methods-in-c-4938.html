<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Combining iterator blocks and async methods in C# | Premier Developer - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Combining iterator blocks and async methods in C# | Premier Developer - linksfor.dev(s)"/>
    <meta property="article:author" content="Sergey TepliakovSenior Software Engineer,&#xA0;Tools for Software EngineersFollow Sergey"/>
    <meta property="og:description" content="One of the best traits of a well-designed system is composability. Large systems are complex and hierarchical and one of the best ways to fight accidental complexity is to compose a system from smaller components. You write and test each component independently then you glue them together to achieve a higher-level behavior."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blogs.msdn.microsoft.com/seteplia/2018/09/05/combining-iterator-blocks-and-async-methods-in-c/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Combining iterator blocks and async methods in C# | Premier Developer</title>
<div class="readable">
        <h1>Combining iterator blocks and async methods in C# | Premier Developer</h1>
            <div>by Sergey TepliakovSenior Software Engineer,&#xA0;Tools for Software EngineersFollow Sergey</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://blogs.msdn.microsoft.com/seteplia/2018/09/05/combining-iterator-blocks-and-async-methods-in-c/">https://blogs.msdn.microsoft.com/seteplia/2018/09/05/combining-iterator-blocks-and-async-methods-in-c/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/premier-developer/wp-content/uploads/sites/31/2019/06/Sergey-Tepliakov-150x150.jpg" width="58" height="58" alt="Sergey Tepliakov"></p><p>Sergey</p></div></div></div><p>September 5th, 2018</p><p>One of the best traits of a well-designed system is composability. Large systems are complex and hierarchical and one of the best ways to fight accidental complexity is to compose a system from smaller components. You write and test each component independently then you glue them together to achieve a higher-level behavior.</p><p>Programming languages usually designed to have “composable” features as well. You should be able to use multiple features together and the entire thing should just work. In C# you can compose different features together, and everything works. Unless it isn’t.</p><p>Recently I stumbled across a piece of C# code that shows the complexity of the language and demonstrates how easy these days to make mistakes by combining different language features. C# language is complex, and it is important to understand the features deep enough to use them correctly.</p><p>Let’s review the following code:</p><div id="crayon-5e39e5549d3ed359138934" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p></div></td><td><div><p><span>public</span><span> </span><span>static</span><span> </span><span>IEnumerable</span><span>&lt;</span><span>Task</span><span>&lt;</span><span>int</span><span>&gt;</span><span>&gt;</span><span> </span><span>ParseFile</span><span>(</span><span>string</span><span> </span><span>path</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>if</span><span> </span><span>(</span><span>string</span><span>.</span><span>IsNullOrEmpty</span><span>(</span><span>path</span><span>)</span><span>)</span><span> </span><span>throw</span><span> </span><span>new</span><span> </span><span>ArgumentNullException</span><span>(</span><span>nameof</span><span>(</span><span>path</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// OpenWithRetryPolicyAsync uses RetryPolicy to try to open the file more than once.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// The method throws FileNotFoundException if the file does not exists.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>using</span><span> </span><span>(</span><span>var</span><span> </span><span>file</span><span> </span>=<span> </span><span>OpenWithRetryPolicyAsync</span><span>(</span><span>path</span><span>)</span><span>.</span><span>Result</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>using</span><span> </span><span>(</span><span>var</span><span> </span><span>reader</span><span> </span>=<span> </span><span>new</span><span> </span><span>StreamReader</span><span>(</span><span>file</span><span>)</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Let's assume that the first line contains a number of entries.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Using int.Parse for simplicities sake</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>numberOfEntries</span><span> </span>=<span> </span><span>int</span><span>.</span><span>Parse</span><span>(</span><span>reader</span><span>.</span><span>ReadLine</span><span>(</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>entry</span><span> </span>=<span> </span><span>0</span><span>;</span><span> </span><span>entry</span><span> </span><span>&lt;</span><span> </span><span>numberOfEntries</span><span>;</span><span> </span><span>entry</span>++<span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>yield </span><span>return</span><span> </span><span>ReadAndParseAsync</span><span>(</span><span>reader</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>}</span></p><p><span>private</span><span> </span><span>static</span><span> </span><span>async </span><span>Task</span><span>&lt;</span><span>int</span><span>&gt;</span><span> </span><span>ReadAndParseAsync</span><span>(</span><span>StreamReader </span><span>reader</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>string</span><span> </span><span>line</span><span> </span>=<span> </span><span>await </span><span>reader</span><span>.</span><span>ReadLineAsync</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>int</span><span>.</span><span>Parse</span><span>(</span><span>line</span><span>)</span><span>;</span></p><p><span>}</span></p><p><span>public</span><span> </span><span>static</span><span> </span><span>IEnumerable</span><span>&lt;</span><span>Task</span><span>&lt;</span><span>int</span><span>&gt;</span><span>&gt;</span><span> </span><span>ParseAndLogIfNeeded</span><span>(</span><span>string</span><span> </span><span>path</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>try</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>ParseFile</span><span>(</span><span>path</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>catch</span><span> </span><span>(</span><span>Exception</span><span> </span><span>e</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$</span><span>"Failed to parse the file: {e.Message}"</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>Enumerable</span><span>.</span><span>Empty</span><span>&lt;</span><span>Task</span><span>&lt;</span><span>int</span><span>&gt;</span><span>&gt;</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>The code of <code>OpenWithRetryPolicyAsync</code> method is not relevant for our discussion so I moved the code to the end of the blog post.</p><ol><li>Exception handling and iterator blocks</li></ol><p>Iterator blocks are quite different from regular methods. If a method returns <code>IEnumerable&lt;T&gt;</code> or <code>IEnumerator&lt;T&gt;</code> and has <code>yield return</code> in it, the compiler completely changes the semantics of the method. The method becomes lazy and it’ll be executed not when the method is called, but rather when the sequence is consumed.</p><p>This behavior may catch you off-guard especially when the result of the iterator block is “transformed” using other lazily evaluated functions, like LINQ operators:</p><div id="crayon-5e39e5549d405811741873" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>var</span><span> </span><span>s1</span><span> </span>=<span> </span><span>ParseFile</span><span>(</span><span>null</span><span>)</span><span>;</span><span> </span><span>// no exceptions</span></p><p><span>var</span><span> </span><span>s2</span><span> </span>=<span> </span><span>s1</span><span>.</span><span>Select</span><span>(</span><span>t</span><span> </span>=<span>&gt;</span><span> </span><span>t</span><span>.</span><span>GetAwaiter</span><span>(</span><span>)</span><span>.</span><span>GetResult</span><span>(</span><span>)</span><span>)</span><span>.</span><span>Where</span><span>(</span><span>r</span><span> </span>=<span>&gt;</span><span> </span><span>r</span><span> </span>==<span> </span><span>42</span><span>)</span><span>;</span><span> </span><span>// no exceptions</span></p><p><span>if</span><span> </span><span>(</span><span>s2</span><span>.</span><span>Any</span><span>(</span><span>)</span><span>)</span><span> </span><span>// throws an exception, potentially in completely different subsystem!</span></p><p><span>{</span><span> </span><span>}</span></p></div></td></tr></tbody></table></div></div><p>This means that <code>ParseFile</code> method never throws when the method is called, and the catch block <code>ParseAndLogIfNeeded</code> is effectively unreachable and will never handle any errors.</p><ol start="2"><li>Observing <code>ex.Message</code> is not enough</li></ol><p><strong>Exceptions are like ogres, they have layers.</strong> In many cases, exceptions are nested with absolutely unactionable information in the top-level <code>Message</code> property.</p><p>Let’s suppose we resolved laziness issue by calling <code>.ToList()</code>: <code>try { return ParseFile(path).ToList();}</code>.</p><p>If a given <code>path</code> does not exist, then <code>OpenWithRetryPolicyAsync</code> throws <code>FileNotFoundException</code>. But because the method is asynchronous, the actual error will be wrapped in <code>AggregateException</code>. And in this case, the log file (the console in this case) will contain a very useful error message: “One or more error occurred”.</p><p>And <code>AggregateException</code> is not the only example: <code>TypeLoadExcpetion</code> and <code>TargetInvocationException</code> never contain relevant information in <code>Message</code>property. In other cases, you need to know a stack trace or an inner exception in order to understand the root cause of an issue.</p><p>In the perfect world, you would never even catch <code>System.Exception</code>, but in reality, this suggestion isn’t practical. So if you ended up catching generic exception type without re-throwing it, at least trace the full exception instance. Believe me, you’ll save yourself hours of investigation time in the future.</p><ol start="3"><li>Prefer calling <code>GetAwaiter().GetResult</code> over <code>.Result</code></li></ol><p>Blocking asynchronous operations is another anti-pattern that should never be used. But similarly to another anti-pattern mentioned above, you have to use it in practice from time to time to avoid viral asynchrony of the code.</p><p>There are 3 ways to synchronously wait for the result of a task-based operation: <code>.Result</code>, <code>.Wait</code> and <code>GetAwaiter().GetResult()</code>. The first two operations will throw <code>AggregateException</code> if the task fails and <code>GetAwaiter().GetResult()</code> will unwrap and throw the first exception from task’s <code>AggregateException</code>.</p><p>In some rare cases, a task is backed by more than one operation and <code>AggregateException</code> is what you need. But in the majority tasks are backed by an asynchronous operation that could have only one error, and propagating it directly simplifies exception handling a lot, especially when a caller does not expect to get an <code>AggregateException</code> at all.</p><ol start="4"><li>Using block and the lifetime of asynchronous operations</li></ol><p>All the issues we discussed before are important but more or less obvious for experienced developers. The last one is a bit subtler.</p><p>Let’s take a closer look at the lifetime of the <code>file</code> variable in <code>ParseFile</code>. The compiler generates a state machine and calls a generated “finally block” to close the file when all the items of the sequence are produced. But the problem is that the method “yields” tasks (not values) and if the last task is not synchronous, then the task may read a file when the file is already closed!</p><p>Here what may happen if the caller of <code>ParseFile</code> calls <code>ToList()</code> on the result to eagerly obtain all the elements from the sequence and if the tasks are not completed synchronously:</p><div id="crayon-5e39e5549d414303467187" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>Step</span><span> </span><span>1</span><span>:</span><span> </span><span>Opening </span><span>the </span><span>file </span></p><p><span>Step</span><span> </span><span>2</span><span>:</span><span> </span><span>Yielding </span><span>Task0 </span></p><p><span>Step</span><span> </span><span>3</span><span>:</span><span> </span><span>Yielding </span><span>Task1 </span></p><p><span>Step</span><span> </span><span>4</span><span>:</span><span> </span><span>Closing </span><span>the </span><span>file </span></p><p><span>Step</span><span> </span><span>5</span>-<span>6</span><span>:</span><span> </span><span>Tasks</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>1</span><span> </span><span>are </span><span>reading </span><span>the </span><span>file </span><span>and</span><span> </span><span>failing </span><span>with</span><span> </span><span>`</span><span>ObjectDisposeException</span><span>`</span></p></div></td></tr></tbody></table></div></div><p>The issue may be in your code for years and manifest itself in some weird ways. For instance, the code may work fine on Windows for small files when <code>ReadLineAsync()</code>returns synchronously because the data is prefetched, but fail in other cases if <code>ReadLineAsync</code> will do an actual IO. (This is actually exactly how we discovered the issue: once we tried to run the code on MacOS we started getting the errors consistently.)</p><h4>How to solve the main issue?</h4><p>To be honest, I’m not a big fan of <code>IEnumerable&lt;Task&gt;</code>. The main issue from my perspective, that the semantics of a method is not clear. Just by looking at a method signature it is hard to tell if the sequence is “hot” or “cold”. If the sequence is “cold” and lazy, then the tasks in the sequence are initiated one by one. If the sequence is “hot” and is backed by a collection, then all the tasks are running already.</p><p>“The right” approach depends on your needs. If clients will use all the items of the result all the time, then just use <code>Task&lt;List&lt;T&gt;&gt;</code>. As the author of a function, you should think about an ease of use and clarity of your functions. Types can be a useful source of information and you should try to express your intent as clearly as possible.</p><p>Asynchronous sequences could be useful in some cases. For instance, you may use <code>IEnumerable&lt;Task&gt;</code> if the sequence contains many elements, the time for getting the next element is high, and clients may need only the first few elements. But in this case, you should explain your intent in comments or, even better, use something like <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.servicefabric.data.iasyncenumerable-1?view=azure-dotnet" target="_blank"><code>IAsyncEnumerable&lt;T&gt;</code></a>.</p><p>The idea of async streams is not new and you may find types similar to <code>IAsyncEnumerable&lt;T&gt;</code> in many projects. The idiom is so widely used that the C# language authors consider having a language feature to consume async streams using <code>await foreach</code> syntax. (For more information, see <a href="https://github.com/dotnet/csharplang/blob/master/proposals/async-streams.md" target="_blank">Async Streams</a> proposal).</p><h4>The source code of <code>OpenWithRetryPolicyAsync</code></h4><div id="crayon-5e39e5549d421664120051" data-settings=" minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>private</span><span> </span><span>class</span><span> </span><span>RetryIfFileNotFoundPolicy</span><span> </span><span>:</span><span> </span><span>ITransientErrorDetectionStrategy</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>bool</span><span> </span><span>IsTransient</span><span>(</span><span>Exception </span><span>ex</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>ex </span><span>is</span><span> </span><span>FileNotFoundException</span><span>;</span></p><p><span>}</span></p><p><span>public</span><span> </span><span>static</span><span> </span><span>async </span><span>Task</span><span>&lt;</span><span>FileStream</span><span>&gt;</span><span> </span><span>OpenWithRetryPolicyAsync</span><span>(</span><span>string</span><span> </span><span>path</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Trying opening the file more then once.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>await </span><span>new</span><span> </span><span>RetryPolicy</span><span>&lt;</span><span>RetryIfFileNotFoundPolicy</span><span>&gt;</span><span>(</span><span>retryCount</span><span>:</span><span> </span><span>5</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>.</span><span>ExecuteAsync</span><span>(</span><span>(</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>Task</span><span>.</span><span>FromResult</span><span>(</span><span>new</span><span> </span><span>FileStream</span><span>(</span><span>path</span><span>,</span><span> </span><span>FileMode</span><span>.</span><span>Open</span><span>)</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>