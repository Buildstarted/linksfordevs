<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using IHttpClientFactory with Blazor WebAssembly - Marco De Sanctis -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using IHttpClientFactory with Blazor WebAssembly - Marco De Sanctis</h1><div><div class="ac ae af ag ah dp aj ak"><blockquote class="gb gc gd"><p id="20a6" class="ge gf ds gg gh b gi gj gk gl gm gn go gp gq gr gs cu"><strong class="gh gt">EDIT: This article has been originally published for .NET Core 3.1 — Preview2. .NET Core 3.1 Preview 3 introduces a breaking change that requires a slightly more <em class="bk">clunky</em> code in order to work.</strong></p></blockquote><p id="0183" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">When we create a single page web application with <strong class="gh gt">Blazor WebAssembly</strong>, it comes with a pre-configured <code class="dj gu gv gw gx b">HttpClient</code> service in the IoC container. This means that we can simply inject an <code class="dj gu gv gw gx b">HttpClient</code> dependency in our components and <strong class="gh gt">it will just work</strong>.</p><figure class="gz ha hb hc hd cz cl cm paragraph-image"><p id="52c5" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">However, in a real world application, we might need something a bit <strong class="gh gt">more sophisticated</strong> than this and want to use <code class="dj gu gv gw gx b">IHttpClientFactory</code>.</p><p id="09fc" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">Why would we want to do that? At least for three reasons:</p><ul class=""><li id="ab98" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs hi hj hk">interacting with <strong class="gh gt">different services</strong>, that have different base addresses and require different <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0#named-clients" class="at cg hl hm hn ho" target="_blank" rel="noopener nofollow"><strong class="gh gt">named clients</strong></a>;</li><li id="17c3" class="ge gf ds bk gh b gi hp gk hq gm hr go hs gq ht gs hi hj hk">configure a <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0#typed-clients" class="at cg hl hm hn ho" target="_blank" rel="noopener nofollow"><strong class="gh gt">strongly typed client</strong></a> for a given service and use that instead of the plain and simple HttpClient;</li><li id="ac14" class="ge gf ds bk gh b gi hp gk hq gm hr go hs gq ht gs hi hj hk">use a library like <a href="http://www.thepollyproject.org/" class="at cg hl hm hn ho" target="_blank" rel="noopener nofollow"><strong class="gh gt">Polly</strong></a> to <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0#use-polly-based-handlers" class="at cg hl hm hn ho" target="_blank" rel="noopener nofollow">define some policies</a> that we want to apply to our network requests, such as retry, failover or circuit breaker.</li></ul><blockquote class="gb gc gd"><p id="6b3a" class="ge gf ds gg gh b gi gj gk gl gm gn go gp gq gr gs cu">Note: one of the main reasons you want to use IHttpClientFactory is because it <strong class="gh gt">controls the lifecycle</strong> of the HttpClient instances. Although this is perfectly valid for server-side code (<strong class="gh gt">and you should do it if you’re not doing it yet</strong>), this doesn’t apply to Blazor WebAssembly: in fact, when Blazor runs in a browser, it uses a special type of <strong class="gh gt">MessageHandler</strong> which wraps the browser’s <strong class="gh gt">XmlHttpRequests</strong>.</p></blockquote><p id="e908" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">The good news is that <strong class="gh gt">this is all achievable</strong> in Blazor WebAssembly, and frankly seeing all of this running in the browser is <strong class="gh gt">quite mind-blowing</strong>. The (slightly) bad news is that at it’s not there (yet?) out of the box, and requires some plumbing. Please note that this might change in the near future, as we get closer to the final release of Blazor WebAssembly.</p><p id="d013" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">So how do we configure it in Blazor? Keep reading :)</p><h1 id="248e" class="hu hv ds bk bj hw du hx dw hy hz ia ib ic id ie if">Initial setup</h1><p id="9b8f" class="ge gf ds bk gh b gi ig gk ih gm ii go ij gq ik gs cu">Now, let’s assume you have created a brand new Blazor WebAssembly project. The first step is adding a reference to the <code class="dj gu gv gw gx b">Microsoft.Extensions.Http</code> package and (optionally) to <code class="dj gu gv gw gx b">Microsoft.Extensions.Http.Polly</code>:</p><figure class="gz ha hb hc hd cz"><p id="daee" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">Then, we can head to the <code class="dj gu gv gw gx b">ConfigureServices</code> method in Startup, and start configuring the <strong class="gh gt">IoC container</strong>:</p><figure class="gz ha hb hc hd cz"><p id="512f" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">There are a few things going on in the above snippet:</p><ol class=""><li id="5219" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs im hj hk">we <strong class="gh gt">remove the HttpClient service</strong> the default builder has already configured for us: we won’t need it as we’re going to use <strong class="gh gt">IHttpClientFactory </strong>for this;</li><li id="6c48" class="ge gf ds bk gh b gi hp gk hq gm hr go hs gq ht gs im hj hk">we register a <code class="dj gu gv gw gx b">WasmHttpMessageHandler</code> service as <strong class="gh gt">scoped</strong>. This is the special handler Blazor uses in order to <strong class="gh gt">execute HTTP calls</strong> through the browser. The “server side” WebRequestHandler is obviously not an option in the WebAssembly world as it leverages some operating system’s primitives;</li><li id="bf7d" class="ge gf ds bk gh b gi hp gk hq gm hr go hs gq ht gs im hj hk">we then add an example of a <strong class="gh gt">named client</strong> by configuring a “local” HttpClient instance, which uses the application’s Url as it’s base address. As you can see, when doing it, we also specify the message handler we want to adopt by using the <code class="dj gu gv gw gx b">ConfigurePrimaryHttpMessageHandler</code> method;</li><li id="90cf" class="ge gf ds bk gh b gi hp gk hq gm hr go hs gq ht gs im hj hk">in order to be <strong class="gh gt">backwards compatible</strong>, and support all the components that inject an HttpClient directly, we can register an HttpClient service which we internally create through the factory.</li></ol><blockquote class="gb gc gd"><p id="4b96" class="ge gf ds gg gh b gi gj gk gl gm gn go gp gq gr gs cu">Note: before .NET Core Preview 3, the Blazor was exposing a <code class="dj gu gv gw gx b">WebAssemblyHttpMessageHandler</code> type <strong class="gh gt">as part of the class library</strong>. This has now been <strong class="gh gt">removed </strong>and the framework is using <code class="dj gu gv gw gx b">WasmHttpMessageHandler</code>, which is part of <strong class="gh gt">Mono </strong>— and not directly referenced by any Blazor packages. In order to preserve the <strong class="gh gt">independence </strong>from the version of the runtime, we are using reflection to register it, regardless to whichever version of <code class="dj gu gv gw gx b">WebAssembly.Net.Http</code> is in the execution context.</p></blockquote><p id="9a1a" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">All done, if you do Ctrl-F5 now, your Blazor application should work just fine, although using IHttpClientFactory under the hood to inject an HttpClient instance.</p><h1 id="bb53" class="hu hv ds bk bj hw du hx dw hy hz ia ib ic id ie if">Sounds cool, what now?</h1><p id="5dba" class="ge gf ds bk gh b gi ig gk ih gm ii go ij gq ik gs cu">Now that we have the basic infrastructure in place, we can finally start leveraging some of the <strong class="gh gt">cool functionalities</strong> we’ve mentioned at the beginning of the article.</p><p id="e0e8" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">For example, we can easily create a <strong class="gh gt">strongly typed client</strong> for the WeatherForecast web service like the following:</p><figure class="gz ha hb hc hd cz"><p id="3fa5" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">and then configure it in the <strong class="gh gt">IHttpClientFactory</strong>:</p><figure class="gz ha hb hc hd cz"><p id="3728" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">The benefit of this, apart from having s<strong class="gh gt">trongly typed parameters and methods</strong> to call, is also that we can set the base address for the service in a centralised way. If we think about a scenario in which we are interacting with a number of different web services, each of them with its own base address, we can obviously understand how elegant and powerful this solution is, rather than specifying the absolute URL in each call.</p><p id="d778" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">The other great benefit I’ve mentioned is being able to define <strong class="gh gt">policies</strong> through the use of <strong class="gh gt">Polly</strong>, that can apply to certain calls.</p><p id="4c91" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">For example, we can easily modify the typed client configuration above, to integrate a simple retry logic:</p><figure class="gz ha hb hc hd cz"><p id="8dd7" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">In this way, should an error happen during the call, Polly will automatically retry it up to ten times, before raising an exception.</p><h1 id="f07b" class="hu hv ds bk bj hw du hx dw hy hz ia ib ic id ie if">Conclusions</h1><p id="5dfc" class="ge gf ds bk gh b gi ig gk ih gm ii go ij gq ik gs cu">IHttpClientFactory offers some <strong class="gh gt">very powerful features</strong> that are pretty much required in every real world application. Even though Blazor WebAssembly doesn’t support it in its default configuration, we can easily add the <strong class="gh gt">relevant packages</strong> and configure our project to use it.</p><p id="4733" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">This allows us to <strong class="gh gt">encapsulate the configuration </strong>of the different services we want to interact with in a centralised class, define and <strong class="gh gt">use strongly typed clients </strong>and even injecting complex <strong class="gh gt">behavioural policies </strong>by using Polly.</p><p id="c2ba" class="ge gf ds bk gh b gi gj gk gl gm gn go gp gq gr gs cu">Obviously, being Blazor WebAssembly still in preview, please don’t forget that what we’ve seen in this article is <strong class="gh gt">subject to change in the future</strong>.</p></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>