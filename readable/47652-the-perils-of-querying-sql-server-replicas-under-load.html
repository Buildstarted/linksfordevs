<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Perils of Querying SQL Server Replicas Under Load -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The Perils of Querying SQL Server Replicas Under Load</h1>
    <div class="post-content"> <p>Last week at Stack Overflow we had an internal hack-a-thon, or as we call it, a make-a-thon. I was on the bug-bashing team, which is the team that attempts to fix smallish bugs we haven&#x2019;t gotten around to fixing, due to other time-constraints. I was <a href="https://meta.stackoverflow.com/q/384675/426671">tagged to investigate a bug</a> about duplicate badges being awarded because it looked to possibly be an easy fix in SQL. At first glance it looked simple enough, but once I started digging in, I figured out very quickly it wouldn&#x2019;t be.</p> <h2 id="a-little-background">A Little Background</h2> <p>If you&#x2019;re not familiar with <a href="https://stackoverflow.com/help/badges">badges</a> on Stack Overflow, they are awarded for performing actions on the site. For example, the badge in the bug report, <a href="https://stackoverflow.com/help/badges/804/suffrage">Suffrage</a> is awarded for voting 30 times in a day. Some of our badges can be awarded multiple times while others are awarded only once. The Suffrage badge is supposed to be a one time badge, which is why it is odd that someone had it twice.</p> <h2 id="initial-investigation">Initial Investigation</h2> <p>Based on the bug report, I knew three pieces of information: 1) the badge, 2) who it was awarded to and 3) when it happened. I turned to the database to see if I could get any more info.</p> <p>My first step was to see if there were other cases where the Suffrage badge was awarded twice.</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Users2Badges</span>
<span class="k">WHERE</span> <span class="n">BadgeId</span> <span class="o">=</span> <span class="mi">804</span> <span class="c1">-- Suffrage
</span><span class="c1"></span><span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span></code></pre></td></tr></table>
</div>
</div> <p>Nope. Only one user was lucky enough to get it twice. Then I decided to see if anything was unusual about the day it was awarded. When I say unusual, I mean, did we have any outages, or, was there anything that could have glitched when the badges were granted?</p> <p>The badge in question was awarded on June 22nd 2018, so you might be wondering how in the world would I be able to track down outages, etc. from 1.5 years ago?</p> <p>I&#x2019;m glad you asked. When we throw certain exceptions on the site, they get sent to our internal chatrooms. All I had to do was go back to the transcript for that specific day, and do a quick scan to see if anything jumped out at me. Lo and behold something did. A whole lot of badge grant exceptions:</p> <p><img src="/image/2020/chat_exceptions.png" alt="Chat Exceptions"></p> <h3 id="a-bit-more-background">A Bit More Background</h3> <p>Around that time, June 2018, we were feeling the crunch of low free space on our primary SQL Server SSDs. We had &lt; 10% free, which wasn&#x2019;t great, so we investigated what, if anything, we could do without having to buy new drives. During that research, we came across our <code>Log</code> table, which exists in all of our databases. These tables are used to capture messages from the application. Seems harmless, right? Normally, yes, but we had been logging data into these tables for years and never deleted a single row for most log types. The <code>Log</code> tables were storing a ridiculous number of rows across <strong>ALL OF OUR DATABASES</strong>. We were going to gain a ton of space back by purging this old data. Here is just one database as an example:</p> <blockquote>
<p><strong>StackExchange.Tor:</strong></p> <ul>
<li>Database Size: 10.3 GB</li>
<li>Log Table Size: 10.12 GB</li>
</ul>
</blockquote> <p>Since we needed to purge data from these tables across the entire network, we used our scheduler to do it. The scheduler would allow us to do this in batches, in order to not slam the SQL Servers. The goal was to chew through the deletions, but not cause blocking or timeouts on any other process. It was a game of cat and mouse with the servers as we attempted to figure out the correct batch size. We basically were going to execute this everywhere:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">DELETE</span> <span class="n">Top</span> <span class="p">(</span><span class="mi">50000</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Log</span>
<span class="k">WHERE</span> <span class="n">LogEntryType</span> <span class="o">=</span> <span class="mi">30</span> <span class="k">AND</span> <span class="n">CreationDate</span> <span class="o">&lt;</span> <span class="n">GETUTCDATE</span><span class="p">()</span> <span class="o">-</span> <span class="mi">60</span></code></pre></td></tr></table>
</div>
</div> <p>We tried a 50k batch size which resulted in timeouts, similar to the screenshot above. We tried 25k which worked. We upped it again to 40k, and it failed. Finally, we dropped it back down to 25k and just let it delete as needed. Any time the scheduled deletions threw exceptions, we had a record of it in our chatroom. These messages in chat were critical to see what was happening when the duplicate badge was granted.</p> <p>After looking through the chat transcripts, I had a far better understanding of what was taking place when the badge was awarded incorrectly. I also was pretty sure I knew the cause of the duplicate awards, I just needed to prove it.</p> <h2 id="digging-deeper">Digging Deeper</h2> <p>Based on what I saw in the transcripts, my gut was telling me the issue had to do with the massive influx to the transaction logs making the <code>log_send_queue_size</code> sky-rocket. This resulted in a much larger amount of data that needed to be written to the secondary, in other words the <code>redo_queue_size</code> was also extremely large (both values are available by querying <a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-hadr-database-replica-states-transact-sql?view=sql-server-ver15"><code>sys.dm_hadr_database_replica_states</code></a>). As a result, we were reading dirty data when we awarded the badges. We award badges in this manner:</p> <ol>
<li>Query the readable secondary to verify who should get the badge &#x2014; we use the secondary to help spread out our read workload</li>
<li>Award the badge on the primary</li>
</ol> <p>We grant badges every 5 minutes, so if the secondary server was overloaded in trying to write a lot of transactions due to another process, we might be reading stale data on the next execution. I had one example of this from the bug report, I just needed a few more to prove that was the case. Time to go back to the database.</p> <p>I wrote up an ugly little query to get a list of all duplicate badges awarded.</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="p">;</span><span class="k">WITH</span> <span class="n">IncorrectAwards</span> <span class="k">as</span> <span class="p">(</span> <span class="k">SELECT</span> <span class="n">ub</span><span class="p">.</span><span class="n">UserId</span><span class="p">,</span> <span class="n">ub</span><span class="p">.</span><span class="n">BadgeId</span><span class="p">,</span> <span class="n">Total</span> <span class="o">=</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">Users2Badges</span> <span class="n">ub</span> <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">Badges</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">b</span><span class="p">.</span><span class="n">Single</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">AND</span> <span class="n">ub</span><span class="p">.</span><span class="n">BadgeId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">ub</span><span class="p">.</span><span class="n">UserId</span><span class="p">,</span> <span class="n">ub</span><span class="p">.</span><span class="n">BadgeId</span> <span class="k">HAVING</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">Users2Badges</span> <span class="n">ub</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">IncorrectAwards</span> <span class="n">ia</span> <span class="k">WHERE</span> <span class="n">ub</span><span class="p">.</span><span class="n">UserId</span> <span class="o">=</span> <span class="n">ia</span><span class="p">.</span><span class="n">UserId</span> <span class="k">and</span> <span class="n">ub</span><span class="p">.</span><span class="n">BadgeId</span> <span class="o">=</span> <span class="n">ia</span><span class="p">.</span><span class="n">BadgeId</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div> <p>Using the results and the exceptions in our chatroom, I was able to confirm that we had other instances where a huge process hit the servers, overloaded the transaction logs, and resulted in duplicate badges. And what do you know I found a bunch of them!</p> <p>I didn&#x2019;t need to look very far back in time either. Back in November 2019, we performed a <a href="https://stackoverflow.blog/2019/11/13/were-rewarding-the-question-askers/">massive reputation recalculation</a> which involved awarding reputation to question askers across the entire network. Let&#x2019;s just say we overwhelmed our servers just a little bit during this time and the redo of the transaction logs in our Availability Groups and Distributed Availability Groups was incredibly slow. Since we were hammering the secondaries with a lot of transactions, we unfortunately were reading staler and staler data when we awarded badges which lead to other duplicates.</p> <h2 id="fixing-the-issue-or-not">Fixing the Issue&#x2026;Or Not</h2> <p>Now that I discovered the issue, it should be an easy fix, right? Well, sort of. Yeah, I could easily delete the duplicate badges and move on &#x2014; which of course fixes the initial bug report, but doesn&#x2019;t solve the underlying issue.</p> <p>What happens the next time we run something massive on the primary and we overload the transaction logs, creating a delay in the data on the secondary? The same thing would most likely happen. The problem is, we need to use the secondary to check to see who should get the badge, we can&#x2019;t move that back to the primary. Honestly, we&#x2019;re not exactly sure how we&#x2019;re going to fix it yet. We have some ideas like maybe checking the size of the redo queue before we execute the badge grants and if it&#x2019;s <code>some undetermined size threshold</code> we skip the next badge grant, or some other fix we haven&#x2019;t thought of yet.</p> <h2 id="final-thoughts">Final Thoughts</h2> <p>You&#x2019;re probably wondering why I wrote this post since we didn&#x2019;t even fix the bug? Well, mainly because we use our readable secondary a lot and I&#x2019;m sure we aren&#x2019;t the only ones. While I knew we always needed to be mindful of the redo of the transaction logs to our secondaries in the availability groups, I need to be more vigilant in watching the impact to hopefully prevent a lot of clean-up later on.</p> <p>By the way, since this initial bug was caused by purging the <code>Log</code> tables due to low free drive space, I figured I&#x2019;d let you know that purging all that old unneeded data brought us from 90%+ used to &lt;50% used. It triggered some duplicate badges, but it saved us lots of money in buying new SSDs and has given us a few more years of breathing room.</p> <p>Also if you&#x2019;ve hit any issues like this and have suggestions on how to fix it, let me know. I&#x2019;m super curious.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>