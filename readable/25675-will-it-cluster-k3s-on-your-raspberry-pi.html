<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Will it cluster? k3s on your Raspberry Pi -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Will it cluster? k3s on your Raspberry Pi</h1><div><div class="kg-card-markdown"><p>In this post we'll test-drive <a href="https://github.com/rancher/k3s">k3s</a> which is a stripped-down Kubernetes distribution from <a href="https://rancher.com/">Rancher Labs</a>. With a single binary and a one-line bootstrap process it's even easier than before to create a light-weight cluster. So grab your <a href="https://raspberrypi.org">Raspberry Pi</a> and get ready to deploy the smallest Kubernetes distribution ever.</p><p>You may have seen my previous work with Kubernetes and Docker on Raspberry Pi such as <a href="https://blog.alexellis.io/build-your-own-bare-metal-arm-cluster/">Build your own bare-metal ARM cluster</a>. I'm hoping that this post will be a lot simpler to follow, with fewer workarounds and even more resources left over for your projects to consume.</p><p><em>Featured: Raspberry Pi x5 Compute Module (COM) holder with Gigabit ethernet, from <a href="https://www.mininodes.com/">mininodes.com</a></em></p><h2 id="whyk3s">Why k3s?</h2><p><a href="https://github.com/ibuildthecloud">Darren Shepherd</a>, Chief Architect at Rancher Labs is known for building simple solutions and accessible user-experiences for distributed systems. k3s is one of his latest experiements to reduce the footprint and bootstrap-process of Kubernetes to a single binary.</p><p>The k3s binary <a href="https://github.com/rancher/k3s">available on GitHub</a> comes in at around 40mb and bundles all the low-level components required such as containerd, runc and even <code>kubectl</code>. <code>k3s</code> can take the place of <code>kubeadm</code> which started as part of a response from the Kubernetes community to up their game for user-experience of bootstrapping clusters.</p><p><code>kubeadm</code> is now able to create production-ready multi-master clusters, but is not well-suited for the Raspberry Pi. This is because it assumes hosts have high CPU/memory and low-latency. When I ran through the installation for <code>k3s</code> the first time it was several times quicker to boot up than <code>kubeadm</code>, but the important part was that it worked first-time, every time without any manual hacks or troubleshooting.</p><blockquote><p>Note: k3s just like Kubernetes, also works on armhf (Raspberry Pi), ARM64 (Packet/AWS/Scaleway) and x86_64 (regular PCs/VMs).</p></blockquote><h2 id="prereqs">Pre-reqs</h2><p>I'll list the pre-requisites and add some affiliate links to Amazon US.</p><ul><li><p>At least 2 of: Raspberry Pi 2B/3B/3B/4+ (ARMv7)</p><blockquote><p>The Raspberry Pi Zero and first-gen RPi (armv6l) are not compatible with k3s. The main reason is that these devices have very low-powered and so the Kubernetes project does not publish Docker images for this CPU architecture.</p></blockquote><p>I say that you need two nodes, but one node <em>can</em> work if that is all you can spare.</p><p><a target="_blank" href="https://www.amazon.com/gp/product/B07BDR5PDW/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B07BDR5PDW&amp;linkCode=as2&amp;tag=alexellisuk-20&amp;linkId=c17881d2d28995ccd2b3d74be84b2b7e">Element14 Raspberry Pi 3 B+ Motherboard</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=alexellisuk-20&amp;l=am2&amp;o=1&amp;a=B07BDR5PDW" width="1" height="1" border="0" alt=""></p><p>The golden-standard is the 4GB Raspberry Pi 4, if you can afford it, I'd recommend getting several:</p><p><a target="_blank" href="https://www.amazon.com/gp/product/B07WBZM4K9/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B07WBZM4K9&amp;linkCode=as2&amp;tag=alexellisuk-20&amp;linkId=539a710ac83588c88aea5547b569ea9f">seeed studio Raspberry Pi 4 Computer Model B 4GB</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=alexellisuk-20&amp;l=am2&amp;o=1&amp;a=B07WBZM4K9" width="1" height="1" border="0" alt=""></p></li><li><p>SD card</p><p>Whatever you do, don't buy a fake. My personal recommendation:</p><p><a target="_blank" href="https://www.amazon.com/gp/product/B007JTKLEK/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B007JTKLEK&amp;linkCode=as2&amp;tag=alexellisuk-20&amp;linkId=72069d86b6c70e1dc49c2f0ce35f08ef">SanDisk 32GB ULTRA microSDHC Card Class 10 (SDSDQUA-032G-A11A)</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=alexellisuk-20&amp;l=am2&amp;o=1&amp;a=B007JTKLEK" width="1" height="1" border="0" alt=""></p><blockquote><p>Note: power users may want to look into <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/msd.md">booting from a USB stick or external storage</a> as an alternative. This will generally work out more expensive and less portable</p></blockquote></li><li><p>5-8 port Ethernet switch</p><p>For something like Kubernetes that depends on low-latency I would strongly encourage against you using WiFi. A 5-port Ethernet switch is very cheap and widely available.</p><p><a target="_blank" href="https://www.amazon.com/gp/product/B00QR6XFHQ/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00QR6XFHQ&amp;linkCode=as2&amp;tag=alexellisuk-20&amp;linkId=9940c9455696127006b304481fa99354">NETGEAR 5-Port Gigabit Ethernet Unmanaged Switch, Desktop, Internet Splitter, Sturdy Metal, Fanless, Plug-and-Play (GS305)</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=alexellisuk-20&amp;l=am2&amp;o=1&amp;a=B00QR6XFHQ" width="1" height="1" border="0" alt=""></p></li><li><p>Official power-supply</p><p>You don't want to be using a random adapter or mobile phone charger. Get the official adapter so you're sure the RPi has enough power.</p><p><a target="_blank" href="https://www.amazon.com/gp/product/B01LCNF8FU/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B01LCNF8FU&amp;linkCode=as2&amp;tag=alexellisuk-20&amp;linkId=8105e6e3b30396738314fbefada435fe">Official Raspberry Pi Foundation 5V 2.5A Power Supply WHITE</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=alexellisuk-20&amp;l=am2&amp;o=1&amp;a=B01LCNF8FU" width="1" height="1" border="0" alt=""></p></li></ul><h3 id="clusteringparts">Clustering parts</h3><p>If you're running with more than one RPi then buying multiple cases or multiple power adapters can be a false economy.</p><h2 id="preparetherpi">Prepare the RPi</h2><p>Let's start the tutorial.</p><h3 id="flashtheostothesdcard">Flash the OS to the SD card</h3><p>Let's not make things complicated by messing about with bespoke operating systems. The Raspberry Pi team have done a great job with Raspbian and for a headless system Raspbian Lite is easy to use and quick to flash.</p><p>On MacOS you can usually type in: <code>sudo touch /Volumes/boot/ssh</code> for this step.</p><p><img src="https://cdn-ak.f.st-hatena.com/images/fotolife/k/kenev/20190311/20190311084525.png" alt="Etcher.io in action"></p><h3 id="powerupthedevicecustomiseit">Power-up the device &amp; customise it</h3><p>Now power-up your device. It will be accessible on your network over ssh using the following command:</p><pre><code>$ ssh pi@raspberrypi.local
</code></pre><p>Log in with the password <code>raspberry</code> and then type in <code>sudo raspi-config</code>.</p><p>Update the following:</p><ul><li>Set the GPU memory split to 16mb</li><li>Set the hostname to whatever you want (write it down?)</li><li>Change the password for the <code>pi</code> user</li></ul><p>I also highly recommend setting a static IP for each Raspberry Pi in your cluster.</p><p>Do you have an <code>ssh</code> key?</p><pre><code>$ ls -l ~/.ssh/id_rsa.pub
</code></pre><p>If that says file not found, then let's generate a key-pair for use with SSH. This means you can set a complicated password, or disable password login completely and rely on your public key to log into each RPi without typing a password in.</p><p>Hit enter to everything:</p><pre><code>$ ssh-keygen
</code></pre><p>Finally run: <code>ssh-copy-id pi@raspberrypi.local</code></p><h3 id="enablecontainerfeatures">Enable container features</h3><p>We need to enable container features in the kernel, edit <code>/boot/cmdline.txt</code> and add the following to the end of the line:</p><pre><code> cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory
</code></pre><p>Now reboot the device.</p><h2 id="createthek3scluster">Create the <code>k3s</code> cluster</h2><p>Note: during installation <code>kubectl</code> will be aliased to the command <code>k3s kubectl</code> so that we can use the pre-packaged version of <code>kubectl</code>.</p><p>If you type in <code>docker</code> after the installation, you won't find the command installed. This is because <code>k3s</code> uses a low-level component called <code>containerd</code> directly.</p><h3 id="bootstrapthek3sserver">Bootstrap the <code>k3s</code> server</h3><p>We can install k3s using a utility script which gets the latest stable version from the <a href="https://github.com/rancher/k3s/releases">releases page</a> and then installs a systemd service to start k3s automatically.</p><p>On one of the nodes log-in and run the following:</p><pre><code>$ curl -sfL https://get.k3s.io | sh -
</code></pre><p>Check that the systemd service started correctly:</p><pre><code>$ sudo systemctl status k3s
</code></pre><p>Wait for k3s to start and to download the required images from the Kubernetes registry. This may take a few minutes.</p><p>Grab the join key from this node with:</p><pre><code>$ sudo cat /var/lib/rancher/k3s/server/node-token

K1089729d4ab5e51a44b1871768c7c04ad80bc6319d7bef5d94c7caaf9b0bd29efc::node:1fcdc14840494f3ebdcad635c7b7a9b7
</code></pre><h3 id="introducingk3supupdate">Introducing k3sup (update)</h3><p>You can now automate the installation and bootstrap of k3s onto any cloud, VM or Raspberry Pi with <a href="https://github.com/alexellis/k3sup">k3sup</a>.</p><p><code>k3sup</code> gives you access to <code>kubectl</code> in under a minute:</p><pre><code class="language-sh">k3sup install --ip $SERVER --user pi
k3sup join --ip $AGENT --server-ip $SERVER --user pi
</code></pre><p>Try it out to fetch your <code>KUBECONFIG</code> for use from your laptop.</p><p>Once you have a <code>KUBECONFIG</code> from your k3s cluster, or any Kubernetes cluster at all you can use <code>k3sup app install</code> to add things like OpenFaaS, inlets-operator, metrics-sever, nginx, and more. Just check which of the <code>apps</code> is available for arm.</p><p>Here's an example of how easy it becomes to install OpenFaaS for instance:</p><pre><code class="language-sh">k3sup app install openfaas
</code></pre><p>If you liked <code>k3sup</code>, then please add your <em>Star</em><a href="https://k3sup.dev/">on GitHub</a></p><h3 id="joinaworker">Join a worker</h3><p>Now log into another node and download the binary as before, moving it to <code>/usr/local/bin/</code>.</p><p>Now join any number of your worker nodes to the server with the following:</p><pre><code>$ export K3S_URL="https://192.168.0.32:6443"

$ export K3S_TOKEN="K1089729d4ab5e51a44b1871768c7c04ad80bc6319d7bef5d94c7caaf9b0bd29efc::node:1fcdc14840494f3ebdcad635c7b7a9b7"

$ curl -sfL https://get.k3s.io | sh -
</code></pre><p>If you installed k3s manually using a binary, then you can join your node to the server in this way:</p><pre><code>$ sudo k3s agent --server ${K3S_URL} --token ${K3S_TOKEN}
</code></pre><h3 id="listyournodes">List your nodes</h3><pre><code>$ kubectl get node -o wide

NAME   STATUS   ROLES    AGE     VERSION         INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                         KERNEL-VERSION   CONTAINER-RUNTIME
cm3    Ready    &lt;none&gt;   9m45s   v1.13.4-k3s.1   192.168.0.30   &lt;none&gt;        Raspbian GNU/Linux 9 (stretch)   4.14.79-v7+      containerd://1.2.4+unknown
cm4    Ready    &lt;none&gt;   13m     v1.13.4-k3s.1   192.168.0.32   &lt;none&gt;        Raspbian GNU/Linux 9 (stretch)   4.14.79-v7+      containerd://1.2.4+unknown
</code></pre><p>We can see our nodes and that they are using containerd rather than full Docker. This is part of how Darren was able to reduce the footprint.</p><h3 id="deployamicroservice">Deploy a microservice</h3><p>We can now log into the k3s server and deploy a microservice. We'll deploy figlet which will take a body over HTTP on port 8080 and return an ASCII-formatted string.</p><ul><li>Create a service (with a NodePort):</li></ul><p>Save: <code>openfaas-figlet-svc.yaml</code>.</p><pre><code>apiVersion: v1
kind: Service
metadata:
  name: openfaas-figlet
  labels:
    app: openfaas-figlet
spec:
  type: NodePort
  ports:
    - port: 8080
      protocol: TCP
      targetPort: 8080
      nodePort: 31111
  selector:
    app: openfaas-figlet
</code></pre><p>The deployment will be used to schedule a Pod using a Docker image published in the <a href="https://github.com/openfaas/store/">OpenFaaS Function Store</a>.</p><p>Save: <code>openfaas-figlet-dep.yaml</code>.</p><pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: openfaas-figlet
  labels:
   app: openfaas-figlet
spec:
  replicas: 1
  selector:
    matchLabels:
      app: openfaas-figlet
  template:
    metadata:
      labels:
        app: openfaas-figlet
    spec:
      containers:
      - name: openfaas-figlet
        image: functions/figlet:latest-armhf
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          protocol: TCP
</code></pre><ul><li>Now apply the configuration:</li></ul><pre><code>$ kubectl apply -f openfaas-figlet-dep.yaml,openfaas-figlet-svc.yaml

deployment.apps/openfaas-figlet created
service/openfaas-figlet created
</code></pre><p>Wait for the figlet microservice to come up:</p><pre><code>$ kubectl rollout status deploy/openfaas-figlet

deployment "openfaas-figlet" successfully rolled out
</code></pre><p>Now invoke the function:</p><pre><code>echo -n "I like $(uname -m)" | curl --data-binary @- http://127.0.0.1:31111
 ___   _ _ _                                    _____ _
|_ _| | (_) | _____    __ _ _ __ _ __ _____   _|___  | |
 | |  | | | |/ / _ \  / _` | '__| '_ ` _ \ \ / /  / /| |
 | |  | | |   &lt;  __/ | (_| | |  | | | | | \ V /  / / | |
|___| |_|_|_|\_\___|  \__,_|_|  |_| |_| |_|\_/  /_/  |_|
</code></pre><h3 id="shareyourmicroservicewithyourfriends">Share your microservice with your friends</h3><p>You can use an Open Source tool like <a href="https://inlets.dev">inlets.dev</a> to create a tunnel to the public Internet for your Raspberry Pi k3s cluster. All you need to do is to create a cheap VPS or EC2 node to get a public IP address that connects back to your cluster.</p><p>The advantages of using inlets are that it's Open Source, has no limitations and can use an exit node wherever you like in the world with a custom DNS entry and TLS for free.</p><h4 id="optionasetupinletswithinletsctl">Option A) Setup inlets with inletsctl</h4><p>You have two options, both require an access token for a cloud provider such as DigitalOcean or Google Cloud.</p><ul><li><a href="https://github.com/inlets/inletsctl">inletsctl</a> - proxy one or more services through a tunnel server provisioned through <code>inletsctl create</code></li><li><a href="https://github.com/inlets/inlets-operator">inlets-operator</a> - the operator will automate everything for you and expose any Service of type <code>LoadBalancer</code> to the public Internet and give you the IP back on <code>kubectl get svc -A</code></li></ul><h4 id="optionbusengroksfreetier">Option B) Use ngrok's free tier</h4><p>If you only need your tunnel for 7 hours or are happy to pay for a SaaS service, then then <a href="https://ngrok.com/">ngrok</a> is also very easy to use and well-known amongst developers.</p><pre><code>$ wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm.zip
$ unzip ngrok-stable-linux-arm.zip
$ sudo mv ngrok /usr/local/bin/
</code></pre><ul><li>Start a HTTP tunnel to the microservice</li></ul><pre><code>$ ngrok http 127.0.0.1:31111
</code></pre><p>You'll get a web address appear such as:</p><pre><code>Forwarding                    https://16f7c980.ngrok.io -&gt; http://127.0.0.1:31111
</code></pre><p>Now you can share that URL with your friends:</p><pre><code>$ curl -SLs --data $(whoami) https://16f7c980.ngrok.io
       _           
  __ _| | _____  __
 / _` | |/ _ \ \/ /
| (_| | |  __/&gt;  &lt; 
 \__,_|_|\___/_/\_\
                   
</code></pre><p>You can check the logs to see if they tried it:</p><pre><code>$ kubectl logs deploy/openfaas-figlet -f
</code></pre><p>You can even scale up the microservice:</p><pre><code>$ kubectl scale deploy/openfaas-figlet --replicas=4
</code></pre><p>Then find out which nodes the Pods were created on:</p><pre><code>$ kubectl get pods -l app=openfaas-figlet -o wide
NAME                               READY   STATUS    RESTARTS   AGE   IP          NODE
openfaas-figlet-8486c9f585-4ks2f   1/1     Running   0          26s   10.42.0.6   cm4 
openfaas-figlet-8486c9f585-d7kpk   1/1     Running   0          26s   10.42.1.3   cm3 
openfaas-figlet-8486c9f585-l7x89   1/1     Running   0          10m   10.42.1.2   cm3 
openfaas-figlet-8486c9f585-nhqj6   1/1     Running   0          25s   10.42.1.4   cm3 
</code></pre><p>We're only scratching the surface here. You can see Darren demo k3s and OpenFaaS in a CNCF Webinar below:</p><h3 id="tryserverlesswithopenfaas">Try Serverless with OpenFaaS</h3><p>One way of looking at your cluster is like a big computer. The cluster is your computer. With that in mind we can deploy OpenFaaS - Serverless Functions Made Simple.</p><p>It allows you to define a function or endpoint on Kubernetes in a very short period of time with minimal investment and a low learning curve.</p><p>You can deploy OpenFaaS to Kubernetes or k3s on ARM using my tutorial or the documentation:</p><p>If you're short on time, you can run this:</p><pre><code class="language-sh">k3sup app install openfaas
</code></pre><blockquote><p>Note: if you want to use the inlets-operator then you can run <code>k3sup app install openfaas --loadbalancer</code> to create a tunnel with a public IP for your cluster</p></blockquote><p>Watch for the instructions at the end for how to access OpenFaaS. The gateway is also available on port <code>31112</code> on the IP of each Raspberry Pi.</p><p>You can customise the configuration with <code>k3sup app install openfaas --help</code></p><p>A <a href="https://github.com/openfaas/workshop">complete OpenFaaS online training workshop is available here</a>, designed for PCs / cloud.</p><p>You should also note that if you create your own functions, that the Docker images need to be built on a Raspberry Pi and not on your PC.</p><h4 id="seek3sopenfaasautoscalingonraspberrypi4">See k3s &amp; OpenFaaS auto-scaling on Raspberry Pi 4</h4><blockquote><p>In this live walkthrough with my brand new Raspberry Pi 4s, I show you how to install Kubernetes (k3s) to create a cluster and then how to deploy OpenFaaS and see it auto-scale based upon metrics.</p></blockquote><h2 id="teardownoptional">Tear down (optional)</h2><p>Either run:</p><pre><code>$ sudo /usr/local/bin/k3s-uninstall.sh
</code></pre><p>Or stop k3s on each node and remove the data directory.</p><pre><code>$ sudo systemctl stop k3s
$ sudo systemctl disable k3s
$ sudo rm -rf /var/lib/rancher
</code></pre><p>For more information on k3s, see the <a href="https://github.com/rancher/k3s">page on GitHub</a>.</p><h2 id="wrappingup">Wrapping-up</h2><p>It is very early for k3s on ARM, but at this stage it's certainly more usable than the alternatives. If you're considering building a cluster for tinkering and for learning more about Kubernetes then you can't go wrong with trying k3s.</p><p>Next time you setup k3s try out my new tool <a href="https://github.com/alexellis/k3sup">k3sup</a>. It uses your SSH key to bring up k3s on any cloud, VM, or Raspberry Pi and then downloads a <code>KUBECONFIG</code> file so that you can use <code>kubectl</code> from your own computer.</p><p>Did you like the blog post? Follow me on <a href="https://twitter.com/alexellisuk">Twitter @alexellisuk</a> for more.</p><h3 id="shareyourcluster">Share your cluster</h3><p>It would be great to add your build my <a href="https://github.com/teamserverless/k8s-on-raspbian#readers-clusters">Readers' Clusters</a>.</p><p>Here's how to take part:</p><ul><li>Write a short blog post on your experiences, learnings or feedback.</li><li>Or Tweet a photo</li></ul><p>Then send a Pull Request to the <a href="https://github.com/teamserverless/k8s-on-raspbian#readers-clusters">README.md</a> file of my k8s-on-raspbian repo.</p><p>You can become an insider and get <em>insider updates</em> on all of my work with OSS, blogs, links, tweets, videos, events and new features for OpenFaaS. You can become an insider by sponsoring me on GitHub from 5 USD / mo.</p><p>Don't miss the next update, <a href="https://github.com/users/alexellis/sponsorship">sponsor me on GitHub</a> today.</p><h3 id="continuelearningmoreaboutkubernetes">Continue learning more about Kubernetes:</h3><p>k3s is a compliant Kubernetes distribution which means if you learn k3s, you're learning Kubernetes and as I tweeted earlier last week - it's never too late to start learning Kubernetes and nobody ever got fired for that.</p><h3 id="youmayalsolike">You may also like</h3><p>For even more - Follow me <a href="https://twitter.com/alexellisuk">on Twitter @alexellisuk</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>