<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The frustrating state of tails calls in .NET &#xB7; Issue #2191 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>The frustrating state of tails calls in .NET · Issue #2191 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><h1>The frustrating state of tails calls in .NET</h1><p>I listened to <a href="https://www.twitch.tv/visualstudio" rel="nofollow">Microsoft Language &amp; Runtime Community standup on twitch</a><br>were they said they like "aggressive" well-informed feedback from the community<br>so I figured I bring up something that has been rubbing me the wrong way a long<br>time in .NET; tail call performance.</p><p>I am sure that has been discussed before but I am going to add more fuel to the debate.</p><h2>Tails calls in .NET</h2><p>In .NET it's possible that annotate calls with a <code>.tail</code> attribute allowing the<br>jitter to eliminate stack frames and thus avoiding to run out of stack space.</p><p>If you are a C# developer you probably never encountered tail calls as the C#<br>compiler as of now (AFAIK?) doesn't emit <code>.tail</code> attributes (might change with <code>tail return</code>?).</p><p>It's different for F# developers though where the compiler does emit <code>.tail</code><br>attributes.</p><h2>The problem</h2><p>Avoiding running out stack space is a good thing so what's the problem?</p><p>The problem is the abysmal performance of tail calls in the general case.</p><p>Let me demonstrate by implementing a simple data pipeline based on push rather than pull (<code>IEnumerable&lt;_&gt;</code> is pull based).</p><div class="highlight highlight-source-fsharp"><pre><span class="pl-c">// Minimalistic PushStream</span><span class="pl-c">//  A PushStream accepts a receiver function that will be called</span><span class="pl-c">//  with each value in the PushStream</span><span class="pl-k">type</span><span class="pl-en">'T PushStream </span><span class="pl-k">=</span> ('T <span class="pl-k">-&gt;</span><span class="pl-c1">unit</span>) <span class="pl-k">-&gt;</span><span class="pl-c1">unit</span><span class="pl-en"><span class="pl-k">module</span><span class="pl-en">PushStream </span>=</span><span class="pl-k">let inline</span><span class="pl-smi">zero</span><span class="pl-c1">()</span><span class="pl-k">=</span> LanguagePrimitives.GenericZero
  <span class="pl-k">let inline</span><span class="pl-smi">push</span><span class="pl-v">r</span><span class="pl-v">v</span><span class="pl-k">=</span> r v

  <span class="pl-c">// Creates a PushStream with all integers from b to e (inclusive)</span><span class="pl-k">let inline</span><span class="pl-smi">fromRange</span><span class="pl-v">b</span><span class="pl-v">e</span><span class="pl-v">r</span><span class="pl-k">=</span><span class="pl-k">for</span> i <span class="pl-k">=</span> b to e <span class="pl-k">do</span> push r i
  <span class="pl-c">// Maps all values in ps using mapping function f</span><span class="pl-k">let inline</span><span class="pl-smi">map</span><span class="pl-v">f</span><span class="pl-v">ps</span><span class="pl-v">r</span><span class="pl-k">=</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> push r (f v))
  <span class="pl-c">// Filters all values in ps using filter function f</span><span class="pl-k">let inline</span><span class="pl-smi">filter</span><span class="pl-v">f</span><span class="pl-v">ps</span><span class="pl-v">r</span><span class="pl-k">=</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">if</span> f v <span class="pl-k">then</span> push r v)
  <span class="pl-c">// Sums all values in ps</span><span class="pl-k">let inline</span><span class="pl-smi">sum</span><span class="pl-v">ps</span><span class="pl-k">=</span><span class="pl-k">let mutable</span><span class="pl-smi">s</span><span class="pl-k">=</span> zero <span class="pl-c1">()</span><span class="pl-k">in</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> s <span class="pl-k">&lt;-</span> s <span class="pl-k">+</span> v)<span class="pl-k">;</span> s</pre></div><p>For a simple data pipeline designed to detect the overhead of the pipeline the push stream shows some promising performance when comparing it to LINQ.</p><div class="highlight highlight-source-fsharp"><pre><span class="pl-c">// Uses BenchmarkDotNet</span><span class="pl-k">type</span><span class="pl-en">Benchmarks </span><span class="pl-c1">()</span><span class="pl-k">=</span><span class="pl-c1">[&lt;Params (<span class="pl-c1">10000</span>, <span class="pl-c1">1000</span>, <span class="pl-c1">100</span>)&gt;]</span><span class="pl-k">member</span><span class="pl-smi">val</span><span class="pl-v">public</span><span class="pl-v">Count</span><span class="pl-k">=</span><span class="pl-c1">100</span><span class="pl-k">with</span> get, set

  <span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimpleImperativeTest</span><span class="pl-c1">()</span><span class="pl-k">=</span><span class="pl-k">let mutable</span><span class="pl-smi">i</span><span class="pl-k">=</span> x.Count
    <span class="pl-k">let mutable</span><span class="pl-smi">sum</span><span class="pl-k">=</span><span class="pl-c1">0</span>L
    <span class="pl-k">while</span> i <span class="pl-k">&gt;=</span><span class="pl-c1">0</span><span class="pl-k">do</span><span class="pl-k">let</span><span class="pl-smi">v</span><span class="pl-k">=</span>  int64 i
      i     <span class="pl-k">&lt;-</span> i <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">if</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L <span class="pl-k">then</span>
        sum <span class="pl-k">&lt;-</span> sum <span class="pl-k">+</span> (v <span class="pl-k">+</span><span class="pl-c1">1</span>L)
    sum

  <span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimpleLinqTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
    Enumerable.Range(<span class="pl-c1">0</span>, x.Count)
      .Select(int64)
      .Where(<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L)
      .Select((<span class="pl-k">+</span>) <span class="pl-c1">1</span>L)
      .Sum<span class="pl-c1">()</span><span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimplePushStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
    PushStream.fromRange  <span class="pl-c1">0</span> x.Count
    <span class="pl-k">|&gt;</span> PushStream.map     int64
    <span class="pl-k">|&gt;</span> PushStream.filter  (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L)
    <span class="pl-k">|&gt;</span> PushStream.map     ((<span class="pl-k">+</span>) <span class="pl-c1">1</span>L)
    <span class="pl-k">|&gt;</span> PushStream.sum</pre></div><pre><code>BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18363
Intel Core i5-3570K CPU 3.40GHz (Ivy Bridge), 1 CPU, 4 logical and 4 physical cores
.NET Core SDK=3.1.100
  [Host]     : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT DEBUG
  DefaultJob : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT
|               Method | Count |          Mean |      Error |     StdDev |
|--------------------- |------ |--------------:|-----------:|-----------:|
| SimpleImperativeTest |   100 |      73.36 ns |   0.259 ns |   0.243 ns |
|       SimpleLinqTest |   100 |   1,550.18 ns |   7.837 ns |   7.331 ns |
| SimplePushStreamTest |   100 |     419.71 ns |   1.768 ns |   1.654 ns |
| SimpleImperativeTest |  1000 |     611.51 ns |   2.081 ns |   1.946 ns |
|       SimpleLinqTest |  1000 |  13,677.24 ns |  47.074 ns |  44.033 ns |
| SimplePushStreamTest |  1000 |   3,576.24 ns |  11.202 ns |  10.478 ns |
| SimpleImperativeTest | 10000 |   5,996.41 ns |  27.344 ns |  25.578 ns |
|       SimpleLinqTest | 10000 | 134,129.03 ns | 443.042 ns | 414.422 ns |
| SimplePushStreamTest | 10000 |  34,988.54 ns | 126.441 ns | 118.273 ns |
</code></pre><p>The imperative "pipeline" does the best as expected as there's no pipeline<br>overhead but the push stream is doing a lot better than LINQ. Great right?</p><p>Not so fast! If we add a second test which does the same thing in a slightly<br>different way then what happens?</p><div class="highlight highlight-source-fsharp"><pre><span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.StructLinqStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
    Enumerable.Range(<span class="pl-c1">0</span>, x.Count)
      .Select(int64)
      .Select(<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">struct</span> ((v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L, v))
      .Select(<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">struct</span> (b, v <span class="pl-k">+</span><span class="pl-c1">1</span>L))
      .Select(<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">if</span> b <span class="pl-k">then</span> v <span class="pl-k">else</span><span class="pl-c1">0</span>L)
      .Sum<span class="pl-c1">()</span><span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.StructPushStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
    PushStream.fromRange <span class="pl-c1">0</span> x.Count
    <span class="pl-k">|&gt;</span> PushStream.map     int64
    <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">struct</span> ((v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L, v))
    <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">struct</span> (b, v <span class="pl-k">+</span><span class="pl-c1">1</span>L))
    <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">if</span> b <span class="pl-k">then</span> v <span class="pl-k">else</span><span class="pl-c1">0</span>L)
    <span class="pl-k">|&gt;</span> PushStream.sum</pre></div><p>Suddenly the push stream performance is abysmal.</p><pre><code>|               Method | Count |            Mean |        Error |       StdDev |
|--------------------- |------ |----------------:|-------------:|-------------:|
| StructLinqStreamTest |   100 |     3,060.52 ns |    15.855 ns |    14.831 ns |
| StructPushStreamTest |   100 |    60,241.31 ns |   256.031 ns |   239.492 ns |
| StructLinqStreamTest |  1000 |    27,813.86 ns |    99.601 ns |    93.167 ns |
| StructPushStreamTest |  1000 |   591,909.97 ns | 1,710.549 ns | 1,600.048 ns |
| StructLinqStreamTest | 10000 |   274,592.50 ns |   591.566 ns |   553.351 ns |
| StructPushStreamTest | 10000 | 5,908,867.08 ns | 9,791.398 ns | 9,158.880 ns |
</code></pre><p>We see the LINQ now performs 20x times better? What's going on?</p><p>Let's fix the problem using magic! Rewrite the <code>push</code> function from this:</p><div class="highlight highlight-source-fsharp"><pre><span class="pl-c">// Original push function, just invokes the function r with v</span><span class="pl-k">let inline</span><span class="pl-smi">push</span><span class="pl-v">r</span><span class="pl-v">v</span><span class="pl-k">=</span> r v</pre></div><p>Replace it with this nonsense:</p><div class="highlight highlight-source-fsharp"><pre><span class="pl-c">// New invoke. Seems just to add redundant code that does nothing</span><span class="pl-k">let inline</span><span class="pl-smi">push</span><span class="pl-v">r</span><span class="pl-v">v</span><span class="pl-k">=</span><span class="pl-k">match</span> r v <span class="pl-k">with</span><span class="pl-c1">()</span><span class="pl-k">-&gt;</span><span class="pl-c1">()</span></pre></div><p>Now push stream compares favorably in all cases</p><pre><code>|               Method | Count |          Mean |        Error |       StdDev |
|--------------------- |------ |--------------:|-------------:|-------------:|
| SimpleImperativeTest |   100 |      73.52 ns |     0.290 ns |     0.271 ns |
|       SimpleLinqTest |   100 |   1,552.31 ns |     4.984 ns |     4.418 ns |
| SimplePushStreamTest |   100 |     503.42 ns |     3.451 ns |     3.228 ns |
| StructLinqStreamTest |   100 |   3,079.51 ns |    18.761 ns |    17.549 ns |
| StructPushStreamTest |   100 |   2,531.61 ns |     9.913 ns |     9.273 ns |
| SimpleImperativeTest |  1000 |     612.66 ns |     1.832 ns |     1.713 ns |
|       SimpleLinqTest |  1000 |  13,667.12 ns |    41.531 ns |    38.848 ns |
| SimplePushStreamTest |  1000 |   4,346.26 ns |    16.795 ns |    15.710 ns |
| StructLinqStreamTest |  1000 |  28,029.09 ns |    70.510 ns |    58.879 ns |
| StructPushStreamTest |  1000 |  22,131.33 ns |    63.323 ns |    59.232 ns |
| SimpleImperativeTest | 10000 |   6,007.44 ns |    19.996 ns |    18.704 ns |
|       SimpleLinqTest | 10000 | 133,865.57 ns |   355.534 ns |   332.567 ns |
| SimplePushStreamTest | 10000 |  42,625.87 ns |    75.884 ns |    67.270 ns |
| StructLinqStreamTest | 10000 | 321,961.25 ns | 1,074.170 ns | 1,004.780 ns |
| StructPushStreamTest | 10000 | 242,181.19 ns |   419.269 ns |   392.185 ns |
</code></pre><p>What's going on?</p><h2>The difference are the tail calls.</h2><p>With the original <code>push</code> function the IL code to invoke the receiver function looks like this:</p><div class="highlight highlight-source-assembly"><pre><span class="pl-en">// let inline </span><span class="pl-k">push</span><span class="pl-en">      r v      = r v</span><span class="pl-en">// Tell the jitter th</span><span class="pl-c1">at</span><span class="pl-en">the </span><span class="pl-k">call</span><span class="pl-en"> is a tail </span><span class="pl-k">call</span><span class="pl-en">IL_000D: tail.</span><span class="pl-en">// </span><span class="pl-k">Call</span><span class="pl-en"> invoke virtually</span><span class="pl-en">IL_000F: callvirt  instance !</span><span class="pl-c1">1</span><span class="pl-en"> class &lt;&gt;::Invoke</span><span class="pl-en">// For a tail </span><span class="pl-k">call</span><span class="pl-en"> the </span><span class="pl-k">call</span><span class="pl-en"> function has to be followed by </span><span class="pl-k">ret</span><span class="pl-en">IL_0014: </span><span class="pl-k">ret</span></pre></div><p>The modified <code>push</code> function which doesn't change the meaning of the program at all the IL code looks like this:</p><div class="highlight highlight-source-assembly"><pre><span class="pl-en">// let inline </span><span class="pl-k">push</span><span class="pl-en">      r v      = match r v with () </span><span class="pl-s1">-</span><span class="pl-en">&gt; ()</span><span class="pl-en">// </span><span class="pl-k">Call</span><span class="pl-en"> Invoke (no tail </span><span class="pl-k">call</span><span class="pl-en">)</span><span class="pl-en">callvirt  instance !</span><span class="pl-c1">1</span><span class="pl-en"> class </span><span class="pl-s1">[</span><span class="pl-en">FSharp.Core</span><span class="pl-s1">]</span><span class="pl-en">Microsoft.FSharp.Core.FSharpFunc`</span><span class="pl-c1">2</span><span class="pl-en">&lt;int64</span><span class="pl-s1">,</span><span class="pl-en"> class </span><span class="pl-s1">[</span><span class="pl-en">FSharp.Core</span><span class="pl-s1">]</span><span class="pl-en">Microsoft.FSharp.Core.Unit&gt;::Invoke(!</span><span class="pl-c1">0</span><span class="pl-en">)</span><span class="pl-en">// Throw away the result (which is the unit value anyway)</span><span class="pl-en">IL_0012: </span><span class="pl-k">pop</span><span class="pl-en">// </span><span class="pl-k">Push</span><span class="pl-en"> the result (the unit value is null)</span><span class="pl-en">IL_0013: ldnull</span><span class="pl-en">// Done</span><span class="pl-en">IL_0014: </span><span class="pl-k">ret</span></pre></div><p>As the modified <code>push</code> "looks" at the value (match) and then loads a new result this doesn't fit the pattern of a tail call. Thus the compiler doens't inject the <code>.tail</code> attribute.</p><h2>Why do <code>.tail</code> calls sometimes go fast and sometimes go really really slow?</h2><p>Let's look at the assembly code when <code>.tail</code> call executes quickly.</p><h3>Fast <code>.tail</code> calls (Yay!)</h3><div class="highlight highlight-source-assembly"><pre><span class="pl-en">// This is the implementation of: PushStream.map (fun v </span><span class="pl-s1">-</span><span class="pl-en">&gt; struct ((v &amp;&amp;&amp; 1L) = 0L</span><span class="pl-s1">,</span><span class="pl-en"> v))</span><span class="pl-en">// Wh</span><span class="pl-c1">at</span><span class="pl-en">'s this? Tiered compilation left behinds?</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362010</span><span class="pl-en"> 0f1f440000      </span><span class="pl-k">nop</span><span class="pl-en">     dword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">+</span><span class="pl-v">rax</span><span class="pl-s1">]</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362015</span><span class="pl-en"> 8bc2            </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">edx</span><span class="pl-en">// Check is number odd</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362017</span><span class="pl-en"> a801            </span><span class="pl-k">test</span><span class="pl-en"></span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-c1">1</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362019</span><span class="pl-en"></span><span class="pl-c1">7512</span><span class="pl-en"></span><span class="pl-k">jne</span><span class="pl-en">     00007fff`9036202d</span><span class="pl-en">// Number is even</span><span class="pl-s1">,</span><span class="pl-en"> pass value down the pipeline</span><span class="pl-en">// This is a virtual </span><span class="pl-k">call</span><span class="pl-en"> so we find the jump address by looking</span><span class="pl-en">//  up the value </span><span class="pl-k">in</span><span class="pl-en"> the vtables</span><span class="pl-en">00007fff`9036201b 488b4908        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rcx</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rcx</span><span class="pl-s1">+</span><span class="pl-c1">8</span><span class="pl-s1">]</span><span class="pl-en">00007fff`9036201f 488b01          </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rcx</span><span class="pl-s1">]</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362022</span><span class="pl-en"> 488b4040        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">+</span><span class="pl-c1">40h</span><span class="pl-s1">]</span><span class="pl-en">00007fff`</span><span class="pl-c1">90362026</span><span class="pl-en"> 488b4020        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">+</span><span class="pl-c1">20h</span><span class="pl-s1">]</span><span class="pl-en">// </span><span class="pl-v">rax</span><span class="pl-en"> now contains the address of the next step </span><span class="pl-k">in</span><span class="pl-en"> the pipeline</span><span class="pl-en">//  thanks to .tail </span><span class="pl-k">call</span><span class="pl-en"> we do a </span><span class="pl-k">jmp</span><span class="pl-en"> here </span><span class="pl-k">not</span><span class="pl-en"></span><span class="pl-k">call</span><span class="pl-en">//  this means th</span><span class="pl-c1">at</span><span class="pl-en">when the pipeline finally returns it will return</span><span class="pl-en">//  directly to the top </span><span class="pl-k">loop</span><span class="pl-en">00007fff`9036202a 48ffe0          </span><span class="pl-k">jmp</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-en">// Number was odd</span><span class="pl-s1">,</span><span class="pl-en"> clear the result </span><span class="pl-k">and</span><span class="pl-en"> return</span><span class="pl-en">00007fff`9036202d 33c0            </span><span class="pl-k">xor</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">eax</span><span class="pl-en">00007fff`9036202f c3              </span><span class="pl-k">ret</span></pre></div><p>So apart from the odd nop in the beginning and the usual vtable dance over<br>virtual functions (what are the conditions to make the jitter succeed with<br>devirtualizations?) it's quite ok. Actually suprisingly just 5x slower than the<br>fast imperative solution considering how much more junk happens in each step.</p><p>Let's look at the slow <code>.tail</code> call</p><h3>Slow <code>.tail</code> calls (Boo!)</h3><div class="highlight highlight-source-assembly"><pre><span class="pl-en">// This is the implementation of: PushStream.map (fun v </span><span class="pl-s1">-</span><span class="pl-en">&gt; struct ((v &amp;&amp;&amp; 1L) = 0L</span><span class="pl-s1">,</span><span class="pl-en"> v))</span><span class="pl-en">// Function prelude</span><span class="pl-en">00007ff7`d77725e0 </span><span class="pl-c1">56</span><span class="pl-en"></span><span class="pl-k">push</span><span class="pl-en"></span><span class="pl-v">rsi</span><span class="pl-en">00007ff7`d77725e1 4883ec40        </span><span class="pl-k">sub</span><span class="pl-en"></span><span class="pl-v">rsp</span><span class="pl-s1">,</span><span class="pl-c1">40h</span><span class="pl-en">00007ff7`d77725e5 c5f877          </span><span class="pl-k">vzeroupper</span><span class="pl-en">00007ff7`d77725e8 4c8d442430      </span><span class="pl-k">lea</span><span class="pl-en"></span><span class="pl-v">r8</span><span class="pl-s1">,[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">30h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d77725ed c5f857c0        </span><span class="pl-k">vxorps</span><span class="pl-en"></span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d77725f1 c4c17a7f00      </span><span class="pl-k">vmovdqu</span><span class="pl-en"> xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">r8</span><span class="pl-s1">],</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d77725f6 488b7108        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rsi</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rcx</span><span class="pl-s1">+</span><span class="pl-c1">8</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d77725fa 448bc2          </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">r8d</span><span class="pl-s1">,</span><span class="pl-v">edx</span><span class="pl-en">// Is number odd?</span><span class="pl-en">00007ff7`d77725fd 41f6c001        </span><span class="pl-k">test</span><span class="pl-en"></span><span class="pl-v">r8b</span><span class="pl-s1">,</span><span class="pl-c1">1</span><span class="pl-en">00007ff7`d7772601 410f94c0        </span><span class="pl-k">sete</span><span class="pl-en"></span><span class="pl-v">r8b</span><span class="pl-en">00007ff7`d7772605 450fb6c0        </span><span class="pl-k">movzx</span><span class="pl-en"></span><span class="pl-v">r8d</span><span class="pl-s1">,</span><span class="pl-v">r8b</span><span class="pl-en">// Save results</span><span class="pl-en">00007ff7`d7772609 </span><span class="pl-c1">4488442438</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     byte ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">38h</span><span class="pl-s1">],</span><span class="pl-v">r8b</span><span class="pl-en">00007ff7`d777260e </span><span class="pl-c1">4889542430</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">30h</span><span class="pl-s1">],</span><span class="pl-v">rdx</span><span class="pl-en">00007ff7`d7772613 49b8784b6637f87f0000 </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">r8</span><span class="pl-s1">,</span><span class="pl-en">offset </span><span class="pl-en">// Checks: Volatile&lt;LONG&gt;       g_TrapReturningThreads</span><span class="pl-c">;</span><span class="pl-en">coreclr!g_TrapReturningThreads (00007ff8`37664b78)</span><span class="pl-en">// If true we need to suspend thread (by calling coreclr!JIT_PollGC ())</span><span class="pl-en">00007ff7`d777261d </span><span class="pl-c1">41833800</span><span class="pl-en"></span><span class="pl-k">cmp</span><span class="pl-en">     dword ptr </span><span class="pl-s1">[</span><span class="pl-v">r8</span><span class="pl-s1">],</span><span class="pl-c1">0</span><span class="pl-en">00007ff7`d7772621 752e            </span><span class="pl-k">jne</span><span class="pl-en">     00007ff7`d7772651</span><span class="pl-en">00007ff7`d7772623 4c8bc6          </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">r8</span><span class="pl-s1">,</span><span class="pl-v">rsi</span><span class="pl-en">// Juggling with struct tuple values</span><span class="pl-en">00007ff7`d7772626 c5fa6f442430    </span><span class="pl-k">vmovdqu</span><span class="pl-en"></span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-en">xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">30h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d777262c c5fa7f442420    </span><span class="pl-k">vmovdqu</span><span class="pl-en"> xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">20h</span><span class="pl-s1">],</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d7772632 4c8d4c2420      </span><span class="pl-k">lea</span><span class="pl-en"></span><span class="pl-v">r9</span><span class="pl-s1">,[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">20h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7772637 48b990d162d7f77f0000 </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rcx</span><span class="pl-s1">,</span><span class="pl-c1">7FF7D762D190h</span><span class="pl-en">// Loading vtable to find the address to </span><span class="pl-k">call</span><span class="pl-en"> to</span><span class="pl-en">00007ff7`d7772641 498b10          </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">r8</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7772644 488b5240        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rdx</span><span class="pl-s1">+</span><span class="pl-c1">40h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7772648 488b5220        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rdx</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rdx</span><span class="pl-s1">+</span><span class="pl-c1">20h</span><span class="pl-s1">]</span><span class="pl-en">// </span><span class="pl-c1">Do</span><span class="pl-en"> the </span><span class="pl-k">call</span><span class="pl-en"> to next step through: coreclr!JIT_TailCall</span><span class="pl-en">00007ff7`d777264c e89ff6c35f      </span><span class="pl-k">call</span><span class="pl-en">    coreclr!JIT_TailCall (00007ff8`373b1cf0)</span><span class="pl-en">00007ff7`d7772651 e86ad6c35f      </span><span class="pl-k">call</span><span class="pl-en">    coreclr!JIT_PollGC (00007ff8`373afcc0)</span><span class="pl-en">00007ff7`d7772656 ebcb            </span><span class="pl-k">jmp</span><span class="pl-en">     00007ff7`d7772623</span></pre></div><p>So, there's lot more setup here but this is because this function actually needs<br>a stackframe to store intermediate results. Also I suspect because the stackframe<br>is needed it has to call <code>coreclr!JIT_TailCall</code> at the end which is the CPU hog.</p><p>I don't know exactly what <code>coreclr!JIT_TailCall</code> does but it does a lot when<br>stepping through the assembly code. However, my suspicion is that its purpose is<br>eliminate the stackframe and call the next function. While it eliminates the stackframe it adds about 60x overhead to the <code>PushStream</code> pipeline.</p><p>Finally let's look at the code for the modified <code>push</code> function to get back<br>predictable performance</p><h3>Predictable calls</h3><div class="highlight highlight-source-assembly"><pre><span class="pl-en">// Function prelude</span><span class="pl-en">00007ff7`d77725e1 4883ec40        </span><span class="pl-k">sub</span><span class="pl-en"></span><span class="pl-v">rsp</span><span class="pl-s1">,</span><span class="pl-c1">58h</span><span class="pl-en">00007ff7`d78625f4 c5f877          </span><span class="pl-k">vzeroupper</span><span class="pl-en">00007ff7`d78625f7 33c0            </span><span class="pl-k">xor</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">eax</span><span class="pl-en">00007ff7`d78625f9 </span><span class="pl-c1">4889442448</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">48h</span><span class="pl-s1">],</span><span class="pl-v">rax</span><span class="pl-en">00007ff7`d78625fe </span><span class="pl-c1">4889442450</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">50h</span><span class="pl-s1">],</span><span class="pl-v">rax</span><span class="pl-en">00007ff7`d7862603 488d442438      </span><span class="pl-k">lea</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">38h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7862608 c5f857c0        </span><span class="pl-k">vxorps</span><span class="pl-en"></span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d786260c c5fa7f00        </span><span class="pl-k">vmovdqu</span><span class="pl-en"> xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">],</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d7862610 8bc2            </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">edx</span><span class="pl-en">// Is number odd?</span><span class="pl-en">00007ff7`d7862612 a801            </span><span class="pl-k">test</span><span class="pl-en"></span><span class="pl-v">al</span><span class="pl-s1">,</span><span class="pl-c1">1</span><span class="pl-en">00007ff7`d7862614 0f94c0          </span><span class="pl-k">sete</span><span class="pl-en"></span><span class="pl-v">al</span><span class="pl-en">00007ff7`d7862617 0fb6c0          </span><span class="pl-k">movzx</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">al</span><span class="pl-en">// Juggling with struct tuple values</span><span class="pl-en">00007ff7`d786261a </span><span class="pl-c1">88442440</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     byte ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">40h</span><span class="pl-s1">],</span><span class="pl-v">al</span><span class="pl-en">00007ff7`d786261e </span><span class="pl-c1">4889542438</span><span class="pl-en"></span><span class="pl-k">mov</span><span class="pl-en">     qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">38h</span><span class="pl-s1">],</span><span class="pl-v">rdx</span><span class="pl-en">00007ff7`d7862623 c5fa6f442438    </span><span class="pl-k">vmovdqu</span><span class="pl-en"></span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-en">xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">38h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7862629 c5fa7f442448    </span><span class="pl-k">vmovdqu</span><span class="pl-en"> xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">48h</span><span class="pl-s1">],</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d786262f 488b4908        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rcx</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rcx</span><span class="pl-s1">+</span><span class="pl-c1">8</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7862633 c5fa6f442448    </span><span class="pl-k">vmovdqu</span><span class="pl-en"></span><span class="pl-v">xmm0</span><span class="pl-s1">,</span><span class="pl-en">xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">48h</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7862639 c5fa7f442428    </span><span class="pl-k">vmovdqu</span><span class="pl-en"> xmmword ptr </span><span class="pl-s1">[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">28h</span><span class="pl-s1">],</span><span class="pl-v">xmm0</span><span class="pl-en">00007ff7`d786263f 488d542428      </span><span class="pl-k">lea</span><span class="pl-en"></span><span class="pl-v">rdx</span><span class="pl-s1">,[</span><span class="pl-v">rsp</span><span class="pl-s1">+</span><span class="pl-c1">28h</span><span class="pl-s1">]</span><span class="pl-en">// Loading vtable to find the address to </span><span class="pl-k">call</span><span class="pl-en"> to</span><span class="pl-en">00007ff7`d7862644 488b01          </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rcx</span><span class="pl-s1">]</span><span class="pl-en">00007ff7`d7862647 488b4040        </span><span class="pl-k">mov</span><span class="pl-en"></span><span class="pl-v">rax</span><span class="pl-s1">,</span><span class="pl-en">qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">+</span><span class="pl-c1">40h</span><span class="pl-s1">]</span><span class="pl-en">// </span><span class="pl-k">Call</span><span class="pl-en"> the next step </span><span class="pl-k">in</span><span class="pl-en"> the pipeline</span><span class="pl-en">00007ff7`d786264b ff5020          </span><span class="pl-k">call</span><span class="pl-en">    qword ptr </span><span class="pl-s1">[</span><span class="pl-v">rax</span><span class="pl-s1">+</span><span class="pl-c1">20h</span><span class="pl-s1">]</span><span class="pl-en">// The function returns</span><span class="pl-s1">,</span><span class="pl-en"> clear </span><span class="pl-v">eax</span><span class="pl-en">00007ff7`d786264e 33c0            </span><span class="pl-k">xor</span><span class="pl-en"></span><span class="pl-v">eax</span><span class="pl-s1">,</span><span class="pl-v">eax</span><span class="pl-en">// Deallocate stackframe</span><span class="pl-en">00007ff7`d7862650 4883c458        </span><span class="pl-k">add</span><span class="pl-en"></span><span class="pl-v">rsp</span><span class="pl-s1">,</span><span class="pl-c1">58h</span><span class="pl-en">// Return to previous chain</span><span class="pl-en">00007ff7`d7862654 c3              </span><span class="pl-k">ret</span></pre></div><p>Because juggling with struct tuple is more complex than the first example it is<br>more complex code but at least the next step in the pipeline is invoked without<br>the need of <code>coreclr!JIT_TailCall</code> which means the performance is reasonable and<br>predictable.</p><p>It turns out that the only overhead of <code>match r v with () -&gt; ()</code> ends up being a<br><code>xor eax,eax</code> which is essentially free compared to everything else.</p><h1>Frustration sets in...</h1><p>I believe for most of us we only have to make that we just have to avoid writing<br>code that has TRUELY TERRIBLE PERFORMANCE. We can get away with bad performance<br>in 99% of all code we write.</p><p>However, if I need to write performant code in F# (and maybe future versions of<br>C#) because tail calls are really really slow I have to be very careful to ensure<br>with the code I write so that the F# compiler don't emit the <code>.tail</code> attribute.</p><p>Sure, I have a pattern that allows me to do it in this case but what if F# compiler improves in future releases and eliminate the nonsense code I wrote to avoid tail calls? The F# compiler has compiler options that allows me to suppress tail calls but F# also supports true inlining which means even if my library is compiled without tail calls when the functions are inlined into the calling assembly it might well inject tail calls.</p><p>Further, sometimes the tail calls does go faster when no stack frame is needed.</p><p>This puts me in a frustrating spot; I want tail calls but I don't want to pay the<br>price of the worst case tail call performance.</p><p>Obviously the best solution would be that tail calls are always faster than normal<br>calls but I am sure that is tricky to implement (otherwise it would have been done already).</p><p>The second best solution for my particular scenario would be, if the tail call<br>can be faster than normal calls let's do it otherwise fallback to normal calls.<br>That is probably confusing as then it doesn't always have the correct semantics<br>of a tail call but for this particular scenario that is what I want.</p><p>I realize F# is a small language so I am hoping that the C# compiler will start<br>emitting <code>.tail</code> attributes so that the big C# community will notice the awkward<br>performance of tail calls.</p><p>Be sure to complain to <a href="https://www.twitch.tv/visualstudio" rel="nofollow">Microsoft Language &amp; Runtime Community standup on twitch</a><br>if you were bored by this rant and want to see less of it.</p><p>Regards.</p><h1>Full sample code</h1><div class="highlight highlight-source-fsharp"><pre><span class="pl-c">// Turn off tiered compilation</span><span class="pl-c">// $env:COMPlus_TieredCompilation="0"</span><span class="pl-c">// dotnet core    : 3.1.100</span><span class="pl-c">// FSharp.Core    : 4.7.0</span><span class="pl-c">// BenchMarkDotNet: 0.12.0</span><span class="pl-en"><span class="pl-k">module</span><span class="pl-en">TailCall </span>=</span><span class="pl-k">open</span><span class="pl-en">System</span><span class="pl-k">open</span><span class="pl-en">System.<span class="pl-en">Linq</span></span><span class="pl-k">open</span><span class="pl-en">System.<span class="pl-en">Diagnostics</span></span><span class="pl-c">//    let inline push      r v      = match r v with () -&gt; ()</span><span class="pl-c">//    let inline push      r v      = r v</span><span class="pl-c">// Minimalistic PushStream</span><span class="pl-c">//  A PushStream accepts a receiver function that will be called</span><span class="pl-c">//  with each value in the PushStream</span><span class="pl-k">type</span><span class="pl-en">'T PushStream </span><span class="pl-k">=</span> ('T <span class="pl-k">-&gt;</span><span class="pl-c1">unit</span>) <span class="pl-k">-&gt;</span><span class="pl-c1">unit</span><span class="pl-en"><span class="pl-k">module</span><span class="pl-en">PushStream </span>=</span><span class="pl-k">let inline</span><span class="pl-smi">zero</span><span class="pl-c1">()</span><span class="pl-k">=</span> LanguagePrimitives.GenericZero
    <span class="pl-k">let inline</span><span class="pl-smi">push</span><span class="pl-v">r</span><span class="pl-v">v</span><span class="pl-k">=</span> r v

    <span class="pl-c">// Creates a PushStream with all integers from b to e (inclusive)</span><span class="pl-k">let inline</span><span class="pl-smi">fromRange</span><span class="pl-v">b</span><span class="pl-v">e</span><span class="pl-v">r</span><span class="pl-k">=</span><span class="pl-k">for</span> i <span class="pl-k">=</span> b to e <span class="pl-k">do</span> push r i
    <span class="pl-c">// Maps all values in ps using mapping function f</span><span class="pl-k">let inline</span><span class="pl-smi">map</span><span class="pl-v">f</span><span class="pl-v">ps</span><span class="pl-v">r</span><span class="pl-k">=</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> push r (f v))
    <span class="pl-c">// Filters all values in ps using filter function f</span><span class="pl-k">let inline</span><span class="pl-smi">filter</span><span class="pl-v">f</span><span class="pl-v">ps</span><span class="pl-v">r</span><span class="pl-k">=</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">if</span> f v <span class="pl-k">then</span> push r v)
    <span class="pl-c">// Sums all values in ps</span><span class="pl-k">let inline</span><span class="pl-smi">sum</span><span class="pl-v">ps</span><span class="pl-k">=</span><span class="pl-k">let mutable</span><span class="pl-smi">s</span><span class="pl-k">=</span> zero <span class="pl-c1">()</span><span class="pl-k">in</span> ps (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> s <span class="pl-k">&lt;-</span> s <span class="pl-k">+</span> v)<span class="pl-k">;</span> s

  <span class="pl-en"><span class="pl-k">module</span><span class="pl-en">Tests </span>=</span><span class="pl-k">open</span><span class="pl-en">BenchmarkDotNet.<span class="pl-en">Attributes</span></span><span class="pl-k">open</span><span class="pl-en">BenchmarkDotNet.<span class="pl-en">Running</span></span><span class="pl-k">type</span><span class="pl-en">Benchmarks </span><span class="pl-c1">()</span><span class="pl-k">=</span><span class="pl-c1">[&lt;Params (<span class="pl-c1">10000</span>, <span class="pl-c1">1000</span>, <span class="pl-c1">100</span>)&gt;]</span><span class="pl-k">member</span><span class="pl-smi">val</span><span class="pl-v">public</span><span class="pl-v">Count</span><span class="pl-k">=</span><span class="pl-c1">100</span><span class="pl-k">with</span> get, set

      <span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimpleImperativeTest</span><span class="pl-c1">()</span><span class="pl-k">=</span><span class="pl-k">let mutable</span><span class="pl-smi">i</span><span class="pl-k">=</span> x.Count
        <span class="pl-k">let mutable</span><span class="pl-smi">sum</span><span class="pl-k">=</span><span class="pl-c1">0</span>L
        <span class="pl-k">while</span> i <span class="pl-k">&gt;=</span><span class="pl-c1">0</span><span class="pl-k">do</span><span class="pl-k">let</span><span class="pl-smi">v</span><span class="pl-k">=</span>  int64 i
          i     <span class="pl-k">&lt;-</span> i <span class="pl-k">-</span><span class="pl-c1">1</span><span class="pl-k">if</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L <span class="pl-k">then</span>
            sum <span class="pl-k">&lt;-</span> sum <span class="pl-k">+</span> (v <span class="pl-k">+</span><span class="pl-c1">1</span>L)
        sum

      <span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimpleLinqTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
        Enumerable.Range(<span class="pl-c1">0</span>, x.Count)
          .Select(int64)
          .Where(<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L)
          .Select((<span class="pl-k">+</span>) <span class="pl-c1">1</span>L)
          .Sum<span class="pl-c1">()</span><span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.SimplePushStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
        PushStream.fromRange  <span class="pl-c1">0</span> x.Count
        <span class="pl-k">|&gt;</span> PushStream.map     int64
        <span class="pl-k">|&gt;</span> PushStream.filter  (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span> (v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L)
        <span class="pl-k">|&gt;</span> PushStream.map     ((<span class="pl-k">+</span>) <span class="pl-c1">1</span>L)
        <span class="pl-k">|&gt;</span> PushStream.sum

      <span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.StructLinqStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
        Enumerable.Range(<span class="pl-c1">0</span>, x.Count)
          .Select(int64)
          .Select(<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">struct</span> ((v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L, v))
          .Select(<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">struct</span> (b, v <span class="pl-k">+</span><span class="pl-c1">1</span>L))
          .Select(<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">if</span> b <span class="pl-k">then</span> v <span class="pl-k">else</span><span class="pl-c1">0</span>L)
          .Sum<span class="pl-c1">()</span><span class="pl-c1">[&lt;Benchmark&gt;]</span><span class="pl-k">member</span><span class="pl-smi">x.StructPushStreamTest</span><span class="pl-c1">()</span><span class="pl-k">=</span>
        PushStream.fromRange <span class="pl-c1">0</span> x.Count
        <span class="pl-k">|&gt;</span> PushStream.map     int64
        <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">v</span> -<span class="pl-k">&gt;</span><span class="pl-k">struct</span> ((v <span class="pl-k">&amp;&amp;&amp;</span><span class="pl-c1">1</span>L) <span class="pl-k">=</span><span class="pl-c1">0</span>L, v))
        <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">struct</span> (b, v <span class="pl-k">+</span><span class="pl-c1">1</span>L))
        <span class="pl-k">|&gt;</span> PushStream.map     (<span class="pl-k">fun</span><span class="pl-v">struct</span> (b, v) <span class="pl-k">-&gt;</span><span class="pl-k">if</span> b <span class="pl-k">then</span> v <span class="pl-k">else</span><span class="pl-c1">0</span>L)
        <span class="pl-k">|&gt;</span> PushStream.sum

    <span class="pl-k">let</span><span class="pl-smi">now</span><span class="pl-k">=</span><span class="pl-k">let</span><span class="pl-smi">sw</span><span class="pl-k">=</span> Stopwatch <span class="pl-c1">()</span>
      sw.Start <span class="pl-c1">()</span><span class="pl-k">fun</span> () <span class="pl-k">-&gt;</span> sw.ElapsedMilliseconds

    <span class="pl-k">let</span><span class="pl-smi">time</span><span class="pl-v">o</span><span class="pl-v">a</span><span class="pl-k">=</span><span class="pl-k">let inline</span><span class="pl-smi">cc</span><span class="pl-v">n</span><span class="pl-k">=</span> GC.CollectionCount n

      <span class="pl-k">let</span><span class="pl-smi">v</span><span class="pl-k">=</span> a <span class="pl-c1">()</span>

      GC.Collect (<span class="pl-c1">2</span>, GCCollectionMode.Forced)
      GC.WaitForFullGCComplete <span class="pl-c1">()</span><span class="pl-k">|&gt;</span> ignore

      <span class="pl-k">let</span><span class="pl-smi">bcc0, bcc1, bcc2</span><span class="pl-k">=</span> cc <span class="pl-c1">0</span>, cc <span class="pl-c1">1</span>, cc <span class="pl-c1">2</span><span class="pl-k">let</span><span class="pl-smi">before</span><span class="pl-k">=</span> now <span class="pl-c1">()</span><span class="pl-k">for</span><span class="pl-k">_</span><span class="pl-k">=</span><span class="pl-c1">1</span> to o <span class="pl-k">do</span>
        a <span class="pl-c1">()</span><span class="pl-k">|&gt;</span> ignore

      <span class="pl-k">let</span><span class="pl-smi">after</span><span class="pl-k">=</span> now <span class="pl-c1">()</span><span class="pl-k">let</span><span class="pl-smi">acc0, acc1, acc2</span><span class="pl-k">=</span> cc <span class="pl-c1">0</span>, cc <span class="pl-c1">1</span>, cc <span class="pl-c1">2</span>

      v, (after <span class="pl-k">-</span> before), (acc0 <span class="pl-k">-</span> bcc0, acc1 <span class="pl-k">-</span> bcc1, acc2 <span class="pl-k">-</span> bcc2)

    <span class="pl-k">let</span><span class="pl-smi">run</span><span class="pl-v">argv</span><span class="pl-k">=</span><span class="pl-k">let</span><span class="pl-smi">b</span><span class="pl-k">=</span> BenchmarkSwitcher <span class="pl-k">[|</span>typeof<span class="pl-k">&lt;</span>Benchmarks<span class="pl-k">&gt;|]</span><span class="pl-k">let</span><span class="pl-smi">summary</span><span class="pl-k">=</span> b.Run argv
      printfn <span class="pl-s"><span class="pl-pds">"</span>%A<span class="pl-pds">"</span></span> summary

    <span class="pl-c">// BenchMarkDotNet is good but the runs takes too long for me for experimentation</span><span class="pl-c">//  Then I rely on quickRun</span><span class="pl-k">let</span><span class="pl-smi">quickRun</span><span class="pl-c1">()</span><span class="pl-k">=</span><span class="pl-k">let inline</span><span class="pl-smi">testCase</span><span class="pl-v">n</span><span class="pl-v">a</span><span class="pl-k">=</span> n, <span class="pl-k">fun</span><span class="pl-v">c</span> -<span class="pl-k">&gt;</span> string (a c)

      <span class="pl-k">let</span><span class="pl-smi">benchmarks</span><span class="pl-k">=</span> Benchmarks <span class="pl-c1">()</span><span class="pl-k">let</span><span class="pl-smi">testCases</span><span class="pl-k">=</span><span class="pl-k">[|</span>
          testCase  <span class="pl-s"><span class="pl-pds">"</span>simple, imperative<span class="pl-pds">"</span></span>  benchmarks.SimpleImperativeTest
          testCase  <span class="pl-s"><span class="pl-pds">"</span>simple, linq<span class="pl-pds">"</span></span>        benchmarks.SimpleLinqTest
          testCase  <span class="pl-s"><span class="pl-pds">"</span>simple, pushstream<span class="pl-pds">"</span></span>  benchmarks.SimplePushStreamTest
<span class="pl-c">//          testCase  "struct, linq"        benchmarks.StructLinqStreamTest</span><span class="pl-c">//          testCase  "struct, pushstream"  benchmarks.StructPushStreamTest</span><span class="pl-k">|]</span><span class="pl-k">let</span><span class="pl-smi">total</span><span class="pl-k">=</span><span class="pl-c1">100000000</span><span class="pl-k">let</span><span class="pl-smi">inners</span><span class="pl-k">=</span><span class="pl-k">[|</span><span class="pl-c1">1000000</span><span class="pl-k">;</span><span class="pl-c1">10000</span><span class="pl-k">;</span><span class="pl-c1">100</span><span class="pl-k">|]</span><span class="pl-k">for</span> inner <span class="pl-k">in</span> inners <span class="pl-k">do</span><span class="pl-k">let</span><span class="pl-smi">outer</span><span class="pl-k">=</span> total <span class="pl-k">/</span> inner

        benchmarks.Count <span class="pl-k">&lt;-</span> inner

        printfn <span class="pl-s"><span class="pl-pds">"</span>Performance test, total: %d, outer: %d, inner: %d<span class="pl-pds">"</span></span> total outer inner

        <span class="pl-k">for</span> n, a <span class="pl-k">in</span> testCases <span class="pl-k">do</span>
          printfn <span class="pl-s"><span class="pl-pds">"</span>  Running '%s'...<span class="pl-pds">"</span></span> n
          <span class="pl-k">let</span><span class="pl-smi">v, r, cc</span><span class="pl-k">=</span> time outer a
          printfn <span class="pl-s"><span class="pl-pds">"</span>    result is %A, it took %d ms to produce with (%A) CC<span class="pl-pds">"</span></span> v r cc

<span class="pl-c1">[&lt;EntryPoint&gt;]</span><span class="pl-k">let</span><span class="pl-smi">main</span><span class="pl-v">argv</span><span class="pl-k">=</span><span class="pl-c">//  TailCall.Tests.quickRun ()</span>
  TailCall.Tests.run argv
  <span class="pl-c1">0</span></pre></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>