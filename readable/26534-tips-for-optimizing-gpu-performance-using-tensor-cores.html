<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Tips for Optimizing GPU Performance Using Tensor Cores -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Tips for Optimizing GPU Performance Using Tensor Cores</h1>
    <div class="entry-content"> <p>Our most popular question is &#x201C;What can I do to get great GPU performance for deep learning?&#x201D;&#xA0;We&#x2019;ve recently published a detailed <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html">Deep Learning Performance Guide</a>&#xA0;to help answer this question.&#xA0;The guide explains how GPUs process data and gives tips on how to design networks for better performance. We also take a close look at Tensor Core optimization to help improve performance.</p>
<p>This post takes a closer look at some of the most important recommendations from the guide.&#xA0;We&#x2019;ll give a general guideline and explanation for each tip, apply the guideline to an example layer, and compare performance before and after.&#xA0;</p>
<p>This post can be read standalone. However, we suggest you refer&#xA0;to the Deep Learning Performance Guide for a better understanding of why deep learning tasks perform the way they do on GPUs and how to improve that performance.</p>
<h2 id="h.3x7mf460q9aw">Tip 1: Activating Tensor Cores</h2>
<p>Tensor Cores, available on Volta and subsequent GPU architectures, accelerate common deep learning operations&#x2014;specifically computationally-intensive tasks such as fully-connected and convolutional layers.</p>
<p>Workloads must use mixed precision to take advantage of Tensor Cores. Check out our post on <a href="https://developer.nvidia.com/automatic-mixed-precision">Automatic Mixed Precision</a>&#xA0;for quick setup and our <a href="https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html">Training With Mixed Precision Guide</a>&#xA0;for more details. &#xA0;<strong>Additionally, Tensor Cores are activated when certain parameters of a layer are divisible by 8 (for FP16 data) or 16 (for INT8 data). &#xA0;</strong>A fully-connected layer with a batch size and number of inputs and outputs that follow this rule will use Tensor Cores, as will a convolutional layer with a number of input and output channels that do the same<strong>.</strong>&#xA0;</p>
<p>This is due to how GPUs store and access data. Layers that don&#x2019;t meet this requirement are still accelerated on the GPU. However, these layers use 32-bit&#xA0;CUDA cores instead of Tensor Cores as a fallback option.</p>
<p>Note: There are cases where we relax the requirements. However, following these guidelines is the easiest way to ensure&#xA0;enabling&#xA0;Tensor Cores. For details, see sections on <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#requirements-tc">Tensor Core Requirements</a>&#xA0;for matrix multiplies and <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#channels">Channels In and Out</a>&#xA0;of convolutions from the Deep Learning Performance Guide.</p>
<p>Let&#x2019;s look at two examples from the popular Transformer neural network to illustrate the kind of speedup you can expect from activating Tensor Cores . Transformers, described in <em>Attention Is All You Need</em>&#xA0;[Vaswani 2017], are currently state-of-the-art networks for language translation and other sequence tasks. Much of a Transformer network consists of fully-connected layers. We&#x2019;ll discuss ways to optimize a few for Tensor Cores.</p>
<h3 id="h.9yili3t5wcy5">Padding Vocabulary Size &#x2013; Projection&#xA0;Layer Example</h3>
<p>Figure 1 shows a simplified representation of a Transformer network. The&#xA0;network outputs a vector containing a probability for each token in the vocabulary. This vector of probabilities is produced using the softmax&#xA0;function over the outputs from a fully-connected layer, which we&#x2019;ll call the projection layer. The number of outputs of this layer is equal to the vocabulary size, often in excess of 30,000. Given the heavyweight computation involved, it&#x2019;s important to ensure effective Tensor Core use.</p>
<figure id="attachment_14694" class="wp-caption aligncenter"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1.png"><img class="wp-image-14694 size-full" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1.png" alt="Softmax conversion diagram" width="624" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1.png 624w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1-300x78.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1-500x130.png 500w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1-160x42.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1-362x94.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/Figure1-424x110.png 424w" sizes="(max-width: 624px) 100vw, 624px"></a><figcaption id="figcaption_attachment_14694" class="wp-caption-text">Figure 1. The projection layer (labeled FC) produces a vector of output values, one per word in the vocabulary. Softmax converts these values to a probability distribution; the word with the highest probability is the predicted output for this step. Three steps are shown here in different colors.</figcaption></figure>
<p><img alt>Figure 2 shows the performance of one such projection layer, with 1024 inputs and a batch size of 5120, training on FP16 data on a Volta Tesla V100. Suppose we are using the combined English-German training datasets for the <a href="http://statmt.org/wmt14/translation-task.html">WMT14 task</a>, which have&#xA0;a vocabulary size of 33708. Simply padding&#xA0;the vocabulary size to the next multiple of 8 activates Tensor Cores and improves throughput significantly.</p>
<figure id="attachment_14682" class="wp-caption aligncenter"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120.png"><img class="wp-image-14682 size-large" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-625x431.png" alt="Projection layer performance chart" width="625" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-625x431.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-300x207.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-768x530.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-435x300.png 435w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-131x90.png 131w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-362x250.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120-160x110.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nbatch5120.png 931w" sizes="(max-width: 625px) 100vw, 625px"></a><figcaption id="figcaption_attachment_14682" class="wp-caption-text">Figure 2. Activating Tensor Cores by choosing&#xA0;the vocabulary size to be a multiple of 8 substantially benefits performance of the projection&#xA0;layer. For all data shown, the layer uses 1024 inputs and a batch size of 5120. (Measured using FP16 data, Tesla V100 GPU, cuBLAS 10.1.)</figcaption></figure>
<h3 id="h.l1b3p7b632a5">Choosing Batch Size for Tensor Cores &#x2013; Feed-Forward Layer Example</h3>
<p>The Transformer architecture also contains fully-connected layers as part of self-attention and feed-forward blocks. Let&#x2019;s consider the first layer in a feed-forward block, a fully-connected layer&#xA0;with 1024 inputs and 4096 outputs. This layer&#x2019;s batch size depends on batch assembly, which splits inputs to the network into batches, up to some maximum batch size. When assembly doesn&#x2019;t consider Tensor Cores, irregularly-sized batches may be created.</p>
<p>Performance of this layer&#x2019;s training steps with several batch sizes is shown in figure 3. This is an example where Tensor Core requirements are relaxed. Both forward and activation gradient passes perform the same with and without padding. The weight gradient pass, on the other hand, shows the same dramatic performance difference we saw in figure 2. CUDA cores are used as a fallback for weight gradient computation with batch sizes of 4084 or 4095 tokens, using 4088 or 4096 tokens per batch instead enables Tensor Core acceleration.</p>
<figure id="attachment_14686" class="wp-caption aligncenter"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1.png"><img class="wp-image-14686 size-large" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-625x423.png" alt="Feedforward layer performance chart" width="625" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-625x423.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-300x203.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-768x520.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-443x300.png 443w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-133x90.png 133w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-362x245.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1-163x110.png 163w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-1.png 949w" sizes="(max-width: 625px) 100vw, 625px"></a><figcaption id="figcaption_attachment_14686" class="wp-caption-text">Figure 3. Activating Tensor Cores by choosing batch size to be a multiple of 8 benefits performance of the first fully-connected layer in the feed-forward block (1024 inputs, 4096 outputs). The weight gradient pass shows significant improvement with Tensor Cores over CUDA cores; forward and activation gradient passes demonstrate that Tensor Cores may activate for some parts of training even when a parameter is indivisible by 8. (Measured using FP16 data, Tesla V100 GPU, cuBLAS 10.1.)</figcaption></figure>
<p>At least one of the forward, activation gradient, and weight gradient passes will not be accelerated by Tensor Cores when any relevant parameter is not optimally sized. We recommend ensuring all such parameters are multiples of 8 when training with FP16 and multiples of 16 when training with INT8. These include batch size and number of inputs and outputs, for a fully-connected layer and channels in and out, for a convolutional layer. This is the easiest way to guarantee Tensor Cores will accelerate your task!</p>
<h3 id="h.g2god3ge3ch">Checking for Tensor Core Usage</h3>
<p>You can use <a href="https://devblogs.nvidia.com/using-nsight-compute-nvprof-mixed-precision-deep-learning-models/">NVIDIA&#x2019;s profiling tools</a>&#xA0;to check if Tensor Cores have been activated. More information about these tools is available in the <a href="https://docs.nvidia.com/cuda/profiler-users-guide/index.html">CUDA documentation</a>.</p>
<p>Note: although we focus on Tensor Cores in this post, deep learning operations not accelerated by Tensor Cores also contribute to overall network performance. You can read about these operations in the <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#mem-limited">Memory-Limited Layers</a>&#xA0;section of the Deep Learning Performance Guide, and about further optimizations and <a href="https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html#decrease-nontc">decreasing non-Tensor-Core work</a>&#xA0;in the Training With Mixed Precision documentation.</p>
<h2 id="h.5ewahopem94a">Tip 2: Considering Quantization Effects</h2>
<p>We&#x2019;ve focused so far on how to ensure&#xA0;Tensor Cores are accelerating your task. Now let&#x2019;s discuss efficiency on the GPU and a few parameter tweaks that can help you get the most out of Tensor Cores.</p>
<p>GPUs perform many computations concurrently; we refer to these parallel computations as threads. Conceptually, threads are grouped into thread blocks, each of which is responsible for a subset of the calculations being done. When the GPU executes a task, it is split into equally-sized thread blocks.</p>
<p>Now&#xA0;consider a fully-connected layer. During training, forward propagation, activation gradient calculation, and weight gradient calculation are each represented as a matrix multiply. The GPU divides the output matrix into uniformly-sized, rectangular tiles. Each tile is computed by a thread block; figure 4 illustrates the process for one such tile. You can find cases where multiple thread blocks contribute to one tile, but for simplicity, we&#x2019;ll assume one thread block per tile in this post. More detail can be found in the Deep Learning Performance Guide, in the sections discussing <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#gpu-perf">GPU efficiency</a>&#xA0;and <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#cublas-tile-dim">tiling</a>.</p>
<figure id="attachment_14684" class="wp-caption aligncenter"><img class="wp-image-14684 size-full" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1.png" alt="Matrix multiply layout figure" width="401" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1.png 401w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1-300x266.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1-338x300.png 338w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1-101x90.png 101w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1-362x321.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-1-124x110.png 124w" sizes="(max-width: 401px) 100vw, 401px"><figcaption id="figcaption_attachment_14684" class="wp-caption-text">Figure 4. A matrix multiply (A &#x22C5; B = C) is computed by dividing the output (C) matrix into tiles of size Mtile x Ntile and stepping through the K dimension.</figcaption></figure>
<p>However, not all output matrices divide evenly into an available tile size. Further, the thread blocks created may not divide evenly among the multiprocessors on the GPU. These effects, called <em>tile quantization</em>&#xA0;and <em>wave quantization</em>&#xA0;respectively, can lead to wasted cycles and inefficiency.</p>
<p>Tile quantization occurs when one dimension of the output matrix is not evenly divisible by the corresponding tile dimension. The thread blocks for the final row or column of tiles created for the remainder then perform the same amount of math as any other column, but produce a smaller amount of useful output data. While the cuBLAS library tries to choose the best tile size available, most tile sizes are powers of 2. To avoid tile quantization, <strong>choose</strong> <strong>parameters that are divisible by powers of 2</strong> (at least 64 and ideally 256, to account for the most common tile sizes).</p>
<p>We also consider the number of thread blocks that can run concurrently on the GPU for wave quantization. Take the example of a Tesla V100 GPU, which has 80 multiprocessors and a tile size of 256&#xD7;128, where the V100 GPU can execute one thread block per multiprocessor. In this case, a wave of 80 thread blocks fully occupies the GPU. Suppose a task creates 96 thread blocks. The first 80 will be computed efficiently as a &#x2018;full wave&#x2019; while the 16 leftover thread blocks will make up an inefficient &#x2018;tail wave&#x2019; during which the GPU is underutilized. Figure 5 illustrates a simple version of this situation.</p>
<figure id="attachment_14683" class="wp-caption aligncenter"><img class="wp-image-14683 size-full" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0.png" alt="Threadblock split example diagram" width="305" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0.png 305w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-300x155.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-160x83.png 160w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/pasted-image-0-212x110.png 212w" sizes="(max-width: 305px) 100vw, 305px"><figcaption id="figcaption_attachment_14683" class="wp-caption-text">Figure 5. On a GPU with 8 SMs, a task with 12 thread blocks will be split into a wave of 8 thread blocks (occupying all SMs) and a tail wave of 4 thread blocks (occupying only 50% of SMs). Thus, overall GPU utilization for the task will be 75% at best.</figcaption></figure>
<p>Absent information about what tile size will be used, <strong>choose parameters so that the total number of tiles/thread blocks is divisible by the number of multiprocessors</strong>&#xA0;to avoid wave quantization effects.</p>
<p>Now let&#x2019;s look at how this maps back to parameters of a fully-connected layer. Figure 6 shows the dimensions of equivalent matrix multiplies for forward, activation gradient, and weight gradient passes.</p>
<figure id="attachment_14713" class="wp-caption aligncenter"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6.jpg"><img class="wp-image-14713 size-full" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6.jpg" alt="Equivalent matrix multiplies for different calculation types diagram" width="727" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6.jpg 727w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-300x116.jpg 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-625x242.jpg 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-500x194.jpg 500w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-160x62.jpg 160w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-362x140.jpg 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/figure6-284x110.jpg 284w" sizes="(max-width: 727px) 100vw, 727px"></a><figcaption id="figcaption_attachment_14713" class="wp-caption-text">Figure 6. Equivalent matrix multiplies for (a) forward propagation, (b) activation gradient calculation, and (c) weight gradient calculation of a fully-connected layer. The Deep Learning Performance Guide contains <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#fullyconnected-layer">details</a>&#xA0;as well as the <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#imp-gemm-dim">equivalent dimensions for convolutional layers</a>.</figcaption></figure>
<p>Batch size directly controls the width of the output matrix during both forward and activation gradient passes. Consider again our previous example of the first layer in a Transformer feed-forward block (a fully-connected layer with 1024 inputs and 4096 outputs). During forward propagation, the output matrix is of shape 4096 x batch size. Assuming a tile size of 256&#xD7;128, this matrix divides into 4096/256 = 16 rows and (batch size) / 128 columns of tiles.</p>
<p>Avoiding tile quantization is straightforward: batch size should be divisible by 128.&#xA0;Wave quantization is more complex. For some integer n, we want n*80 total tiles and already know that there will be 16 rows of tiles. Therefore, our task should create n*5 columns of tiles. Given a tile width of 128, this corresponds to an output matrix width (and batch size) of n*5*128 = n*640. Thus, choosing batch size to be divisible by 640 avoids wave quantization effects.</p>
<p>The Deep Learning Performance Guide goes into more detail about <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#dim-quantization">both types of quantization effects</a>,&#xA0;<a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#quant-effects">as well as how this applies to convolutions</a>, with examples.</p>
<h3 id="h.de96g34t3ue7">Choosing Batch Size for Quantization &#x2013; Feed-Forward Layer Example</h3>
<p>Figure 7 shows the performance&#xA0;of our example feed-forward layer for several different batch sizes. Choosing a quantization-free batch size (2560 instead of 2048, 5120 instead of 4096) considerably improves performance. Notice that a batch size of 2560 (resulting in 4 waves of 80 thread blocks) <em>achieves higher throughput than the larger batch size of 4096</em>&#xA0;(a total of 512 tiles, resulting in 6 waves of 80 thread blocks and a tail wave remainder of 32 thread blocks). The weight gradient pass doesn&#x2019;t show this drastic change. Batch size maps to the &#x2018;K&#x2019; dimension of the matrix multiply during this pass and thus does not directly control the size of the output matrix or the number of tiles and thread blocks created.</p>
<figure id="attachment_14681" class="wp-caption aligncenter"><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096.png"><img class="wp-image-14681 size-large" src="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-625x423.png" alt="Feedforward performance with differing batches chart" width="625" srcset="https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-625x423.png 625w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-300x203.png 300w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-768x520.png 768w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-443x300.png 443w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-133x90.png 133w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-362x245.png 362w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096-163x110.png 163w, https://devblogs.nvidia.com/wp-content/uploads/2019/06/fig_num_tests1_tfactor100_invalid-tensorformat_Depthwise-Separable_GEMM__fillr_nin1024_nout4096.png 949w" sizes="(max-width: 625px) 100vw, 625px"></a><figcaption id="figcaption_attachment_14681" class="wp-caption-text">Figure 7. Choosing batch size to avoid wave quantization effects improves performance of the first fully-connected layer in the feed-forward block (1024 inputs, 4096 outputs) during the forward and activation gradient passes. Wave quantization does not occur over batch size for the weight gradient pass. (Measured using FP16 data, Tesla V100 GPU, cuBLAS 10.1.)</figcaption></figure>
<h2 id="h.v9dy7afbwy8a">Learning&#xA0;More</h2>
<p>Learn more about how to ensure&#xA0;your network is taking advantage of Tensor Cores from the <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html">Deep Learning Performance Guide</a>. To get started, read <a href="https://docs.nvidia.com/deeplearning/sdk/dl-performance-guide/index.html#perf-guidelines">our summary of performance guidelines</a>, which offers quick rundown of the most important information about Tensor Core performance and includes tips that you can apply to your network in a few minutes! &#xA0;Each part of the summary links to other sections in the guide where you can find more detail about the topic.</p>
<p>Also, check out the recording of GTC Silicon Valley 2019 session S9926: <a href="https://developer.nvidia.com/gtc/2019/video/S9926">Tensor Core Performance: The Ultimate Guide</a>&#xA0;and S9143: <a href="https://developer.nvidia.com/gtc/2019/video/S9143">Mixed Precision Training of Deep Neural Networks</a>. &#xA0;Additional information about how to train using mixed precision can be found in the <a href="https://arxiv.org/abs/1710.03740">Mixed Precision Training paper</a>&#xA0;and <a href="https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html">Training With Mixed Precision documentation</a>.</p>
<h3 id="h.oku6rqmulm89">References</h3>
<p>[Vaswani 2017] Ashish Vaswani, <a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a>, arXiv:1706.03762, 2017.&#xA0;</p> <div class="entry-content-author"> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>