<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What&#x27;s Deno, and how is it different from Node.js? -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>What's Deno, and how is it different from Node.js?</h1><div><div id="" class="article-post"><p>Ryan Dahl, creator of <a href="https://blog.logrocket.com/use-cases-for-node-workers/" target="_blank" rel="noopener noreferrer">Node.js</a>, has spent the last year and a half working on <a href="https://deno.land/">Deno</a>, a new runtime for JavaScript that is supposed to fix all the inherent problems of Node.</p><p>Don’t get me wrong, Node is a great server-side JavaScript runtime in its own right, mostly due to its vast ecosystem and the usage of JavaScript. However, Dahl admits there are a few things he should have thought about more — security, modules, and dependencies, to name a few.</p><p>In his defense, it’s not like he could envision how much the platform would grow in such a short period of time. Also, back in 2009, JavaScript was still this weird little language that everyone made fun of, and many of its features weren’t there yet.</p><h2>What is Deno, and what are its main features?</h2><p>Deno is a secure <a href="https://blog.logrocket.com/writing-idiomatic-typescript/" target="_blank" rel="noopener noreferrer">Typescript</a> runtime built on V8, the Google runtime engine for JavaScript.</p><p>It was built with:</p><ul><li>Rust (Deno’s core was written in Rust, Node’s in C++)</li><li>Tokio (the event loop written in Rust)</li><li>TypeScript (Deno supports both JavaScript and TypeScript out of the box)</li><li>V8 (Google’s JavaScript runtime used in Chrome and Node, among others)</li></ul><p>So let’s see what features Deno offers.</p><h3>Security (permissions)</h3><p>Among the most important of Deno’s features is its focus on security.</p><p>As opposed to Node, Deno by default executes the code in a sandbox, which means that runtime has no access to:</p><ul><li>The file system</li><li>The network</li><li>Execution of other scripts</li><li>The environment variables</li></ul><p>Let’s take a look at how the permission system works.</p><pre>(async () =&gt; {
 const encoder = new TextEncoder();
 const data = encoder.encode('Hello world\n');

 await Deno.writeFile('hello.txt', data);
 await Deno.writeFile('hello2.txt', data);
})();</pre><p>The script creates two text files called <code>hello.txt</code> and <code>hello2.txt</code> with a <code>Hello&nbsp;world</code> message within. The code is being executed inside a sandbox, so it has no access to the file system.</p><p>Also note that we are using the Deno namespace instead of the fs module, as we would in Node. The Deno namespace provides many fundamental helper functions. By using the namespace, we are losing the browser compatibility, which will be discussed later on.</p><p>When we run it by executing:</p><pre>deno run write-hello.ts</pre><p>We are prompted with the following:</p><pre>⚠️Deno requests write access to "/Users/user/folder/hello.txt". Grant? [a/y/n/d (a = allow always, y = allow once, n = deny once, d = deny always)]</pre><p>We are actually prompted twice since each call from the sandbox must ask for permission. Of course if we chose the <code>allow always</code> option, we would only get asked once.</p><p>If we choose the <code>deny</code> option, the <code>PermissionDenied</code> error will be thrown, and the process will be terminated since we don’t have any error-handling logic.</p><p>If we execute the script with the following command:</p><pre>deno run --allow-write write-hello.ts</pre><p>There are no prompts and both files are created.</p><p>Aside from the <code>--allow-write</code> flag for the file system, there are also <code>--allow-net</code>, <code>--allow-env</code>, and <code>--allow-run</code> flags to enable network requests, access the environment, and for running subprocesses, respectively.</p><h3>Modules</h3><p>Deno, just like browsers, loads modules by URLs. Many people got confused at first when they saw an import statement with a URL on the server side, but it actually makes sense — just bear with me:</p><pre>import { assertEquals } from "https://deno.land/std/testing/asserts.ts";</pre><p>What’s the big deal with importing packages by their URLs, you may ask? The answer is simple: by using URLs, Deno packages can be distributed without a centralized registry such as <code>npm</code>, which recently has had a lot of problems, all of them explained <a href="https://www.youtube.com/watch?v=MO8hZlgK5zc">here</a>.</p><p>By importing code via URL, we make it possible for package creators to host their code wherever they see fit — decentralization at its finest. <strong>No more <code>package.json</code> and <code>node_modules</code>.</strong></p><p>When we start the application, Deno downloads all the imported modules and caches them. Once they are cached, Deno will not download them again until we specifically ask for it with the <code>--reload</code> flag.</p><p>There are a few important questions to be asked here:</p><h4>What if a website goes down?</h4><p>Since it’s not a centralized registry, the website that hosts the module may be taken down for many reasons. Depending on its being up during development — or, even worse, during production — is risky.</p><p>As we mentioned before, Deno caches the downloaded modules. Since the cache is stored on our local disk, the creators of Deno recommend checking it in our version control system (i.e., git) and keeping it in the repository. This way, even when the website goes down, all the developers retain access to the downloaded version.</p><p>Deno stores the cache in the directory specified under the <code>$DENO_DIR</code> environmental variable. If we don’t set the variable ourselves, it will be set to the system’s default cache directory. We can set the <code>$DENO_DIR</code> somewhere in our local repository and check it into the version control system.</p><h4>Do I have to import it by the URL all the time?</h4><p>Constantly typing URLs would be very tedious. Thankfully, Deno presents us with two options to avoid doing that.</p><p>The first option is to re-export the imported module from a local file, like so:</p><pre>export { test, assertEquals } from "https://deno.land/std/testing/mod.ts";</pre><p>Let’s say the file above is called <code>local-test-utils.ts</code>. Now, if we want to again make use of either <code>test</code> or <code>assertEquals</code> functions, we can just reference it like this:</p><pre>import { test, assertEquals } from './local-test-utils.ts';</pre><p>So it doesn’t really matter if it’s loaded from a URL or not.</p><p>The second option is to create an imports map, which we specify in a JSON file:</p><pre>{
   "imports": {
      "http/": "https://deno.land/std/http/"
   }
}</pre><p>And then import it as such:</p><pre>import { serve } from "http/server.ts";</pre><p>In order for it to work, we have to tell Deno about the imports map by including the <code>--importmap</code> flag:</p><pre>deno run --importmap=import_map.json hello_server.ts</pre><h4>What about package versioning?</h4><p>Versioning has to be supported by the package provider, but from the client side it comes down to just setting the version number in the URL like so: <code><a href="https://unpkg.com/liltest@0.0.5/dist/liltest.js" rel="nofollow">https://unpkg.com/liltest@0.0.5/dist/liltest.js</a></code>.</p><h3>Browser compatibility</h3><p>Deno aims to be browser-compatible. Technically speaking, when using the ES modules, we don’t have to use any build tools like webpack to make our application ready to use in a browser.</p><p>However, tools like Babel will transpile the code to the ES5 version of JavaScript, and as a result, the code can be run even in older browsers that don’t support all the newest features of the language. But that also comes at the price of including a lot of unnecessary code in the final file and bloating the output file.</p><p>It is up to us to decide what our main goal is and choose accordingly.</p><h3>TypeScript support out of the box</h3><p>Deno makes it easy to use TypeScript without the need for any config files. Still, it is possible to write programs in plain JavaScript and execute them with Deno without any trouble.</p><h2>Summary</h2><p>Deno, the new runtime for TypeScript and JavaScript, is an interesting project that has been steadily growing for quite some time now. But it still has a long way to go before it’s considered production-ready.</p><p>With it’s decentralized approach, it takes the necessary step of freeing the JavaScript ecosystem from the centralized package registry that is npm.</p><p>Dahl says that he expects to release version 1.0 by the end of the summer, so if you are interested in Deno’s future developments, star <a href="https://github.com/denoland/deno">its repository</a>.</p><div class="code-block code-block-24"><div class="inline-plug node-plug"><h2>200’s only <img src="https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?ssl=1" data-recalc-dims="1" data-lazy-src="https://i0.wp.com/blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?ssl=1&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image">: Monitor failed and slow network requests in production</h2><p class="readability-styled" style="display: inline;"> Deploying a Node-based web app or website is the easy part. Making sure your Node instance continues to serve resources to your app is where things get tougher. If you’re interested in ensuring requests to the backend or third party services are successful, </p><a href="https://logrocket.com/signup/">try LogRocket</a><p class="readability-styled" style="display: inline;">. </p><a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer"><img src="https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?w=1496&amp;ssl=1" alt="LogRocket Network Request Monitoring" data-recalc-dims="1" data-lazy-src="https://i2.wp.com/blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?w=1496&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image"></a><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">LogRocket</a> is like a DVR for web apps, recording literally everything that happens on your site. Instead of guessing why problems happen, you can aggregate and report on problematic network requests to quickly understand the root cause.</p><p class="readability-styled" style="display: inline;"> LogRocket instruments your app to record baseline performance timings such as page load time, time to first byte, slow network requests, and also logs Redux, NgRx, and Vuex actions/state. </p><a class="signup" href="https://logrocket.com/signup/" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p class="readability-styled" style="display: inline;">. </p></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>