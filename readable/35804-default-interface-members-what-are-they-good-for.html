<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Default Interface Members, What Are They Good For? -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Default Interface Members, What Are They Good For?</h1>
    <div id="content" class="col-md-12"> <p><a href="/posts/default-interface-members-and-inheritance">In my last post</a> I promised to look at some of the use cases where I think it&apos;s worthwhile to consider using default interface members. They&apos;re certainly not going to replace many existing conventions, but I have found some situations where targetted use can lead to cleaner, more maintainable code (at least in my own opinion).</p> <p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/default-interface-members-versions">The docs</a> say:</p>
<blockquote class="blockquote">
<p>The most common scenario is to safely add members to an interface already released and used by innumerable clients.</p>
</blockquote>
<p>The problem this solves is that if add a new member to an interface, every type that implements that interface will need to provide an implementation for that member. This may not be such a big deal if the interface is in your own code but as with any breaking change, in a library released to the public or other teams it can create a lot of headaches.</p>
<p>Consider the example from my previous post:</p>
<p>Consider the following code:</p>
<pre><code class="language-csharp">interface ICar
{
    string Make { get; }
}

public class Avalon : ICar
{
    public string Make =&gt; &quot;Toyota&quot;;
}
</code></pre>
<p>If I wanted to add a new <code>GetTopSpeed()</code> method to the interface, I&apos;d need to then implement it in the <code>Avalon</code> class:</p>
<pre><code class="language-csharp">interface ICar
{
    string Make { get; }
    int GetTopSpeed();
}

public class Avalon : ICar
{
    public string Make =&gt; &quot;Toyota&quot;;
    public int GetTopSpeed() =&gt; 130;
}
</code></pre>
<p>However, if I create a default implementation of the new <code>GetTopSpeed()</code> method in <code>ICar</code> I don&apos;t need to add it to every implementing class:</p>
<pre><code class="language-csharp">interface ICar
{
    string Make { get; }
    public int GetTopSpeed() =&gt; 150;
}

public class Avalon : ICar
{
    public string Make =&gt; &quot;Toyota&quot;;
}
</code></pre>
<p>In addition, I can still provide override implementations for classes where the default isn&apos;t appropriate:</p>
<pre><code class="language-csharp">interface ICar
{
    string Make { get; }
    public int GetTopSpeed() =&gt; 150;
}

public class Avalon : ICar
{
    public string Make =&gt; &quot;Toyota&quot;;
    public int GetTopSpeed() =&gt; 130;
}
</code></pre>
<p>One important note though is that as I mentioned in my previous post, the default <code>GetTopSpeed()</code> method will only be available on variables of type <code>ICar</code> and not <code>Avalon</code> if you don&apos;t also provide an override implementation in the class. That means this technique is primarily useful only if you pass around interface types and not implementing types (otherwise you&apos;ll end up with a bunch of casts to the interface type in order to get access to the default member implementations).</p>
<h2 id="mixins-and-traits-sort-of">Mixins and Traits (Sort Of)</h2>
<p><a href="https://en.wikipedia.org/wiki/Mixin">Mixins</a> and the similar language concept of <a href="https://en.wikipedia.org/wiki/Trait_(computer_programming)">traits</a> both describe ways of extending the behavior of an object through composition without resorting to multiple inheritance.</p>
<p><a href="https://en.wikipedia.org/wiki/Mixin">The Wikipedia article on mixins</a> says:</p>
<blockquote class="blockquote">
<p>A mixin can also be viewed as an interface with implemented methods.</p>
</blockquote>
<p>Sound familiar?</p>
<p>Interfaces in C# that contain default implementations aren&apos;t exactly mixins because they can also contain unimplemented members, support interface inheritance, can be specialized, etc. However, if we make an interface that just contains default members we have a mostly traditional mixin.</p>
<p>Consider the following code that adds functionality for &quot;moving&quot; an object and tracking it&apos;s location (for example, in a game environment):</p>
<pre><code class="language-csharp">public interface IMovable
{
    public (int, int) Location { get; set; }
    public int Angle { get; set; }
    public int Speed { get; set; }

    // A method that changes location
    // using angle and speed
    public void Move() =&gt; Location = ...;
}

public class Car : IMovable
{
    public string Make =&gt; &quot;Toyota&quot;;
}
</code></pre>
<p>Whops! There&apos;s a problem with this code that I hadn&apos;t considered until I wrote it for the post and tried to compile it. Interfaces (even ones with default implementations) can&apos;t contain state. Therefore auto-implemented properties aren&apos;t supported by default interface members. From the <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md#detailed-design">design document for default interface members</a>:</p>
<blockquote class="blockquote">
<p>Interfaces may not contain instance state. While static fields are now permitted instance fields are not permitted in interfaces. Instance auto-properties are not supported in interfaces, as they would implicitly declare a hidden field.</p>
</blockquote>
<p>This is where default interface members and the concept of mixins start to diverge a bit (mixins can conceptually contain state as far as I understand them), but we can still accomplish the original goal:</p>
<pre><code class="language-csharp">public interface IMovable
{
    public (int, int) Location { get; set; }
    public int Angle { get; set; }
    public int Speed { get; set; }

    // A method that changes location
    // using angle and speed
    public void Move() =&gt; Location = ...;
}

public class Car : IMovable
{
    public string Make =&gt; &quot;Toyota&quot;;

    // IMovable
    public (int, int) Location { get; set; }
    public int Angle { get; set; }
    public int Speed { get; set; }
}
</code></pre>
<p>This accomplishes the original goal by making the common <code>Move()</code> method and it&apos;s implementation available to all classes that apply the interface. Sure, the class still needs to provide implementations for the properties, but the way that they&apos;re at least declared in the <code>IMovable</code> interface means the default members in that interface can operate on the those properties and guarantees any class applying the interface will expose the correct state.</p>
<p>As a more complete and practical example, consider a logging mixin:</p>
<pre><code class="language-csharp">public interface ILogger
{
    public void LogInfo(string message) =&gt;
        LoggerFactory
            .GetLogger(this.GetType().Name)
            .LogInfo(message);
}

public static class LoggerFactory
{
    public static ILogger GetLogger(string name) =&gt;
        new ConsoleLogger(name);
}

public class ConsoleLogger : ILogger
{
    private readonly string _name;

    public ConsoleLogger(string name)
    {
        _name = name
        ?? throw new ArgumentNullException(nameof(name));
    }

    public void LogInfo(string message) =&gt;
        Console.WriteLine($&quot;[INFO] {_name}: {message}&quot;);
}
</code></pre>
<p>I could then apply the <code>ILogger</code> interface to any class:</p>
<pre><code class="language-csharp">public class Foo : ILogger
{
    public void DoSomething()
    {
        ((ILogger)this).LogInfo(&quot;Woot!&quot;);
    }
}
</code></pre>
<p>And code like:</p>
<pre><code class="language-csharp">Foo foo = new Foo();
foo.DoSomething();
</code></pre>
<p>Would produce:</p>
<pre><code>[INFO] Foo: Woot!
</code></pre>
<h2 id="replacing-extension-methods">Replacing Extension Methods</h2>
<p>The biggest area of utility I&apos;ve found so far is replacing large sets of extension methods. Let&apos;s go back to a simple logging example:</p>
<pre><code class="language-csharp">public interface ILogger
{
    void Log(string level, string message);
}
</code></pre>
<p>Before default interface members I would typically implement a bunch of extensions to this logging interface so that the logger implementation would only have to implement a single method but users could call a variety of overloads:</p>
<pre><code class="language-csharp">public static class ILoggerExtensions
{
    public static void LogInfo(this ILogger logger, string message) =&gt;
        logger.Log(&quot;INFO&quot;, message);

    public static void LogInfo(this ILogger logger, int id, string message) =&gt;
        logger.Log(&quot;INFO&quot;, $&quot;[{id}] message&quot;);

    public static void LogError(this ILogger logger, string message) =&gt;
        logger.Log(&quot;ERROR&quot;, message);

    public static void LogError(this ILogger logger, int id, string message) =&gt;
        logger.Log(&quot;ERROR&quot;, $&quot;[{id}] {message}&quot;);

    public static void LogError(this ILogger logger, Exception ex) =&gt;
        logger.Log(&quot;ERROR&quot;, ex.Message);

    public static void LogError(this ILogger logger, int id, Exception ex) =&gt;
        logger.Log(&quot;ERROR&quot;, $&quot;[{id}] {ex.Message}&quot;);
}
</code></pre>
<p>That&apos;s fine, and works. But it has a few shortfalls. For one, the namespaces of the static extension class and the interface may not necessarily match. It also creates some noise by requiring the <code>this ILogger logger</code> parameter and referring to a <code>logger</code> instance.</p>
<p>What I&apos;ve started doing with big sets of extensions is making them default interface members instead:</p>
<pre><code class="language-csharp">public interface ILogger
{
    void Log(string level, string message);

    public void LogInfo(string message) =&gt;
        Log(&quot;INFO&quot;, message);

    public void LogInfo(int id, string message) =&gt;
        Log(&quot;INFO&quot;, $&quot;[{id}] message&quot;);

    public void LogError(string message) =&gt;
        Log(&quot;ERROR&quot;, message);

    public void LogError(int id, string message) =&gt;
        Log(&quot;ERROR&quot;, $&quot;[{id}] {message}&quot;);

    public void LogError(Exception ex) =&gt;
        Log(&quot;ERROR&quot;, ex.Message);

    public void LogError(int id, Exception ex) =&gt;
        Log(&quot;ERROR&quot;, $&quot;[{id}] {ex.Message}&quot;);
}
</code></pre>
<p>I find those implementation much cleaner and easier to read (and thus maintain). Using default interface members also presents some other benefits where extensions might otherwise have been used:</p>
<ul>
<li>They&apos;re in the scope of the instance and <code>this</code> can be used.</li>
<li>Other types of members like indexers can be provided.</li>
<li>They can be overridden by implementing classes to specialize the behavior.</li>
</ul>
<p>Something that bugs me about the code above though is that it&apos;s not totally clear what the required, unimplemented contract of the interface is and what&apos;s implemented by default. A comment separating the two sections might help but I do like how extension classes are explicit in this regard.</p>
<p>To address that, I&apos;ve starting making any interface that contains default members partial (other than one or two trivial ones). Then I put the default members in other files with the naming convention &quot;ILogger.LogInfoDefaults.cs&quot; and &quot;ILogger.LogErrorDefaults.cs&quot;, etc. If I only have a small set of default members that don&apos;t suggest any sort of grouping, I name the file &quot;ILogger.Defaults.cs&quot;.</p>
<p>This separates the default member implementations from the unimplemented contract that any implementing class will have to provide implementations for. It also helps break up what could become a very long file. There&apos;s even a neat trick to enable ASP.NET-style Visual Studio file nesting in any project format. Add this to your project file or <code>Directory.Build.props</code>:</p>
<pre><code class="language-xml">&lt;ItemGroup&gt;
  &lt;ProjectCapability Include=&quot;DynamicDependentFile&quot;/&gt;
  &lt;ProjectCapability Include=&quot;DynamicFileNesting&quot;/&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>Then you can select &quot;File Nesting&quot; in the Solution Explorer and all your <code>.Defaults.cs</code> files will appear as children of the main interface file.</p>
<p>Finally, there are still some situations where extension methods are preferred:</p>
<ul>
<li>If you typically pass around class types instead of the interface type (because you&apos;d have to cast to the interface to access the default member implementations).</li>
<li>If you often use the pattern <code>public static T SomeExt&lt;T&gt;(this T foo)</code> to return the exact type the extension was called for (for example, in a fluent API).</li>
</ul> <a href="http://disqus.com" class="dsq-brlink">comments powered by </a> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>