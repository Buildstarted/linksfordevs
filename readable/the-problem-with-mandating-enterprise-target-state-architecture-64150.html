<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Problem with Mandating Enterprise Target State Architecture - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Problem with Mandating Enterprise Target State Architecture - linksfor.dev(s)"/>
    <meta property="og:description" content="In attempt to standardize, future proof, and keep up with technology standards, organizations are challenged to provide a set of standards in how solutions are architected and implemented. This is &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://danonsoftware.com/2020/07/10/the-problem-with-mandating-enterprise-target-state-architecture/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Problem with Mandating Enterprise Target State Architecture</title>
<div class="readable">
        <h1>The Problem with Mandating Enterprise Target State Architecture</h1>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 11 Jul 2020</div>
        <p><a href="https://danonsoftware.com/2020/07/10/the-problem-with-mandating-enterprise-target-state-architecture/">https://danonsoftware.com/2020/07/10/the-problem-with-mandating-enterprise-target-state-architecture/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

		
		
				<!-- SITE HEADER (.site-header) -->
		
		<!-- END SITE HEADER (.site-header) -->
		
						
			
		
		
		<!-- INNER SITE CONTAINER (.site-inner) -->
		<div>

			<div>

			

			

			<!-- PRIMARY CONTENT AREA (#primary) -->
			<div id="primary">

				<!-- CONTENT AREA (.site-content) -->
				<main id="content" itemprop="mainContentOfPage">

					
						<div itemscope="itemscope" itemtype="http://schema.org/Blog">
							<article id="post-3633" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost">
								
							<div>

								<div>

									 
										<!-- .entry-header -->
									
									
									<div itemprop="text">
										
<p>In attempt to standardize, future proof, and keep up with technology standards, organizations are challenged to provide a set of standards in how solutions are architected and implemented.  This is reasonable, and I’ve often been tasked with creating and working with teams to lead and create these standards for said organizations, and as an architect, I find myself working within these boundaries while also creating new boundaries.</p>



<p>Of course, what worked 10 or 15 years ago (or even 3 years ago) may not be the most optimal way forward for the organization, so new standards get created, and often the expectation is for all new solutions and applications to follow the new standards.  Teams are created to come up with standards and best practices which are eventually agreed upon and broadcast to the rest of the organization to follow.   When considering solution and application architecture, standards can be used, as an example, to define how systems should interact with each other (REST API’s, microservices, etc), how software is built (design patterns, frameworks, ORM, languages, platforms, etc), how integration architecture is applied (batch, queues, APIs),  and so forth.  </p>



<p>Problems arise when standards become too rigid which force solutions into target states that are not ideal based on the existing landscape.  What is ideal and what is not is based on many factors, including cost, complexity, timing, maintenance, technical debt, and technical expertise.   Although I advocate to challenge standards when necessary, it is important to realize that target architecture and design standards need to provide room and mechanism for deviations from those standards without a lot of bureaucracy.  They also can’t be so lax that people are tempted to just do it the way they’ve always done it.  </p>



<p>Let’s consider an organization which wants to enforce a target state architecture that ensures that all integration between systems is done through an API service.  The organization has procured all of the technology in order to do this, which includes, an API Management layer, an API Gateway, and cloud infrastructure to orchestrate API calls between systems on-premise, in their private cloud, and with SaaS cloud solutions. </p>



<p>Let’s look at a new SaaS solution being brought into the enterprise that an architect is responsible for creating the Solution and Integration Architecture.  The architect does his or her due diligence to work with the vendor to understand the possible ways to push and pull data.  Although this particular solution doesn’t support a direct Rest API integration, the architect pushes and works with the SaaS vendor to get this capability baked into the solution.  It turns out this capability is part of the vendor’s roadmap, but there is no definite timeframe, so we can’t expect a Rest API to be available anytime soon.  </p>



<p>Without the Rest API capability, the organization, which requires critical integration of master, reference, and transactional data to/from the SaaS application, is limited to SFTP transfers of flat files on a regular schedule.  Generally, this type of integration would be pretty straightforward, but unfortunately it would violate the enterprises recently executive signed-off standards directives.   </p>



<p>But, there are still ways, given what we have been dealt with, to meet the organizations target state and slide this through.  It doesn’t mean it’s the right thing to do, and in this case it isn’t, but let’s take a look at what would be built if mandated standards had to be strictly enforced.</p>



<p>Let’s consider just a single integration flow for a minute.  If we didn’t have to worry about the new defined target state architecture to adhere to, we’d end up with something like the following:</p>



<figure><img src="https://danonsoftware.com/wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1-1024x79.png" alt="" srcset="/wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1-1024x79.png 1024w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1-300x23.png 300w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1-768x59.png 768w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1-1536x118.png 1536w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-1-1.png 1831w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Suitable Target State Architecture Taking Business Constraints Into Account</figcaption></figure>



<p>It’s pretty straightforward.  It supports multiple sources being able to messages onto a common outbound queue where the logic to send to the SaaS application is encapsulated and re-useable.  We can re-use existing publishers in a publisher/subscriber messaging implementation.  We simple create a new subscriber to subscribe to the real time data and push it to a new subscriber queue which picks it up on a schedule (it could be daily or even near real time if necessary) creates the XML and does some transformation before  pushing that off to the Enterprise File Transfer platform which takes care of the rest and securely provides the data to the SaaS solution.</p>



<p>But, we have that mandatory target state using service based architecture to worry about, so, let’s look at how we could actually be “successful” in meeting the organizations signed off target state architecture.  Take a look at the following:</p>



<figure><img src="https://danonsoftware.com/wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3-1024x283.png" alt="" srcset="/wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3-1024x283.png 1024w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3-300x83.png 300w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3-768x212.png 768w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3-1536x424.png 1536w, /wp-content/uploads/2020/07/Untitled-Diagram-Page-2-3.png 1824w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Unsuitable Target State Architecture Focusing Only on Achieving a Mandatory Target State</figcaption></figure>



<p>As you can see, we’ve met the “target state architecture” by wrapping all of the inner workings around a REST API Management layer with its own internal workings.  You could call that being “successful” or something that is “fun” to architect, but <strong><em>it’s wrong</em></strong> and it should never see the light of day.  </p>



<p>Let’s look at the added complexity this “target state” compliant version of the architecture adds:</p>



<ul><li>Solution still needs to consume the same data from the source system and can get that in real time from the existing messaging interface, so we are limited to the existing messaging infrastructure from the source system</li><li>Many more additional points of failure</li><li>Performance concerns in the API Management layer</li><li>Outbound API needs to write the data out in real time to storage (queue, persisted table, etc) only to be consumed later by a batch process that pushes the data to the SaaS solution</li><li>Just because we write to the API, we don’t know the status of the information as the rest of the processing happens asynchronously, so we need to implement another API endpoint to handle that and track internally as well</li><li>Need to consider supporting PUT, POST, and GET operations with the API as well as allowing PUT and POST on single and bulk list of entities </li></ul>



<p>Now, there is the potential benefit that in the future the SaaS solution builds their API and you can just adapt your current API Management layer to send outbound API requests to the SaaS solution, but keep in mind this won’t be 100 percent straightforward and you do not yet know the complexity of the vendor’s Rest API.  I’m a huge proponent of YAGNI (you ain’t gonna need it!) and LRM (last responsible moment) principles.  Don’t build this now, don’t over architect this now.  Build it when and if you need it because likely, you ain’t gonna need it. </p>



<p>It’s important that we are not so rigid in ensuring solutions are built to an ideal target state or set of ideals.  Being pragmatic ensures we are thinking about the actual approach for the job, ensuring that the architectural decisions made are made on a sound basis taking into account cost, complexity, maintenance, technical debt, speed to market, and what is most practical.  These are very important points because an architect should not be creating unnecessary complexity by over-architecting solutions even if it is required to meet some “mandatory” target state.  It doesn’t mean let’s do what’s easy and only what’s easy.  It means finding a balance between cost, complexity, maintenance, and target state. If you find yourself architecting or implementing a solution where one of these items is out of balance, you need to re-think it.</p>



<p>There should not be rigid and mandatory target states in an organization, generally, and it’s important for the teams’ setting the standards, executives approving the standards, and those implementing solutions based on those standards to all have a solid understand that everything is negotiable.  Architecture is negotiable and it always should be.  As an architect you should be prepared to sell your solution even if the solution does not meet “mandatory” target states.  Your solution should not be based only on meeting the target state, but based on the pragmatic points the organization and your business stakeholders care most about, and that is based on a variety of things, including, cost (short and long term) business value, and complexity.  </p>
									</div><!-- .entry-content -->

								</div> <!-- .entry-container -->

								<!-- .entry-footer -->

							</div> <!-- .entry-wrap -->							</article><!-- .post -->


<!-- #comments -->
	<!-- .pagination -->

</div>
					
				</main><!-- END CONTENT AREA (.site-content) -->

				
			</div><!-- END PRIMARY CONTENT AREA (#primary) -->


		</div><!-- .site-inner-wrap -->

		</div><!-- END INNER SITE CONTAINER (.site-inner) -->

		
		
			<!-- FOOTER WIDGETS (#footer-widgets) -->
			<!-- END FOOTER WIDGETS (#footer-widgets) -->
		
		<!-- SITE FOOTER (.site-footer) -->
		<!-- END SITE FOOTER (.site-footer) -->

	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>