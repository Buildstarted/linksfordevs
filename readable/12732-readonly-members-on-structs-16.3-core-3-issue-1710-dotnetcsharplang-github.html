<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Readonly members on structs (16.3, Core 3) &#xB7; Issue #1710 &#xB7; dotnet/csharplang &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Readonly members on structs (16.3, Core 3) · Issue #1710 · dotnet/csharplang · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><h2>Summary</h2><p>Provide a way to specify individual instance members on a struct do not modify state, in the same way that <code>readonly struct</code> specifies no instance members modify state.</p><p>It is worth noting that <code>readonly instance member</code> != <code>pure instance member</code>. A <code>pure</code> instance member guarantees no state will be modified. A <code>readonly</code> instance member only guarantees that instance state will not be modified.</p><p>All instance members on a <code>readonly struct</code> could be considered implicitly <code>readonly instance members</code>. Explicit <code>readonly instance members</code> declared on non-readonly structs would behave in the same manner. For example, they would still create hidden copies if you called an instance member (on the current instance or on a field of the instance) which was itself not-readonly.</p><h2>Motivation</h2><p>Today, users have the ability to create <code>readonly struct</code> types which the compiler enforces that all fields are readonly (and by extension, that no instance members modify the state). However, there are some scenarios where you have an existing API that exposes accessible fields or that has a mix of mutating and non-mutating members. Under these circumstances, you cannot mark the type as <code>readonly</code> (it would be a breaking change).</p><p>This normally doesn't have much impact, except in the case of <code>in</code> parameters. With <code>in</code> parameters for non-readonly structs, the compiler will make a copy of the parameter for each instance member invocation, since it cannot guarantee that the invocation does not modify internal state. This can lead to a multitude of copies and worse overall performance than if you had just passed the struct directly by value. For an example, see this code on <a href="https://sharplab.io/#v2:CYLg1APgAgDABFAjAbgLACgNQMxwM4AuATgK4DGBcAagKYUD2RATBgN4ZycK4BmANvQCGlAB5p0XbnH5DKAT3GSOXHNIHC4AGRoA7AOYEAFgGUAjiUFEawZZ3YTJXPTQK3H9x54QB2OAAoROAAqOBEASjgwNy8YvzlguDkwxS8AXzd09EysXCgmOABhOA8VXnVKAFk/AEsdajoCRnyAN0E+EhoIks8oX1b2mgA6bX0jMwsrYEi4fo7h3QMTc0trFM5M1KA==" rel="nofollow">sharplab</a></p><p>Some other scenarios where hidden copies can occur include <code>static readonly fields</code> and <code>literals</code>. If they are supported in the future, <code>blittable constants</code> would end up in the same boat; that is they all currently necessitate a full copy (on instance member invocation) if the struct is not marked <code>readonly</code>.</p><h2>Design</h2><p>Allow a user to specify that an instance member is, itself, <code>readonly</code> and does not modify the state of the instance (with all the appropriate verification done by the compiler, of course). For example:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">struct</span><span class="pl-en">Vector2</span>
{
    <span class="pl-k">public</span><span class="pl-k">float</span><span class="pl-smi">x</span>;
    <span class="pl-k">public</span><span class="pl-k">float</span><span class="pl-smi">y</span>;

    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">float</span><span class="pl-en">GetLengthReadonly</span>()
    {
        <span class="pl-k">return</span><span class="pl-smi">MathF</span>.<span class="pl-en">Sqrt</span>(<span class="pl-smi">LengthSquared</span>);
    }

    <span class="pl-k">public</span><span class="pl-k">float</span><span class="pl-en">GetLength</span>()
    {
        <span class="pl-k">return</span><span class="pl-smi">MathF</span>.<span class="pl-en">Sqrt</span>(<span class="pl-smi">LengthSquared</span>);
    }

    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">float</span><span class="pl-en">GetLengthIllegal</span>()
    {
        <span class="pl-k">var</span><span class="pl-smi">tmp</span><span class="pl-k">=</span><span class="pl-smi">MathF</span>.<span class="pl-en">Sqrt</span>(<span class="pl-smi">LengthSquared</span>);

        <span class="pl-smi">x</span><span class="pl-k">=</span><span class="pl-smi">tmp</span>;    <span class="pl-c"><span class="pl-c">//</span> Compiler error, cannot write x</span><span class="pl-smi">y</span><span class="pl-k">=</span><span class="pl-smi">tmp</span>;    <span class="pl-c"><span class="pl-c">//</span> Compiler error, cannot write y</span><span class="pl-k">return</span><span class="pl-smi">tmp</span>;
    }

    <span class="pl-k">public</span><span class="pl-k">float</span><span class="pl-smi">LengthSquared</span>
    {
        readonly <span class="pl-k">get</span>
        {
            <span class="pl-k">return</span> (<span class="pl-smi">x</span><span class="pl-k">*</span><span class="pl-smi">x</span>) <span class="pl-k">+</span>
                   (<span class="pl-smi">y</span><span class="pl-k">*</span><span class="pl-smi">y</span>);
        }
    }
}

<span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">MyClass</span>
{
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">float</span><span class="pl-en">ExistingBehavior</span>(<span class="pl-k">in</span><span class="pl-en">Vector2</span><span class="pl-smi">vector</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> This code causes a hidden copy, the compiler effectively emits:</span><span class="pl-c"><span class="pl-c">//</span>    var tmpVector = vector;</span><span class="pl-c"><span class="pl-c">//</span>    return tmpVector.GetLength();</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> This is done because the compiler doesn't know that `GetLength()`</span><span class="pl-c"><span class="pl-c">//</span> won't mutate `vector`.</span><span class="pl-k">return</span><span class="pl-smi">vector</span>.<span class="pl-en">GetLength</span>();
    }

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">float</span><span class="pl-en">ReadonlyBehavior</span>(<span class="pl-k">in</span><span class="pl-en">Vector2</span><span class="pl-smi">vector</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> This code is emitted exactly as listed. There are no hidden</span><span class="pl-c"><span class="pl-c">//</span> copies as the `readonly` modifier indicates that the method</span><span class="pl-c"><span class="pl-c">//</span> won't mutate `vector`.</span><span class="pl-k">return</span><span class="pl-smi">vector</span>.<span class="pl-en">GetLengthReadonly</span>();
    }
}</pre></div><p>Readonly can be applied to property accessors to indicate that <code>this</code> will not be mutated in the accessor.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Prop1</span>
{
    <span class="pl-smi">readonly</span><span class="pl-smi">get</span>
    {
        <span class="pl-k">return</span><span class="pl-k">this</span>.<span class="pl-smi">_store</span>[<span class="pl-s"><span class="pl-pds">"</span>Prop1<span class="pl-pds">"</span></span>];
    }
    <span class="pl-smi">readonly</span><span class="pl-smi">set</span>
    {
        <span class="pl-k">this</span>.<span class="pl-smi">_store</span>[<span class="pl-s"><span class="pl-pds">"</span>Prop1<span class="pl-pds">"</span></span>] <span class="pl-k">=</span><span class="pl-smi">value</span>;
    }
}</pre></div><p>When <code>readonly</code> is applied to the property syntax, it means that all accessors are <code>readonly</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-smi">int</span><span class="pl-smi">Prop2</span>
{
    <span class="pl-smi">get</span>
    {
        <span class="pl-k">return</span><span class="pl-k">this</span>.<span class="pl-smi">_store</span>[<span class="pl-s"><span class="pl-pds">"</span>Prop2<span class="pl-pds">"</span></span>];
    }
    <span class="pl-smi">set</span>
    {
        <span class="pl-k">this</span>.<span class="pl-smi">_store</span>[<span class="pl-s"><span class="pl-pds">"</span>Prop2<span class="pl-pds">"</span></span>] <span class="pl-k">=</span><span class="pl-smi">value</span>;
    }
}</pre></div><p>Readonly can only be applied to accessors which do not mutate the containing type.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Prop3</span>
{
    <span class="pl-smi">readonly</span><span class="pl-smi">get</span>
    {
        <span class="pl-k">return</span><span class="pl-k">this</span>.<span class="pl-smi">_prop3</span>;
    }
    <span class="pl-smi">set</span>
    {
        <span class="pl-k">this</span>.<span class="pl-smi">_prop3</span><span class="pl-k">=</span><span class="pl-smi">value</span>;
    }
}</pre></div><p>Readonly can be applied to some auto-implemented properties, but it won't have a meaningful effect. The compiler will treat all auto-implemented getters as readonly whether or not the <code>readonly</code> keyword is present.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Allowed</span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-smi">int</span><span class="pl-smi">Prop4</span> { <span class="pl-smi">get</span>; }
<span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Prop5</span> { <span class="pl-k">readonly</span><span class="pl-smi">get</span>; }
<span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Prop6</span> { <span class="pl-k">readonly</span><span class="pl-smi">get</span>; <span class="pl-smi">set</span>; }

<span class="pl-c"><span class="pl-c">//</span> Not allowed</span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-smi">int</span><span class="pl-smi">Prop7</span> { <span class="pl-smi">get</span>; <span class="pl-smi">set</span>; }
<span class="pl-k">public</span><span class="pl-smi">int</span><span class="pl-smi">Prop8</span> { <span class="pl-smi">get</span>; <span class="pl-k">readonly</span><span class="pl-smi">set</span>; }</pre></div><p>Readonly can be applied to manually-implemented events, but not field-like events. Readonly cannot be applied to individual event accessors (add/remove).</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Allowed</span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-smi">event</span><span class="pl-smi">Action</span><span class="pl-k">&lt;</span><span class="pl-smi">EventArgs</span><span class="pl-k">&gt;</span><span class="pl-smi">Event1</span>
{
    <span class="pl-smi">add</span> { }
    <span class="pl-smi">remove</span> { }
}

<span class="pl-c"><span class="pl-c">//</span> Not allowed</span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-smi">event</span><span class="pl-en">Action</span>&lt;<span class="pl-en">EventArgs</span>&gt; <span class="pl-smi">Event2</span>;
<span class="pl-k">public</span><span class="pl-smi">event</span><span class="pl-smi">Action</span><span class="pl-k">&lt;</span><span class="pl-smi">EventArgs</span><span class="pl-k">&gt;</span><span class="pl-smi">Event3</span>
{
    <span class="pl-smi">readonly</span><span class="pl-smi">add</span> { }
    <span class="pl-smi">readonly</span><span class="pl-smi">remove</span> { }
}
<span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-smi">event</span><span class="pl-smi">Event4</span>
{
    <span class="pl-smi">add</span> { }
    <span class="pl-smi">remove</span> { }
}</pre></div><p>Some other syntax examples:</p><ul><li>Expression bodied members: <code>public readonly float ExpressionBodiedMember =&gt; (x * x) + (y * y);</code></li><li>Generic constraints: <code>public static readonly void GenericMethod&lt;T&gt;(T value) where T : struct { }</code></li></ul><p>The compiler would emit the instance member, as usual, and would additionally emit a compiler recognized attribute indicating that the instance member does not modify state. This effectively causes the hidden <code>this</code> parameter to become <code>in T</code> instead of <code>ref T</code>.</p><p>This would allow the user to safely call said instance method without the compiler needing to make a copy.</p><p>The restrictions would include:</p><ul><li>The <code>readonly</code> modifier cannot be applied to static methods, constructors or destructors.</li><li>The <code>readonly</code> modifier cannot be applied to delegates.</li><li>The <code>readonly</code> modifier cannot be applied to members of class or interface.</li></ul><h2>Drawbacks</h2><p>Same drawbacks as exist with <code>readonly struct</code> methods today. Certain code may still cause hidden copies.</p><h2>Notes</h2><p>Using an attribute or another keyword may also be possible.</p><p>This proposal is somewhat related to (but is more a subset of) <code>functional purity</code> and/or <code>constant expressions</code>, both of which have had some existing proposals.</p><p>LDM history:</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>