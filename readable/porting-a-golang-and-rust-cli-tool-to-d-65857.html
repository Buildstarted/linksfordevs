<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Porting a Golang and Rust CLI tool to D - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Porting a Golang and Rust CLI tool to D - linksfor.dev(s)"/>
    <meta property="og:description" content="A few days ago, in the programming subreddit, Paulo Henrique Cuchi shared his experience writing a command line tool in both Rust and Go . T..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://pingfrommorocco.blogspot.com/2020/08/porting-golang-and-rust-cli-tool-to-d.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Porting a Golang and Rust CLI tool to D</title>
<div class="readable">
        <h1>Porting a Golang and Rust CLI tool to D</h1>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 19 Aug 2020</div>
        <p><a href="https://pingfrommorocco.blogspot.com/2020/08/porting-golang-and-rust-cli-tool-to-d.html">https://pingfrommorocco.blogspot.com/2020/08/porting-golang-and-rust-cli-tool-to-d.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="post-body-117003837978044104">
<p>A few days ago, in the programming subreddit, <a href="https://cuchi.me/posts/go-vs-rust">Paulo Henrique Cuchi shared his experience writing a command line tool in both Rust and Go</a>. The tool in question is a client for his side project, Hashtrack. Hashtrack exposes a GraphQL API with which the clients can track certain twitter hashtags and get a real time list of relevant tweets. Prompted by <a href="https://www.reddit.com/r/programming/comments/i3529m/writing_the_same_cli_application_twice_using_go/g09rnsy/">this comment</a>, I decided to write a D port to demonstrate how D can be used to achieve a similar goal. I'll try to keep the same structure as the one he used in his blog post.</p>

<p><a href="https://github.com/azihassan/hashtrack-client">Source code on Github</a></p>





<p>The main reason is that the original blog post compared statically typed languages like Go and Rust, and made honorable mentions to Nim and Crystal, but didn't mention D. D falls under this category, so I think this will make for an interesting comparison</p>

<p>I also like D as a language and I have mentioned it in various other blog posts.</p>



<p><a href="https://dlang.org/download.html">The manual</a> has a lengthy page on how to download and install the reference compiler, DMD. Windows users can get the installer, while MacOS users can use homebrew. On Ubuntu, I simply add the apt repository and perform a normal apt installation. With this, you'll get DMD, but also dub, the package manager.</p>

<p>I installed Rust to have an idea on how easy it would be to get up and running. I was surprised by how easy it was. I only had to run <a href="https://www.rust-lang.org/tools/install">the interactive installer</a>, which took care of the rest. I did have to add ~/.cargo/bin to the path. Now that I think about it, I probably should have just restarted the console for the changes to take effect.</p>



<p>I wrote hashtrack in Vim without much difficulty, but that's probably because I have some familiarity with where everything goes in the standard library. I did have the documentation open at all times because I occasionally used a symbol I didn't import from the right package, or I called a function with the wrong arguments. Note that as far as the standard library is concerned, you can just import std; and have everything at your disposal. For third party libraries though, you're on your own.</p>

<p>I was curious about the state of tooling so I looked into plugins for my favourite IDE, Intellij IDEA. I found <a href="https://github.com/intellij-dlanguage/intellij-dlanguage">this one</a> and installed it. I also instealled DCD and DScanner by cloning their respective repos and building them, then configuring the IDEA plugin to point to the right paths. Shout out to the author of <a href="http://www.samael.me.uk/2015/12/d-plugin-for-intellij-idea.html">this blog post</a> for explaining the process.</p>

<p>I ran into a few issues at first, but they were fixed after updating both the IDE and the plugin. One of the problems I had is that it couldn't recognize my own packages and kept marking them as "possibly undefined". I later discovered that I had to put "module name_of_the_package;" on top of the file in order for it to be recognized.</p>

<p>I think it still has a bug where it doesn't recognize .length, at least on my machine. I opened an issue on Github, you can follow it <a href="https://github.com/intellij-dlanguage/intellij-dlanguage/issues/587">here</a> if you're curious.</p>

<p>If you're on Windows, I've heard good things about <a href="https://github.com/rainers/visuald">VisualD</a></p>



<p>Dub is the defacto package manager in D. It fetches and installs dependencies from https://code.dlang.org/. For this project, I needed an HTTP client because I didn't feel like using cURL. I ended up fetching two dependencies, requests and its dependency, cachetools, which has no dependency of its own. For some reason though, it fetched twelve more dependencies :</p><p><a href="https://1.bp.blogspot.com/-vlxU75DJksw/Xzx2RdIs2pI/AAAAAAAAAZk/jl8OA1kUD2U6HjaFu_2jUVUi76-aVORsQCLcBGAsYHQ/s1108/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client.png"><img data-original-height="525" data-original-width="1108" src="https://1.bp.blogspot.com/-vlxU75DJksw/Xzx2RdIs2pI/AAAAAAAAAZk/jl8OA1kUD2U6HjaFu_2jUVUi76-aVORsQCLcBGAsYHQ/s640/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client.png" width="640"></a></p>&nbsp;

<p>I think dub uses them internally, but I'm not sure about that.</p>

<p>Rust downloaded a lot of crates, but that's probably because the Rust version of the code has more features than mine has. For example, it fetched <a href="https://github.com/conradkleinespel/rpassword">rpassword</a>, a tool that hides password characters as you type them into a terminal, much like Python's getpass function. That's one of the many things I don't have in my code.</p>



<p>Having little knowledge of graphql, I had no idea where to begin. A "graphql" search on code.dlang.org led me to a relevant library, aptly named <a href="https://github.com/burner/graphqld">"graphqld"</a>. After looking into it though, it struck me as more of a vibe.d plugin than an actual client, if there is such a thing.</p>

<p>After inspecting the network requests on Firefox, I realized that for this project, I could just mimic the graphql queries and mutations, which I would then send with an HTTP client. Responses are just JSON objects that I can parse with the tools provided by the std.json package. With this in mind, I started looking for HTTP clients and settled on <a href="https://github.com/ikod/dlang-requests/">requests</a>, a simple to use HTTP client, but more importantly, one that has reached a certain level of maturity.</p>

<p>I copied the outgoing requests from the network inspector and pasted them in separate .graphql files, which I then imported and sent with the appropriate variables. The bulk of the functionality was put in the GraphQLRequest structure because I wanted to inject different endpoints and configurations into it, a requirement of the project :</p>

<pre>struct GraphQLRequest
{
    string operationName;
    string query;
    JSONValue variables;
    Config configuration;

    JSONValue toJson()
    {
        return JSONValue([
            "operationName": JSONValue(operationName),
            "variables": variables,
            "query": JSONValue(query),
        ]);
    }

    string toString()
    {
        return toJson().toPrettyString();
    }

    Response send()
    {
        auto request = Request();
        request.addHeaders(["Authorization": configuration.get("token", "")]);
        return request.post(
            configuration.get("endpoint"),
            toString(),
            "application/json"
        );
    }
}
</pre>

<p>Here's a snippet of the session package. The following code handles authentication :</p>

<pre>struct Session
{
    Config configuration;

    void login(string username, string password)
    {
        auto request = createSession(username, password);
        auto response = request.send();
        response.throwOnFailure();
        string token = response.jsonBody
            ["data"].object
            ["createSession"].object
            ["token"].str;
        configuration.put("token", token);
    }

    GraphQLRequest createSession(string username, string password)
    {
        enum query = import("createSession.graphql").lineSplitter().join("
");
        auto variables = SessionPayload(username, password).toJson();
        return GraphQLRequest("createSession", query, variables, configuration);
    }
}

struct SessionPayload
{
    string email;
    string password;

    //todo : make this a template mixin or something
    JSONValue toJson()
    {
        return JSONValue([
            "email": JSONValue(email),
            "password": JSONValue(password)
        ]);
    }

    string toString()
    {
        return toJson().toPrettyString();
    }
}
</pre>

<p>Spoiler alert : I never did that todo</p>

<p>It goes like this: the main() function creates a Config struct from the command line arguments and injects it into the Session struct, which implements the functionality of the login, logout and status commands. The createSession() method constructs the graphQL request by reading the actual request from the appropriate .graphql file and passing the variables along with it. I didn't want to pollute the source code with graphQL mutations and queries so I moved them to .graphql files that I then import during the compilation with the help of enum and import. The latter requires a compiler flag to point it to the stringImportPaths (which defaults to views/).</p>

<p>As to the login() method, its sole responsibility is sending the HTTP request and handling the response. In this case, it handles the potential errors, though not thoroughly. It then stores the token in a config file, which is really nothing more than a glorified JSON object.</p>

<p>The throwOnFailure method is not part of the core functionality of the requests library. It is actually a helper function that does quick and dirty error handling:</p>

<pre>void throwOnFailure(Response response)
{
    if(!response.isSuccessful || "errors" in response.jsonBody)
    {
        string[] errors = response.errors;
        throw new RequestException(errors.join("
"));
    }
}
</pre>

<p>Since D supports <a href="https://tour.dlang.org/tour/de/gems/uniform-function-call-syntax-ufcs">UFCS</a>, the throwOnFailure(response) syntax can be rewritten as response.throwOnFailure(). This makes it integrate seemlessly with other built-in methods like send(). I may have abused this feature throughout the project.</p>



<p>D pretty much favors exceptions when it comes to error handling. The rationale is explained in detail <a href="https://dlang.org/spec/errors.html#the_d_error_handling_solution">here</a>. One of the things I like about it is that unhandled errors will eventually get reported unless explicitely silenced. This is why I was able to get away with simplistic error handling. For example, in these lines :</p>

<pre>string token = response.jsonBody
    ["data"].object
    ["createSession"].object
    ["token"].str;
configuration.put("token", token);
</pre>

<p>If the response body didn't contain the token object, or any of the objects leading to it, it will throw an exception that will bubble up to the main function, then explode in the face of the user. If I had been using Go, I would have had to be very careful about handling the errors at every stage. And to be honest, since it's annoying to write if err != null every time I call a function, I would be very tempted to just ignore it. My understanding of Go is however primitive and I wouldn't be surprised if the compiler barked at you for not doing anything with the error return value, so feel free to correct me if I'm wrong.</p>

<p>Rust style error handling as explained in the original post was interesting. I don't think D has anything like that in the standard library, but there <a href="https://forum.dlang.org/thread/kjkosvfljzfyquhdzbbr@forum.dlang.org">have</a> <a href="https://forum.dlang.org/thread/mcodusbzzthlkcwstrjp@forum.dlang.org">been</a> <a href="https://forum.dlang.org/thread/apphidjekselhhctclgr@forum.dlang.org">discussions</a> about implementing it as a third party library.</p>



<p>I just want to quickly mention that I didn't use websockets to implement the "watch" command. I tried using Vibe.d's websocket client, but I couldn't get to work with the hashtrack backend because it kept closing the connection. I ended up dropping it in favor of polling, even though it's frowned upon. The client does work since I've tested it with another websocket server, so I might come back to this in the future.</p>



<p>For CI, I set up two build jobs : a normal build for feature branches, and an a release for master to provide optimized builds in the form of downloadable artifacts.</p><p><a href="https://1.bp.blogspot.com/-TKUUZUwZ4Sc/Xzx2-IxolaI/AAAAAAAAAZs/Y18DsDKPP-wzTX1-NYxjyzgf2svzYmPdgCLcBGAsYHQ/s1466/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client%25282%2529.png"><img alt="It takes about 30 seconds" data-original-height="396" data-original-width="1466" height="173" src="https://1.bp.blogspot.com/-TKUUZUwZ4Sc/Xzx2-IxolaI/AAAAAAAAAZs/Y18DsDKPP-wzTX1-NYxjyzgf2svzYmPdgCLcBGAsYHQ/w640-h173/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client%25282%2529.png" title="It takes about 30 seconds" width="640"></a></p>&nbsp;<p><a href="https://1.bp.blogspot.com/-mLzJTirNfbk/Xzx3Mb4LbRI/AAAAAAAAAZw/1qOsCK658ZAHW3GSN9ftP-uPj-gnV9njQCLcBGAsYHQ/s1456/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client%25281%2529.png"><img alt="The optimized build takes about 40 seconds" data-original-height="434" data-original-width="1456" height="191" src="https://1.bp.blogspot.com/-mLzJTirNfbk/Xzx3Mb4LbRI/AAAAAAAAAZw/1qOsCK658ZAHW3GSN9ftP-uPj-gnV9njQCLcBGAsYHQ/w640-h191/Screenshot_2020-08-19%2Bazihassan%2Bhashtrack-client%25281%2529.png" title="The optimized build takes about 40 seconds" width="640"></a></p>&nbsp;



<p>I ran the /usr/bin/time -v ./hashtrack --list command to measure memory usage, as explained in the original article. I don't know if memory usage depends on the hashtags that the logged in user follows, but here are the results for D, built with dub build -b release :</p>

<pre>	Maximum resident set size (kbytes): 10036
	Maximum resident set size (kbytes): 10164
	Maximum resident set size (kbytes): 9940
	Maximum resident set size (kbytes): 10060
	Maximum resident set size (kbytes): 10008
</pre>

<p>Not bad. I ran the Go and Rust versions with my hashtrack user and got these results :</p>

<p>Go, built with go build -ldflags "-s -w" :</p>
<pre>	Maximum resident set size (kbytes): 13684
	Maximum resident set size (kbytes): 13820
	Maximum resident set size (kbytes): 13904
	Maximum resident set size (kbytes): 13796
	Maximum resident set size (kbytes): 13600
</pre>

<p>Rust, built with cargo build --release :</p>
<pre>        Maximum resident set size (kbytes): 9224
	Maximum resident set size (kbytes): 9192
	Maximum resident set size (kbytes): 9384
	Maximum resident set size (kbytes): 9132
	Maximum resident set size (kbytes): 9168

</pre>

<p>D has garbage collection, but it also supports smart pointers and, more recently, an <a href="https://dlang.org/spec/ob.html">experimental memory management methodology</a> that is inspired by Rust. I'm not really sure how well these features integrate with the standard library, so I decided to let the GC handle memory for me. I think the results are pretty good considering that I didn't have memory consumption in mind while I was writing the code.</p>



<p>Rust, built with cargo build --release : 7.0M</p>
<p>D, built with dub build -b release : 5.7M</p>
<p>Go, built with go build : 7.1M</p>
<p>Go, <a href="https://stackoverflow.com/a/29600086/3729391">built with go build -ldflags "-s -w" : 5.0M</a></p>



<p>I think D is a solid language for writing command line tools like these. I didn't reach out to external dependencies often because the standard library had most of what I needed. Things like parsing command line arguments, handling JSON, unit testing, making HTTP requests (with <a href="https://dlang.org/phobos/std_net_curl.html">cURL</a>) are all available in the standard library. Third party packages are out there if the standard library lacks what you need, but I think there's still room for improvement in that area. On the bright side, if you have a "not invented here" mentality, or if you want to easily make an impact as an open source contributor, then you'll definitely like the D ecosystem.</p>

<p>Reasons I would use D</p>
<ul>
    <li>Yes</li>
</ul>
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>