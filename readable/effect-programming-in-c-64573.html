<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Effect Programming in C# - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Effect Programming in C# - linksfor.dev(s)"/>
    <meta property="article:author" content="eirik"/>
    <meta property="og:description" content="Programming with algebraic effects and handlers, a method for reasoning about computational effects of programs that originates from functional programming research, has recently found increasing a&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Effect Programming in C#</title>
<div class="readable">
        <h1>Effect Programming in C#</h1>
            <div>by eirik</div>
            <div>Reading time: 9-12 minutes</div>
        <div>Posted here: 21 Jul 2020</div>
        <p><a href="https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/">https://eiriktsarpalis.wordpress.com/2020/07/20/effect-programming-in-csharp/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p data-adtags-visited="true">Programming with algebraic effects and handlers, a method for reasoning about computational effects of programs that originates from functional programming research, has recently found increasing adoption in more mainstream languages. Implementations can be found in <a href="https://www.eff-lang.org/">OCaml</a>, <a href="https://hackage.haskell.org/package/effect-handlers">Haskell</a>, <a href="https://b-studios.de/scala-effekt/">Scala</a>, <a href="https://github.com/palladin/Eff">F#</a> and the <a href="https://www.microsoft.com/en-us/research/project/koka/">Koka language</a>.</p>
<p data-adtags-visited="true">Algebraic effects are an immensely powerful language feature that can be used to implement a diverse array of features such as dependency injection, cancellation, nondeterminism, debug tracing, first-class continuations and replayable computations.</p>
<p data-adtags-visited="true">For a beginner’s introduction to the concept of algebraic effects, I would recommend reading Dan Abramov’s <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/">excellent article on the subject</a>, which provides a primer using a hypothetical dialect of JavaScript.</p>
<p data-adtags-visited="true">In this article I will be talking about <a href="https://github.com/nessos/Eff">Eff</a>, an experimental C# library that provides a pragmatic adaptation of the concept by taking advantage of the <a href="https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/">async method extensibility features</a> available since C# 7. It was originally created by my former colleague, Nick Palladinos, and recently I have also been contributing to the project.</p>
<p data-adtags-visited="true">I have decided to start writing about Eff since I strongly believe in its experimental potential, and since hardly any documentation exists about it online.</p>
<h2>Key Concepts</h2>
<p data-adtags-visited="true">At its core, the library defines a task-like type, <code>Eff</code>, which can be built using <code>async</code> methods:</p>
<div><div id="highlighter_304375"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><div><p><code>using</code> <code>Nessos.Effects;</code></p><p><code>async</code> <code>Eff&lt;</code><code>int</code><code>&gt; Sqr(</code><code>int</code> <code>x) =&gt; x * x;</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">and can be composed using the <code>await</code> keyword:</p>
<div><div id="highlighter_131606"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>async</code> <code>Eff&lt;</code><code>int</code><code>&gt; SumOfSquares(</code><code>params</code> <code>int</code><code>[] inputs)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>sum = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>foreach</code> <code>(</code><code>int</code> <code>input </code><code>in</code> <code>inputs)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>sum += </code><code>await</code> <code>Sqr(input);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>sum;</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">An <code>Eff</code> computation has to be run explicitly by passing an <em>effect handler</em>:</p>
<div><div id="highlighter_899315"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>using</code> <code>Nessos.Effects.Handlers;</code></p><p><code>Eff&lt;</code><code>int</code><code>&gt; computation = SumOfSquares(1,2,3);</code></p><p><code>computation.Run(</code><code>new</code> <code>DefaultEffectHandler());</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">It should be noted that unlike <code>Task</code>, Eff values have delayed semantics and so running</p>
<div><div id="highlighter_321167"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><div><p><code>async</code> <code>Eff HelloWorld() =&gt; Console.WriteLine(</code><code>"Hello, World!"</code><code>);</code></p><p><code>Eff hello = HelloWord();</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">will have no observable side-effect. It is useful to think of Eff values as delegates, as opposed to futures.</p>
<p data-adtags-visited="true">Finally, Eff methods are capable of awaiting regular async awaitables</p>
<div><div id="highlighter_719719"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><div><p><code>async</code> <code>Eff Delay()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>Task.Delay(1000);</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">It should be noted however that the opposite is not possible, that is Eff values cannot be awaited inside regular async methods.</p>
<h2>Programming with Effects</h2>
<p data-adtags-visited="true">The examples thus far illustrate what is effectively an alternative implementation for async method builders. We have not talked about effects yet.</p>
<p data-adtags-visited="true">In the Eff library, abstract effects can be defined by inheriting the abstract <code>Effect&lt;T&gt;</code> class:</p>
<div><div id="highlighter_508416"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><div><p><code>public</code> <code>class</code> <code>DateTimeNowEffect : Effect&lt;DateTime&gt;</code></p><p><code>{</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">Abstract effects can be awaited inside Eff computations:</p>
<div><div id="highlighter_610547"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>async</code> <code>Eff&lt;</code><code>bool</code><code>&gt; IsSummerWeekend()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>DateTime now = </code><code>await</code> <code>new</code> <code>DateTimeNowEffect();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>(now.Month, now.DayOfWeek) </code><code>switch</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>(6 or 7 or 8, DayOfWeek.Saturday or DayOfWeek.Sunday) =&gt; </code><code>true</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_ =&gt; </code><code>false</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">And Eff computations depending on Effects can be further composed with other Eff computations:</p>
<div><div id="highlighter_384069"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p></td><td><div><p><code>async</code> <code>Eff SomeDomainLogic(Customer customer)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(</code><code>await</code> <code>IsSummerWeekend())</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>SendIceCreamPromo(customer);</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">Let’s now see how we can run this effect computation. Suppose I try to pass it the default effect handler:</p>
<div><div id="highlighter_856097"><table><tbody><tr><td><p>1</p></td><td><div><p><code>SomeDomainLogic(customer).Run(</code><code>new</code> <code>DefaultEffectHandler());</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">Then execution will fail with an exception:</p>
<div><div id="highlighter_524889"><table><tbody><tr><td><p>1</p><p>2</p></td><td><div><p><code>System.NotSupportedException: Abstract effects not supported by this handler.</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>at Nessos.Effects.Handlers.DefaultEffectHandler.Handle[TResult](EffectAwaiter`1 awaiter) </code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">The failure is caused by the fact that the effect handler we used does not provide semantics for <code>DateTimeNowEffect</code>. In order to get this to work we need to implement an effect handler of our own:</p>
<div><div id="highlighter_428412"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p></td><td><div><p><code>public</code> <code>class</code> <code>DateTimeEffectHandler : EffectHandler</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>override</code> <code>async</code> <code>ValueTask Handle&lt;TResult&gt;(EffectAwaiter&lt;TResult&gt; awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>switch</code> <code>(awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>case</code> <code>EffectAwaiter&lt;DateTime&gt; { Effect: DateTimeNowEffect } dateTimeEffectAwaiter:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>dateTimeEffectAwaiter.SetResult(DateTime.Now);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">The handler runs a pattern match over an <code>EffectAwaiter</code> argument, and populates any <code>DateTimeNowEffect</code> awaiter with the result of <code>System.DateTime.Now</code>. We can now run the previous computation with our new effect handler:</p>
<div><div id="highlighter_953845"><table><tbody><tr><td><p>1</p></td><td><div><p><code>SomeDomainLogic(customer).Run(</code><code>new</code> <code>DateTimeEffectHandler());</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">which will execute with the expected result.</p>
<p data-adtags-visited="true">We can also use effect handlers to mock the result of an effect:</p>
<div><div id="highlighter_490937"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></td><td><div><p><code>public</code> <code>class</code> <code>MockedDateTimeEffectHandler : EffectHandler</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>DateTime Now { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>override</code> <code>async</code> <code>ValueTask Handle&lt;TResult&gt;(EffectAwaiter&lt;TResult&gt; awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>switch</code> <code>(awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>case</code> <code>EffectAwaiter&lt;DateTime&gt; { Effect: DateTimeNowEffect } dateTimeEffectAwaiter:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>dateTimeEffectAwaiter.SetResult(Now);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p><p><code>var</code> <code>handler = </code><code>new</code> <code>MockedDateTimeEffectHandler() { Now = DateTime.Parse(</code><code>"2020-07-19"</code><code>) };</code></p><p><code>SomeDomainLogic(customer).Run(handler);</code></p></div></td></tr></tbody></table></div></div>
<h2>Combining Effects</h2>
<p data-adtags-visited="true">Consider the following set of abstract console effects</p>
<div><div id="highlighter_577799"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>public</code> <code>static</code> <code>class</code> <code>ConsoleEffect</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>WriteLineEffect WriteLine(</code><code>string</code> <code>line) =&gt; </code><code>new</code> <code>WriteLineEffect() { LogEntry = line };</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>ReadLineEffect ReadLine() =&gt; </code><code>new</code> <code>ReadLineEffect();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>class</code> <code>WriteLineEffect : Effect</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>string</code><code>? LogEntry { </code><code>get</code><code>; </code><code>set</code><code>; }</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>class</code> <code>ReadLineEffect : Effect&lt;</code><code>string</code><code>&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">and relevant handler that is backed by System.Console:</p>
<div><div id="highlighter_45733"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></td><td><div><p><code>public</code> <code>class</code> <code>ConsoleEffectHandler : EffectHandler</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>override</code> <code>async</code> <code>ValueTask Handle&lt;TResult&gt;(EffectAwaiter&lt;TResult&gt; awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>switch</code> <code>(awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>case</code> <code>EffectAwaiter { Effect: ConsoleEffect.WriteLineEffect writeLineEffect } writeLineAwaiter:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Console.WriteLine(writeLineEffect.LogEntry);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>writeLineAwaiter.SetResult();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>case</code> <code>EffectAwaiter&lt;</code><code>string</code><code>&gt; { Effect: ConsoleEffect.ReadLineEffect } readLineAwaiter:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>string</code> <code>line = Console.ReadLine();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>readLineAwaiter.SetResult(line);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">Now suppose we have an Eff computation that combines effects from both examples:</p>
<div><div id="highlighter_873280"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>async</code> <code>Eff Test()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>DateTime now = </code><code>await</code> <code>new</code> <code>DateTimeNowEffect();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>ConsoleEffect.WriteLine($</code><code>"The current date is {now}."</code><code>);</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">Then defining an effect handler that supports both effect families is very straightforward:</p>
<div><div id="highlighter_912849"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></td><td><div><p><code>public</code> <code>class</code> <code>CombinedDateTimeConsoleEffectHandler : EffectHandler</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>private</code> <code>readonly</code> <code>EffectHandler[] _nestedHandlers = </code><code>new</code> <code>EffectHandler[]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>ConsoleEffectHandler(),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>new</code> <code>DateTimeEffectHandler(),</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>public</code> <code>override</code> <code>async</code> <code>ValueTask Handle&lt;TResult&gt;(EffectAwaiter&lt;TResult&gt; awaiter)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>foreach</code> <code>(EffectHandler handler </code><code>in</code> <code>_nestedHandlers)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>handler.Handle(awaiter);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(awaiter.IsCompleted)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p><p><code>Test().Run(</code><code>new</code> <code>CombinedDateTimeConsoleEffectHandler());</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">It should be then clear by the examples that effects can be used to define a form of dependency injection. There is however a twist: since effect handlers flow with function calls, there is no need to pass dependencies via constructor parameters. Domain logic can be expressed by composing static methods, with the effect handler serving as the composition root for the application. This provides a truly functional approach to dependency injection.</p>
<h2>Encoding Cancellation</h2>
<p data-adtags-visited="true">A common criticism of C# is that async methods do not flow cancellation, that is any cancellation tokens will have to be passed manually to operations that require it. We will now see how one might use effects to work around that limitation; the Eff library comes with a <a href="https://github.com/nessos/Eff/blob/688d7e85ec808ec182c2d7f0ed54b968476b3d86/src/Eff/Applications/Cancellation/CancellationEffectHandler.cs">baked-in effect handler</a> that provides cancellation semantics. Consider the following example:</p>
<div><div id="highlighter_858814"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></td><td><div><p><code>using</code> <code>Nessos.Effects.Cancellation;</code></p><p><code>async</code> <code>Eff Test()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(</code><code>true</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>Delay();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>async</code> <code>Eff Delay()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>Task.Delay(1000);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p><p><code>var</code> <code>cts = </code><code>new</code> <code>CancellationTokenSource(millisecondsDelay:10_000);</code></p><p><code>var</code> <code>handler = </code><code>new</code> <code>CancellationEffectHandler(cts.Token);</code></p><p><code>Test().Run(handler);</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">While one might expect the above to diverge, it will actually throw an <code>OperationCanceledException</code> after ten seconds. This is because the effect handler will <a href="https://github.com/nessos/Eff/blob/688d7e85ec808ec182c2d7f0ed54b968476b3d86/src/Eff/Applications/Cancellation/CancellationEffectHandler.cs#L48">actively check for cancellation</a> before evaluating the state machine of a nested <code>Eff</code> call.</p>
<p data-adtags-visited="true">But what happens if we need to pass the cancellation token to a non-eff asynchronous operation? We can recover it by awaiting on the cancellation token effect:</p>
<div><div id="highlighter_536236"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><div><p><code>async</code> <code>Eff&lt;HttpResponseMessage&gt; Get(HttpClient httpClient, </code><code>string</code> <code>requestUri)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>CancellationToken token = </code><code>await</code> <code>CancellationTokenEffect.Value;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>await</code> <code>httpClient.GetAsync(requestUri, token);</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p data-adtags-visited="true">For those familiar with F#, this is precisely how its <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/asynchronous-and-concurrent-programming/async">async method implementation</a> flows cancellation.</p>
<h2>Conclusions</h2>
<p data-adtags-visited="true">This concludes my introductory overview of the Eff library. I have tried to convey its most basic concepts, however this article hardly covers all capabilities of effects. I will try to follow up with future articles digging deeper into both applications and the implementation details of Eff itself. For the impatient, there is a fairly extensive <a href="https://github.com/nessos/Eff/tree/master/samples">catalog of samples</a> in the Eff repo itself, including a proof-of-concept <a href="https://github.com/nessos/Eff/tree/master/samples/Eff.Examples.AspNetCore">AspNetCore application</a>.</p>
<p data-adtags-visited="true">I do hope that you have found the concepts interesting, and that this might furthermore spark a conversation about future programming paradigms.</p>
			
			
				</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>