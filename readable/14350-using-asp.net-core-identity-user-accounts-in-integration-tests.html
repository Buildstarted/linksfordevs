<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using ASP.NET Core Identity user accounts in integration tests -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using ASP.NET Core Identity user accounts in integration tests</h1><div><div class="entry-content clearfix"><p>I have application that uses ASP.NET Core Identity with classic logins and there’s need to cover this application with integration tests. Some tests are for anonymous users and others for authenticated users. This blog post shows how to set selectively set authenticated ASP.NET Core Identity user for ASP.NET Core integration tests.</p><h3>Getting started</h3><p>We start with ASP.NET Core web application where basic authentication is done using <a title="Introduction to Identity on ASP.NET Core" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-2.2&amp;tabs=visual-studio">ASP.NET Core Identity</a>. There’s integration tests project that uses fake startup class and custom appsettings.json from my blog post <a href="/testing/aspnet-core-integration-tests-startup/">Using custom startup class with ASP.NET Core integration tests</a>. Take a look at this post as there are some additional classes defined.</p><p>Our starting point is simple integration test from my previous blog post.</p><pre><span>public</span>&nbsp;<span>class</span>&nbsp;<span>HomeControllerTests</span> : <span>IClassFixture</span>&lt;<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt;&gt;<br>{<br><span>private</span>&nbsp;<span>readonly</span>&nbsp;<span>WebApplicationFactory</span>&lt;<span>FakeStartup</span>&gt; _factory;<p>&nbsp;&nbsp;&nbsp; <span>public</span> HomeControllerTests(<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt; factory)<br>{<br><span>var</span> projectDir = <span>Directory</span>.GetCurrentDirectory();<br><span>var</span> configPath = <span>Path</span>.Combine(projectDir, <span>"appsettings.json"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _factory = factory.WithWebHostBuilder(builder =&gt;<br>{<br>builder.UseSolutionRelativeContentRoot(<span>"MediaGallery"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.ConfigureAppConfiguration(conf =&gt;<br>{<br>conf.AddJsonFile(configPath);<br>});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.ConfigureTestServices(services =&gt;<br>{<br>services.AddMvc().AddApplicationPart(<span>typeof</span>(<span>Startup</span>).Assembly);<br>});<br>});<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Theory</span>]<br>[<span>InlineData</span>(<span>"/"</span>)]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_EndpointsReturnSuccessAndCorrectContentType(<span>string</span> url)<br>{<br><span>// Arrange</span><br><span>var</span> client = _factory.CreateClient();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(url);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br>response.EnsureSuccessStatusCode(); <span>// Status Code 200-299</span><br><span>Assert</span>.Equal(<span>"text/html; charset=utf-8"</span>, response.Content.Headers.ContentType.ToString());<br>}<br>}</p></pre><p>To work with identity we need also controller action that has <a title="AuthorizeAttribute Class" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute?view=aspnetcore-2.2">authorize attribute</a>. Here’s the action of home controller we will use for this post.</p><pre>[<span>Authorize</span>(Roles = <span>"Admin"</span>)]<br>[<span>Route</span>(<span>"/foradmin"</span>)]<br><span>public</span>&nbsp;<span>IActionResult</span> ForAdmin()<br>{<br><span>return</span> Content(<span>string</span>.Format(<span>"User: {0}, is admin:&nbsp; {1}"</span>, <br>User.Identity.Name, User.IsInRole(<span>"Admin"</span>)));<br>}</pre><p>For this action we add test from ASP.NET Core integration testing documentation.</p><pre>[<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageRequiresAnAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = _factory.CreateClient(<br><span>new</span>&nbsp;<span>WebApplicationFactoryClientOptions</span><br>{<br>AllowAutoRedirect = <span>false</span><br>});<p>&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);</p><p>&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.Redirect, response.StatusCode);<br><span>Assert</span>.StartsWith(<span>"http://localhost/Identity/Account/Login"</span>,<br>response.Headers.Location.OriginalString);<br>}</p></pre><p>This test turns off redirects for HTTP client. If response is 301 or 302 then HTTP client doesn’t go to URL given in location header. It stops so we can explore the response. For anonymous user this test passes and we can see that browser is redirected to login page.</p><h3>Introducing fake user filter</h3><p>We can use global <a title="Filters in ASP.NET Core" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-2.2">action filters</a> to “authenticate” users so ASP.NET Core thinks there’s real user authenticated. It’s a little bit tricky. We have to turn off default user detection as otherwise HTTP client is redirected to login page. We can use AllowAnonymousFilter for this. This filter will open the door for request to pass authentication but we need another filter right next to it that sets authenticated user.</p><p>To introduce authenticated user we need custom action filter shown here.</p><pre><span>class</span>&nbsp;<span>FakeUserFilter</span> : <span>IAsyncActionFilter</span><br>{<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> OnActionExecutionAsync(<span>ActionExecutingContext</span> context, <span>ActionExecutionDelegate</span> next)<br>{<br>context.HttpContext.User = <span>new</span>&nbsp;<span>ClaimsPrincipal</span>(<span>new</span>&nbsp;<span>ClaimsIdentity</span>(<span>new</span>&nbsp;<span>List</span>&lt;<span>Claim</span>&gt;<br>{<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.NameIdentifier, <span>"123"</span>),<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Name, <span>"Test user"</span>),<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Email, <span><a href="mailto:test@example.com">test@example.com</a></span>),<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Role, <span>"Admin"</span>)<br>}));<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>await</span> next();<br>}<br>}</p></pre><p>It sets dummy claims for user and ASP.NET Core is okay with it.</p><p>Here is the new test that expects authenticated user.</p><pre>[<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageIsAvailableForAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = _factory.CreateClient(<br><span>new</span>&nbsp;<span>WebApplicationFactoryClientOptions</span><br>{<br>AllowAutoRedirect = <span>false</span><br>});<p>&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);<br><span>var</span> body = <span>await</span> response.Content.ReadAsStringAsync();</p><p>&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.OK, response.StatusCode);<br><span>Assert</span>.Equal(<span>"text/plain; charset=utf-8"</span>, response.Content.Headers.ContentType.ToString());<br>}</p></pre><p>Now we have two integration tests that depend on authenticated user and their needs are conflicting. One test needs anonymous user and the other needs authenticated user.</p><p align="center"><a href="https://static.gunnarpeipman.com/wp-content/uploads/2019/04/aspnet-core-testserver-identity-conflict.png"><picture><source data-srcset="https://static.gunnarpeipman.com/wp-content/uploads/2019/04/aspnet-core-testserver-identity-conflict_thumb.png.webp" type="image/webp"><img width="472" height="453" title="Conflicting requirements between integration tests" alt="Conflicting requirements between integration tests" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20472%20453%22%3E%3C/svg%3E" data-src="https://static.gunnarpeipman.com/wp-content/uploads/2019/04/aspnet-core-testserver-identity-conflict_thumb.png" border="0" class="lazyload webpexpress-processed"></picture></a></p><p>We have to solve this conflict in integration tests file.</p><h3>Setting authenticated user for integration tests</h3><p>The easiest solution I found was to modify tests and make presence of authenticated user configurable. We need to move configuring of factory to separate method so we can set if authenticated user is needed or not. I give here full source of integration tests file.</p><pre><span>public</span>&nbsp;<span>class</span>&nbsp;<span>HomeControllerTests</span> : <span>IClassFixture</span>&lt;<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt;&gt;<br>{<br><span>private</span>&nbsp;<span>readonly</span>&nbsp;<span>WebApplicationFactory</span>&lt;<span>FakeStartup</span>&gt; _factory;<p>&nbsp;&nbsp;&nbsp; <span>public</span> HomeControllerTests(<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt; factory)<br>{<br>_factory = factory;<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageRequiresAnAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory().CreateClient(<br><span>new</span>&nbsp;<span>WebApplicationFactoryClientOptions</span><br>{<br>AllowAutoRedirect = <span>false</span><br>});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.Redirect, response.StatusCode);<br><span>Assert</span>.StartsWith(<span>"http://localhost/Identity/Account/Login"</span>,<br>response.Headers.Location.OriginalString);<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageIsAvailableForAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory(hasUser: <span>true</span>).CreateClient();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);<br><span>var</span> body = <span>await</span> response.Content.ReadAsStringAsync();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.OK, response.StatusCode);<br><span>Assert</span>.Equal(<span>"text/plain; charset=utf-8"</span>,response.Content.Headers.ContentType.ToString());<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Theory</span>]<br>[<span>InlineData</span>(<span>"/"</span>)]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_EndpointsReturnSuccessAndCorrectContentType(<span>string</span> url)<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory().CreateClient();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(url);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br>response.EnsureSuccessStatusCode(); <span>// Status Code 200-299</span><br><span>Assert</span>.Equal(<span>"text/html; charset=utf-8"</span>, response.Content.Headers.ContentType.ToString());<br>}</p><p>&nbsp;&nbsp;&nbsp; <span>private</span>&nbsp;<span>WebApplicationFactory</span>&lt;<span>FakeStartup</span>&gt; GetFactory(<span>bool</span> hasUser = <span>false</span>)<br>{<br><span>var</span> projectDir = <span>Directory</span>.GetCurrentDirectory();<br><span>var</span> configPath = <span>Path</span>.Combine(projectDir, <span>"appsettings.json"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>return</span> _factory.WithWebHostBuilder(builder =&gt;<br>{<br>builder.ConfigureAppConfiguration(conf =&gt;<br>{<br>conf.AddJsonFile(configPath);<br>});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.UseSolutionRelativeContentRoot(<span>"MediaGallery"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.ConfigureTestServices(services =&gt;<br>{<br>services.AddMvc(options =&gt;<br>{<br><span>if</span> (hasUser)<br>{<br>options.Filters.Add(<span>new</span>&nbsp;<span>AllowAnonymousFilter</span>());<br>options.Filters.Add(<span>new</span>&nbsp;<span>FakeUserFilter</span>());<br>}<br>})<br>.AddApplicationPart(<span>typeof</span>(<span>Startup</span>).Assembly);<br>});<br>});<br>}<br>}</p></pre><p>Tests can now specify if authenticated user is needed or not through hasUser parameter of GetFactory() method.</p><p>Best of all – our tests pass now.</p><p align="center"><picture><source data-srcset="https://static.gunnarpeipman.com/wp-content/uploads/2019/04/aspnet-core-testserver-identity-passed.png.webp" type="image/webp"><img width="472" height="346" title="All integration tests pass" alt="All integration tests pass" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20472%20346%22%3E%3C/svg%3E" data-src="https://static.gunnarpeipman.com/wp-content/uploads/2019/04/aspnet-core-testserver-identity-passed.png" border="0" class="lazyload webpexpress-processed"></picture></p><p>There’s one thing to take care of – controller actions that use current user identity to query data from database or other services.</p><h3>Using real ASP.NET Core Identity accounts</h3><p>We need now a way to have test user in ASP.NET Core Identity database. If we have users then usually we have data related to these users. To make sure that user identity is always the same through tests I created simple user settings class.</p><pre><span>public</span>&nbsp;<span>static</span>&nbsp;<span>class</span>&nbsp;<span>UserSettings</span><br>{<br><span>public</span>&nbsp;<span>const</span>&nbsp;<span>string</span> UserId = <span>"47d90476-8de1-4a71-b0f0-9beaf4d89c98"</span>;<br><span>public</span>&nbsp;<span>const</span>&nbsp;<span>string</span> Name = <span>"Test User"</span>;<br><span>public</span>&nbsp;<span>const</span>&nbsp;<span>string</span> UserEmail = <span>"user@test.com"</span>;<br>}</pre><p>Our fake user filter must use the same settings.</p><pre><span>class</span>&nbsp;<span>FakeUserFilter</span> : <span>IAsyncActionFilter</span><br>{<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> OnActionExecutionAsync(<span>ActionExecutingContext</span> context, <span>ActionExecutionDelegate</span> next)<br>{<br>context.HttpContext.User = <span>new</span>&nbsp;<span>ClaimsPrincipal</span>(<span>new</span>&nbsp;<span>ClaimsIdentity</span>(<span>new</span>&nbsp;<span>List</span>&lt;<span>Claim</span>&gt;<br>{<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.NameIdentifier, <span>UserSettings</span>.UserId),<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Name, <span>UserSettings</span>.Name),<br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Email, <span>UserSettings</span>.UserEmail), <br><span>new</span>&nbsp;<span>Claim</span>(<span>ClaimTypes</span>.Role, <span>"Admin"</span>)<br>}));<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>await</span> next();<br>}<br>}</p></pre><p>To get this user to database we can use fake startup class. My solution supports empty and previously filled databases.</p><pre><span>public</span>&nbsp;<span>class</span>&nbsp;<span>FakeStartup</span> : <span>Startup</span><br>{<br><span>public</span> FakeStartup(<span>IConfiguration</span> configuration) : <span>base</span>(configuration)<br>{<br>}<p>&nbsp;&nbsp;&nbsp; <span>public</span>&nbsp;<span>override</span>&nbsp;<span>void</span> Configure(<span>IApplicationBuilder</span> app, <span>IHostingEnvironment</span> env, <span>ILoggerFactory</span> loggerFactory)<br>{<br><span>base</span>.Configure(app, env, loggerFactory);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>var</span> serviceScopeFactory = app.ApplicationServices.GetRequiredService&lt;<span>IServiceScopeFactory</span>&gt;();<br><span>using</span> (<span>var</span> serviceScope = serviceScopeFactory.CreateScope())<br>{<br><span>var</span> dbContext = serviceScope.ServiceProvider.GetService&lt;<span>ApplicationDbContext</span>&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>if</span> (dbContext.Database.GetDbConnection().ConnectionString.ToLower().Contains(<span>"database.windows.net"</span>))<br>{<br><span>throw</span>&nbsp;<span>new</span>&nbsp;<span>Exception</span>(<span>"LIVE SETTINGS IN TESTS!"</span>);<br>}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>if</span> (!dbContext.Users.Any(u =&gt; u.Id == <span>UserSettings</span>.UserId))<br>{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>var</span> user = <span>new</span>&nbsp;<span>IdentityUser</span>();<br>user.ConcurrencyStamp = <span>DateTime</span>.Now.Ticks.ToString();<br>user.Email = <span>UserSettings</span>.UserEmail;<br>user.EmailConfirmed = <span>true</span>;<br>user.Id = <span>UserSettings</span>.UserId;<br>user.NormalizedEmail = user.Email;<br>user.NormalizedUserName = user.Email;<br>user.PasswordHash = <span>Guid</span>.NewGuid().ToString();<br>user.UserName = user.Email;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>var</span> role = <span>new</span>&nbsp;<span>IdentityRole</span>();<br>role.ConcurrencyStamp = <span>DateTime</span>.Now.Ticks.ToString();<br>role.Id = <span>"Admin"</span>;<br>role.Name = <span>"Admin"</span>;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>var</span> userRole = <span>new</span>&nbsp;<span>IdentityUserRole</span>&lt;<span>string</span>&gt;();<br>userRole.RoleId = <span>"Admin"</span>;<br>userRole.UserId = user.Id;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbContext.Users.Add(user);<br>dbContext.Roles.Add(role);<br>dbContext.UserRoles.Add(userRole);<br>dbContext.SaveChanges();<br>}<br>}<br>}<br>}</p></pre><p>Now we can also test controller actions where data is queried based on current user.</p><h3>Moving web application factory to base class</h3><p>It’s time to clean up all the mess. When I look at integration tests file I don’t like the fact that there’s GetFactory() method and _factory attribute equally accessible to tests. Those who know use GetFactory() method and novice guys in project may accidentally use _factory attribute instead. Another this is that we don’t want to repeat GetFactory() method to all integration test classes we have.</p><p>To get rid of these issues I create base class for integration tests.</p><pre><span>public</span>&nbsp;<span>class</span>&nbsp;<span>IntegrationTestBase</span> : <span>IClassFixture</span>&lt;<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt;&gt;<br>{<br><span>private</span>&nbsp;<span>readonly</span>&nbsp;<span>WebApplicationFactory</span>&lt;<span>FakeStartup</span>&gt; _factory;<p>&nbsp;&nbsp;&nbsp; <span>public</span> IntegrationTestBase(<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt; factory)<br>{<br>_factory = factory;<br>}</p><p>&nbsp;&nbsp;&nbsp; <span>protected</span>&nbsp;<span>WebApplicationFactory</span>&lt;<span>FakeStartup</span>&gt; GetFactory(<span>bool</span> hasUser = <span>false</span>)<br>{<br><span>var</span> projectDir = <span>Directory</span>.GetCurrentDirectory();<br><span>var</span> configPath = <span>Path</span>.Combine(projectDir, <span>"appsettings.json"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>return</span> _factory.WithWebHostBuilder(builder =&gt;<br>{<br>builder.ConfigureAppConfiguration((context,conf) =&gt;<br>{<br>conf.AddJsonFile(configPath);<br>});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.UseSolutionRelativeContentRoot(<span>"MediaGallery"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder.ConfigureTestServices(services =&gt;<br>{<br>services.AddMvc(options =&gt;<br>{<br><span>if</span> (hasUser)<br>{<br>options.Filters.Add(<span>new</span>&nbsp;<span>AllowAnonymousFilter</span>());<br>options.Filters.Add(<span>new</span>&nbsp;<span>FakeUserFilter</span>());<br>}<br>})<br>.AddApplicationPart(<span>typeof</span>(<span>Startup</span>).Assembly);<br>});<br>});<br>}<br>}</p></pre><p>Our test class gets also smaller and it doesn’t expose injected _factory attribute anymore.</p><pre><span>public</span>&nbsp;<span>class</span>&nbsp;<span>HomeControllerTests</span> : <span>IntegrationTestBase</span><br>{<br><span>public</span> HomeControllerTests(<span>MediaGalleryFactory</span>&lt;<span>FakeStartup</span>&gt; factory) : <span>base</span>(factory)<br>{<br>}<p>&nbsp;&nbsp;&nbsp; [<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageRequiresAnAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory().CreateClient(<br><span>new</span>&nbsp;<span>WebApplicationFactoryClientOptions</span><br>{<br>AllowAutoRedirect = <span>false</span><br>});</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.Redirect, response.StatusCode);<br><span>Assert</span>.StartsWith(<span>"http://localhost/Identity/Account/Login"</span>,<br>response.Headers.Location.OriginalString);<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Fact</span>]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_SecurePageIsAvailableForAuthenticatedUser()<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory(hasUser: <span>true</span>).CreateClient();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(<span>"/ForAdmin"</span>);<br><span>var</span> body = <span>await</span> response.Content.ReadAsStringAsync();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br><span>Assert</span>.Equal(<span>HttpStatusCode</span>.OK, response.StatusCode);<br><span>Assert</span>.Equal(<span>"text/plain; charset=utf-8"</span>,response.Content.Headers.ContentType.ToString());<br>}</p><p>&nbsp;&nbsp;&nbsp; [<span>Theory</span>]<br>[<span>InlineData</span>(<span>"/"</span>)]<br><span>public</span>&nbsp;<span>async</span>&nbsp;<span>Task</span> Get_EndpointsReturnSuccessAndCorrectContentType(<span>string</span> url)<br>{<br><span>// Arrange</span><br><span>var</span> client = GetFactory().CreateClient();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Act</span><br><span>var</span> response = <span>await</span> client.GetAsync(url);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span>// Assert</span><br>response.EnsureSuccessStatusCode(); <span>// Status Code 200-299</span><br><span>Assert</span>.Equal(<span>"text/html; charset=utf-8"</span>, response.Content.Headers.ContentType.ToString());<br>}<br>}</p></pre><h3>Wrapping up</h3><p>There are more than one way to get user context to ASP.NET Core Identity integration tests. The method introduced here is kind of hacky but effective. If needed we can easily extend it for more complex scenarios. To support scenarios where there’s user related data in database we have test user available also in database – be ie empty or previously filled. By moving factory creating logic to base class we ended up with nice and clean integration test classes.</p><div class="ShariffSC shariff-styling"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>