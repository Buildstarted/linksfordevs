<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Container technologies at Coinbase - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Container technologies at Coinbase - linksfor.dev(s)"/>
    <meta property="article:author" content="https://blog.coinbase.com/@coinbaseblog"/>
    <meta property="og:description" content="Why Kubernetes is not part of our stack"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.coinbase.com/container-technologies-at-coinbase-d4ae118dcb6c?gi=960dc397b5ba"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Container technologies at Coinbase</title>
<div class="readable">
        <h1>Container technologies at Coinbase</h1>
            <div>by https://blog.coinbase.com/@coinbaseblog</div>
            <div>Reading time: 21-27 minutes</div>
        <div>Posted here: 09 Jun 2020</div>
        <p><a href="https://blog.coinbase.com/container-technologies-at-coinbase-d4ae118dcb6c?gi=960dc397b5ba">https://blog.coinbase.com/container-technologies-at-coinbase-d4ae118dcb6c?gi=960dc397b5ba</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><h2 id="3d05"><strong>Why Kubernetes is not part of our stack</strong></h2><div><div><div><p><a href="https://blog.coinbase.com/@coinbaseblog?source=post_page-----d4ae118dcb6c----------------------" rel="noopener"><img alt="Coinbase" src="https://miro.medium.com/fit/c/96/96/2*aPYWIFK3sVKT1KK9NwNOAQ.jpeg" width="48" height="48"></a></p></div></div></div><p id="6953" data-selectable-paragraph="">By Drew Rothstein, Director of Engineering</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*ekgXkPjYTRoCnx10?q=20" width="1500" height="750" role="presentation"></p><p><img width="1500" height="750" srcset="https://miro.medium.com/max/552/0*ekgXkPjYTRoCnx10 276w, https://miro.medium.com/max/1104/0*ekgXkPjYTRoCnx10 552w, https://miro.medium.com/max/1280/0*ekgXkPjYTRoCnx10 640w, https://miro.medium.com/max/1400/0*ekgXkPjYTRoCnx10 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/1500/0*ekgXkPjYTRoCnx10"></p></div></div></div></div></figure><p id="c92f" data-selectable-paragraph="">TLDR: Container orchestration platforms are complex and amazing technologies, helping some businesses and teams solve a whole suite of problems. What’s commonly overlooked however, is that container technologies also create a large set of challenges that must be overcome to <a href="https://github.com/hjacobs/kubernetes-failure-stories" target="_blank" rel="noopener">prevent failures</a>.</p><p id="ff9c" data-selectable-paragraph=""><em>This post is adapted from an internal blog post as I haven’t seen many write-ups like this externally available. Minimal redaction has been done and images have been added to provide more flare. If you are interested in working on some of what we discuss below — we are actively hiring on our </em><a href="https://www.coinbase.com/careers/positions?department=Engineering%2520-%2520Infrastructure" target="_blank" rel="noopener"><em>Infrastructure team</em></a><em>.</em></p><h2 id="49ec" data-selectable-paragraph="">History</h2><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*TFRID9Sh9NUJYqUl?q=20" width="1400" height="641" role="presentation"></p><p><img width="1400" height="641" srcset="https://miro.medium.com/max/552/0*TFRID9Sh9NUJYqUl 276w, https://miro.medium.com/max/1104/0*TFRID9Sh9NUJYqUl 552w, https://miro.medium.com/max/1280/0*TFRID9Sh9NUJYqUl 640w, https://miro.medium.com/max/1400/0*TFRID9Sh9NUJYqUl 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/1400/0*TFRID9Sh9NUJYqUl"></p></div></div></div></div></figure><p id="a6b0" data-selectable-paragraph="">Before jumping into the current day, it is important to understand the technologies that led us here.</p><ul><li id="fe1b" data-selectable-paragraph="">1980s: <a href="https://en.wikipedia.org/wiki/Chroot" target="_blank" rel="noopener">chroot</a></li><li id="7685" data-selectable-paragraph="">1990s: <a href="https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/jails.html" target="_blank" rel="noopener">jail</a></li><li id="a1e1" data-selectable-paragraph="">2000s (early): <a href="https://docs.freebsd.org/44doc/papers/jail/jail-9.html" target="_blank" rel="noopener">jail &gt; FreeBSD</a></li><li id="0308" data-selectable-paragraph="">2000s (mid): <a href="https://en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>, 2.6.24</li><li id="5a22" data-selectable-paragraph="">2000s (late): <a href="https://en.wikipedia.org/wiki/LXC" target="_blank" rel="noopener">LXC (Linux Containers)</a>, 2.6.4</li><li id="010c" data-selectable-paragraph="">2010s (early): <a href="https://en.wikipedia.org/wiki/Docker_(software)" target="_blank" rel="noopener">Docker</a></li><li id="89c4" data-selectable-paragraph="">2010s (late): <a href="https://en.wikipedia.org/wiki/Kubernetes" target="_blank" rel="noopener">Kubernetes</a></li></ul><p id="98f3" data-selectable-paragraph="">There is a more detailed history in Chapter 7 of <a href="https://www.oreilly.com/library/view/enterprise-docker/9781491994986/" target="_blank" rel="noopener">Enterprise Docker</a> if interested.</p><p id="3f6c" data-selectable-paragraph="">Without containers as we know them today, let’s go back ~10yrs. At this time we did not have/use docker, rkt, or any other mainstream containerized wrapper/service. Most large-scale companies built in-house systems to bundle their applications to go from source code to deployment in production. What engineers ran on their machine was usually not what was running in production or if it was, it was lovingly one-off built/packaged in a manner that was likely very custom and complex.</p><p id="c0bf" data-selectable-paragraph="">In this world of an in-house system to bundle and deploy applications there was a large operations team, usually in a platform or infrastructure organization that would manage the bundle/building processes, deployment, and post-deployment. These roles were generally highly operational involving troubleshooting bad hosts, diagnosing specific dependency issues on OS patches/upgrades, etc. Post-deployment had minimal to no automated orchestration and involved capacity planning, ordering more servers, getting them racked/installed, and somehow getting software updated on them.</p><p id="c481" data-selectable-paragraph="">If you were lucky, there was some regular process to build a “golden image” (think: <a href="https://www.packer.io/" target="_blank" rel="noopener">Packer</a> by Hashicorp) that was well documented, potentially even codified, and run by a Continuous Integration system such as Hudson (previous to Jenkins {<a href="https://en.wikipedia.org/wiki/Hudson_(software)" target="_blank" rel="noopener">ref</a>}). These images were somehow distributed to your systems either manually or automatically through some sort-of configuration management utilities and then started in some ordering, likely with parallel SSH or similar.</p><p id="dcab" data-selectable-paragraph="">This past decade everything has changed. We went from gigantic monolithic applications to breaking down services into more discrete and less coupled parts. We went from having to build/own your own compute to having a managed or Public Cloud offering with a couple clicks and a credit card. We went from scaling applications vertically to re-architecting them to scale horizontally. All of this was happening at the same time that societal changes were also occurring: cell phones in every pocket, network speeds improving, network latencies dropping across the world, to doing everything online from booking your dog walker to commoditized video conferencing.</p><p id="c7a2" data-selectable-paragraph="">AWS’s offering in 2009 was quite limited. For perspective, it wasn’t until 2008 when AWS’s EC2 offering exited beta and began offering an SLA (<a href="https://en.wikipedia.org/wiki/Timeline_of_Amazon_Web_Services" target="_blank" rel="noopener">ref</a>). For reference, GCP didn’t launch a compute offering in GA until 2013 (<a href="https://en.wikipedia.org/wiki/Google_Cloud_Platform" target="_blank" rel="noopener">ref</a>).</p><h2 id="d5a8" data-selectable-paragraph="">Why do companies choose to containerize their applications?</h2><p id="b5f0" data-selectable-paragraph="">Companies choose to containerize their applications to increase engineering output/developer productivity in a quick, safe, and reliable manner. Containerizing is a choice made vs. building images, although containers can sometimes be built into images, but that is out of scope (<a href="https://thenewstack.io/bakery-foundation-container-images-microservices/" target="_blank" rel="noopener">ref</a>).</p><p id="930d" data-selectable-paragraph="">Containers enable engineers to develop, test, and run their applications locally in the same or similar manner that they will run in other environments (staging and production). Containers enable bundling of dependencies to be articulated and explicit vs. implied (the OS will always contain package $foo that my service depends on). Containers allow for more discreet service encapsulation and resource definition (using X CPUs and Y GB of Memory). Containers inherently enable you to think about scaling your application horizontally vs. vertically, resulting in more robust architectural decisions.</p><p id="d074" data-selectable-paragraph="">Some of these points could be argued in great detail. These are purposely bold and a bit over-extended to move the conversation forward as this isn’t a discussion of the pros/cons of containerization or <em>service-ification</em> (i.e. the breakdown of monolithic applications to a proliferation of more discreet services that run separately).</p><h2 id="a0d4" data-selectable-paragraph="">What about virtualization?</h2><p id="6e68" data-selectable-paragraph="">Virtualization is the concept of being able to run multiple containers on an OS virtualized system (<a href="https://en.wikipedia.org/wiki/OS-level_virtualization" target="_blank" rel="noopener">ref</a>). Containers can only see the devices/resources granted to it. On a managed compute platform such as AWS you are actually running below a Hypervisor (<a href="https://en.wikipedia.org/wiki/Hypervisor" target="_blank" rel="noopener">ref</a>) which manages the VMs that your OS and resulting containers run within.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*-lN2p3YLeKOIfjvr?q=20" width="1400" height="641" role="presentation"></p><p><img width="1400" height="641" srcset="https://miro.medium.com/max/552/0*-lN2p3YLeKOIfjvr 276w, https://miro.medium.com/max/1104/0*-lN2p3YLeKOIfjvr 552w, https://miro.medium.com/max/1280/0*-lN2p3YLeKOIfjvr 640w, https://miro.medium.com/max/1400/0*-lN2p3YLeKOIfjvr 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Simplified diagram</figcaption></figure><p id="23f2" data-selectable-paragraph="">Virtualization enables the world of containers today. Without the ability to virtualize, hardware resources running multiple applications in containers wouldn’t be possible today.</p><h2 id="892f" data-selectable-paragraph="">What problem does a container orchestration platform (Mesos, Kubernetes, Docker Swarm) solve?</h2><p id="2e17" data-selectable-paragraph="">A container orchestration platform solves the following types of problems:</p><ul><li id="6e91" data-selectable-paragraph="">Managed/Standardized deployment tooling (deployment).</li><li id="c219" data-selectable-paragraph="">Scaling of applications based-on some defined heuristic (horizontal scaling).</li><li id="9f69" data-selectable-paragraph="">Re-scheduling/Moving containers when failures occur (self-healing).</li></ul><p id="4693" data-selectable-paragraph="">While some platforms may state that they have other features such as storage orchestration, secret/config. management, and automatic bin packing to name a few: the reality is that these <strong>generally do not work for larger scale installations without intense investments either in forking / customization or through integrations and separation</strong>.</p><p id="198a" data-selectable-paragraph="">For example, most folks that run large-scale container orchestration platforms cannot utilize their built-in secret or configuration management. These primitives are generally not meant, designed, or built for hundreds of engineers on tens of teams and generally do not include the necessary controls to be able to sanely manage, own, and operate their applications. It is extremely common for folks to separate their secret and config. management to a system that has stronger guarantees and controls (not to mention scaling).</p><p id="64a4" data-selectable-paragraph="">Similarly for service discovery and load balancing it is quite common to separate this out and run an overlay or abstract control plane. It is quite common to deploy <a href="https://istio.io/" target="_blank" rel="noopener">Istio</a> to handle this for Kubernetes. Managing and running Istio is not a trivial task and many modern-day cluster outages are due to misconfiguration of this control plane/service mesh and a lack of understanding of the minute details of it.</p><h2 id="8f92" data-selectable-paragraph="">What do we use as our container orchestration platform?</h2><p id="07cc" data-selectable-paragraph="">Our container orchestration platform is <a href="https://github.com/coinbase/odin" target="_blank" rel="noopener">Odin</a> + AWS ASGs (auto-scaling groups). When you click Deploy from Codeflow (our <a target="_blank" rel="noopener" href="https://blog.coinbase.com/scaling-developer-productivity-d23ce491f869">internal UI</a> for deployments), Odin is invoked with an API call from Codeflow. Odin kicks off a step function and begins to deploy your application. New VMs are stood up in AWS and loaded into a new ASG, your software is fetched from various internal locations, a load balancer starts health-checking these new instances, and eventually traffic is cut over in a Blue/Green manner to the new hosts in the new ASG behind the load balancer.</p><p id="1cff" data-selectable-paragraph="">Our container orchestration platform is <strong>extremely simple</strong> (on purpose). We enable the same key features of Kubernetes: A single Deploy + Rollback button in Codeflow, Scaling based-on some defined heuristic (we support custom AWS metrics or standard CPU metrics), and re-scheduling/moving of your containers if your VM dies/becomes unhealthy in your ASG.</p><p id="62f4" data-selectable-paragraph="">To handle secrets and configuration management we have built a dynamic configuration service that provides libraries to all internal customers with a p95 of 6ms. It is backed by DynamoDB and serves 100s of thousands of requests per minute of synchronous and asynchronous methods types.</p><p id="db35" data-selectable-paragraph="">To handle service discovery and load balancing we utilize Route53 (DNS), ALBs (Application Load Balancers), and client-side load balancing for gRPC either natively or through Envoy. We expect to invest more here later in the year.</p><h2 id="6939" data-selectable-paragraph="">Why do we not run Kubernetes?</h2><p id="b53d" data-selectable-paragraph=""><strong>Running Kubernetes does not solve any customer (engineering) problems. Running Kubernetes would actually create a whole new set of problems.</strong></p><ol><li id="9aaf" data-selectable-paragraph=""><strong>We would need to build/staff a full-time Compute team</strong>. While we may do this anyway as we grow, this would be required immediately so that they could focus on building out tens of clusters (likely separate for each team/org), starting to scope/build the wrapping/glue tooling, starting to build out the abstract control plane/service mesh, etc.</li><li id="fc99" data-selectable-paragraph=""><strong>Securing Kubernetes is not a trivial, easy, or well understood operation</strong>. To enable us to own/operate Kubernetes we would need the same tooling and controls that we have today with our entire platform (Odin, ASGs, Step Deployers — and everything they enforce). To build these same primitives providing the same level of safety that these provide today would be a substantial investment both by a (future) Compute team and our Security team.</li><li id="611a" data-selectable-paragraph=""><strong>Managed Kubernetes (EKS on AWS, GKE on Google) is very much in its infancy and doesn’t solve most of the challenges with owning/operating Kubernetes (if anything it makes them more difficult at this time)</strong>. At AWS they are scaling their support/operations teams to run EKS and at Google it isn’t uncommon for them to have multi-hour outages with GKE (<a href="https://status.cloud.google.com/incident/container-engine/19012" target="_blank" rel="noopener">ref</a>). You are trading off some operations issues and challenges to another operations team (and removing a lot of visibility).</li><li id="e96a" data-selectable-paragraph=""><strong>Cluster upgrades and management require a much more operationally heavy focus than we have today</strong>. The only way to sanely run Kubernetes is by giving teams/orgs their own clusters (similar to giving them their own AWS accounts or GCP projects). Upgrading clusters and patching vulnerabilities is not a quick/easy task even with Istio and associated tooling. Generally you have to build/run a secondary cluster, failover all applications, and then fail back after an upgrade. This primitive is not built into any abstracts at this point in time. While this may exist for managed clusters (GKE) it doesn’t always work as you might expect and rolling back once started is generally not well handled.</li><li id="16f4" data-selectable-paragraph="">Today, <strong>we do not carry this burden</strong>. We run on a hardened OS with minimal &gt; no dependencies. Our AMI rollout is managed starting with development and then moving forward after weeks of testing. If we need to rollback we have the ability to do so with a trivial one-line change. On average we spend &lt; 5hrs/month on anything even closely related to this area of concern.</li></ol><p id="20e7" data-selectable-paragraph=""><em>Additional references on the complexities of owning/operating Kubernetes &amp; Istio:</em></p><ul><li id="a554" data-selectable-paragraph=""><a href="https://docs.openstack.org/developer/performance-docs/issues/scale_testing_issues.html" target="_blank" rel="noopener">OpenStack</a> (Kubernetes Issues At Scale 900 Minions)</li><li id="b81a" data-selectable-paragraph=""><a href="https://openai.com/blog/scaling-kubernetes-to-2500-nodes/" target="_blank" rel="noopener">OpenAI</a> (Scaling Kubernetes to 2,500 Nodes)</li><li id="f0f8" data-selectable-paragraph=""><a href="https://medium.com/civis-analytics/https-medium-com-civis-analytics-breaking-kubernetes-how-we-broke-and-fixed-our-k8s-cluster-adfa6fbade61" target="_blank" rel="noopener">Civis</a> (Breaking Kubernetes: How We Broke and Fixed our K8s Cluster)</li><li id="270d" data-selectable-paragraph=""><a href="https://k8s.af/" target="_blank" rel="noopener">k8s.af</a></li></ul><p id="bd91" data-selectable-paragraph="">Let’s discuss some of the complexity of securing and running Kubernetes as a business that <a target="_blank" rel="noopener" href="https://blog.coinbase.com/our-focus-on-the-institutional-space-5c8e87332268">stores more than $8 billion in crypto assets</a>.</p><h2 id="06cb" data-selectable-paragraph="">Components</h2><p id="e786" data-selectable-paragraph="">The basics of securing a Kubernetes cluster (<a href="https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/" target="_blank" rel="noopener">ref</a>) are well known/understood but once you dig into each of them the complexities start to unravel. Securing all of the system components (etcd, kubelet), the API server, and any abstracts/overlays (Istio) opens up a lot of surface to understand, test, and secure. Going deep into namespaces, seccomp, SELinux, cgroups, etc. is all required given the increased attack surface. Kubernetes is so large that it has its own CIS <a href="https://www.cisecurity.org/benchmark/kubernetes/" target="_blank" rel="noopener">benchmark</a> &amp; InSpec <a href="https://github.com/dev-sec/cis-kubernetes-benchmark" target="_blank" rel="noopener">suite</a> (thankfully).</p><h2 id="437d" data-selectable-paragraph="">Vulnerabilities</h2><p id="3c3c" data-selectable-paragraph="">A small list of references that provide a good starting point for researching:</p><ul><li id="f1fd" data-selectable-paragraph=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-5736" target="_blank" rel="noopener">CVE-2019–5736</a> (8.6 High): Allows attackers to overwrite the host runc binary (and consequently obtain host root access).</li><li id="a25c" data-selectable-paragraph=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11246" target="_blank" rel="noopener">CVE-2019–11246</a> (6.5 Medium): If the tar binary in the container is malicious, it could run any code and output unexpected, malicious results.</li><li id="99d6" data-selectable-paragraph=""><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11253" target="_blank" rel="noopener">CVE-2019–11253</a> (7.5 High): Allows authorized users to send malicious YAML or JSON payloads, causing the API server to consume excessive CPU or memory, potentially crashing and becoming unavailable.</li></ul><h2 id="62bc" data-selectable-paragraph="">Overview</h2><p id="888f" data-selectable-paragraph="">Kubernetes is a powerful PaaS as a kit with <strong>lots</strong> of security-relevant options to support the variety of deployment scenarios that it can be used in. It’s incredibly valuable from a security perspective when it is the universal consensus choice for PaaS, because most of those options can be abstracted away, and secondary systems must be put into place to support its use.</p><p id="4e9c" data-selectable-paragraph="">Kubernetes is fundamentally designed for workload orchestration — Trust is not the differentiator or purpose behind the encapsulation or pieces in Kubernetes; The multi-tenancy purpose is for bin packing and not in support of furthering permission boundaries. It provides several layers at which you can choose to place mild boundaries of varying enforceability. Some of these boundaries are built-in, while others are simply integration points for other tools to help manage. Here are some of the primitives Kube provides (and doesn’t provide) to isolate workloads.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*L6cjtloELoU0T6Ru?q=20" width="1400" height="641" role="presentation"></p><p><img width="1400" height="641" srcset="https://miro.medium.com/max/552/0*L6cjtloELoU0T6Ru 276w, https://miro.medium.com/max/1104/0*L6cjtloELoU0T6Ru 552w, https://miro.medium.com/max/1280/0*L6cjtloELoU0T6Ru 640w, https://miro.medium.com/max/1400/0*L6cjtloELoU0T6Ru 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><h2 id="3130" data-selectable-paragraph="">Control Plane (AWS Account / GCP Project)</h2><p id="dbcd" data-selectable-paragraph="">Kubernetes clusters operate within the services and networks that are provided to them, and naturally have some interaction with the AWS/GCP control plane such as provisioning load balancers for ingress, accessing secrets stored in KMS, etc. Teams grow and expand to have separate accounts, projects, and further isolation over time. A separate AWS account or GCP project is the primary primitive by which you can achieve total IAM segmentation.</p><p id="0b68" data-selectable-paragraph="">A Kubernetes cluster, on the other hand, needs to operate within one AWS account (even if federated with other clusters elsewhere). This limits segmentation options and flexibility. We could provision a cluster per team or service, but this takes away many of the efficiency gains that Kubernetes brings, and brings on new management problems, like meta-orchestrating all of those clusters.</p><h2 id="4d85" data-selectable-paragraph=""><em>Clusters &amp; Nodes &amp; Pods &amp; Containers (Oh my!)</em></h2><h2 id="1306" data-selectable-paragraph=""><strong>Clusters</strong></h2><p id="f139" data-selectable-paragraph="">Cluster master (API) servers are a secondary control plane (besides the AWS one) that we need to secure as well. Service accounts and access scopes, which containers can assume to access resources both within and outside the cluster, are just as complex as AWS’ IAM is, and need to be mapped against one another strictly so that a breakout does not affect the, e.g., AWS control plane.</p><h2 id="b8e6" data-selectable-paragraph=""><strong>Nodes</strong></h2><p id="68cc" data-selectable-paragraph="">The operating system of the underlying nodes must be maintained much as we do today. In fact, our OS is very similar to the <a href="https://cloud.google.com/container-optimized-os/docs" target="_blank" rel="noopener">base OS</a> Google uses for GKE. While we wouldn’t necessarily have to change anything to move our OS to Kubernetes, we wouldn’t gain anything either.</p><h2 id="6cfc" data-selectable-paragraph=""><strong>Pods</strong></h2><p id="512d" data-selectable-paragraph="">Creation of pods in the cluster, and the rules about what standards they have to meet to be created, are accomplished through PodSecurityPolicy, which operates similarly to <a href="https://github.com/coinbase/salus" target="_blank" rel="noopener">Salus</a> and our consensus management tooling today. We would have to invest in significant integration work, and additional open source dependencies, to cleanly integrate them.</p><p id="1382" data-selectable-paragraph="">Pods are segmented from each other through networking policies, much as we do today with Security Groups and/or our internal service framework. But in the world of Kubernetes, identity, authentication, and authorization of pods to communicate with each other involve a number of supporting technologies, such as SPIFFE and SPIRE for identity format and attestation below the node level, Envoy for authorization gating, Istio for authN and Z orchestration, and OPA for authorization policy. Each of these is a significant effort to standardize and adopt.</p><h2 id="363f" data-selectable-paragraph=""><strong>Containers</strong></h2><p id="7844" data-selectable-paragraph="">Containers are not security boundaries, they’re resource boundaries. In order to define security boundaries around containers, you need to delve into custom kernel namespaces, syscall filtering, mandatory access control frameworks, and/or vm-based isolation technologies designed for containers like <a href="https://github.com/google/gvisor" target="_blank" rel="noopener">gVisor</a>.</p><p id="29e1" data-selectable-paragraph="">Currently, we have not invested much in this area because we do not operate in a multi-tenant fashion. If we moved to a multi-tenant model, we would have to make significant investments here almost immediately so that we could trust that pods/containers are only running on the same nodes as similarly classified pods, and that they are not interfering with one another with host/vm isolation technologies.</p><h2 id="77c4" data-selectable-paragraph="">When will we run Kubernetes and is Kubernetes in our future?</h2><p id="7e6f" data-selectable-paragraph="">If/when there are significant use cases for a more advanced container orchestration platform we will likely <strong>first visit the problem statement</strong>. If this is something that can easily be added to our existing platform: we will likely visit that first and explore/scope from there. If we deem it unreasonable to extend/add to our platform then we would visit all potential options — not just Kubernetes. It is much more likely that we would visit AWS’s managed offerings first such as Fargate and ECS before diving in to Kubernetes based on the above.</p><p id="a541" data-selectable-paragraph="">If/when there are significant gains to be had by our engineers by offering Kubernetes (or any other container orchestration platform) we will explore offering them. At this time there is not a significant gain to be had by offering Kubernetes. This may change if/when Kubernetes offers enough new features that we haven’t kept up, they have paid down their technical debt (or we have not), or our customers require new functionality that they are able to offer and we are not in the foreseeable future. If the barrier to entry of our current platform were to significantly change and that were now a clear differentiator, then we would also explore offering a different platform.</p><p id="098e" data-selectable-paragraph="">If/when we hit the limits of our existing platform, are too deeply burdened or foresee being too deeply burdened in our platform due to missing features that our customers need, extending our platform is becoming too onerous, or we are having too many outages that are violating our SLA, than we would likely revisit a different container orchestration platform.</p><p id="9127" data-selectable-paragraph="">If/when we lose support of a major upstream dependency such as AWS or ASGs, we would then look into other options.</p><p id="6e1c" data-selectable-paragraph="">These are a few of the reasons we might choose to look into another container orchestration platform. <strong>At this time we have no plans to build/own/operate Kubernetes</strong>.</p><h2 id="882e" data-selectable-paragraph="">Doesn’t Kubernetes solve various problems such as re-balancing/auto-healing, auto-scaling, and service discovery? How do we solve these today?</h2><p id="212d" data-selectable-paragraph="">Kubernetes at a smaller scale solves most of these problems without a lot of fuss. At a larger scale it requires a lot more thought, glue code, and putting wrappers / safe guards on pretty much everything to make it work safely and reliably. Generally, as mentioned above, folks tend to add a Service Mesh such as Istio to enable more advanced features / requirements.</p><p id="0cb2" data-selectable-paragraph="">Today we solve:</p><ul><li id="f3b3" data-selectable-paragraph="">Re-balancing/auto-healing with Odin and ASGs.</li><li id="0970" data-selectable-paragraph="">Service discovery with DNS and Envoy.</li></ul><h2 id="3378" data-selectable-paragraph="">Kubernetes has Storage Orchestration and we don’t have that today, should we?</h2><p id="4c6b" data-selectable-paragraph="">We have two major stateful applications at Coinbase today- <strong>blockchain nodes</strong> and the <strong>trading engines</strong> that could be potential customers of a feature such as storage orchestration. For the former (blockchain nodes) the usage of storage is fairly custom and we have built a custom deployer that gives them the features that they need. For the latter (trading engines), we embedded from the Reliability (SRE) team and provided support to a number of their specific challenges.</p><p id="d341" data-selectable-paragraph="">While having Storage Orchestration built-in to Kubernetes might have been a nice starting point for both blockchain nodes and the trading engines- a lot of the same issues we have with the underlying technology would still exist.</p><h2 id="bbfd" data-selectable-paragraph="">What is the future of a Container Orchestration Platform if not Kubernetes?</h2><p id="e771" data-selectable-paragraph="">We will explore and migrate to a higher-level abstracted service for some applications. We will explore Fargate and ECS as contenders for this purpose. The current initial reasons would be utilization and cost improvements — both of which are not very customer focused. We may choose to wait until we have more customer focused reasons to implement.</p><p id="f5a1" data-selectable-paragraph="">Potential customer focused asks would be around deployment times, deployment patterns (beyond canaries), more complex service mesh needs than exist today, or specific improvements/ features that may be added to Fargate or ECS that building onto existing tooling is not possible/not reasonable. These are some of the potential customer focused asks that are possible but not known or realized at this time.</p><p id="1c81" data-selectable-paragraph="">Ideally the move to a different underlying container technology would be fairly invisible as the tools to interact with them wouldn’t fundamentally change. The reality of moving to a different platform would likely uncover hidden or unknown expectations about the existing system. How you deploy and debug services in staging and production would still be abstracted, but there may be different features offered that do not exist today.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*pqEELN9nlaleIhYz?q=20" width="1400" height="641" role="presentation"></p><p><img width="1400" height="641" srcset="https://miro.medium.com/max/552/0*pqEELN9nlaleIhYz 276w, https://miro.medium.com/max/1104/0*pqEELN9nlaleIhYz 552w, https://miro.medium.com/max/1280/0*pqEELN9nlaleIhYz 640w, https://miro.medium.com/max/1400/0*pqEELN9nlaleIhYz 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><h2 id="6769" data-selectable-paragraph="">Do I/we hate Kubernetes? Does Kubernetes fail as a container platform?</h2><p id="a634" data-selectable-paragraph="">No. It is a great tool despite its challenges. Kubernetes has moved our industry forward in an increasingly positive direction. With Kubernetes well into a v1, the development of <a href="https://cloud.google.com/knative/" target="_blank" rel="noopener">Knative</a>, <a href="https://aws.amazon.com/fargate/" target="_blank" rel="noopener">Fargate</a>, and <a href="https://cloud.google.com/run/" target="_blank" rel="noopener">Cloud Run</a> are increasingly raising the level of abstraction and solving the underlying challenges with managing Kubernetes. The future is bright. As these underlying challenges are solved, many existing concerns will likely be alleviated in the future.</p></div></div></section><section><div><p id="5da2" data-selectable-paragraph="">If you are interested in working on our next generation of container technologies, our dynamic configuration service or other technologies mentioned above — we are actively hiring on our <a href="https://www.coinbase.com/careers/positions?department=Engineering%2520-%2520Infrastructure" target="_blank" rel="noopener">Infrastructure team</a>. Please reach out and we would love to chat with you.</p></div></section><section><div><div><p id="fee6" data-selectable-paragraph=""><em>This website contains links to third-party websites or other content for information purposes only (“Third-Party Sites”). The Third-Party Sites are not under the control of Coinbase, Inc., and its affiliates (“Coinbase”), and Coinbase is not responsible for the content of any Third-Party Site, including without limitation any link contained in a Third-Party Site, or any changes or updates to a Third-Party Site. Coinbase is not responsible for webcasting or any other form of transmission received from any Third-Party Site. Coinbase is providing these links to you only as a convenience, and the inclusion of any link does not imply endorsement, approval or recommendation by Coinbase of the site or any association with its operators.</em></p><p id="5c81" data-selectable-paragraph=""><em>Unless otherwise noted, all images provided herein are by Coinbase.</em></p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>