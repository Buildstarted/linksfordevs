<!DOCTYPE html>
<html lang="en">
<head>
    <title>
System.Buffers - .NET -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>System.Buffers - .NET</h1>
    <main id="main" class="content "> <ul class="metadata page-metadata"> <li class="displayDate loading"> <time>12/05/2019</time> </li> <li class="readingTime">9 minutes to read</li> <li class="contributors-holder"> <a class="has-inner-focus" href="https://github.com/dotnet/docs/blob/master/docs/standard/io/buffers.md"> <ul class="contributors"> <li><img src="https://github.com/Rick-Anderson.png?size=32"></li> </ul> </a> </li> </ul> <p>This article provides an overview of types that help read data that runs across multiple buffers. They&apos;re primarily used to support <a class="xref" href="/en-us/dotnet/api/system.io.pipelines.pipereader">PipeReader</a> objects.</p>
<h2 id="ibufferwritert">IBufferWriter&lt;T&gt;</h2>
<p><a class="xref" href="/en-us/dotnet/api/system.buffers.ibufferwriter-1">System.Buffers.IBufferWriter&lt;T&gt;</a> is a contract for synchronous buffered writing. At the lowest level, the interface:</p>
<ul>
<li>Is basic and not difficult to use.</li>
<li>Allows access to a <a class="xref" href="/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a> or <a class="xref" href="/en-us/dotnet/api/system.span-1">Span&lt;T&gt;</a>. The <code>Memory&lt;T&gt;</code> or <code>Span&lt;T&gt;</code> can be written to and you can determine how many <code>T</code> items were written.</li>
</ul>
<pre><code class="lang-csharp">void WriteHello(IBufferWriter&lt;byte&gt; writer)
{
    // Request at least 5 bytes.
    Span&lt;byte&gt; span = writer.GetSpan(5);
    ReadOnlySpan&lt;char&gt; helloSpan = &quot;Hello&quot;.AsSpan();
    int written = Encoding.ASCII.GetBytes(helloSpan, span);

    // Tell the writer how many bytes were written.
    writer.Advance(written);
}
</code></pre>
<p>The preceding method:</p>
<ul>
<li>Requests a buffer of at least 5 bytes from the <code>IBufferWriter&lt;byte&gt;</code> using <code>GetSpan(5)</code>.</li>
<li>Writes bytes for the ASCII string &quot;Hello&quot; to the returned <code>Span&lt;byte&gt;</code>.</li>
<li>Calls <a class="xref" href="/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;T&gt;</a> to indicate how many bytes were written to the buffer.</li>
</ul>
<p>This method of writing uses the <code>Memory&lt;T&gt;</code>/<code>Span&lt;T&gt;</code> buffer provided by the <code>IBufferWriter&lt;T&gt;</code>. Alternatively, the <a class="xref" href="/en-us/dotnet/api/system.buffers.buffersextensions.write">Write</a> extension method can be used to copy an existing buffer to the <code>IBufferWriter&lt;T&gt;</code>. <code>Write</code> does the work of calling <code>GetSpan</code>/<code>Advance</code> as appropriate, so there&apos;s no need to call <code>Advance</code> after writing:</p>
<pre><code class="lang-csharp">void WriteHello(IBufferWriter&lt;byte&gt; writer)
{
    byte[] helloBytes = Encoding.ASCII.GetBytes(&quot;Hello&quot;);

    // Write helloBytes to the writer. There&apos;s no need to call Advance here
    // since Write calls Advance.
    writer.Write(helloBytes);
}
</code></pre>
<p><a class="xref" href="/en-us/dotnet/api/system.buffers.arraybufferwriter-1">ArrayBufferWriter&lt;T&gt;</a> is an implementation of <code>IBufferWriter&lt;T&gt;</code> whose backing store is a single contiguous array.</p>
<h3 id="ibufferwriter-common-problems">IBufferWriter common problems</h3>
<ul>
<li><code>GetSpan</code> and <code>GetMemory</code> return a buffer with at least the requested amount of memory. Don&apos;t assume exact buffer sizes.</li>
<li>There&apos;s no guarantee that successive calls will return the same buffer or the same-sized buffer.</li>
<li>A new buffer must be requested after calling <code>Advance</code> to continue writing more data. A previously acquired buffer cannot be written to after <code>Advance</code> has been called.</li>
</ul>
<h2 id="readonlysequencet">ReadOnlySequence&lt;T&gt;</h2>
<p><img src="media/buffers/ro-sequence.png" alt="ReadOnlySequence showing memory in pipe and below that sequence position of read-only memory"></p>
<p><a class="xref" href="/en-us/dotnet/api/system.buffers.readonlysequence-1">ReadOnlySequence&lt;T&gt;</a> is a struct that can represent a contiguous or noncontiguous sequence of <code>T</code>. It can be constructed from:</p>
<ol>
<li>A <code>T[]</code></li>
<li>A <code>ReadOnlyMemory&lt;T&gt;</code></li>
<li>A pair of linked list node <a class="xref" href="/en-us/dotnet/api/system.buffers.readonlysequencesegment-1">ReadOnlySequenceSegment&lt;T&gt;</a> and index to represent the start and end position of the sequence.</li>
</ol>
<p>The third representation is the most interesting one as it has performance implications on various operations on the <code>ReadOnlySequence&lt;T&gt;</code>:</p>
<table>
<thead>
<tr>
<th>Representation</th>
<th>Operation</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T[]</code>/<code>ReadOnlyMemory&lt;T&gt;</code></td>
<td><code>Length</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>T[]</code>/<code>ReadOnlyMemory&lt;T&gt;</code></td>
<td><code>GetPosition(long)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>T[]</code>/<code>ReadOnlyMemory&lt;T&gt;</code></td>
<td><code>Slice(int, int)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>T[]</code>/<code>ReadOnlyMemory&lt;T&gt;</code></td>
<td><code>Slice(SequencePostion, SequencePostion)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>ReadOnlySequenceSegment&lt;T&gt;</code></td>
<td><code>Length</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>ReadOnlySequenceSegment&lt;T&gt;</code></td>
<td><code>GetPosition(long)</code></td>
<td><code>O(number of segments)</code></td>
</tr>
<tr>
<td><code>ReadOnlySequenceSegment&lt;T&gt;</code></td>
<td><code>Slice(int, int)</code></td>
<td><code>O(number of segments)</code></td>
</tr>
<tr>
<td><code>ReadOnlySequenceSegment&lt;T&gt;</code></td>
<td><code>Slice(SequencePostion, SequencePostion)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody>
</table>
<p>Because of this mixed representation, the <code>ReadOnlySequence&lt;T&gt;</code> exposes indexes as <code>SequencePosition</code> instead of an integer. A <code>SequencePosition</code>:</p>
<ul>
<li>Is an opaque value that represents an index into the <code>ReadOnlySequence&lt;T&gt;</code> where it originated.</li>
<li>Consists of two parts, an integer and an object. What these two values represent are tied to the implementation of <code>ReadOnlySequence&lt;T&gt;</code>.</li>
</ul>
<h3 id="access-data">Access data</h3>
<p>The <code>ReadOnlySequence&lt;T&gt;</code> exposes data as an enumerable of <code>ReadOnlyMemory&lt;T&gt;</code>. Enumerating each of the segments can be done using a basic foreach:</p>
<pre><code class="lang-csharp">long FindIndexOf(in ReadOnlySequence&lt;byte&gt; buffer, byte data)
{
    long position = 0;

    foreach (ReadOnlyMemory&lt;byte&gt; segment in buffer)
    {
        ReadOnlySpan&lt;byte&gt; span = segment.Span;
        var index = span.IndexOf(data);
        if (index != -1)
        {
            return position + index;
        }

        position += span.Length;
    }

    return -1;
}
</code></pre>
<p>The preceding method searches each segment for a specific byte. If you need to keep track of each segment&apos;s <code>SequencePosition</code>,
<a class="xref" href="/en-us/dotnet/api/system.buffers.readonlysequence-1.tryget">ReadOnlySequence&lt;T&gt;.TryGet</a> is more appropriate. The next sample changes the preceding code to return a <code>SequencePosition</code> instead of an integer. Returning a <code>SequencePosition</code> has the benefit of allowing the caller to avoid a second scan to get the data at a specific index.</p>
<pre><code class="lang-csharp">SequencePosition? FindIndexOf(in ReadOnlySequence&lt;byte&gt; buffer, byte data)
{
    SequencePosition position = buffer.Start;

    while (buffer.TryGet(ref position, out ReadOnlyMemory&lt;byte&gt; segment))
    {
        ReadOnlySpan&lt;byte&gt; span = segment.Span;
        var index = span.IndexOf(data);
        if (index != -1)
        {
            return buffer.GetPosition(position, index);
        }
    }
    return null;
}
</code></pre>
<p>The combination of <code>SequencePosition</code> and <code>TryGet</code> acts like an enumerator. The position field is modified at the start of each iteration to be start of each segment within the <code>ReadOnlySequence&lt;T&gt;</code>.</p>
<p>The preceding method exists as an extension method on <code>ReadOnlySequence&lt;T&gt;</code>. <a class="xref" href="/en-us/dotnet/api/system.buffers.buffersextensions.positionof">PositionOf</a> can be used to simplify the preceding code:</p>
<pre><code class="lang-csharp">SequencePosition? FindIndexOf(in ReadOnlySequence&lt;byte&gt; buffer, byte data) =&gt; buffer.PositionOf(data);
</code></pre>
<h4 id="process-a-readonlysequencet">Process a ReadOnlySequence&lt;T&gt;</h4>
<p>Processing a <code>ReadOnlySequence&lt;T&gt;</code> can be challenging since data may be split across multiple segments within the sequence. For the best performance, split code into two paths:</p>
<ul>
<li>A fast path that deals with the single segment case.</li>
<li>A slow path that deals with the data split across segments.</li>
</ul>
<p>There are a few approaches that can be used to process data in multi-segmented sequences:</p>
<ul>
<li>Use the <a href="#sequencereadert"><code>SequenceReader&lt;T&gt;</code></a>.</li>
<li>Parse data segment by segment, keeping track of the <code>SequencePosition</code> and index within the segment parsed. This avoids unnecessary allocations but may be inefficient, especially for small buffers.</li>
<li>Copy the <code>ReadOnlySequence&lt;T&gt;</code> to a contiguous array and treat it like a single buffer:
<ul>
<li>If the size of the <code>ReadOnlySequence&lt;T&gt;</code> is small, it may be reasonable to copy the data into a stack-allocated buffer using the <a href="../../csharp/language-reference/operators/stackalloc">stackalloc</a> operator.</li>
<li>Copy the <code>ReadOnlySequence&lt;T&gt;</code> into a pooled array using <a class="xref" href="/en-us/dotnet/api/system.buffers.arraypool-1.shared">ArrayPool&lt;T&gt;.Shared</a>.</li>
<li>Use <a class="xref" href="/en-us/dotnet/api/system.buffers.buffersextensions.toarray"><code>ReadOnlySequence&lt;T&gt;.ToArray()</code></a>. This isn&apos;t recommended in hot paths as it allocates a new <code>T[]</code> on the heap.</li>
</ul>
</li>
</ul>
<p>The following examples demonstrate some common cases for processing <code>ReadOnlySequence&lt;byte&gt;</code>:</p>
<h5 id="process-binary-data">Process binary data</h5>
<p>The following example parses a 4-byte big-endian integer length from the start of the <code>ReadOnlySequence&lt;byte&gt;</code>.</p>
<pre><code class="lang-csharp">bool TryParseHeaderLength(ref ReadOnlySequence&lt;byte&gt; buffer, out int length)
{
    // If there&apos;s not enough space, the length can&apos;t be obtained.
    if (buffer.Length &lt; 4)
    {
        length = 0;
        return false;
    }

    // Grab the first 4 bytes of the buffer.
    var lengthSlice = buffer.Slice(buffer.Start, 4);
    if (lengthSlice.IsSingleSegment)
    {
        // Fast path since it&apos;s a single segment.
        length = BinaryPrimitives.ReadInt32BigEndian(lengthSlice.First.Span);
    }
    else
    {
        // There are 4 bytes split across multiple segments. Since it&apos;s so small, it 
        // can be copied to a stack allocated buffer. This avoids a heap allocation.
        Span&lt;byte&gt; stackBuffer = stackalloc byte[4];
        lengthSlice.CopyTo(stackBuffer);
        length = BinaryPrimitives.ReadInt32BigEndian(stackBuffer);
    }

    // Move the buffer 4 bytes ahead.
    buffer = buffer.Slice(lengthSlice.End);

    return true;
}
</code></pre><h5 id="process-text-data">Process text data</h5>
<p>The following example:</p>
<ul>
<li>Finds the first newline (<code>\r\n</code>) in the <code>ReadOnlySequence&lt;byte&gt;</code> and returns it via the out &apos;line&apos; parameter.</li>
<li>Trims that line, excluding the <code>\r\n</code> from the input buffer.</li>
</ul>
<pre><code class="lang-csharp">static bool TryParseLine(ref ReadOnlySequence&lt;byte&gt; buffer, out ReadOnlySequence&lt;byte&gt; line)
{
    SequencePosition position = buffer.Start;
    SequencePosition previous = position;
    var index = -1;
    line = default;

    while (buffer.TryGet(ref position, out ReadOnlyMemory&lt;byte&gt; segment))
    {
        ReadOnlySpan&lt;byte&gt; span = segment.Span;

        // Look for \r in the current segment.
        index = span.IndexOf((byte)&apos;\r&apos;);

        if (index != -1)
        {
            // Check next segment for \n.
            if (index + 1 &gt;= span.Length)
            {
                var next = position;
                if (!buffer.TryGet(ref next, out ReadOnlyMemory&lt;byte&gt; nextSegment))
                {
                    // You&apos;re at the end of the sequence.
                    return false;
                }
                else if (nextSegment.Span[0] == (byte)&apos;\n&apos;)
                {
                    //  A match was found.
                    break;
                }
            }
            // Check the current segment of \n.
            else if (span[index + 1] == (byte)&apos;\n&apos;)
            {
                // It was found.
                break;
            }
        }

        previous = position;
    }

    if (index != -1)
    {
        // Get the position just before the \r\n.
        var delimeter = buffer.GetPosition(index, previous);

        // Slice the line (excluding \r\n).
        line = buffer.Slice(buffer.Start, delimeter);

        // Slice the buffer to get the remaining data after the line.
        buffer = buffer.Slice(buffer.GetPosition(2, delimeter));
        return true;
    }

    return false;
}
</code></pre><h5 id="empty-segments">Empty segments</h5>
<p>It&apos;s valid to store empty segments inside of a <code>ReadOnlySequence&lt;T&gt;</code>. Empty segments may occur while enumerating segments explicitly:</p>
<pre><code class="lang-csharp">static void EmptySegments()
{
    // This logic creates a ReadOnlySequence&lt;byte&gt; with 4 segments,
    // two of which are empty.
    var first = new BufferSegment(new byte[0]);
    var last = first.Append(new byte[] { 97 })
                    .Append(new byte[0]).Append(new byte[] { 98 });

    // Construct the ReadOnlySequence&lt;byte&gt; from the linked list segments.
    var data = new ReadOnlySequence&lt;byte&gt;(first, 0, last, 1);

    // Slice using numbers.
    var sequence1 = data.Slice(0, 2);

    // Slice using SequencePosition pointing at the empty segment.
    var sequence2 = data.Slice(data.Start, 2);

    Console.WriteLine($&quot;sequence1.Length={sequence1.Length}&quot;); // sequence1.Length=2
    Console.WriteLine($&quot;sequence2.Length={sequence2.Length}&quot;); // sequence2.Length=2

    // sequence1.FirstSpan.Length=1
    Console.WriteLine($&quot;sequence1.FirstSpan.Length={sequence1.FirstSpan.Length}&quot;);

    // Slicing using SequencePosition will Slice the ReadOnlySequence&lt;byte&gt; directly 
    // on the empty segment!
    // sequence2.FirstSpan.Length=0
    Console.WriteLine($&quot;sequence2.FirstSpan.Length={sequence2.FirstSpan.Length}&quot;);

    // The following code prints 0, 1, 0, 1.
    SequencePosition position = data.Start;
    while (data.TryGet(ref position, out ReadOnlyMemory&lt;byte&gt; memory))
    {
        Console.WriteLine(memory.Length);
    }
}

class BufferSegment : ReadOnlySequenceSegment&lt;byte&gt;
{
    public BufferSegment(Memory&lt;byte&gt; memory)
    {
        Memory = memory;
    }

    public BufferSegment Append(Memory&lt;byte&gt; memory)
    {
        var segment = new BufferSegment(memory)
        {
            RunningIndex = RunningIndex + Memory.Length
        };
        Next = segment;
        return segment;
    }
}
</code></pre>
<p>The preceding code creates a <code>ReadOnlySequence&lt;byte&gt;</code> with empty segments and shows how those empty segments affect the various APIs:</p>
<ul>
<li><code>ReadOnlySequence&lt;T&gt;.Slice</code> with a <code>SequencePosition</code> pointing to an empty segment preserves that segment.</li>
<li><code>ReadOnlySequence&lt;T&gt;.Slice</code> with an int skips over the empty segments.</li>
<li>Enumerating the <code>ReadOnlySequence&lt;T&gt;</code> enumerates the empty segments.</li>
</ul>
<h3 id="potential-problems-with-readonlysequencet-and-sequenceposition">Potential problems with ReadOnlySequence&lt;T&gt; and SequencePosition</h3>
<p>There are several unusual outcomes when dealing with a <code>ReadOnlySequence&lt;T&gt;</code>/<code>SequencePosition</code> vs. a normal <code>ReadOnlySpan&lt;T&gt;</code>/<code>ReadOnlyMemory&lt;T&gt;</code>/<code>T[]</code>/<code>int</code>:</p>
<ul>
<li><code>SequencePosition</code> is a position marker for a specific <code>ReadOnlySequence&lt;T&gt;</code>, not an absolute position. Because it&apos;s relative to a specific <code>ReadOnlySequence&lt;T&gt;</code>, it doesn&apos;t have meaning if used outside of the <code>ReadOnlySequence&lt;T&gt;</code> where it originated.</li>
<li>Arithmetic can&apos;t be performed on <code>SequencePosition</code> without the <code>ReadOnlySequence&lt;T&gt;</code>. That means doing basic things like <code>position++</code> is written <code>ReadOnlySequence&lt;T&gt;.GetPosition(position, 1)</code>.</li>
<li><code>GetPosition(long)</code> does <strong>not</strong> support negative indexes. That means it&apos;s impossible to get the second to last character without walking all segments.</li>
<li>Two <code>SequencePosition</code> can&apos;t be compared, making it difficult to:
<ul>
<li>Know if one position is greater than or less than another position.</li>
<li>Write some parsing algorithms.</li>
</ul>
</li>
<li><code>ReadOnlySequence&lt;T&gt;</code> is bigger than an object reference and should be passed by <a href="../../csharp/language-reference/keywords/in-parameter-modifier">in</a> or <a href="../../csharp/language-reference/keywords/ref">ref</a> where possible. Passing <code>ReadOnlySequence&lt;T&gt;</code> by <code>in</code> or <code>ref</code> reduces copies of the <a href="../../csharp/language-reference/keywords/struct">struct</a>.</li>
<li>Empty segments:
<ul>
<li>Are valid within a <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Can appear when iterating using the <code>ReadOnlySequence&lt;T&gt;.TryGet</code> method.</li>
<li>Can appear slicing the sequence using the <code>ReadOnlySequence&lt;T&gt;.Slice()</code> method with <code>SequencePosition</code> objects.</li>
</ul>
</li>
</ul>
<h2 id="sequencereadert">SequenceReader&lt;T&gt;</h2>
<p><a class="xref" href="/en-us/dotnet/api/system.buffers.sequencereader-1">SequenceReader&lt;T&gt;</a>:</p>
<ul>
<li>Is a new type that was introduced in .NET Core 3.0 to simplify the processing of a <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Unifies the differences between a single segment <code>ReadOnlySequence&lt;T&gt;</code> and multi-segment <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Provides helpers for reading binary and text data (<code>byte</code> and <code>char</code>) that may or may not be split across segments.</li>
</ul>
<p>There are built-in methods for dealing with processing both binary and delimited data. The following section demonstrates what those same methods look like with the <code>SequenceReader&lt;T&gt;</code>:</p>
<h3 id="access-data-1">Access data</h3>
<p><code>SequenceReader&lt;T&gt;</code> has methods for enumerating data inside of the <code>ReadOnlySequence&lt;T&gt;</code> directly. The following code is an example of processing a <code>ReadOnlySequence&lt;byte&gt;</code> a <code>byte</code> at a time:</p>
<pre><code class="lang-csharp">while (reader.TryRead(out byte b))
{
    Process(b);
}
</code></pre>
<p>The <code>CurrentSpan</code> exposes the current segment&apos;s <code>Span</code>, which is similar to what was done in the method manually.</p>
<h3 id="use-position">Use position</h3>
<p>The following code is an example implementation of <code>FindIndexOf</code> using the <code>SequenceReader&lt;T&gt;</code>:</p>
<pre><code class="lang-csharp">SequencePosition? FindIndexOf(in ReadOnlySequence&lt;byte&gt; buffer, byte data)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);

    while (!reader.End)
    {
        // Search for the byte in the current span.
        var index = reader.CurrentSpan.IndexOf(data);
        if (index != -1)
        {
            // It was found, so advance to the position.
            reader.Advance(index);

            return reader.Position;
        }
        // Skip the current segment since there&apos;s nothing in it.
        reader.Advance(reader.CurrentSpan.Length);
    }

    return null;
}
</code></pre><h3 id="process-binary-data-1">Process binary data</h3>
<p>The following example parses a 4-byte big-endian integer length from the start of the <code>ReadOnlySequence&lt;byte&gt;</code>.</p>
<pre><code class="lang-csharp">bool TryParseHeaderLength(ref ReadOnlySequence&lt;byte&gt; buffer, out int length)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);
    return reader.TryReadBigEndian(out length);
}
</code></pre><h3 id="process-text-data-1">Process text data</h3>
<pre><code class="lang-csharp">static ReadOnlySpan&lt;byte&gt; NewLine =&gt; new byte[] { (byte)&apos;\r&apos;, (byte)&apos;\n&apos; };

static bool TryParseLine(ref ReadOnlySequence&lt;byte&gt; buffer, 
                         out ReadOnlySequence&lt;byte&gt; line)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);

    if (reader.TryReadTo(out line, NewLine))
    {
        buffer = buffer.Slice(reader.Position);

        return true;
    }

    line = default;
    return false;
}
</code></pre><h3 id="sequencereadert-common-problems">SequenceReader&lt;T&gt; common problems</h3>
<ul>
<li>Because <code>SequenceReader&lt;T&gt;</code> is a mutable struct, it should always be passed by <a href="../../csharp/language-reference/keywords/ref">reference</a>.</li>
<li><code>SequenceReader&lt;T&gt;</code> is a <a href="../../csharp/language-reference/keywords/ref#ref-struct-types">ref struct</a> so it can only be used in synchronous methods and can&apos;t be stored in fields. For more information, see <a href="../../csharp/write-safe-efficient-code">Write safe and efficient C# code</a>.</li>
<li><code>SequenceReader&lt;T&gt;</code> is optimized for use as a forward-only reader. <code>Rewind</code> is intended for small backups that can&apos;t be addressed utilizing other <code>Read</code>, <code>Peek</code>, and <code>IsNext</code> APIs.</li>
</ul> </main>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>