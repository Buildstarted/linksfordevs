<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bakedbean.org.uk - Building Stack Overflow Job Search -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Bakedbean.org.uk - Building Stack Overflow Job Search</h1><div><div id="" class=""><p>In <a href="/posts/2019-05-job-search-1-intro">Part 1</a> we talked about some of the shortcomings of Stack Overflow’s job search and how we planned to address them. In this episode we’ll dive into how our parser is written.</p><h2 id="some-background">Some Background</h2><p>Most people seem to get scared the moment the words lexer or parser get mentioned. I’d highly recommend watching <a href="https://youtube.com/watch?v=HxaD_trXwRE">Rob Pike’s talk</a> on the Go lexer and parser; it clears up a lot of misconceptions and provides a solid basis for writing a hand-rolled parser.</p><p>Intitially we went with a hand-rolled parser instead of using a parser generator like ANTLR because the output produced by ANTLR was large and unwieldy. We also had to customise it to handle malformed input (more on that below) which made the code less than elegant.</p><p>Originally I wrote this post about building that hand-rolled parser but trying to explain it concisely wound up being complex and verbose. I think this points to it being hard to grok and maintain so I set out to write an implementation using a <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator</a> library instead. It turned out good enough (i.e. it passes all tests and performance is relatively close to the original) that I thought I’d write about that instead, although we’re not yet using it in production.</p><p>You can find all the source code related to this post in <a href="https://github.com/deanward81/bakedbean.org.uk/tree/master/samples">GitHub</a>.</p><p>Onwards, let’s talk about the steps we took to build our parser!</p><h2 id="defining-the-grammar">Defining the Grammar</h2><p>We started with an idea of the language we wanted to implement. We wanted it to be similar to what was available in <a href="https://stackoverflow.com/help/searching">Stack Overflow’s search</a> and for it to support the facets defined upon a job. So we came up with some example queries:</p><ul><li><strong>Simple Text</strong>: <code>hello world</code></li><li><strong>Quoted Text</strong>: <code>"hello world"</code></li><li><strong>Tags</strong>: <code>[asp.net]</code></li><li><strong>Modifiers</strong>: <code>salary:10000</code> or <code>salary:10000USD</code></li><li><strong>Ranges</strong>: <code>salary:10000..20000</code> or <code>salary:..50000</code> or <code>salary:10000..</code></li><li><strong>Expressions</strong>: <code>[asp.net] or "hello world"</code> or <code>[c#] and not [java] and salary:10000..20000</code></li><li><strong>Complex Expressions</strong>: <code>([asp.net] or "hello world") and (([c#] and not [java]) or salary:10000..)</code></li></ul><p>We then defined the language using <a href="https://en.m.wikipedia.org/wiki/Extended_Backus–Naur_form">Extended Backus-Naur Form (EBNF)</a>. This is generally referred to as the grammar of the language and EBNF is a syntax used to describe the individual components of the grammar. Here’s a snippet of Jobs Query Language (JQL) in EBNF:</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></pre></td><td class="lntd"><pre class="chroma">&lt;and&gt; ::= 'and' | '&amp;&amp;';
&lt;or&gt; ::= 'or' | '||';
&lt;not&gt; ::= 'not' | '-';
&lt;quote&gt; ::= '"';
&lt;colon&gt; ::= ':';
&lt;lparen&gt; ::= '(';
&lt;rparen&gt; ::= ')';
&lt;parens&gt; ::= &lt;lparen&gt; | &lt;rparen&gt;;
&lt;lbracket&gt; ::= '[';
&lt;rbracket&gt; ::= ']';
&lt;brackets&gt; ::= &lt;lbracket&gt; | &lt;rbracket&gt;;
&lt;string&gt; ::= { &lt;any_character&gt; - (&lt;brackets&gt; | &lt;parens&gt; | &lt;quote&gt;) };
&lt;quoted_string&gt; ::= &lt;quote&gt; { &lt;any_character&gt; - &lt;quote&gt; } &lt;quote&gt;;
&lt;tag&gt; ::= { &lt;letter&gt; | &lt;number&gt; | '-' | '.' | '#' | '+' | '*' };
&lt;modifier&gt; ::= { &lt;letter&gt; | '-' } &lt;colon&gt;;
&lt;range&gt; ::= '.', '.';
&lt;unit&gt; ::= &lt;letter&gt;, &lt;letter&gt;, &lt;letter&gt; | &lt;letter&gt;, &lt;letter&gt; | &lt;letter&gt;;
&lt;literal&gt; ::= &lt;number&gt; | &lt;string&gt; | &lt;quoted_string&gt;;
&lt;term&gt; ::= 
    &lt;modifier&gt;, &lt;colon&gt;, &lt;literal&gt; |
    &lt;lbracket&gt;, &lt;tag&gt;, &lt;rbracket&gt; | 
    &lt;string&gt; | 
    &lt;quoted_string&gt;;
    
&lt;expression&gt; ::= 
    &lt;lparen&gt;, &lt;expression&gt;, &lt;rparen&gt; | 
    &lt;not&gt;, &lt;expression&gt; |
    &lt;expression&gt;, &lt;and&gt;, &lt;expression&gt; | 
    &lt;expression&gt;, &lt;or&gt;, &lt;expression&gt; |
    &lt;term&gt;;</pre></td></tr></tbody></table></div></div><p>Of particular importance is the definition of <code>&lt;expression&gt;</code>; this is what allows for the nesting of different parts of the grammar via recursion.</p><h2 id="building-the-parser">Building the Parser</h2><p>Once we’ve defined a grammar, our next step is to break down each rule into a set of mini-parsers. This is what a parser combinator does best so we decided to use <a href="https://github.com/benjamin-hodgson/Pidgin">Pidgin</a> - it eliminates a lot of the mistakes that are common in writing your own parser and performs very well thanks to Stack’s very own parser wizard <a href="https://benjamin.pizza/">Benjamin Hodgson</a>.</p><p>In our case we’d like to take an arbitrary string input and return something representing the parsed form of it. A common way of representing the parsed form is as an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a>.</p><p>JQL is represented using an AST that uses an abstract base class called <code>JqlNode</code>. We have implementations that reflect the structure of the grammar. E.g. it consists of a <code>QueryNode</code> representing a query which can contain things like <code>LiteralNode</code> to represent text/numbers/bools and <code>ModifierNode</code> to handle modifiers like <code>remote:true</code>. Here’s how that looks:</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">abstract</span><span class="k">class</span><span class="nc">JqlNode</span><span class="p">{}</span><span class="k">class</span><span class="nc">QueryNode</span><span class="p">:</span><span class="n">JqlNode</span><span class="p">{</span><span class="k">public</span><span class="n">ImmutableList</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">Children</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="k">class</span><span class="nc">GroupNode</span><span class="p">:</span><span class="n">JqlNode</span><span class="p">{</span><span class="k">public</span><span class="n">ImmutableList</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">Children</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="k">class</span><span class="nc">ModifierNode</span><span class="p">:</span><span class="n">JqlNode</span><span class="p">{</span><span class="c1">// for the remote:true case this would be equal to "remote"
</span><span class="c1"></span><span class="k">public</span><span class="kt">string</span><span class="n">Value</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="c1">// for the remote:true case this would be a "BooleanNode" with its value set to true
</span><span class="c1"></span><span class="k">public</span><span class="n">JqlNode</span><span class="n">Operand</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="k">class</span><span class="nc">LiteralNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">:</span><span class="n">JqlNode</span><span class="p">{</span><span class="k">public</span><span class="n">T</span><span class="n">Value</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="k">class</span><span class="nc">TextNode</span><span class="p">:</span><span class="n">LiteralNode</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span><span class="p">{</span><span class="p">}</span><span class="k">class</span><span class="nc">BooleanNode</span><span class="p">:</span><span class="n">LiteralNode</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span><span class="p">{</span><span class="p">}</span></code></pre></td></tr></tbody></table></div></div><p>We can build a parser that takes a <code>string</code> (which at its most primitive level is just an array of <code>char</code>) and produces a <code>JqlNode</code> tree as a result. This is represented in Pidgin using a <code>Parser&lt;char, JqlNode&gt;</code> - here’s an example of how we define a tag:</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span><span class="k">class</span><span class="nc">JqlParser</span><span class="p">{</span><span class="k">private</span><span class="k">static</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;</span><span class="n">Token</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">T</span><span class="p">&gt;</span><span class="n">p</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">Try</span><span class="p">(</span><span class="n">p</span><span class="p">).</span><span class="n">Before</span><span class="p">(</span><span class="n">SkipWhitespaces</span><span class="p">);</span><span class="k">private</span><span class="k">static</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">string</span><span class="p">&gt;</span><span class="n">Token</span><span class="p">(</span><span class="kt">string</span><span class="n">token</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">Token</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">char</span><span class="p">&gt;</span><span class="n">Token</span><span class="p">(</span><span class="kt">char</span><span class="n">token</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">Token</span><span class="p">(</span><span class="n">Char</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">char</span><span class="p">&gt;</span><span class="n">_tagChars</span><span class="p">=</span><span class="n">LetterOrDigit</span><span class="p">.</span><span class="n">Or</span><span class="p">(</span><span class="n">OneOf</span><span class="p">(</span><span class="sc">'-'</span><span class="p">,</span><span class="sc">'#'</span><span class="p">,</span><span class="sc">'_'</span><span class="p">,</span><span class="sc">'+'</span><span class="p">,</span><span class="sc">'*'</span><span class="p">,</span><span class="sc">'.'</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">_tag</span><span class="p">=</span><span class="n">Token</span><span class="p">(</span><span class="n">_tagChars</span><span class="p">.</span><span class="n">AtLeastOnceString</span><span class="p">()</span><span class="p">.</span><span class="n">Between</span><span class="p">(</span><span class="n">Char</span><span class="p">(</span><span class="sc">'['</span><span class="p">),</span><span class="n">Char</span><span class="p">(</span><span class="sc">']'</span><span class="p">))</span><span class="p">)</span><span class="p">.</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">=&gt;</span><span class="n">JqlBuilder</span><span class="p">.</span><span class="n">Tag</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="p">.</span><span class="n">Labelled</span><span class="p">(</span><span class="s">"tag"</span><span class="p">);</span><span class="k">public</span><span class="k">static</span><span class="n">JqlNode</span><span class="n">Parse</span><span class="p">(</span><span class="kt">string</span><span class="n">input</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">_tag</span><span class="p">.</span><span class="n">ParseOrThrow</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="p">}</span></code></pre></td></tr></tbody></table></div></div><p>Here we can see that we’ve defined the characters that a tag supports in the <code>_tagChars</code> static member; any letter or digit or the <code>-</code>, <code>#</code>, <code>+</code>, <code>*</code>, and <code>.</code> characters. We’ve also defined a helper called <code>Token</code> that attempts to consume input defined by a parser (using <code>Try</code>) skipping whitespace at the start of the input - this means we don’t need to worry about handling whitespace in our individual parsers. If the parser fails then <code>Try</code> also provides back-tracking so we can try another parser. This becomes important later because it lets our parser recover when it starts parsing an expression that eventually ends up being something else. For example the expression <code>[hello&amp;world]</code> might initially look like a tag to the parser above, however, once it hits the <code>&amp;</code> our parser discovers there’s no way that the input can be a tag (remember that <code>&amp;</code> is not a valid character in a tag). In this case <code>Try</code> will rewind the input to the <code>[</code> character and interpret the expression in another way - but only if there are rules that allow it to do so. If there aren’t then the parser fails and an error is returned instead.</p><p>Finally we put these pieces together in the <code>_tag</code> static member. This parser says that we’re expecting a string of tag characters, surrounded by square brackets (<code>[</code>, <code>]</code>), optionally preceeded by whitespace and that when we get a string of these characters we should <code>Select</code> a JQL <code>TagNode</code> with the value within it.</p><p>We perform this process for each rule in the grammar, re-using combinations of smaller parsers to build more complete parsers. Eventually we get to a point where we have a parser that can handle the entire grammar!</p><h2 id="something-a-bit-more-complex">Something a bit more complex</h2><p>The tag example is simple but let’s extend it to support <code>and</code> and <code>or</code> operations to allow us to support inputs like:</p><ul><li><code>[c#] and [sql-server]</code></li><li><code>[javascript] or [reactjs] and [nodejs]</code></li><li><code>[php] and ([mysql] or [postgres])</code></li></ul><p>This seems like it would be complicated, but fear not, Pidgin makes this really quite easy… Building upon our example above:</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span><span class="k">class</span><span class="nc">JqlParser</span><span class="p">{</span><span class="k">private</span><span class="k">static</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">Parenthesised</span><span class="p">(</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">parser</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">parser</span><span class="p">.</span><span class="n">Between</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="sc">'('</span><span class="p">),</span><span class="n">Token</span><span class="p">(</span><span class="sc">')'</span><span class="p">)).</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">n</span><span class="p">=&gt;</span><span class="k">new</span><span class="n">GroupNode</span><span class="p">(</span><span class="n">n</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;&gt;</span><span class="n">_and</span><span class="p">=</span><span class="n">Binary</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="s">"and"</span><span class="p">).</span><span class="n">ThenReturn</span><span class="p">(</span><span class="n">JqlNodeType</span><span class="p">.</span><span class="n">And</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;&gt;</span><span class="n">_or</span><span class="p">=</span><span class="n">Binary</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="s">"or"</span><span class="p">).</span><span class="n">ThenReturn</span><span class="p">(</span><span class="n">JqlNodeType</span><span class="p">.</span><span class="n">Or</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;&gt;</span><span class="n">Binary</span><span class="p">(</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNodeType</span><span class="p">&gt;</span><span class="n">op</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;&gt;(</span><span class="n">type</span><span class="p">=&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="p">=&gt;</span><span class="k">new</span><span class="n">BinaryNode</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">type</span><span class="p">));</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">_expressionParser</span><span class="p">=</span><span class="n">ExpressionParser</span><span class="p">.</span><span class="n">Build</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">p</span><span class="p">=&gt;</span><span class="n">OneOf</span><span class="p">(</span><span class="n">_tag</span><span class="p">,</span><span class="n">Parenthesised</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="p">).</span><span class="n">AtLeastOnce</span><span class="p">().</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">JqlBuilder</span><span class="p">.</span><span class="n">Group</span><span class="p">),</span><span class="k">new</span><span class="na">[]</span><span class="p">{</span><span class="n">Operator</span><span class="p">.</span><span class="n">InfixL</span><span class="p">(</span><span class="n">_and</span><span class="p">),</span><span class="n">Operator</span><span class="p">.</span><span class="n">InfixL</span><span class="p">(</span><span class="n">_or</span><span class="p">)</span><span class="p">}</span><span class="p">).</span><span class="n">AtLeastOnce</span><span class="p">().</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">x</span><span class="p">=&gt;</span><span class="k">new</span><span class="n">QueryNode</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="k">public</span><span class="k">static</span><span class="n">QueryNode</span><span class="n">Parse</span><span class="p">(</span><span class="kt">string</span><span class="n">input</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">(</span><span class="n">QueryNode</span><span class="p">)</span><span class="n">_expressionParser</span><span class="p">.</span><span class="n">ParseOrThrow</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="p">}</span></code></pre></td></tr></tbody></table></div></div><p>Here we use a Pidgin helper called <code>ExpressionParser.Build</code> that handles a lot of the pain associated with parsing more complex expressions;</p><ul><li>Its first parameter takes a <code>Func&lt;Parser, Parser&gt;</code> that returns a parser that can be used for parsing individual terms in the expression. Here we say that we either accept a tag <em>or</em> something that matches any term defined here wrapped in parenthesis. This is important because it allows us to trivially handle recursion in the grammar.</li><li>Its second parameter takes an array of operators that can be applied to individual terms in the expression. We support <code>and</code> and <code>or</code> and we apply them using <a href="http://www.cs.man.ac.uk/~pjj/cs212/fix.html">infix</a> notation from the left-hand side of the expression. That means we that we treat <code>[a] and [b] or [c]</code> as <code>([a] and [b]) or [c]</code> rather than <code>[a] and ([b] or [c])</code>.</li><li>Our <code>and</code> and <code>or</code> parsers are defined as functions that take previously parsed <code>JqlNode</code> objects and combine them into <code>BinaryNode</code> objects with the correct operator.</li></ul><p>That’s it - we can throw input at this thing and it’ll be parsed to its equivalent AST representation.</p><p>But that’s not the end of the tale, we have a grammar that works well for <em>expected</em> input, but production web apps end up encountering all kinds of random junk… How do we make our parser resilient to this kind of input?</p><h2 id="handling-bad-input">Handling Bad Input</h2><p>We’ve seen all kinds of nonsense make its way into job search. Sometimes it’s typos, other times it’s malicious input. We <em>could</em> just return a HTTP <code>400 Bad Request</code> with details of where in the input we failed but we can generally pull something useful enough out of the input to run a query against the backend, so why not do so?</p><p>Our most common fallback is to treat anything we don’t really understand as just a text query. It’s a reasonable fallback - we pass the text to Elastic and it works out any relevant terms. This means we return results and users generally adjust their query, possibly correcting syntactic mistakes, if the results don’t seem to be that useful.</p><p>However, there are a couple of cases where the parser can become confused. For example <code>[c#] and ([sql-server] or)</code> will break the parser - it doesn’t know how to handle the trailing <code>or</code> because it interprets it as part of a binary expression. This is essentially an implementation detail of Pidgin’s <code>ExpressionParser</code> that we need to work around - notably that it starts parsing by evaluating the list of terms we provided and when it successfully parses a term it starts to parse the operators. Once it is parsing the operator it does not have the ability to backtrack again so the trailing <code>or</code> is <em>always</em> treated as an operator. To workaround this we explicitly handle a trailing binary operator followed by a bracket and treat it as a JQL <code>TextNode</code>:</p><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span><span class="k">class</span><span class="nc">JqlParser</span><span class="p">{</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">Unit</span><span class="p">&gt;</span><span class="n">_validTerminators</span><span class="p">=</span><span class="n">Lookahead</span><span class="p">(</span><span class="n">_rparen</span><span class="p">.</span><span class="n">ThenReturn</span><span class="p">(</span><span class="n">Unit</span><span class="p">.</span><span class="n">Value</span><span class="p">)</span><span class="p">).</span><span class="n">Or</span><span class="p">(</span><span class="n">EndOfLine</span><span class="p">);</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">_trailingAnd</span><span class="p">=</span><span class="n">Try</span><span class="p">(</span><span class="n">_and</span><span class="p">.</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">JqlBuilder</span><span class="p">.</span><span class="n">Text</span><span class="p">).</span><span class="n">Before</span><span class="p">(</span><span class="n">_validTerminators</span><span class="p">)</span><span class="p">);</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">_trailingOr</span><span class="p">=</span><span class="n">Try</span><span class="p">(</span><span class="n">_or</span><span class="p">.</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">JqlBuilder</span><span class="p">.</span><span class="n">Text</span><span class="p">).</span><span class="n">Before</span><span class="p">(</span><span class="n">_validTerminators</span><span class="p">)</span><span class="p">);</span><span class="k">private</span><span class="k">static</span><span class="k">readonly</span><span class="n">Parser</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;</span><span class="n">_expressionParser</span><span class="p">=</span><span class="n">ExpressionParser</span><span class="p">.</span><span class="n">Build</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">p</span><span class="p">=&gt;</span><span class="n">OneOf</span><span class="p">(</span><span class="n">_trailingAnd</span><span class="p">,</span><span class="n">_trailingOr</span><span class="p">,</span><span class="n">_tag</span><span class="p">,</span><span class="n">Parenthesised</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="p">).</span><span class="n">AtLeastOnce</span><span class="p">().</span><span class="n">Select</span><span class="p">&lt;</span><span class="n">JqlNode</span><span class="p">&gt;(</span><span class="n">JqlBuilder</span><span class="p">.</span><span class="n">Group</span><span class="p">),</span><span class="k">new</span><span class="na">[]</span><span class="p">{</span><span class="n">Operator</span><span class="p">.</span><span class="n">InfixL</span><span class="p">(</span><span class="n">_and</span><span class="p">),</span><span class="n">Operator</span><span class="p">.</span><span class="n">InfixL</span><span class="p">(</span><span class="n">_or</span><span class="p">)</span><span class="p">}</span><span class="p">).</span><span class="n">Many</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="n">x</span><span class="p">=&gt;</span><span class="k">new</span><span class="n">QueryNode</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="p">}</span></code></pre></td></tr></tbody></table></div></div><h2 id="performance">Performance</h2><p>So, how does our Pidgin-based parser perform compared to the hand-rolled implementation we used previously? Here’s a benchmark for a few representative cases:</p><ul><li>Complex - <code>[c#] and ([sql-server] or [oracle]) -[php] remote:true</code></li><li>Empty - an empty search</li><li>Invalid - an invalid search</li><li>Text - <code>full stack developer</code></li><li>Modifiers - <code>remote:true</code></li></ul><div class="highlight"><div class="chroma"><table class="lntable"><tbody><tr><td class="lntd"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="na">BenchmarkDotNet</span><span class="o">=</span><span class="s">v0.11.4, OS=Windows 10.0.17763.437 (1809/October2018Update/Redstone5)</span><span class="na">Intel Core i9-9900K CPU 3.60GHz, 1 CPU, 16 logical and 8 physical cores</span><span class="na">[Host]     : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3362.0</span><span class="na">DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3362.0</span></code></pre></td></tr></tbody></table></div></div><table><thead><tr><th>Method</th><th>query</th><th align="right">Mean</th><th align="right">Error</th><th align="right">StdDev</th><th align="right">Ratio</th><th align="right">RatioSD</th><th align="right">Gen 0/1k Op</th><th align="right">Gen 1/1k Op</th><th align="right">Gen 2/1k Op</th><th align="right">Allocated Memory/Op</th></tr></thead><tbody><tr><td><strong>JqlParser_HandRolled</strong></td><td><strong>Complex</strong></td><td align="right"><strong>12,874.49 ns</strong></td><td align="right"><strong>62.1052 ns</strong></td><td align="right"><strong>55.0546 ns</strong></td><td align="right"><strong>1.00</strong></td><td align="right"><strong>0.00</strong></td><td align="right"><strong>1.9836</strong></td><td align="right"><strong>0.0153</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>12528 B</strong></td></tr><tr><td>JqlParser_Pidgin</td><td>Complex</td><td align="right">25,961.08 ns</td><td align="right">91.6681 ns</td><td align="right">76.5470 ns</td><td align="right">2.02</td><td align="right">0.01</td><td align="right">1.0071</td><td align="right">-</td><td align="right">-</td><td align="right">6544 B</td></tr><tr><td></td><td></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td><strong>JqlParser_HandRolled</strong></td><td><strong>Empty</strong></td><td align="right"><strong>302.70 ns</strong></td><td align="right"><strong>1.1613 ns</strong></td><td align="right"><strong>1.0863 ns</strong></td><td align="right"><strong>1.00</strong></td><td align="right"><strong>0.00</strong></td><td align="right"><strong>0.1025</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>648 B</strong></td></tr><tr><td>JqlParser_Pidgin</td><td>Empty</td><td align="right">96.39 ns</td><td align="right">0.7613 ns</td><td align="right">0.7121 ns</td><td align="right">0.32</td><td align="right">0.00</td><td align="right">0.0088</td><td align="right">-</td><td align="right">-</td><td align="right">56 B</td></tr><tr><td></td><td></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td><strong>JqlParser_HandRolled</strong></td><td><strong>Invalid</strong></td><td align="right"><strong>3,881.28 ns</strong></td><td align="right"><strong>22.3465 ns</strong></td><td align="right"><strong>20.9030 ns</strong></td><td align="right"><strong>1.00</strong></td><td align="right"><strong>0.00</strong></td><td align="right"><strong>0.4883</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>3096 B</strong></td></tr><tr><td>JqlParser_Pidgin</td><td>Invalid</td><td align="right">9,201.01 ns</td><td align="right">43.5177 ns</td><td align="right">40.7065 ns</td><td align="right">2.37</td><td align="right">0.02</td><td align="right">0.3204</td><td align="right">-</td><td align="right">-</td><td align="right">2136 B</td></tr><tr><td></td><td></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td><strong>JqlParser_HandRolled</strong></td><td><strong>Modifiers</strong></td><td align="right"><strong>3,633.93 ns</strong></td><td align="right"><strong>16.8197 ns</strong></td><td align="right"><strong>14.9102 ns</strong></td><td align="right"><strong>1.00</strong></td><td align="right"><strong>0.00</strong></td><td align="right"><strong>0.4692</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>2968 B</strong></td></tr><tr><td>JqlParser_Pidgin</td><td>Modifiers</td><td align="right">8,010.70 ns</td><td align="right">61.3875 ns</td><td align="right">47.9273 ns</td><td align="right">2.20</td><td align="right">0.02</td><td align="right">0.3052</td><td align="right">-</td><td align="right">-</td><td align="right">1984 B</td></tr><tr><td></td><td></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr><tr><td><strong>JqlParser_HandRolled</strong></td><td><strong>Text</strong></td><td align="right"><strong>6,395.75 ns</strong></td><td align="right"><strong>24.5107 ns</strong></td><td align="right"><strong>22.9273 ns</strong></td><td align="right"><strong>1.00</strong></td><td align="right"><strong>0.00</strong></td><td align="right"><strong>0.8392</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>-</strong></td><td align="right"><strong>5328 B</strong></td></tr><tr><td>JqlParser_Pidgin</td><td>Text</td><td align="right">11,221.87 ns</td><td align="right">66.0639 ns</td><td align="right">55.1664 ns</td><td align="right">1.75</td><td align="right">0.01</td><td align="right">0.4730</td><td align="right">-</td><td align="right">-</td><td align="right">3032 B</td></tr></tbody></table><p>There are some interesting results! We can see that Pidgin allocates less but that our implementation is faster. However, we’re talking on the order of microseconds here which, in the context of a request that takes ~30ms, is nothing <em>and</em> we haven’t performed any optimization of the Pidgin implementation just yet. Also, it’s worth noting that we don’t <em>parse</em> that many things - only around 0.5% of our daily traffic needs to be run through a parser in the first place - I’ll detail more about the why of that next time.</p><p>I think we’ll likely put the Pidgin version into production in the coming weeks - it drastically reduces the line count future developers have to understand and maintain without a significant impact on our performance.</p><h2 id="next-time">Next Time…</h2><p>Next time we’ll look into how we can use our AST to do useful things like pre-processing queries prior to sending them to Elastic and how we perform the translation into something Elastic understands!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>