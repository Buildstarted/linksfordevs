<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Isogeny crypto -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Isogeny crypto</h1>
    <div id="post-1314" class="post-1314 post type-post status-publish format-standard hentry category-uncategorized"> <div class="entry-content"> <p>A long time ago, when pairing-based cryptography was new, cryptographers who did not fully understand the mathematics of pairings would sometimes make mistakes. They would assume that everything that can be done with discrete logarithms could also be done with pairings. Unfortunately, this would sometimes result in protocols that were insecure, or else un-implementable.</p>
<p>Indeed, such cases apparently still happen:</p>
<div class="embed-twitter">
<blockquote class="twitter-tweet">
<p>PSA: in BLS sigs, hash to G1/G2 by hashing the message and multiplying by the generator is not secure.</p>
<p>With a signature s=k*H(m1)*g, I can transform it into a signature for m2 with H(m2)*H(m1)^(-1)*s.</p>
<p>Have noticed a few (non production) libraries doing that.</p>
<p>&#x2014; Kobi Gurkan (@kobigurk) <a href="https://twitter.com/kobigurk/status/1186915493195780097?ref_src=twsrc%5Etfw">October 23, 2019</a></p></blockquote>
</div>
<p>This situation is natural whenever a crypto tool that is technically subtle (and crypto tools <b>always</b> have technical subtleties) moves from &#x201C;niche&#x201D; into the mainstream. However it can result in incorrect schemes being published, for example because there are not enough experts to review all the papers.</p>
<p>Back in 2006, in response to those issues in pairing-based crypto, Kenny Paterson, Nigel Smart and I wrote the paper <a href="https://eprint.iacr.org/2006/165">Pairings for Cryptographers</a>. The abstract read:</p>
<p><q><i>Many research papers in pairing based cryptography treat pairings as a &#x201C;black box&#x201D;. These papers build cryptographic schemes making use of various properties of pairings. If this approach is taken, then it is easy for authors to make invalid assumptions concerning the properties of pairings. The cryptographic schemes developed may not be realizable in practice, or may not be as efficient as the authors assume. The aim of this paper is to outline, in as simple a fashion as possible, the basic choices that are available when using pairings in cryptography. For each choice, the main properties and efficiency issues are summarized. The paper is intended to be of use to non-specialists who are interested in using pairings to design cryptographic schemes.</i></q></p>
<p>This abstract exhibits the particular style of understated writing that is cultivated by British people. What we really meant was: <i>Please read this and stop screwing up.</i></p>
<p>Rolling forward 15 years, isogeny-based cryptography is another area with many technical subtleties, but is moving into the mainstream of cryptography. Once again, not everything that can be done with discrete logarithms can necessarily be done with isogenies. It is therefore not surprising to find papers that have issues with their security. </p>
<p>It is probably time for an <i>Isogenies for Cryptographers</i> paper, but I don&#x2019;t have time to write it. Instead, in this blog post I will mention several recent examples of incorrect papers. My hope is that these examples are instructional and will help prevent future mistakes. My intention is not to bring shame upon the authors.</p>
<ul>
<li> In 2014, D. Jao and V. Soukharev proposed an isogeny-based undeniable signature scheme. The security analysis of their scheme required the introduction of some computational problems in isogenies. Recently, S.-P. Merz, R. Minko and C. Petit <a href="https://eprint.iacr.org/2019/950">Another look at some isogeny hardness assumptions</a> have broken the computational assumptions and formulated attacks on the scheme.
<p>In this case, there is no reason for the original authors to be embarrassed. There has been considerable progress in isogeny crypto in the last 5 years, and it is natural that new cryptanalytic tools would become available that could break earlier schemes.</p>
</li><li> Several papers, including <a href="https://eprint.iacr.org/2017/774">this one</a>, have argued that a certain decisional assumption related to the SIDH isogeny cryptosystem should be hard.
<p>Without going into all the details, in SIDH there is a base curve <img src="https://s0.wp.com/latex.php?latex=E&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="E" class="latex"> and four points <img src="https://s0.wp.com/latex.php?latex=P_A%2C+Q_A%2C+P_B%2C+Q_B&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="P_A, Q_A, P_B, Q_B" class="latex"> on it. An SIDH instance includes a triple <img src="https://s0.wp.com/latex.php?latex=%28E_A%2C+%5Cphi_A%28P_B%29%2C+%5Cphi_A%28Q_B%29%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="(E_A, \phi_A(P_B), \phi_A(Q_B))" class="latex"> where <img src="https://s0.wp.com/latex.php?latex=%5Cphi_A+%3A+E+%5Cto+E_A&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="\phi_A : E \to E_A" class="latex"> is an isogeny of degree <img src="https://s0.wp.com/latex.php?latex=2%5En&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="2^n" class="latex">. One of the basic computational problems is to compute <img src="https://s0.wp.com/latex.php?latex=%5Cphi_A&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="\phi_A" class="latex"> when given this information.</p>
<p>The decisional assumption is to distinguish a valid triple <img src="https://s0.wp.com/latex.php?latex=%28E_A%2C+%5Cphi_A%28P_B%29%2C+%5Cphi_A%28Q_B%29%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="(E_A, \phi_A(P_B), \phi_A(Q_B))" class="latex"> from another triple <img src="https://s0.wp.com/latex.php?latex=%28E%27%2C+P%27%2C+Q%27%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="(E&apos;, P&apos;, Q&apos;)" class="latex"> where <img src="https://s0.wp.com/latex.php?latex=E%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="E&apos;" class="latex"> is a supersingular curve, and <img src="https://s0.wp.com/latex.php?latex=P%27%2C+Q%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="P&apos;, Q&apos;" class="latex"> are points satisfying various conditions.</p>
<p>At Provsec 2019, S. Terada and K. Yoneyama (&#x201C;Password-based Authenticated Key Exchange from Standard Isogeny Assumptions&#x201D;) proposed a password-based authenticated key exchange scheme for SIDH. The security against offline dictionary attacks was based on the hardness of a decision problem, but it was not the above decision problem. Instead, the security of the scheme under such an offline dictionary attack relies on the difficulty of distinguishing the triple <img src="https://s0.wp.com/latex.php?latex=%28E%27%2C+P%27%2C+Q%27%29&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="(E&apos;, P&apos;, Q&apos;)" class="latex"> from a uniformly random binary string of the same length. This problem is not hard at all since there are many properties that the valid triple should satisfy (e.g., <img src="https://s0.wp.com/latex.php?latex=E&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="E" class="latex"> is a supersingular elliptic curve, <img src="https://s0.wp.com/latex.php?latex=P%27%2C+Q%27+%5Cin+E%27&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="P&apos;, Q&apos; \in E&apos;" class="latex"> etc) which would not be satisfied by a uniformly chosen binary string. Hence the scheme in the paper is not secure against offline dictionary attacks.</p>
<p>It is actually a really interesting open question to fix this, related to compression of SIDH protocol messages. If one could compress SIDH protocol messages down to the minimum number of bits, then one might actually be able to argue that the protocol message is indistinguishable from a uniform binary string. I don&#x2019;t know any way to solve this problem and I think it is probably impossible. For the state-of-the-art in compression of SIDH messages see G. H. M. Zanon, M. A. Simplicio Jr, G. C. C. F. Pereira, J. Doliskani and P. S. L. M. Barreto, &#x201C;Faster key compression for isogeny-based cryptosystems&#x201D;.</p>
</li><li> A very natural and desirable feature is to be able to hash to an SIDH or CSIDH public key. Unfortunately this is hard. Really hard.
<p>D. Boneh and J. Love <a href="https://arxiv.org/abs/1910.03180">Supersingular Curves With Small Non-integer Endomorphisms</a> show, among other things, that it is hard to hash to SIDH public keys. W. Castryck, L. Panny and F. Vercauteren, <a href="https://eprint.iacr.org/2019/1202">Rational isogenies from irrational endomorphisms</a> show it is hard to hash to CSIDH.</p>
<p>It would be great if someone can solve one of these problems, but I think they are both hard. In the meantime, cryptographers should not assume that it is possible to hash to public keys/protocol messages. This also limits the possibility to transport some protocols from the discrete-log world into the isogeny world.</p>
</li><li> Due to the adaptive attacks on SIDH, one cannot get CCA1 or CCA2 secure encryption from SIDH without doing the Fujisaki-Okamoto transform (or something similar). Similarly, one cannot get non-interactive key exchange from SIDH. It is natural to try to get around this by some tweak to SIDH. R. Azarderakhsh, D. Jao and C. Leonardi gave a solution to this problem by running <img src="https://s0.wp.com/latex.php?latex=k&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="k" class="latex"> instances in parallel (e.g. for <img src="https://s0.wp.com/latex.php?latex=k+%3D+60&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="k = 60" class="latex">). S. Kayacan suggested two schemes that were hoped to be secure. However adaptive attacks have been shown in both schemes by my students and collaborators: </li><li> A. Fujioka, K. Takashima, S. Terada and K. Yoneyama proposed an authenticated key exchange scheme similar to some previous discrete-log-based schemes that required gap assumptions in the security proof. Gap assumptions are of the form: Problem X is hard, even when given an oracle to solve the decisional variant of problem X.
<p>For the isogeny context it is dangerous to use a gap assumption, as there are known arguments that one can reduce the computational isogeny problem to a decisional isogeny problem in certain cases. I already warned about this in the key exchange setting in <a href="https://eprint.iacr.org/2018/266">this note</a>. The solution of Fujioka et al was to introduce a &#x201C;degree-insensitive&#x201D; version of the problem, which is essentially to extend the protocol to <img src="https://s0.wp.com/latex.php?latex=%5Cell&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="\ell" class="latex">-isogeny chains of any length (rather than fixed length). It is an interesting idea.</p>
<p>However, my student S. Dobson and I have given evidence (see <a href="https://eprint.iacr.org/2019/929">On the Degree-Insensitive SI-GDH problem and assumption</a>) that the distribution of public keys in the degree insensitive case is close to uniform, and so it no longer makes sense to consider a gap problem. We do not have an attack on this protocol, but we conclude that the security proof is not correct. This shows again that one must be very careful to adapt ideas from discrete-log-based protocols into the isogeny setting.</p>
</li><li> S. Furukawa, N. Kunihiro and K. Takashima (&#x201C;Multi-party key exchange protocols from supersingular isogenies&#x201D;) proposed an isogeny variant of the Burmester-Desmedt protocol for <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="n" class="latex">-party key exchange in two rounds for any <img src="https://s0.wp.com/latex.php?latex=n&amp;bg=ffffff&amp;fg=333333&amp;s=0" alt="n" class="latex">. It is a nice paper, but Takashima (&#x201C;Post-Quantum Constant-Round Group Key Exchange from Static Assumptions&#x201D;) comments that:
<p><q><i>Furukawa et al. [14] proposed an isogeny-based BD-type GKE protocol called SIBD. However, the security proof of SIBD (Theorem 4 in [14]) is imperfect, and several points remain unclear, for example, on how to simulate some public variables.</i></q></p>
<p>Once again, the scheme is not broken (as far as I know), but the security argument is not correct. Takashima gives a new security analysis in his paper (but I have not had time to check it).
</p></li></ul>
<p>What can authors do to avoid the dangers of isogeny crypto? There are some very good surveys of the basic ideas behind isogenies (for example see <a href="https://arxiv.org/abs/1711.04062">Mathematics of Isogeny Based Cryptography</a> by Luca De Feo), but there is no good resource for cryptographers who want to use isogenies as a &#x201C;black box&#x201D;, and just want to know what is possible and what is not possible for building protocols. My best attempt so far is <a href="https://eprint.iacr.org/2018/266">this note</a>. In any case, I hope the present blog post can act as a cautionary tale: treating isogenies as a black box is risky!</p>
<p> &#x2014; Steven Galbraith</p> </div> <div class="entry-utility"> This entry was posted in <a href="https://ellipticnews.wordpress.com/category/uncategorized/">Uncategorized</a>. Bookmark the <a href="https://ellipticnews.wordpress.com/2019/11/09/isogeny-crypto/">permalink</a>. </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>