<!DOCTYPE html>
<html lang="en">
<head>
    <title>
.NET Core Counters internals: how to integrate counters in your monitoring pipeline - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content=".NET Core Counters internals: how to integrate counters in your monitoring pipeline - linksfor.dev(s)"/>
    <meta property="article:author" content="Christophe Nasarre"/>
    <meta property="og:description" content="This post shows how to easily get&#xA0;.NET Core counters. Their internals are also detailed for a better understanding of usage/limits"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@chnasarre/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - .NET Core Counters internals: how to integrate counters in your monitoring pipeline</title>
<div class="readable">
        <h1>.NET Core Counters internals: how to integrate counters in your monitoring pipeline</h1>
            <div>by Christophe Nasarre</div>
            <div>Reading time: 11-13 minutes</div>
        <div>Posted here: 23 Jul 2019</div>
        <p><a href="https://medium.com/@chnasarre/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e">https://medium.com/@chnasarre/net-core-counters-internals-how-to-integrate-counters-in-your-monitoring-pipeline-5354cd61b42e</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@chnasarre?source=post_page-----5354cd61b42e----------------------"><img alt="Christophe Nasarre" src="https://miro.medium.com/fit/c/96/96/0*p_afBNMUbL9S3Ojv" width="48" height="48"></a></p></div></div></div></div><p id="b743" data-selectable-paragraph="">This post of the series digs into the implementation details of the new .NET Core counters.</p><p id="ba2e" data-selectable-paragraph="">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" target="_blank" rel="noopener nofollow">Replace .NET performance counters by CLR event tracing</a>.</p><p id="2eaf" data-selectable-paragraph="">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" target="_blank" rel="noopener nofollow">Grab ETW Session, Providers and Events</a>.</p><p id="a70a" data-selectable-paragraph="">Part 3: <a href="http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/" target="_blank" rel="noopener nofollow">CLR Threading events with TraceEvent</a>.</p><p id="afdd" data-selectable-paragraph="">Part 4: <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de">Spying on .NET Garbage Collector with TraceEvent</a>.</p><p id="5fe1" data-selectable-paragraph="">Part 5: <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">Building your own Java GC logs in .NET</a></p><p id="3a6f" data-selectable-paragraph="">Part6: <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705">Spying on .NET Core Garbage Collector with .NET Core EventPipes</a></p><p id="354f" data-selectable-paragraph="">As explained in <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">a previous post</a>, <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">.NET Core 2.2 introduced</a> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-2.2" target="_blank" rel="noopener nofollow">EventListener class</a> to receive in-proc CLR events both on Windows and Linux. Starting with .NET Core 3.0 Preview 6, the <strong>EventPipe</strong>-based infrastructure makes it now possible to get these events from another process. The <a href="https://github.com/dotnet/diagnostics" target="_blank" rel="noopener nofollow">diagnostics repository</a> contains the cross-platform tools leveraging this infrastructure:</p><ul><li id="2a3b" data-selectable-paragraph=""><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-dump-instructions.md" target="_blank" rel="noopener nofollow"><strong>dotnet-dump</strong></a>: take memory snapshot and allow analysis based on most SOS commands</li><li id="b432" data-selectable-paragraph=""><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md" target="_blank" rel="noopener nofollow"><strong>dotnet-trace</strong></a>: collect events emitted by the Core CLR and generate trace file to be analyzed with Perfview</li><li id="3249" data-selectable-paragraph=""><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md" target="_blank" rel="noopener nofollow"><strong>dotnet-counters</strong></a>: collect the metrics corresponding to some performance counters that used to be exposed by the .NET Framework</li></ul><p id="ba4f" data-selectable-paragraph="">At Criteo, our metrics are exposed in Grafana dashboards and it is interesting to figure out how the new counters are implemented and see how to fetch them via the <strong>EventPipe</strong> infrastructure. With this knowledge in hand, I’ve implemented helpers to let you get counters in less than 10 lines of code:</p><figure><div></div></figure><p id="e913" data-selectable-paragraph="">At the end of this post you will be able to very easily integrate any counter to your own monitoring pipeline!</p><p id="f064" data-selectable-paragraph="">With .NET Core being cross-platform, performance counters were gone and, as explained in the previous posts of the series, CLR events were the only way to get metrics about how your .NET Core applications were behaving. However, with .NET Core 3.0, it is now possible to view a few metrics thanks to the <strong>dotnet-counters</strong> tool.</p><p id="dbec" data-selectable-paragraph="">You can download and install the tools automatically if you have installed .NET Core SDK 2.1+. Microsoft is currently working to provide other ways to directly download the tools binaries without having to install the SDK or recompile the diagnostics repository.</p><p id="33de" data-selectable-paragraph="">Use the following command line to install dotnet-counters:<br><code>dotnet tool install --global dotnet-counters --version 3.0.0-preview7.19365.2</code></p><p id="dd28" data-selectable-paragraph="">Note that you need to have the same version both for the Core CLR runtime and for the tools because, as you will soon see, the monitoring and the monitored applications are communicating via a dedicated protocol (that have changed between previews) on top of a transport layer different between Windows and Linux.</p><p id="4958" data-selectable-paragraph="">After the installation, use the following command line <code>dotnet counters monitor -p &lt;your application process id&gt;</code> and you get a 1 second auto-refreshed view of counters.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*tzmG5E7_XphPKWYrK_YNzg.png?q=20" width="423" height="362" role="presentation"></p><p><img width="423" height="362" role="presentation"></p></div></div></div></figure><p id="b84b" data-selectable-paragraph="">These counters are exposed by the <em>System.Runtime</em> provider and are detailed with the <code>list</code> argument:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*vpUJf51QchDMQh9GPlWbRA.png?q=20" width="914" height="340" role="presentation"></p><p><img width="914" height="340" role="presentation"></p></div></div></div></div></figure><p id="5888" data-selectable-paragraph="">This list is currently hard-coded in the <code><a href="https://github.com/dotnet/diagnostics/blob/master/src/Tools/dotnet-counters/KnownData.cs#L19" target="_blank" rel="noopener nofollow">CreateKnownProviders</a></code> method. However, you are free to create your own provider and expose your application metrics as shown in <a href="https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md" target="_blank" rel="noopener nofollow">this tutorial</a> (and in the next forthcoming post). In addition, if you are using ASP.NET Core, starting from Preview 7, then you could get a few counters from the “Microsoft.AspNetCore.Hosting” provider defined in <code><a href="https://github.com/aspnet/AspNetCore/blob/master/src/Hosting/Hosting/src/Internal/HostingEventSource.cs#L25" target="_blank" rel="noopener nofollow">HostingEventSource.cs</a></code>.</p><p id="94a2" data-selectable-paragraph="">Even though it is nice to have a console-based cross-platform tool to see the values of counters change, what would be the cost to get them into your own monitoring pipeline? For example, at Criteo, we are pushing our metrics to Graphite in order to get nice Grafana dashboards. These graphical representations allow us to have a visual representation of the evolution of metrics over time. In addition, it is also possible to define alerts based on threshold for some metrics values (when CPU &gt; 85% for more than 5 seconds for example).</p><p id="a576" data-selectable-paragraph="">In a nutshell, dotnet-counters tool is listening to another application via <strong>EventPipe</strong>. Unlike .NET Framework performance counters that are polled by the monitoring application, the counters are pushed by the monitored .NET Core process.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*SuOEY89mW73PiMJkgHZsng.png?q=20" width="840" height="327" role="presentation"></p><p><img width="840" height="327" role="presentation"></p></div></div></div></div></figure><p id="ee8d" data-selectable-paragraph="">In term of implementation, these counters are values that you could get via .NET internal or public APIs if you were running in-proc as shown <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Diagnostics/Eventing/RuntimeEventSource.cs#L47" target="_blank" rel="noopener nofollow">in RuntimeEventSource.cs</a>:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*NaWnrko0FZBfR1IPpzY0iw.png?q=20" width="927" height="530" role="presentation"></p><p><img width="927" height="530" role="presentation"></p></div></div></div></div></figure><p id="a4f5" data-selectable-paragraph="">Unlike most of the events that previous posts of this series presented, counters are metrics that are computed by the CLR in the monitored application. They are supposed to provide a set of values changing over time in the monitored application without impacting the performance nor flooding the listener client. I highly recommend to take a look at <a href="https://github.com/dotnet/diagnostics/issues/346" target="_blank" rel="noopener nofollow">this issue</a> for a deeper discussion about <strong>EventCounters</strong> compared to regular events.</p><p id="5acf" data-selectable-paragraph="">As of Preview 7, two types of counters are used:</p><ul><li id="1c95" data-selectable-paragraph=""><em>Mean</em>: supposed to contain a mean of all values during the polling interval with its min and max values. However, based on <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/PollingCounter.cs#L70" target="_blank" rel="noopener nofollow">the current implementation</a>, all contain only the current value.</li><li id="51c1" data-selectable-paragraph=""><em>Sum</em>: contains an increment between the previous value and the current one</li></ul><figure><div><div><div><p><img src="https://miro.medium.com/max/50/1*Qxhek7OZy1N-wfDNdKecpQ.png?q=20" width="450" height="530" role="presentation"></p><p><img width="450" height="530" role="presentation"></p></div></div></div></figure><p id="8d51" data-selectable-paragraph="">The question is now to figure out how to get the values of the counters.</p><p id="4b61" data-selectable-paragraph="">Like the Perfview tool that relies on <strong>TraceEvent</strong> library, dotnet-counters uses an API exposed by <strong>Microsoft.Diagnostics.Tools.RuntimeClient</strong> assembly. Note that it is currently <a href="https://github.com/dotnet/diagnostics/issues/343" target="_blank" rel="noopener nofollow">not (yet) available from nuget</a> so you need to recompile it with the <a href="https://github.com/dotnet/diagnostics/issues/343" target="_blank" rel="noopener nofollow">diagnostics git repo</a>.</p><p id="f7f2" data-selectable-paragraph="">To receive counters, you need to create an <strong>EventPipe</strong> session that communicates via IPC (named pipes on Windows and domain sockets on Linux) with the CLR of the monitored process. Here is an excerpt of the <code>CounterMonitor.StartMonitoring</code> <a href="https://github.com/dotnet/diagnostics/blob/master/src/Tools/dotnet-counters/CounterMonitor.cs#L177" target="_blank" rel="noopener nofollow">implementation</a> that connects and listens to counter events:</p><figure><div></div></figure><p id="1b40" data-selectable-paragraph="">The important method call is call is <code>EventPipeClient.CollectTracing()</code> that returns a <code>Stream</code> from which an <code>EventPipeEventSource</code> instance gets created. This class has been added to <strong>TraceEvent</strong> so you can now leverage the event parsing infrastructure on top of <strong>EventPipe</strong>! As shown in <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" target="_blank" rel="noopener nofollow">a previous post</a>, it is easy to attach a listener to the source <code>All</code> .NET event and get notified each time an event is received after the <code>Process</code> method is called.</p><p id="b780" data-selectable-paragraph="">A few parameters are given to <code>CollectTracing</code> via the <code>SessionConfiguration</code> object: the size of the circular buffer used by the CLR and no file path because we want a live session. The last one is supposed to filter which providers and counters you would like to listen to: it expects a list of <code>Provider</code> instances. This struct <a href="https://github.com/dotnet/diagnostics/blob/master/src/Microsoft.Diagnostics.Tools.RuntimeClient/Eventing/Provider.cs#L10" target="_blank" rel="noopener nofollow">is created with a few parameters</a>:</p><figure><div></div></figure><p id="6f65" data-selectable-paragraph="">As we have already mentioned, the name of the provider is “<em>System.Runtime</em>” for the Core CLR counters. The keywords and event level are expected to have these max values. The filter data string starts with “<em>EventCounterIntervalSec=</em>” followed by the refresh interval in seconds. Internally, the CLR in the monitored application <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/CounterGroup.cs#L135" target="_blank" rel="noopener nofollow">is creating a timer</a> with that frequency to push the counters via <strong>EventPipe</strong> (more on this later).</p><p id="cb86" data-selectable-paragraph="">Here is a helper class to easily create your providers:</p><figure><div></div></figure><p id="6ab2" data-selectable-paragraph="">Note that <code>dotnet-counters</code> allows you to pass a subset of the counters with the <em>System.Runtime[counter1,counter2,counter2]</em> syntax: events for all System.Runtime counters will be received but only these three will be displayed in the console.</p><p id="56b1" data-selectable-paragraph="">Next, the important part of the job takes place in the <code>EventSourc.All</code> event listener. Each new counter value is received in the payload of an event named “<em>EventCounters</em>”.</p><figure><div></div></figure><p id="8841" data-selectable-paragraph="">The <code>Name</code> and <code>DisplayName</code> values are self-explanatory. The <em>Sum</em>/<em>Mean</em> type is retrieved from <code>CounterType</code>.</p><p id="7f2b" data-selectable-paragraph="">The value for each counter type is retrieved from the payload with “Increment” (<em>Sum</em> type) or “Mean” (<em>Mean </em>type) keys.</p><figure><div></div></figure><p id="fb48" data-selectable-paragraph="">The <code>CounterMonitor</code> class has been added on my <a href="https://github.com/chrisnas/ClrEvents" target="_blank" rel="noopener nofollow">Github</a> to expose a <code>CounterUpdate</code> C# event when a counter event is received:</p><figure><div></div></figure><p id="cb01" data-selectable-paragraph="">The event argument contains the expected properties but other could be added if needed such as the timestamp for example:</p><figure><div></div></figure><p id="e15a" data-selectable-paragraph="">With these helpers in hand, it is easy to integrate any counter to your monitoring pipeline. As an example, let’s see how to generate a .csv file used to create visual representations in Excel.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*e68YXXlCXrL6kY7HYs-Jow.png?q=20" width="1429" height="520" role="presentation"></p><p><img width="1429" height="520" role="presentation"></p></div></div></div></div></figure><p id="b87a" data-selectable-paragraph="">With a refresh rate of 1 second, one line containing the value of the CLR counters should be added to the .csv file every second. Since we get one event per counter, we need to know which is the “last” counter event sent by the CLR for a given 1 second counters push.</p><p id="4ef0" data-selectable-paragraph="">As mentioned earlier the <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Diagnostics/Eventing/RuntimeEventSource.cs#L47" target="_blank" rel="noopener nofollow">RuntimeEventSource</a> class defines the CLR counters. Each one is an instance of a type derived from the <code>DiagnoticCounter</code> class that <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/DiagnosticCounter.cs#L45" target="_blank" rel="noopener nofollow">associates its instances</a> to a <code>CounterGroup</code> also bound to the <code>RuntimeEventSource</code>. The <code>CounterGroup</code> class will setup a repeating timer responsible for creating the payload for its <code>DiagnosticCounter</code>-derived instances and ask the event source to send each to the monitoring application via <strong>EventPipe</strong>.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*U2SXMs1uV4x36fdjH7nKiA.png?q=20" width="1328" height="447" role="presentation"></p><p><img width="1328" height="447" role="presentation"></p></div></div></div></div></figure><p id="586d" data-selectable-paragraph="">So we can rely on the order defined by the counters creation code in <code>RuntimeEventSource</code>: for a given push of counters, the name of the last one will be “<em>assembly-count</em>”. Beware that in a case of new counters (such as for ASP.NET Core), you would need to check what would be the last one of the counters series. Another way to work around would be to rely on the timestamps of each event but this could become flaky over time. It would have been great if a “<em>CounterSeries</em>”event containing the list of counter names would have been sent before any “<em>EventCounters</em>” of a series push (good idea for a pull request :^)</p><p id="09e2" data-selectable-paragraph="">The <code>CsvCounterListener</code> class wraps the few lines of code needed to handle the events and add a line into the .csv file each time a series of counters is received:</p><figure><div></div></figure><p id="0252" data-selectable-paragraph="">You have seen how easy it is to be notified of CLR counters update. The integration to your own monitoring system should not be more complicated. However, you need to pay attention to the meaning of counter types between <em>Mean </em>and <em>Sum</em>. For example, the value you get for <strong>gen-0-count</strong> (<em>Sum</em>) counters is a difference between now and the previous computation. It means that you can’t have the “current” number of gen 0 collection at a given time.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*XKDMcfmyoXAVetidWvYmcA.png?q=20" width="1435" height="523" role="presentation"></p><p><img width="1435" height="523" role="presentation"></p></div></div></div></div></figure><p id="38eb" data-selectable-paragraph="">This is not a problem in the Excel example because you can “rebuild” a column that will contain the “current” count based on the previous value + the diff returned by the counter.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*3klYCATjxMGhjb_NRcrSZA.png?q=20" width="371" height="229" role="presentation"></p><p><img width="371" height="229" role="presentation"></p></div></div></div></figure><p id="c983" data-selectable-paragraph="">Here is the resulting graph:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*a42c8gZoHWbMwKNBFSnsiA.png?q=20" width="1430" height="507" role="presentation"></p><p><img width="1430" height="507" role="presentation"></p></div></div></div></div></figure><p id="54c3" data-selectable-paragraph="">In other cases, you might need to feed your monitoring system with real count values and benefit from advanced charting such as non derivative computation to show a rate based on a series of values. At the end of the day, it is just a question of initial value from which rebuild a count. And if you think about it, you are often more interested in unexpected variations (i.e. differences returned by counters) when monitoring your application.</p><p id="7bd5" data-selectable-paragraph="">In addition to your business metrics, .NET Core Counters are usually enough to monitor the health of your applications. However, in order to investigate situations where counters value are showing weird results, you often need more details. For example spikes in garbage collections count might not be a problem if the pause time is not too long. Listening to specific CLR events as shown in previous posts of this series is a great way to unveil important metrics such as GC pause time, contentions duration or exception names without performance hit.</p><p id="76fa" data-selectable-paragraph="">The code available on <a href="https://github.com/chrisnas/ClrEvents" target="_blank" rel="noopener nofollow">Github</a> has been updated to provide the <code>CounterMonitor</code> and <code>CsvCounterListener</code> classes that demonstrates how to get .NET Core counters and generate .csv file usable in Excel.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>