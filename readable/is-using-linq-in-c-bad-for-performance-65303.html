<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Is Using LINQ in C# Bad for Performance? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Is Using LINQ in C# Bad for Performance? - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@jamesvickers19"/>
    <meta property="og:description" content="Short answer: not really."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/swlh/is-using-linq-in-c-bad-for-performance-318a1e71a732"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Is Using LINQ in C# Bad for Performance?</title>
<div class="readable">
        <h1>Is Using LINQ in C# Bad for Performance?</h1>
            <div>by https://medium.com/@jamesvickers19</div>
            <div>Reading time: 4-5 minutes</div>
        <div>Posted here: 06 Aug 2020</div>
        <p><a href="https://medium.com/swlh/is-using-linq-in-c-bad-for-performance-318a1e71a732">https://medium.com/swlh/is-using-linq-in-c-bad-for-performance-318a1e71a732</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article><section><div id="lo-highlight-meter-1-highlight-box"><div><div><h4><span id="lo-highlight-meter-1-copy">You have <b>2</b> free stories left this month. </span></h4></div></div></div></section><span></span><div><section><div><div><div><div><div><div><div><a rel="noopener" href="https://medium.com/@jamesvickers19?source=post_page-----318a1e71a732----------------------"><div><p><img alt="James Vickers" src="https://miro.medium.com/fit/c/96/96/2*D1XQUz_7Rn8q7_767XhONA.jpeg" width="48" height="48"></p></div></a></div></div></div></div></div><p id="3bf0" data-selectable-paragraph="">LINQ (Language INtegrated Query) is a set of features in C# for concise and declarative code. I use it pretty much wherever I can, but sometimes I wonder and people ask: is this a performance trap? It would be painful to have to replace many usages of LINQ with other constructs in addition to time spent finding that to be an actual bottleneck. Let’s do a basic benchmark to see what using LINQ might cost us compared to more traditional constructs such as for and foreach loops, and see if this worry is valid.</p><p id="c87f" data-selectable-paragraph="">I used the <a href="https://github.com/dotnet/BenchmarkDotNet" target="_blank" rel="noopener nofollow">BenchmarkDotNet</a> library. The experiment code can be found <a href="https://github.com/jamesvickers19/dotnet-linq-benchmarks" target="_blank" rel="noopener nofollow">here</a>. All benchmarks are of functions that operate on Customer arrays, where a Customer is an immutable struct with an int Age and a string Name. Note that these methods would normally be parameterized, taking the Customer array as an argument; however it is easier to use BenchmarkDotNet with methods that take no arguments.</p><p id="5d3d" data-selectable-paragraph="">I ran these benchmarks on my laptop, which is a 2020 Dell Inspiron 5591 2-in-1 with Intel Core i5–10210U, 16GB RAM (8GB original, 8GB DDR4–3200 from Crucial), running Windows 10 Home 1909. The code runs on .NET Core 3.1. BenchmarkDotNet runs each experiment — in this case a unique size and implementation — 100 times and measures statistics on those runs. All line charts comparing implementations are of the average run time across those runs.</p><p id="0a35" data-selectable-paragraph="">Each implementation returns the number of Customer’s in the array that have an age under 18 (that is, are minors). Baseline implementations using for/foreach:</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*rhOBE_oHOxAM4fyYM4aFfg.png?q=20" width="1333" height="511"></p><p><img alt="Image for post" width="1333" height="511" src="https://miro.medium.com/max/1333/1*rhOBE_oHOxAM4fyYM4aFfg.png" srcset="https://miro.medium.com/max/276/1*rhOBE_oHOxAM4fyYM4aFfg.png 276w, https://miro.medium.com/max/552/1*rhOBE_oHOxAM4fyYM4aFfg.png 552w, https://miro.medium.com/max/640/1*rhOBE_oHOxAM4fyYM4aFfg.png 640w, https://miro.medium.com/max/700/1*rhOBE_oHOxAM4fyYM4aFfg.png 700w" sizes="700px"></p></div></div></div></div></figure><p id="05ec" data-selectable-paragraph="">…and two using LINQ Count:</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*87skhqUXXFh75XiLoOiQDw.png?q=20" width="1275" height="39"></p><p><img alt="Image for post" width="1275" height="39" src="https://miro.medium.com/max/1275/1*87skhqUXXFh75XiLoOiQDw.png" srcset="https://miro.medium.com/max/276/1*87skhqUXXFh75XiLoOiQDw.png 276w, https://miro.medium.com/max/552/1*87skhqUXXFh75XiLoOiQDw.png 552w, https://miro.medium.com/max/640/1*87skhqUXXFh75XiLoOiQDw.png 640w, https://miro.medium.com/max/700/1*87skhqUXXFh75XiLoOiQDw.png 700w" sizes="700px"></p></div></div></div></div></figure><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*BrwGuT9wls-77qQ0tfvzTg.png?q=20" width="1363" height="44"></p><p><img alt="Image for post" width="1363" height="44" src="https://miro.medium.com/max/1363/1*BrwGuT9wls-77qQ0tfvzTg.png" srcset="https://miro.medium.com/max/276/1*BrwGuT9wls-77qQ0tfvzTg.png 276w, https://miro.medium.com/max/552/1*BrwGuT9wls-77qQ0tfvzTg.png 552w, https://miro.medium.com/max/640/1*BrwGuT9wls-77qQ0tfvzTg.png 640w, https://miro.medium.com/max/700/1*BrwGuT9wls-77qQ0tfvzTg.png 700w" sizes="700px"></p></div></div></div></div></figure></div></div><div><div><div><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*eFpsH2X9y6JC5jIWf0VxbQ.png?q=20" width="1562" height="684"></p><p><img alt="Image for post" width="1562" height="684" src="https://miro.medium.com/max/1562/1*eFpsH2X9y6JC5jIWf0VxbQ.png" srcset="https://miro.medium.com/max/276/1*eFpsH2X9y6JC5jIWf0VxbQ.png 276w, https://miro.medium.com/max/552/1*eFpsH2X9y6JC5jIWf0VxbQ.png 552w, https://miro.medium.com/max/640/1*eFpsH2X9y6JC5jIWf0VxbQ.png 640w, https://miro.medium.com/max/728/1*eFpsH2X9y6JC5jIWf0VxbQ.png 728w, https://miro.medium.com/max/816/1*eFpsH2X9y6JC5jIWf0VxbQ.png 816w, https://miro.medium.com/max/904/1*eFpsH2X9y6JC5jIWf0VxbQ.png 904w, https://miro.medium.com/max/992/1*eFpsH2X9y6JC5jIWf0VxbQ.png 992w, https://miro.medium.com/max/1000/1*eFpsH2X9y6JC5jIWf0VxbQ.png 1000w" sizes="1000px"></p></div></div></div></div></figure></div></div></div><div><div><p id="2cf5" data-selectable-paragraph="">The LINQ implementation using Select and then Count with no arguments has a similar slope plus a small overhead penalty compared to for/foreach (overlaid on the graph because they’re so close). However the LINQ implementation using Count that takes a predicate function on the elements has a significant performance penalty and the slope of the graph is much steeper. This was a surprising result to me.</p><p id="99fe" data-selectable-paragraph="">Each implementation returns a list of Customer’s that is a subset of the Customer array of those have an age over 18 (that is, are not minors). Baseline implementations using for/foreach:</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*A6iozpWa_9yz2Tm3F-RZ7w.png?q=20" width="1616" height="552"></p><p><img alt="Image for post" width="1616" height="552"></p></div></div></div></div></figure><p id="e9b0" data-selectable-paragraph="">…and one using LINQ Where:</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*_9VshHVfYclrfRaP3jSgDw.png?q=20" width="1390" height="30"></p><p><img alt="Image for post" width="1390" height="30"></p></div></div></div></div></figure></div></div><div><div><div><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*jpPPT8JLAt6DDEcI6P9zBA.png?q=20" width="1575" height="718"></p><p><img alt="Image for post" width="1575" height="718"></p></div></div></div></div></figure></div></div></div><div><div><p id="3b42" data-selectable-paragraph="">This benchmark has LINQ posting very similar performance to implementations using for/foreach; he slopes are almost identical with LINQ showing an overhead. At 3M elements, the LINQ implementation takes about 4 milliseconds longer than for/foreach.</p><p id="12d7" data-selectable-paragraph="">Each implementation returns a list of Customer’s that are the same as the original customers but with Age represented as months instead of years. Baseline implementations using for/foreach:</p></div></div><div><div><div><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*sYW7QQ8_nA9Oz6YS965UGQ.png?q=20" width="2054" height="396"></p><p><img alt="Image for post" width="2054" height="396"></p></div></div></div></div></figure></div></div></div><div><div><p id="e914" data-selectable-paragraph="">and one using LINQ Select:</p><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*UiIkNht9-DhXNDG3IIQbZQ.png?q=20" width="1331" height="32"></p><p><img alt="Image for post" width="1331" height="32"></p></div></div></div></div></figure></div></div><div><div><div><figure><div><div><div><div><p><img alt="Image for post" src="https://miro.medium.com/max/60/1*uSc7IAso299RGpfdlgRczA.png?q=20" width="1453" height="721"></p><p><img alt="Image for post" width="1453" height="721"></p></div></div></div></div></figure></div></div></div><div><div><p id="9520" data-selectable-paragraph="">Performance for these 3 variants is nearly identical.</p><p id="bc14" data-selectable-paragraph="">It would seem the performance of LINQ is similar to more basic constructs in C#, except for that notable case where Count was significantly slower. If performance is important it’s crucial to do benchmarks on your application rather than relying on anecdotes (including this one).</p><p id="2fe9" data-selectable-paragraph="">Given that LINQ may introduce performance overhead into your code, what’s the upside of using it? This has been discussed plenty but here’s my take:</p><ul><li id="afdd" data-selectable-paragraph=""><strong>Conciseness:</strong> all of the examples here turned a method of a few lines into a short and readable expression</li><li id="3fb4" data-selectable-paragraph=""><strong>Functional data-flow style: </strong>composable, flexible, easy to understand</li><li id="c213" data-selectable-paragraph=""><strong>Parallelization:</strong> just change it to use <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq" target="_blank" rel="noopener nofollow">PLINQ</a> by adding a call to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.asparallel?view=netcore-3.1" target="_blank" rel="noopener nofollow">AsParallel()</a><em>.</em></li></ul><p id="cbe0" data-selectable-paragraph="">The only disadvantage I’ve found with using LINQ is sometimes it can make debugging more difficult. More than once I’ve found myself temporarily converting a piece of code to not use LINQ so I can figure out what’s wrong with it. LINQ can also impede inspecting values in the debugger when they are an Enumerable instead of an array or list (this isn’t specific to LINQ, just more common when using it).</p><p id="d26a" data-selectable-paragraph="">I suggest we reap the benefits of using LINQ and focus on bigger things; the timing differences in these experiments are dwarfed by applications doing things like network I/O that would be a better target of our optimization efforts.</p></div></div></section></div></article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>