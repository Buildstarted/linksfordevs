<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Final Tagless seen alive - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Final Tagless seen alive - linksfor.dev(s)"/>
    <meta property="article:author" content="Adam Warski"/>
    <meta property="og:description" content="If you follow the Scala community, you&#x2019;ve probably heard about John de Goes&#x2019;s talk &#x201C;Death of Final Tagless&#x201D;. If you haven&#x2019;t, no worries &#x2014;&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.softwaremill.com/final-tagless-seen-alive-79a8d884691d"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Final Tagless seen alive</title>
<div class="readable">
        <h1>Final Tagless seen alive</h1>
            <div>by Adam Warski</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 05 Mar 2019</div>
        <p><a href="https://blog.softwaremill.com/final-tagless-seen-alive-79a8d884691d">https://blog.softwaremill.com/final-tagless-seen-alive-79a8d884691d</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><div><div><div><div><p><a href="https://blog.softwaremill.com/@adamwarski?source=post_page-----79a8d884691d----------------------" rel="noopener"><img alt="Adam Warski" src="https://miro.medium.com/fit/c/96/96/1*ibvO_EVklp97exBsutE5yQ.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="6ebc" data-selectable-paragraph="">If you follow the Scala community, you’ve probably heard about John de Goes’s talk “Death of Final Tagless”. If you haven’t, no worries — it’s available online both <a href="https://skillsmatter.com/skillscasts/13247-scala-matters" target="_blank" rel="noopener">as a video</a> &amp; <a href="http://degoes.net/articles/zio-environment" target="_blank" rel="noopener">a blog post</a> — and I definitely recommend watching it. The talk starts with a gentle and very clearly presented motivation on why to use functional effects in the first place. It shows that John is an experienced teacher! But more than that, it’s one of those talks which make you rethink some of the fashions in our industry and assumptions you’ve held so far.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*rlC5OMHZosED6-YJ3x46OA.png?q=20" width="2224" height="1668" role="presentation"></p><p><img width="2224" height="1668" role="presentation"></p></div></div></div></div></figure><p id="74c2" data-selectable-paragraph="">The talk contains a fair amount of critique of the so-called “Final Tagless” encoding. However, this construct can be used for two purposes: <strong>constraining effect wrappers</strong> and <strong>tracking effects in detail</strong>. In John’s talk these are covered together, but they deserve separate treatment and separate criticism.</p><p id="3792" data-selectable-paragraph="">As John mentions in the beginning of his talk, the idea of “programming to an interface” (rather than to a concrete implementation) is well-understood and used pervasively in languages such as Java and Scala. I think we’re all used to defining the interface of a service, and making our code dependent on <strong>some</strong> implementation of that interface.</p><p id="9a00" data-selectable-paragraph="">Repeating John’s <code>Console</code> example, we start with a side-effecting version, where the console service is passed as a constructor parameter to its usage site:</p><pre><span id="727b" data-selectable-paragraph="">trait Console {<br>  def putStrLn(line: String): Unit<br>  def getStrLn: String<br>}</span><span id="6564" data-selectable-paragraph="">object LiveConsole extends Console {<br>  def putStrLn(line: String): Unit = println(line)<br>  def getStrLn: String = scala.io.StdIn.readLine()<br>}</span><span id="173b" data-selectable-paragraph="">class Main(console: Console) {<br>  def run(): String = {<br>    console.putStrLn("Good morning, what’s your name?")<br>    val name = console.getStrLn<br>    console.putStrLn(s"Great to meet you, $name")<br>    name<br>  }<br>}</span></pre><p id="0c19" data-selectable-paragraph="">The first step to improve this code is to introduce some control over side effects, by wrapping them in an <code>IO</code> datatype. This is well motivated both in John’s talk and on <a href="https://typelevel.org/cats-effect/datatypes/io.html#introduction" target="_blank" rel="noopener">various</a> <a target="_blank" rel="noopener" href="https://blog.softwaremill.com/synchronous-or-asynchronous-and-why-wrestle-with-wrappers-2c5667eb7acf">other</a> <a href="https://medium.com/@sderosiaux/are-scala-futures-the-past-69bd62b9c001" target="_blank" rel="noopener">blogs</a>, so I won’t repeat the argument here. We end up with the following code:</p><pre><span id="4361" data-selectable-paragraph="">trait Console {<br>  def putStrLn(line: String): IO[Unit]<br>  def getStrLn: IO[String]<br>}</span><span id="2ee5" data-selectable-paragraph="">object LiveConsole extends Console {<br>  def putStrLn(line: String): IO[Unit] = IO.effect(println(line))<br>  def getStrLn: IO[String] = IO.effect(scala.io.StdIn.readLine())<br>}</span><span id="84a1" data-selectable-paragraph="">class Main(console: Console) {<br>  def run(): IO[String] = {<br>    for {<br>      _    &lt;- console.putStrLn("Good morning, what’s your name?")<br>      name &lt;- console.getStrLn<br>      _    &lt;- console.putStrLn(s"Great to meet you, $name")<br>    } yield name<br>  }<br>}</span></pre><p id="fac3" data-selectable-paragraph="">Note that our <code>Main.run</code> method now builds a data structure which <strong>describes</strong> effectful operations. Side-effects are contained, we can clearly see which methods have side effects (the ones that use <code>IO</code>) and which don’t, and we can use the <code>IO</code> values without fear in a referentially-transparent way.</p><p id="3569" data-selectable-paragraph="">So far so good; no Final Tagless in sight!</p><p id="2e27" data-selectable-paragraph="">Can we improve further? Well, the <code>IO</code> datatype is quite rich. It can describe sequential computations, wrap side effects, run computations in parallel, race two computations nondeterministically, etc. We might want to restrict this to know — just by looking at the signature of a method or class — what kind of operations can be performed on our chosen side-effects wrapper.</p><p id="68ee" data-selectable-paragraph="">The problem here is that we are using a <strong>concrete</strong> implementation of <code>IO</code>, instead of programming to an interface! Let’s fix this. We need to somehow express that our code is dependent on a wrapper with a specific interface, instead of using a concrete implementation. We’ll start by parametrising our interface with “some” abstract wrapper which we will call <code>F</code>:</p><pre><span id="893d" data-selectable-paragraph="">trait Console[F[_]] {<br>  def putStrLn(line: String): F[Unit]<br>  def getStrLn: F[String]<br>}</span></pre><p id="faf2" data-selectable-paragraph="">In <code>LiveConsole</code> and <code>Main</code> we are interacting with the <code>F</code> wrapper by calling methods on it (e.g. <code>flatMap</code> in <code>Main.run</code>’s <code>for</code>-comprehension), so we need something more: a way to express the fact the the <code>F</code> should support a given set of methods. We’ll do this by introducing a dependency to <code>LiveConsole</code> and <code>Main</code>.</p><p id="e8ee" data-selectable-paragraph="">However, working with an effect wrapper (either abstract or concrete) is quite different from working with a regular service. Hence, we are going to introduce that dependency in a way which makes it easy to work with.</p><p id="9d35" data-selectable-paragraph="">In Scala, this is done by adding an implicit parameter (instead of a regular one) which <strong>gives capabilities </strong>to the <code>F</code> effect wrapper. This is then used by extension methods, which are available on a type, if a specific implicit value is in scope.</p><p id="379f" data-selectable-paragraph="">What kind of dependencies do we need to introduce? For <code>Main</code>, we only need <strong>sequential composition</strong>: describing an operation which first runs one effectful computation, and then a second one. This is what a <code>Monad</code> gives us. For <code>LiveConsole</code>, we need a way of <strong>wrapping side-effecting</strong> computations. This is what <code><a href="https://typelevel.org/cats-effect/typeclasses/sync.html" target="_blank" rel="noopener">Sync</a></code><a href="https://typelevel.org/cats-effect/typeclasses/sync.html" target="_blank" rel="noopener"> from cats-effect</a> (if we are using cats) represents. Our code now becomes (<code>class Main[F[_]: Monad]</code> is just a shorthand notation for <code>class Main[F[_]](implicit fm: Monad[F])</code>):</p><pre><span id="98cd" data-selectable-paragraph="">trait Console[F[_]] {<br>  def putStrLn(line: String): F[Unit]<br>  def getStrLn: F[String]<br>}</span><span id="448e" data-selectable-paragraph="">class LiveConsole[F[_]: Sync] extends Console[F] {<br>  def putStrLn(line: String): F[Unit] = <br>    Sync[F].effect(println(line))<br>  def getStrLn: F[String] = <br>    Sync[F].effect(scala.io.StdIn.readLine())<br>}</span><span id="4a31" data-selectable-paragraph="">class Main[F[_]: Monad](console: Console[F]) {<br>  def run(): F[String] = {<br>    for {<br>      _    &lt;- console.putStrLn("Good morning, what’s your name?")<br>      name &lt;- console.getStrLn<br>      _    &lt;- console.putStrLn(s"Great to meet you, $name")<br>    } yield name<br>  }<br>}</span></pre><p id="fe1c" data-selectable-paragraph=""><mark>And that’s the whole idea behind Final Tagless — instead of using concrete effectful wrapper, we declare what kind of interface is needed for the wrapper in a particular class or method.</mark></p><p id="bc1b" data-selectable-paragraph="">We can extend the idea presented above to track what kind of side effects our code uses in more detail. Scala gives us quite a wide range of possibilities here. The only question is: <strong>how fine-grained the effect tracking should be?</strong></p><p id="7a50" data-selectable-paragraph="">Of course: <strong>it depends</strong>!</p><p id="4d1f" data-selectable-paragraph="">First, we have the option to <strong>track no effects</strong> at all. That’s what we’ve seen in the very first code snippet: the <code>LiveConsole</code> implementation was just doing uncontrolled and unconstrained side effects (in this case, printing/reading from the console).</p><p id="01c0" data-selectable-paragraph="">Improving on this, we can track side effects at a <strong>binary level</strong>: “has effects” or “has no effects”. Looking at a method signature, we know if it’s declared as being pure (e.g. <code>f: List[User] =&gt; Statistics</code>) or if it is declared to have side effects (<code>f: List[User] =&gt; IO[SentEmails]</code>).</p><p id="fa45" data-selectable-paragraph="">Making this jump, from tracking no effects at all, to a has effect/no effect distinction is what makes the biggest difference in most code bases. And in many cases you can stop here.</p><p id="000c" data-selectable-paragraph="">However, if you want to, you can go further, and track in the method signatures what kind of effects <strong>exactly</strong> does a method use. <code>IO</code> means “some effect”, while you could want to know — does it mean using a database? Sending emails? Interacting with the console?</p><p id="bbfb" data-selectable-paragraph="">That’s what various effect systems in Scala want to solve. And that’s also what <a href="https://scalaz.github.io/scalaz-zio/" target="_blank" rel="noopener">ZIO Environment</a> is about. And it’s not the only proposed possibile solution; contenders in this space include:</p><ul><li id="f603" data-selectable-paragraph="">the reader monad</li><li id="aeef" data-selectable-paragraph="">final tagless</li><li id="1615" data-selectable-paragraph="">free monads</li><li id="e1ad" data-selectable-paragraph=""><a href="https://www.scala-lang.org/blog/2016/12/07/implicit-function-types.html" target="_blank" rel="noopener">implicit function types</a> in Dotty/Scala 3</li><li id="d9b2" data-selectable-paragraph="">and now ZIO Environment</li></ul><blockquote><p id="e600" data-selectable-paragraph="">As a side note: ZIO Environment is not about “injecting dependencies”. Dependency injection and tracking effects are distinct things. The first one, <a target="_blank" rel="noopener" href="https://blog.softwaremill.com/what-is-dependency-injection-8c9e7805502f">dependency injection</a>, is about creating a static object graph (module graph), where the dependencies are <strong>hidden</strong> from the use sites.</p><p id="1415" data-selectable-paragraph="">Effect tracking is about making dependencies <strong>explicit</strong> to the use sites; dependencies become part of the interface. That’s why the reader monad is not an alternative to dependency injection, but <a href="https://softwaremill.com/reader-monad-constructor-dependency-injection-friend-or-foe/" target="_blank" rel="noopener">can be a complement of it</a>.</p></blockquote><p id="2cd5" data-selectable-paragraph="">How to extend Final Tagless to track effects? Just as John has shown in his example. Instead of passing <code>Console[F]</code> as a constructor parameter to <code>Main</code>, we require it as another constraint for our effect wrapper <code>F</code> on the method:</p><pre><span id="e06f" data-selectable-paragraph="">trait Console[F[_]] {<br>  def putStrLn(line: String): F[Unit]<br>  def getStrLn: F[String]<br>}<br>object Console {<br>  def apply[F[_]](implicit F: Console[F]): Console[F] = F<br>}</span><span id="5770" data-selectable-paragraph="">class LiveConsole[F[_]: Sync] extends Console[F] {<br>  def putStrLn(line: String): F[Unit] = <br>    Sync[F].effect(println(line))<br>  def getStrLn: F[String] = <br>    Sync[F].effect(scala.io.StdIn.readLine())<br>}</span><span id="e1a2" data-selectable-paragraph="">object Main {<br>  def run[F[_]: Monad: Console](): F[String] = {<br>    for {<br>      _    &lt;- Console[F].putStrLn("Good morning, what’s your name?")<br>      name &lt;- Console[F].getStrLn<br>      _    &lt;- Console[F].putStrLn(s"Great to meet you, $name")<br>    } yield name<br>  }<br>}</span></pre><p id="2241" data-selectable-paragraph="">While before the <code>console</code> dependency was <strong>hidden</strong> from <code>Main</code>’s users, now it is explicit. The dependency must be provided by the caller of the method, not when creating the object graph! Hence, each use-site also needs to have the <code>Console</code> dependency, and so on.</p><p id="a4bc" data-selectable-paragraph="">We are now clear that <code>Main.run</code> has side effects (as it uses an effect wrapper at all) and additionally what kind of side-effects exactly (it interacts with the console).</p><p id="2738" data-selectable-paragraph="">Note that the <code>: Sync</code> and <code>: Monad</code> constraints are <strong>different </strong>in their nature from the <code>: Console</code> constraint. The first ones describe the capabilities that the <code>F</code> effect wrapper has, and form lawful, “true”, typeclasses. The second doesn’t say anything new about <code>F</code>, it just constraints the possible side-effects. Such constraints shouldn’t be considered a typeclass in the first place (which is also one of John’s points).</p><p id="0333" data-selectable-paragraph="">It might be —or it might be not. All of the criticism of Final Tagless from John’s talk is of course valid, however it applies only to using Final Tagless for effect tracking — not constraining effect wrappers!</p><p id="6560" data-selectable-paragraph="">Is ZIO Environment the answer? It might be — if you need to track effects in your application! Or, it might as well be the case that just knowing <strong>if</strong> a function has side effects or not is sufficient; that is, using “plain old” <code>IO[_]</code> (or an abstract <code>F[_]</code>).</p><p id="2638" data-selectable-paragraph="">We all know what are the shortcomings of Final Tagless, thanks to John’s excellent talk. But we still have to wait for field reports of using ZIO Environment in real projects. Some of the potential shortcomings have already been pointed out by <a href="https://twitter.com/Odomontois/status/1100622968416288768" target="_blank" rel="noopener">Oleg Nizhnik</a>, so I will refer you to this twitter thread instead of repeating them here.</p><figure><div></div></figure><p id="fad4" data-selectable-paragraph="">What I would add, is that the necessity to use the cake pattern (let’s call it what it is :) ) is quite an intrusive change and might require adapting your codebase. It’s not as simple as just using a “plain old” class with methods.</p><p id="2550" data-selectable-paragraph="">No. As John says in his talk, you don’t need to understand what a trifunctor is, why <code>ZIO[R, E, A]</code> forms a profunctor on its <code>R</code>/<code>E</code> and <code>R</code>/<code>A</code> type parameter pairs, or what a profunctor even is to use ZIO. I would argue that the same is true for Final Tagless: to use it as a way to constrain effect wrappers, you don’t need to have a thorough understanding of type classes, higher kinded types or the Monad typeclass hierarchy.</p><p id="a196" data-selectable-paragraph="">It’s sufficient to understand why coding to an interface, instead of an implementation is preferable. And being open to alternative ways of expressing dependencies (in this case: not as a parameter, but as an implicit type constraint).</p><p id="2903" data-selectable-paragraph="">It’s a very interesting quest to find out how these concept generalise; what a typeclass is; how pervasive monads are; how applicatives differ from monads; how free is equivalent to tagless final; what’s a profunctor; etc. But that’s not necessary to start using them.</p><p id="7627" data-selectable-paragraph="">Final Tagless is definitely a victim of hype and fashion. It shouldn’t be used for everything, as that’s how we end up with monstrosities such as we’ve seen in John’s talk:</p><pre><span id="734d" data-selectable-paragraph="">def genFeed[F[_]: Monad:<br>  Logging: UserDatabase:<br>  ProfileDatabase: RedisCache:<br>  GeoIPService: AuthService:<br>  SessionManager: Localization:<br>  Config: EventQueue: Concurrent:<br>  Async: MetricsManager]: F[Feed] = ???</span></pre><p id="b1d5" data-selectable-paragraph="">A couple of years ago Free Monads were the fashionable thing to use in the functional programming community. Using them as the main way to structure programs turned out to be cumbersome, the amount of boilerplate needed greatly exceeded benefits they bring.</p><p id="b7c9" data-selectable-paragraph="">However, Free Monads have found their niche. They turn out to be a very good choice for representing general-purpose abstractions. For example, when describing database operations (<code>ConnectionIO</code> from <a href="https://tpolecat.github.io/doobie/" target="_blank" rel="noopener">Doobie</a> or <code>DBIOAction</code> from <a href="http://slick.lightbend.com/" target="_blank" rel="noopener">Slick</a>), or when describing concurrent programs (<code>IO</code> in ZIO, <code>Task</code> in Monix, <code>Behavior</code> in Akka-Typed). For these kinds of abstractions, it’s just much more convenient to work with a value-based representation.</p><blockquote><p id="4002" data-selectable-paragraph="">Yes, <code>IO</code>/<code>Task</code> itself is another realisation of the “code to an interface” idea. When describing computation using IO, you create a description of the computation (as a value), using IO’s primitives. Only later that is being interpreted, that is, the IO primitives are given specific meaning. In theory, you can have multiple IO interpretations, which correspond to multiple interface implementations.</p></blockquote><p id="f8d5" data-selectable-paragraph="">The niche for Final Tagless is constraining effect wrappers. But not — as John’s talk shows quite well — tracking effects in detail in an application.</p><p id="4593" data-selectable-paragraph="">I’m quite sure a niche will emerge for ZIO Environment. Such as situations were you need <strong>detailed effect tracking</strong>.</p><p id="4fb0" data-selectable-paragraph="">All tools have their proper use. Neither Final Tagless, Free Monads, constructor-based dependency injection nor ZIO Environment should be used for everything.</p><p id="3335" data-selectable-paragraph="">There’s many ways in which you can realise the “code to an interface” idea in Scala. In each of them, you have a basic “set of instructions” which you use to build your application logic. These instructions can take various forms:</p><ul><li id="ed0f" data-selectable-paragraph="">calling methods on dependencies passed as parameters (constructor based dependency injection)</li><li id="2a84" data-selectable-paragraph="">final tagless: dependencies are passed as implicit capabilities</li><li id="afe8" data-selectable-paragraph="">free monads: instructions are represented as values</li><li id="69ed" data-selectable-paragraph="">reader monad: a convenient way of passing a single dependency</li></ul><p id="2e17" data-selectable-paragraph="">Summing up, what ZIO Environment is: an interesting combination of an optimized reader monad with the cake pattern. What Final Tagless isn’t: dead.</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>