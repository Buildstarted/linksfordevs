<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Options for .NET&#x2019;s versioning issues - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Options for .NET&#x2019;s versioning issues - linksfor.dev(s)"/>
    <meta property="og:description" content="This post revisits the problem described in Versioning Limitations in .NET, based on reactions to that post and a Twitter discussion which occurred later. Before getting onto the main topic of the &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://codeblog.jonskeet.uk/2019/10/25/options-for-nets-versioning-issues/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Options for .NET&#x2019;s versioning issues</title>
<div class="readable">
        <h1>Options for .NET&#x2019;s versioning issues</h1>
        <p>
Reading time: 16-20 minutes        </p>
        <p><a href="https://codeblog.jonskeet.uk/2019/10/25/options-for-nets-versioning-issues/">https://codeblog.jonskeet.uk/2019/10/25/options-for-nets-versioning-issues/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article id="post-1733">
	
	<!-- .entry-header -->

		<div>
		<p>This post revisits the problem described in <a href="https://codeblog.jonskeet.uk/2019/06/30/versioning-limitations-in-net/">Versioning Limitations in .NET</a>, based on reactions to that post and a Twitter discussion which occurred later.</p>
<p>Before getting onto the main topic of the post, I wanted to comment a little on that Twitter discussion. I personally found it frustrating at times, and let that frustration leak out into some of my responses. As Twitter debates go, this was relatively mild, but it was still not as constructive as it might have been, and I take my share of responsibility for that. Sorry, folks. I‚Äôm sure that everyone involved ‚Äì both in that Twitter discussion and more generally in the .NET community ‚Äì genuinely wants the best outcome here. I‚Äôve <em>attempted</em> to frame this post with that thought at the top of mind, assuming that all opinions on the topic are held and expressed in good faith. As you‚Äôll see, that doesn‚Äôt mean I have to agree with everyone, but it hopefully helps me respect arguments I disagree with. I‚Äôm happy to make corrections (probably with some sort of history) if I misrepresent things or miss out some crucial pros/cons. The goal of this post is to help the community weigh up options as pragmatically as possible.</p>

<p>There are many aspects to versioning, of course. In the future I plan to blog about some interesting impacts of multi-targeting libraries, and the choices involved in writing one library to effectively augment another. But those are topics for another day.</p>
<p>The primary situation I want to explore in this post is the problem of breaking changes, particularly with respect to the diamond dependency problem. I‚Äôve found it helpful to make things very, very concrete when it comes to versioning. So we‚Äôll consider the following situation.</p>
<ul>
<li>A team is building an application called Time Zone Magic. They‚Äôre using .NET Core 3.0, and everything they need to use targets .NET Standard 2.0 ‚Äì so they have no problems there.</li>
<li>The team is completely in control of the application, and doesn‚Äôt need to worry about any versioning for the application itself. (Just to simplify things‚Ä¶)</li>
<li>The application depends on <a href="https://www.nuget.org/packages/NodaTime">Noda Time</a>, naturally, for all the marvellous ways in which Noda Time can help you with time zones.</li>
<li>The application also depends on <a href="https://www.nuget.org/packages/DarkSkyCore/">DarkSkyCore</a><sup>1</sup>. </li>
</ul>
<p>Now DarkSkyCore depends on NodaTime 2.4.7. But the Time Zone Magic application needs to depend on NodaTime 3.0.0 to take advantage of some of the newest functionality. (To clarify, NodaTime 3.0.0 hasn‚Äôt actually been released at the time of writing this blog post. This part is concrete but fictional, just like the application itself.) So, we have a diamond dependency problem. It‚Äôs entirely possible that DarkSkyCore depends on functionality that‚Äôs in NodaTime 2.4.7 but has been removed from 3.0.0. If that‚Äôs the case, with the current way .NET works (whether desktop or Core), an exception will occur at some point ‚Äì exactly how that‚Äôs surfaced will probably vary based on a number of factors that I don‚Äôt explore in this post.</p>
<p>Currently, as far as I can tell, DarkSkyCore doesn‚Äôt refer to any NodaTime types in its public API. We‚Äôll consider what difference this makes in the various options under consideration. I‚Äôll mention a term that I learned during the Twitter conversation: <strong>type exchange</strong>. I haven‚Äôt seen a formal definition of this, but I‚Äôm assuming it means one library referring to a type from another library within its public API, e.g. as a parameter or return type, or even as a base class or implemented interface.</p>
<p>The rest of this post consists of some options for what <em>could</em> happen, instead of the current situation. These are just the options I‚Äôve considered; I certainly don‚Äôt want to give the impression it‚Äôs exhaustive or that we (as a community) should stop trying to think of other options too.</p>
<p><sup>1</sup> I‚Äôve never used this package, and have no opinion on it. It‚Äôs just a plausible package to use that depends on NodaTime.</p>

<p>It‚Äôs always including the status quo as a possible option. We can acknowledge that the current situation has problems (the errors thrown at hard-to-predict places) but we may consider that every alternative is worse, either in terms of end result or cost to implement.</p>
<p>It‚Äôs worth bearing in mind that .NET has been around for nearly 20 years, and while this is certainly a known annoyance, I seem to care about it more than most developers I encounter ‚Äì suggesting that this problem doesn‚Äôt make all development on .NET completely infeasible.</p>
<p>I do believe it will hinder the community‚Äôs growth in the future though, particularly if (as I hope) the Open Source ecosystem flourishes more and more. I believe one of the reasons this hasn‚Äôt bitten the platform <em>very</em> hard so far is that the framework provides so much, and ASP .NET (including Core) dominate on the web framework side of things. In the future, if there are more small, ‚Äúdo one thing well‚Äù packages that are popular, the chances of incompatibilities will increase.</p>

<p>If we never make breaking changes, there can‚Äôt be any incompatibilities. We keep the major version at 1, and it doesn‚Äôt matter which minor version anyone depends on.</p>
<p>This has been the approach of the BCL team, very largely (aside from ‚Äúkeeping the major version at 1‚Äù) ‚Äì and is probably appropriate for absolutely ‚Äúsystem level‚Äù packages. Quite what counts as ‚Äúsystem level‚Äù is an open question: Noda Time is relatively low level, and attempts to act as a replacement for system types, so does that mean I should never make any breaking changes either?</p>
<p>I could potentially commit to not making any <em>future</em> breaking changes ‚Äì but deciding to do that right from day 1 would seriously stifle innovation. Releasing version 1.0 is scary enough as it is, without the added pressure of ‚Äúyou own every API mistake in here, forever.‚Äù There‚Äôs a huge cost involved in the kind of painstaking review of every API element that the BCL team goes through. That‚Äôs a cost most open source authors probably can‚Äôt bear, and it‚Äôs not going to be a good investment of time for 99.9% of libraries‚Ä¶ but for the 0.1% that make it and become Json.NET-like in terms of ubiquity, it would be great.</p>
<p>Maybe open source projects should really aim for 2.infinity: version 1.x is to build momentum, and 2.x is forever. Even that leaves me pretty uncomfortable, to be honest.</p>
<p>There‚Äôs another wrinkle in this in terms of versioning that may be relevant: platform targeting. One of the reasons I‚Äôve taken a major version bump for NodaTime 3.0 is that I‚Äôm dropping support for older versions of .NET. As of NodaTime 3.0, I‚Äôm just targeting .NET Standard 2.0. Now that‚Äôs a breaking change in that it stops anyone using a platform that doesn‚Äôt support .NET Standard 2.0 from taking a dependency on NodaTime 3.0, but it <em>doesn‚Äôt</em> have the same compatibility issues as other breaking changes. If the <em>only</em> thing I did for NodaTime 3.0 was to change the target framework, the diamond dependency problem would be a non-issue, I believe: any code that <em>could</em> run 3.0 would be compatible with code expecting 2.x.</p>
<p>Now in Noda Time 3.0 I also removed binary serialization, and I‚Äôd be very reluctant <em>not</em> to do that. Should the legacy of binary serialization haunt a library forever? Is there actually some acceptable deprecation period for things like this? I‚Äôm not sure.</p>
<p>Without breaking changes, type exchange should always be fine, barring code that relies on bugs in older versions.</p>

<p>The <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/versioning">current versioning guidance from Microsoft</a> suggests following SemVer 2.0, but in the <a href="https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/breaking-changes">breaking changes guidance</a> it states:</p>
<blockquote><p>
  <strong>CONSIDER</strong> publishing a major rewrite of a library as a new NuGet package.
</p></blockquote>
<p>Now, it‚Äôs not clear to me what‚Äôs considered a ‚Äúmajor rewrite‚Äù. I implemented a major rewrite of a lot of Noda Time functionality between 1.2 and 1.3, without breaking the API. For 2.0 there was a more significant rewrite, with <em>some</em> breaking changes when we moved to nanosecond precision. It‚Äôs worth at least considering the implications of interpreting that as ‚Äúconsider publishing a breaking change as a new NuGet package‚Äù. This is effectively putting the version in the package name, e.g. <code>NodaTime1</code>, <code>NodaTime2</code> etc.</p>
<p>At this point, on a per-package basis, we have no breaking changes, and we‚Äôd keep the major version at 1 forever, aside from potentially dropping support for older target platforms, as described in option 2. The differences are:</p>
<ul>
<li>The package names become pretty ugly, in my opinion ‚Äì something that I‚Äôd argue is inherently part of the version number has leaked elsewhere. It‚Äôs effectively an admission that .NET and SemVer don‚Äôt play nicely together.</li>
<li>We don‚Äôt see breaking changes in the app example above, because DarkSkyCore would depend on NodaTime2 and the Time Zone Magic application would depend directly on NodaTime3.</li>
<li>Global state becomes potentially more problematic: any singleton in both NodaTime2 and NodaTime3 (such as <code>DateTimeZoneProviders.Tzdb</code> for NodaTime) would be a ‚Äúsingleton per package‚Äù but not a ‚Äúglobal singleton‚Äù. With the example of <code>DateTimeZoneProviders.Tzdb</code>, that means different parts of Time Zone Magic could give different results for the same time zone ID, based on whether the data was retrieved via NodaTime2 or NodaTime3. Ouch.</li>
<li>Type exchange doesn‚Äôt work out of the box: if DarkSkyCore exposed a NodaTime2 type in its API, the Time Zone Magic code wouldn‚Äôt be able to take that result and pass it into NodaTime3 code. On the other hand, it would be feasible to create another package, NodaTime2To3 which depended on both NodaTime2 and NodaTime3 and provided conversions where feasible.</li>
<li>Having largely-the-same code twice in memory could have performance implications ‚Äì twice as much JITting etc. This probably isn‚Äôt a huge deal in most scenarios, but could be painful in some cases.</li>
</ul>
<p>No CLR changes are required for this ‚Äì it‚Äôs an option that anyone can adopt right now.</p>
<p>One point that‚Äôs interesting to note (well, I think so, anyway!) is that in the Google Cloud Client Libraries we already have a version number in the package name: it‚Äôs the version number of the network API that the client library targets. For example, Google.Cloud.Speech.V1 targets the ‚ÄúSpeech V1‚Äù API. This means there can be a ‚ÄúSpeech V2‚Äù API with a different NuGet package, and the two packages can be versioned entirely independently. (And you can use both together.) That feels appropriate to me, because it‚Äôs part of ‚Äúthe purpose of the package‚Äù ‚Äì whereas the version number of the package <em>itself</em> doesn‚Äôt feel right being in the package name.</p>

<p>This option is most simply described as ‚Äúimplicit option 3, handled by tooling and the CLR‚Äù. (If you haven‚Äôt read option 3 yet, please do so now.) Imagine we kept the package name as just NodaTime, but all the tooling involved (MSBuild, NuGet etc) treated ‚ÄúNodaTime v2.x‚Äù and ‚ÄúNodaTime v3.x‚Äù as independent packages. All the benefits <em>and drawbacks</em> of option 3 would still apply, except the drawback of the version number leaking into the package name.</p>
<p>It‚Äôs <em>possible</em> that no CLR changes would be required for this ‚Äì I don‚Äôt know. One of the interesting aspects on the Twitter thread was that <code>AssemblyLoadContext</code> could be used in .NET Core 3 for some of what I‚Äôd been describing, but that there were performance implications. Microsoft engineers also reported that what I‚Äôd been proposing before would be a <em>huge</em> amount of work and complexity. I have no reason to doubt their estimation here.</p>
<p>My <em>hunch</em> is that if 90% of this could be done in tooling, we should be able to achieve a lot without execution-time penalties. Maybe we‚Äôd need to do something like using the major version number as a suffix on the <em>assembly</em> filename, so that NodaTime2.dll and NodaTime3.dll could live side-by-side in the same directory. I could live with that ‚Äì although I readily acknowledge that it‚Äôs a hugely disruptive change. Whatever the implementation, the lack of type exchange would be very disruptive, to the extent that maybe this should be an opt-in (on the part of the package owner) mechanism. ‚ÄúI want more freedom for major version coexistence, at the expense of type exchange.‚Äù</p>
<p>Another aspect of feedback in the Twitter thread was that the CLR has supported side-by-side assembly loading for a very long time (forever?) but that customers didn‚Äôt use it in practice. Again, I have no reason to dispute the data ‚Äì but I would say that it‚Äôs not evidence that it‚Äôs a bad feature. Even great features need to be exposed well before they‚Äôll be used‚Ä¶ look at generic variance in the CLR, which was already present in .NET 2.0, but was effectively unused until languages (e.g. C# 4) and the framework (e.g. interfaces such as a <code>IEnumerable</code>) supported it too.</p>
<p>It took a long time to get from ‚Äúdownload a zip file, copy the DLLs to a lib directory, and add a reference to that DLL‚Äù to ‚Äúadd a reference to a versioned NuGet package which might require its own NuGet dependencies‚Äù. I believe many aspects of the versioning story aren‚Äôt really exposed in that early xcopy-dependency approach, and so maybe we didn‚Äôt take advantage of the CLR facilities nearly as early as we should have don.</p>
<p>If you hadn‚Äôt already guessed, this option is the one I‚Äôd like to pursue with the most energy. I want to acknowledge that it‚Äôs easy for me to write that in a blog post, with none of the cost of fully designing, implementing and supporting such a scheme. Even the exploratory work to determine the full pros and cons, estimate implementation cost etc would be very significant. I‚Äôd love the community to help out with this work, while realizing that Microsoft has the most experience and data in this arena.</p>

<p>When laying out the example, I noted that for the purposes of DarkSkyCore, NodaTime 2.4.7 and NodaTime 3.0 <em>may</em> be entirely compatible. DarkSkyCore may not need any of the members that have been removed in 3.0. More subtly, even if there are areas of incompatibility, the parts of DarkSkyCore that are accessed by the Time Zone Magic application may not trigger those incompatibilities.</p>
<p>One <em>relatively</em> simple (I believe) first step would be to have a way of determining the first kind of ‚Äúcompatibility despite a major version bump‚Äù. I expect that with Mono.Cecil or similar packages, it should be feasible to:</p>
<ul>
<li>List every public member (class, struct, interface, method, property etc) present in NodaTime 3.0, by analyzing NodaTime.dll</li>
<li>List every public member from NodaTime 2.4.7 <em>used</em> within DarkSkyCore, by analyzing DarkSkyCore.dll</li>
<li>Check whether there‚Äôs anything in the second list that‚Äôs not in the first. If there isn‚Äôt, DarkSkyCore is <em>probably</em> compatible with NodaTime 3.0.0, and Time Zone Magic will be okay.</li>
</ul>
<p>This ignores reflection of course, along with breaking <em>behavioral</em> changes, but it would at least give a good first indicator. Note that if we‚Äôre primarily interested in binary compatibility rather than source compatibility, there are lots of things we can ignore, such as parameter names.</p>
<p>It‚Äôs very possible that this tooling already exists, and needs more publicity. Please let me know in comments if so, and I‚Äôll edit a link in here. If it <em>doesn‚Äôt</em> already exist, I‚Äôll prototype it some time soon.</p>
<p>If we had such a tool, and it could be made to work reliably (if conservatively), do we want to put that into our normal build procedure? What would configuration look like?</p>
<p>I‚Äôm a firm believer that we need a <em>lot</em> more tooling around versioning in general. I recently added a version compatibility detector written by a colleague into our CI scripts, and it‚Äôs been wonderful. That‚Äôs a relatively ‚Äúhome-grown‚Äù project (it lives in the Google Cloud client libraries repository) but something similar could certainly become a first class citizen in the .NET ecosystem.</p>
<p>In my previous blog post, I mentioned the idea of ‚Äúprivate dependencies‚Äù, and I‚Äôd still like to see tooling around this, too. It doesn‚Äôt need any CLR or even NuGet support to be useful. If the DarkSkyCore authors could say ‚ÄúI want to depend on NodaTime, but I want to be warned if I ever expose any NodaTime types in my public API‚Äù I think that would be tremendously useful as a starting point. Again, it shouldn‚Äôt be hard to at least prototype.</p>

<p>As I mentioned at the start, corrections and alternative viewpoints are very welcome in comments, and I‚Äôll assume (unless you say otherwise) that you‚Äôre happy for me to edit them into the main post in some form or other (depending on the feedback).</p>
<p>I want to encourage a vigorous but positive discussion about versioning in .NET. Currently I feel slightly impotent in terms of not knowing how to proceed beyond blogging and engaging on Twitter, although I‚Äôm hopeful that the .NET Foundation can have a significant role in helping with this. Suggestions for next steps are very welcome as well as technical suggestions.</p>
	</div><!-- .entry-content -->
	
	</article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>