<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Benchmarking performance of your code between release versions -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Benchmarking performance of your code between release versions</h1><div><div class="col-s-12"><ins class="adsbygoogle" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-6726920020676946" data-ad-slot="3061010867" data-full-width-responsive="false"></ins><p>A while ago in 2016 I posted a <a rel="noopener" href="https://github.com/dotnet/BenchmarkDotNet/issues/290" target="_blank">question</a> on the <a rel="noopener" href="https://github.com/dotnet/BenchmarkDotNet" target="_blank">BenchmarkDotNet</a> repository about an official way to run benchmarks between Nuget releases. In 2018 I managed to find some time and with the with the help of <a rel="noopener" href="https://github.com/adamsitnik" target="_blank">Adam Sitnik</a> (one of the project’s maintainers), was able to <a rel="noopener" href="https://github.com/dotnet/BenchmarkDotNet/pull/922" target="_blank">make that work</a>!</p><p>I won’t go into detail about what BenchmarkDotNet is, but it’s a brilliant way to accurately run benchmarks against your code to see how it performs, how much memory is being used, etc…</p><p>With this new feature you can now easily see how your code changes effect performance between your releases.</p><h2>Show me the code</h2><p>Making this work is quite easy and there’s a <a rel="noopener" href="https://github.com/dotnet/BenchmarkDotNet/blob/master/samples/BenchmarkDotNet.Samples/IntroNuGet.cs" target="_blank">quick start code snippet</a> in the repo already. For the example below I’ll use <a rel="noopener" href="https://sixlabors.com/projects/imagesharp/" target="_blank">ImageSharp</a> as the library to be tested and we’ll see how well <a rel="noopener" href="https://twitter.com/James_M_South" target="_blank">James</a> and his team is doing with regards to improving it’s JPEG decoding performance.</p><pre class="lang-csharp"><code>
[Config(typeof(Config))]
public class ImageTests
{
    private static readonly string _filePath = @"C:\temp\test.jpg";

    private class Config : ManualConfig
    {
        public Config()
        {
            var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value);
            Add(baseJob.WithNuGet("SixLabors.ImageSharp", "1.0.0-beta0006").WithId("1.0.0-beta0006"));
            Add(baseJob.WithNuGet("SixLabors.ImageSharp", "1.0.0-beta0005").WithId("1.0.0-beta0005"));
            Add(baseJob.WithNuGet("SixLabors.ImageSharp", "1.0.0-beta0004").WithId("1.0.0-beta0004"));
        }
    }

    [Benchmark]
    public Size LoadJpg()
    {
        using (var img = Image.Load(_filePath))
        {
            var size = img.Size();
            return size;
        }
    }
}
</code></pre><p>The code above should seem pretty straightforward. It’s just setting up 3 BenchmarkDotNet jobs, each using a different version of the SixLabors.ImageSharp Nuget package. Then the actual benchmark test is loading in a JPEG extracting it’s size and returning it.</p><p>Running the benchmark is like running any other BenchmarkDotNet test, for example in a console app:</p><pre class="lang-csharp"><code>
class Program
{
    static void Main(string[] args)
    {   
        var summary = BenchmarkRunner.Run();
    }
}
</code></pre><h2>The results</h2><table border="0"><thead><tr><th>Method</th><th>Job</th><th>NuGetReferences</th><th>Mean</th><th>Error</th><th>StdDev</th></tr></thead><tbody><tr><td>LoadJpg</td><td>1.0.0-beta0004</td><td>SixLabors.ImageSharp 1.0.0-beta0004</td><td>297.5 ms</td><td>142.8 ms</td><td>7.827 ms</td></tr><tr><td>LoadJpg</td><td>1.0.0-beta0005</td><td>SixLabors.ImageSharp 1.0.0-beta0005</td><td>202.9 ms</td><td>466.6 ms</td><td>25.577 ms</td></tr><tr><td>LoadJpg</td><td>1.0.0-beta0006</td><td>SixLabors.ImageSharp 1.0.0-beta0006</td><td>148.8 ms</td><td>107.8 ms</td><td>5.910 ms</td></tr></tbody></table><p>Looks good! from the beta0004 release to the beta0006 release there’s almost twice the performance boost.</p><h2>API Surface Area</h2><p>There is one caveat though… In order to run these tests between versions of your library, the same API surface area will need to exist otherwise you’ll get exceptions when running the benchmarks. This is the reason why versions beta0001 –&gt; beta0003 are not included in the jobs listed above. Its because in the older versions either the APIs were different or the namespaces were different.</p><p>It is possible to work around this but you’d need to use some ugly reflection to do it and then you need to be careful that you are not testing the reflection performance hit either.</p><p>Now you should have a pretty easy way to know how the performance of your library is changing between versions. Happy coding!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>