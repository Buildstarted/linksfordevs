<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using Chained Certificates for Certificate Authentication in ASP.NET Core&#xA0;3.0 -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Using Chained Certificates for Certificate Authentication in ASP.NET Core&#xA0;3.0</h1>
    <div class="entry-content"> <p>This article shows how to create self signed certificates and use these for chained certificate authentication in ASP.NET Core. By using chained certificates, each client application can use a unique certificate which was created from a root CA directly, or an intermediate certificate which was created from the root CA. The clients can then be grouped or authenticated as required.</p>
<p><strong>Code</strong> <a href="https://github.com/damienbod/AspNetCoreCertificateAuth">https://github.com/damienbod/AspNetCoreCertificateAuth</a></p>
<p>Posts in this series</p> <p><strong>Creating the Certificates</strong></p>
<p>Creating the certificates is the hardest part in setting up this flow. A self signed <strong>Root CA Certificate</strong> is created using the New-SelfSignedCertificate powershell cmdlet. When creating this, please use a strong password, replace the demo one, do not just copy the code. It is important to add the KeyUsageProperty parameter and the KeyUsage parameter as shown.</p>
<p>Powershell commands: </p>
<pre class="brush: csharp; title: ; notranslate">
New-SelfSignedCertificate -DnsName &quot;root_ca_dev_damienbod.com&quot;, &quot;root_ca_dev_damienbod.com&quot; 
   -CertStoreLocation &quot;cert:\LocalMachine\My&quot; 
   -NotAfter (Get-Date).AddYears(20) 
   -FriendlyName &quot;root_ca_dev_damienbod.com&quot; 
   -KeyUsageProperty All 
   -KeyUsage CertSign, CRLSign, DigitalSignature

$mypwd = ConvertTo-SecureString -String &quot;1234&quot; -Force -AsPlainText

Get-ChildItem -Path cert:\localMachine\my\&quot;The thumbprint...&quot; | Export-PfxCertificate -FilePath C:\git\root_ca_dev_damienbod.pfx -Password $mypwd

Export-Certificate -Cert cert:\localMachine\my\&quot;The thumbprint...&quot; -FilePath root_ca_dev_damienbod.crt

</pre>
<p>Install the root certificate in the trusted root of the host windows PC. If deploying this on Linux, different tools need to be used.</p>
<p><a href="https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the">https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the</a></p>
<p>A self signed <strong>intermediate certificate</strong> can now be created from the root certificate. This is not required for all use cases, but you might need to create many certificates or need to activate, disable groups of certificates. The TextExtension parameter is required to set the pathlength in the basic constraints of the certificate. </p>
<p>The intermediate certificate can then be added to the trusted intermediate certificate in the windows host system.</p>
<p>Powershell commands: </p>
<pre class="brush: csharp; title: ; notranslate">

$mypwd = ConvertTo-SecureString -String &quot;1234&quot; -Force -AsPlainText

$parentcert = ( Get-ChildItem -Path cert:\LocalMachine\My\&quot;The thumbprint of the root...&quot; )

New-SelfSignedCertificate -certstorelocation cert:\localmachine\my 
   -dnsname &quot;intermediate_dev_damienbod.com&quot; 
   -Signer $parentcert 
   -NotAfter (Get-Date).AddYears(20) 
   -FriendlyName &quot;intermediate_dev_damienbod.com&quot; 
   -KeyUsageProperty All 
   -KeyUsage CertSign, CRLSign, DigitalSignature
   -TextExtension @(&quot;2.5.29.19={text}CA=1&amp;pathlength=1&quot;)

Get-ChildItem -Path cert:\localMachine\my\&quot;The thumbprint...&quot; | Export-PfxCertificate -FilePath C:\git\AspNetCoreCertificateAuth\Certs\intermediate_dev_damienbod.pfx -Password $mypwd

Export-Certificate -Cert cert:\localMachine\my\&quot;The thumbprint...&quot; -FilePath intermediate_dev_damienbod.crt

</pre>
<p>A <strong>child certificate</strong> can be created from the intermediate certificate. This is the end entity and does not need to create more child certificates.</p>
<p>Powershell commands: </p>
<pre class="brush: csharp; title: ; notranslate">
$parentcert = ( Get-ChildItem -Path cert:\LocalMachine\My\&quot;The thumbprint from the Intermediate certificate...&quot; )

New-SelfSignedCertificate -certstorelocation cert:\localmachine\my 
  -dnsname &quot;child_a_dev_damienbod.com&quot; 
  -Signer $parentcert 
  -NotAfter (Get-Date).AddYears(20) 
  -FriendlyName &quot;child_a_dev_damienbod.com&quot;

$mypwd = ConvertTo-SecureString -String &quot;1234&quot; -Force -AsPlainText

Get-ChildItem -Path cert:\localMachine\my\&quot;The thumbprint...&quot; | Export-PfxCertificate -FilePath C:\git\AspNetCoreCertificateAuth\Certs\child_a_dev_damienbod.pfx -Password $mypwd

Export-Certificate -Cert cert:\localMachine\my\&quot;The thumbprint...&quot; -FilePath child_a_dev_damienbod.crt

</pre>
<p>A child certificate can also be created from the root certificate directly. If you do not have many API clients, this could be used.</p>
<pre class="brush: csharp; title: ; notranslate">
$rootcert = ( Get-ChildItem -Path cert:\LocalMachine\My\&quot;The thumbprint from the root cert...&quot; )

New-SelfSignedCertificate -certstorelocation cert:\localmachine\my 
  -dnsname &quot;child_a_dev_damienbod.com&quot; 
  -Signer $rootcert 
  -NotAfter (Get-Date).AddYears(20) 
  -FriendlyName &quot;child_a_dev_damienbod.com&quot;

$mypwd = ConvertTo-SecureString -String &quot;1234&quot; -Force -AsPlainText

Get-ChildItem -Path cert:\localMachine\my\&quot;The thumbprint...&quot; | Export-PfxCertificate -FilePath C:\git\AspNetCoreCertificateAuth\Certs\child_a_dev_damienbod.pfx -Password $mypwd

Export-Certificate -Cert cert:\localMachine\my\&quot;The thumbprint...&quot; -FilePath child_a_dev_damienbod.crt

</pre>
<p><strong>Server Setup</strong></p>
<p>Now that the certificates are setup, the applications are created like in the previous <a href="https://damienbod.com/2019/06/13/certificate-authentication-in-asp-net-core-3-0/">blog</a>. The AddAuthentication is configured to only accept CertificateTypes.Chained and the RevocationMode is set to NoCheck because we are using self signed chained certificates.</p>
<pre class="brush: csharp; title: ; notranslate">
services.AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)
	.AddCertificate(options =&gt; // code from ASP.NET Core sample
	{
		options.AllowedCertificateTypes = CertificateTypes.Chained;
		options.RevocationMode = X509RevocationMode.NoCheck;

		options.Events = new CertificateAuthenticationEvents
		{
			OnCertificateValidated = context =&gt;
			{
				var validationService =
					context.HttpContext.RequestServices.GetService&lt;MyCertificateValidationService&gt;();

				if (validationService.ValidateCertificate(context.ClientCertificate))
				{
					var claims = new[]
					{
						new Claim(ClaimTypes.NameIdentifier, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer),
						new Claim(ClaimTypes.Name, context.ClientCertificate.Subject, ClaimValueTypes.String, context.Options.ClaimsIssuer)
					};

					context.Principal = new ClaimsPrincipal(new ClaimsIdentity(claims, context.Scheme.Name));
					context.Success();
				}
				else
				{
					context.Fail(&quot;invalid cert&quot;);
				}

				return Task.CompletedTask;
			}
		};
	});

</pre>
<p>The application is configured in the program class to use the root certificate to validate the requests.</p>
<pre class="brush: csharp; title: ; notranslate">
public static IWebHost BuildWebHost(string[] args)
	=&gt; WebHost.CreateDefaultBuilder(args)
	.UseStartup&lt;Startup&gt;()
	.ConfigureKestrel(options =&gt;
	{
		var cert = new X509Certificate2(Path.Combine(&quot;root_ca_dev_damienbod.pfx&quot;), &quot;1234&quot;);
		options.ConfigureHttpsDefaults(o =&gt;
		{
			o.ServerCertificate = cert;
			o.ClientCertificateMode = ClientCertificateMode.RequireCertificate;
		});
	})
	.Build();
</pre>
<p>The custom validation can then be added to the MyCertificateValidationService class. Here the client certificates are validated against the root certificate, or the intermediate certificate. This change be extended to use a dynamic list of Issuers and Subjects so that certificates can be activated or deactivated at runtime.</p>
<pre class="brush: csharp; title: ; notranslate">
using System.IO;
using System.Security.Cryptography.X509Certificates;

namespace AspNetCoreCertificateAuthApi
{
    public class MyCertificateValidationService
    {
        private readonly X509Certificate2 rootCertificate = new X509Certificate2(Path.Combine(&quot;root_ca_dev_damienbod.pfx&quot;), &quot;1234&quot;);
        private readonly X509Certificate2 intermediateCertificate = new X509Certificate2(Path.Combine(&quot;child_a_dev_damienbod.pfx&quot;), &quot;1234&quot;);

        public bool ValidateCertificate(X509Certificate2 clientCertificate)
        {
            if (clientCertificate.Issuer == rootCertificate.Issuer || 
                clientCertificate.Issuer == intermediateCertificate.Subject)
            {
                return true;
            }

            return false;
        }
    }
}

</pre>
<p><strong>Client Code</strong></p>
<p>The client application is then setup to send the client certificate in the X-ARR-ClientCert request header. The server API is configured to use this to receive the certificates from the client. Now the chained certificates can be used to get access to the API.</p>
<pre class="brush: csharp; title: ; notranslate">
private async Task&lt;JArray&gt; GetApiDataAsyncChained()
{
	try
	{
		// This is a child created from the root cert, must work
		//var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, &quot;child_a_dev_damienbod.pfx&quot;), &quot;1234&quot;);

		// This is a child created from the intermediate certificate 
		// which is a cert created from the root cert, must work
		var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, &quot;child_b_from_a_dev_damienbod.pfx&quot;), &quot;1234&quot;);

		// This is a NOT child of the root cert or the intermediate certificate
		// , must fail
		//var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, &quot;sts_dev_cert.pfx&quot;), &quot;1234&quot;);

		var client = _clientFactory.CreateClient();

		var request = new HttpRequestMessage()
		{
			RequestUri = new Uri(&quot;https://localhost:44378/api/values&quot;),
			Method = HttpMethod.Get,
		};

		request.Headers.Add(&quot;X-ARR-ClientCert&quot;, cert.GetRawCertDataString());
		var response = await client.SendAsync(request);

		if (response.IsSuccessStatusCode)
		{
			var responseContent = await response.Content.ReadAsStringAsync();
			var data = JArray.Parse(responseContent);

			return data;
		}

		throw new ApplicationException($&quot;Status code: {response.StatusCode}, Error: {response.ReasonPhrase}&quot;);
	}
	catch (Exception e)
	{
		throw new ApplicationException($&quot;Exception {e}&quot;);
	}
}
</pre>
<p>See the github code for the full working example. By using chained certificates, new certificates can be created on the fly for usage with new API clients, and the root certificate does not need to be deployed. This would become really useful when securing APIs which are not always connected to the internet, or with distributed devices.</p>
<p><strong>Links</strong></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/working-with-certificates">https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/working-with-certificates</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/how-to-create-temporary-certificates-for-use-during-development">https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/how-to-create-temporary-certificates-for-use-during-development</a></p>
<blockquote class="wp-embedded-content"><p><a href="https://blog.davidchristiansen.com/2016/09/howto-create-self-signed-certificates-with-powershell/">HowTo: Create Self-Signed Certificates with PowerShell</a></p></blockquote> <p><a href="https://dotnetcodr.com/2015/06/01/https-and-x509-certificates-in-net-part-2-creating-self-signed-certificates/">HTTPS and X509 certificates in .NET Part 2: creating self-signed&#xA0;certificates</a></p>
<p><a href="https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core">https://www.humankode.com/asp-net-core/develop-locally-with-https-self-signed-certificates-and-asp-net-core</a></p>
<p><a href="https://damienbod.com/2018/09/21/deploying-an-asp-net-core-application-to-windows-iis/">https://damienbod.com/2018/09/21/deploying-an-asp-net-core-application-to-windows-iis/</a></p>
<p><a href="https://docs.microsoft.com/en-us/powershell/module/pkiclient/new-selfsignedcertificate?view=win10-ps">https://docs.microsoft.com/en-us/powershell/module/pkiclient/new-selfsignedcertificate?view=win10-ps</a></p>
<p><a href="https://github.com/damienbod/IdentityServer4AspNetCoreIdentityTemplate#using-powershell-to-create-the-self-signed-certs">https://github.com/damienbod/IdentityServer4AspNetCoreIdentityTemplate#using-powershell-to-create-the-self-signed-certs</a></p>
<p><a href="https://dotnetcodr.com/2016/01/25/using-client-certificates-in-net-part-5-working-with-client-certificates-in-a-web-project/">Using client certificates in .NET part 5: working with client certificates in a web&#xA0;project</a></p>
<p><a href="https://stackoverflow.com/questions/42623080/how-to-validate-a-certificate-chain-from-a-specific-root-ca-in-c-sharp">https://stackoverflow.com/questions/42623080/how-to-validate-a-certificate-chain-from-a-specific-root-ca-in-c-sharp</a></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-3.0</a></p>
<p><a href="https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the">https://social.msdn.microsoft.com/Forums/SqlServer/en-US/5ed119ef-1704-4be4-8a4f-ef11de7c8f34/a-certificate-chain-processed-but-terminated-in-a-root-certificate-which-is-not-trusted-by-the</a></p>
<p><a href="https://tools.ietf.org/html/rfc3280.html">https://tools.ietf.org/html/rfc3280.html</a></p>
<p><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src">https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/Certificate/src</a></p>
<p><a href="https://tools.ietf.org/html/rfc5246#section-7.4.4">https://tools.ietf.org/html/rfc5246#section-7.4.4</a></p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>