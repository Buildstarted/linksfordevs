<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Peephole optimizations in C&#x2B;&#x2B; and C# | Egor Bogatov &#x2014; Developer at Microsoft -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Peephole optimizations in C&#x2B;&#x2B; and C# | Egor Bogatov &#x2014; Developer at Microsoft</h1>
    <body> <p class="wrapper"> <aside class="user-profile fixed"> <p class="about-me">C#, C++, performance</p> </aside> <main class="the-content"> <article class="post single"> <div class="post-content"> <blockquote> <p>&#x201C;Performance gains due to improvements in compiler optimizations will double <br>
the speed of a program every 18 years&#x201D; &#xA9; <a href="http://proebsting.cs.arizona.edu/law.html">Proebsting&#x2019;s Law</a></p>
</blockquote> <p>When we solve equations, we try to simplify them first, e.g. <code class="highlighter-rouge">Y = -(5 - X)</code> can be simplified to just <code class="highlighter-rouge">Y = X - 5</code>. In modern compilers it&#x2019;s called &#x201C;Peephole Optimizations&#x201D;. Roughly speaking, compilers search for certain patterns and replace them with corresponding simplified expressions. In this blog post I&#x2019;ll list some of them which I found in LLVM, GCC and .NET Core (CoreCLR) sources.</p> <p>Let&#x2019;s start with simple cases:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre> <span class="n">X</span> <span class="p">*</span> <span class="m">1</span> <span class="p">=&gt;</span> <span class="n">X</span> <span class="p">-</span><span class="n">X</span> <span class="p">*</span> <span class="p">-</span><span class="n">Y</span> <span class="p">=&gt;</span> <span class="n">X</span> <span class="p">*</span> <span class="n">Y</span>
<span class="p">-(</span><span class="n">X</span> <span class="p">-</span> <span class="n">Y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Y</span> <span class="p">-</span> <span class="n">X</span> <span class="n">X</span> <span class="p">*</span> <span class="n">Z</span> <span class="p">-</span> <span class="n">Y</span> <span class="p">*</span> <span class="n">Z</span> <span class="p">=&gt;</span> <span class="n">Z</span> <span class="p">*</span> <span class="p">(</span><span class="n">X</span> <span class="p">-</span> <span class="n">Y</span><span class="p">)</span></pre></td></tr></tbody></table></code></pre></figure> <p>and check the 4th one in C++ and C# compilers:</p> <figure class="highlight"><pre><code class="language-csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">z</span> <span class="p">-</span> <span class="n">y</span> <span class="p">*</span> <span class="n">z</span><span class="p">;</span> <span class="c1">// =&gt; z * (x - y)</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure> <p>Now let&#x2019;s take a look at what the compilers output:</p>
<figure class="alignleft"> <figure class="highlight"><pre><code class="language-nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">Test</span><span class="p">(</span><span class="k">int</span><span class="p">,</span> <span class="k">int</span><span class="p">,</span> <span class="k">int</span><span class="p">)</span><span class="o">:</span> <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">edi</span> <span class="k">sub</span> <span class="n">eax</span><span class="p">,</span> <span class="n">esi</span> <span class="c">; - </span> <span class="k">imul</span> <span class="n">eax</span><span class="p">,</span> <span class="n">edx</span> <span class="c">; * </span> <span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure> <figcaption>C++ (Clang, GCC, MSVC)</figcaption>
</figure> <figure class="alignleft"> <figure class="highlight"><pre><code class="language-nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">C</span><span class="p">.</span><span class="n">Test</span><span class="p">(</span><span class="n">Int32</span><span class="p">,</span> <span class="n">Int32</span><span class="p">,</span> <span class="n">Int32</span><span class="p">)</span> <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">edx</span> <span class="k">imul</span> <span class="n">eax</span><span class="p">,</span> <span class="n">r9d</span> <span class="c">; *</span> <span class="k">imul</span> <span class="n">r8d</span><span class="p">,</span> <span class="n">r9d</span> <span class="c">; *</span> <span class="k">sub</span> <span class="n">eax</span><span class="p">,</span> <span class="n">r8d</span> <span class="c">; -</span> <span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure> <figcaption>C# (RyuJIT)</figcaption>
</figure>
<figure class="aligncenter">
</figure> <p>All three C++ compilers have just one <code class="highlighter-rouge">imul</code> instruction. C# (.NET Core) has two because it has a very limited set of available peephole optimizations and I&#x2019;ll list some of them later. Be sure to note, the entire InstCombine transformation implementation, where peephole optimizations live, in LLVM takes more than 30K lines of code (+20k LOC in DAGCombiner.cpp). By the way, <a href="https://github.com/llvm-mirror/llvm/blob/45adfa50b3fddb97d7fc512cec80e48c551f3280/lib/Transforms/InstCombine/InstCombineAddSub.cpp#L1329-L1332">here is the piece of code in LLVM</a> responsible for the pattern we are inspecting now. GCC has a special DSL which describes all peephole optimizations, and <a href="https://github.com/gcc-mirror/gcc/blob/5882c51592109e2e228d3c675792f891a09b43d6/gcc/match.pd#L2185-L2220">here is the piece of that DSL</a> for our case.</p> <p>I decided, just for this blog post, to try to implement this optimization for C# in JIT (hold my beer &#x1F61B;):</p>
<figure class="aligncenter"> <img src="/images/instcombine/jit-1.png">
</figure>
<p><br>
Let&#x2019;s now test my JIT improvement (see <a href="https://github.com/EgorBo/coreclr/commit/3d0abaa2c9919a48110a66b3fe19c7abed2bf041">EgorBo/coreclr</a> commit for more details) in VS2019 with Disasmo:
</p></div></article></main></p>
<figure class="aligncenter"> <img src="/images/instcombine/jit-2.png"> <figcaption>lea + imul instead of imul + imul + add</figcaption>
</figure> <p>Let&#x2019;s go back to C++ and trace the optimization in Clang. We need to ask clang to emit LLVM IR for our C++ code via <code class="highlighter-rouge">-emit-llvm -g0</code> flags (see <a href="https://godbolt.org/z/RZQTDV">godbolt.org</a>) and then give it to the LLVM optimizer <strong>opt</strong> via <code class="highlighter-rouge">-O2 -print-before-all -print-after-all</code> flags in order to find out what transformation actually removes that extra multiplication from the <code class="highlighter-rouge">-O2</code> set. (see <a href="https://godbolt.org/z/3f0TyT">godbolt.org</a>):</p> <figure class="aligncenter"> <figure class="highlight"><pre><code class="language-llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><p class="c1">; *** IR Dump Before Combine redundant instructions ***</p>
<p class="k">define</p> <p class="err">dso_lo</p><p class="k">c</p><p class="err">al</p> <p class="kt">i32</p> <p class="vg">@_Z5Case1iii</p><p class="p">(</p><p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">)</p> <p class="p">{</p> <p class="nv">%4</p> <p class="p">=</p> <p class="k">mul</p> <p class="k">nsw</p> <p class="kt">i32</p> <p class="nv">%0</p><p class="p">,</p> <p class="nv">%2</p> <p class="nv">%5</p> <p class="p">=</p> <p class="k">mul</p> <p class="k">nsw</p> <p class="kt">i32</p> <p class="nv">%1</p><p class="p">,</p> <p class="nv">%2</p> <p class="nv">%6</p> <p class="p">=</p> <p class="k">sub</p> <p class="k">nsw</p> <p class="kt">i32</p> <p class="nv">%4</p><p class="p">,</p> <p class="nv">%5</p> <p class="k">ret</p> <p class="kt">i32</p> <p class="nv">%6</p>
<p class="p">}</p> <p class="c1">; *** IR Dump After Combine redundant instructions ***</p>
<p class="k">define</p> <p class="err">dso_lo</p><p class="k">c</p><p class="err">al</p> <p class="kt">i32</p> <p class="vg">@_Z5Case1iii</p><p class="p">(</p><p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">)</p> <p class="p">{</p> <p class="nv">%4</p> <p class="p">=</p> <p class="k">sub</p> <p class="kt">i32</p> <p class="nv">%0</p><p class="p">,</p> <p class="nv">%1</p> <p class="nv">%5</p> <p class="p">=</p> <p class="k">mul</p> <p class="kt">i32</p> <p class="nv">%4</p><p class="p">,</p> <p class="nv">%2</p> <p class="k">ret</p> <p class="kt">i32</p> <p class="nv">%5</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <figcaption>It&apos;s InstCombine!</figcaption>
</figure> <p>So it&#x2019;s InstCombine indeed, we can even use it as the only optimization for our code for tests via <code class="highlighter-rouge">-instcombine</code> flag passed to <code class="highlighter-rouge">opt</code>:</p>
<figure class="aligncenter"> <img src="/images/instcombine/p2.png">
</figure> <p>Let&#x2019;s go back to the examples. Look what a cute optimization I found in GCC sources:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">X</p> <p class="o">==</p> <p class="n">C</p> <p class="o">-</p> <p class="n">X</p> <p class="o">=&gt;</p> <p class="nb">false</p> <p class="k">if</p> <p class="n">C</p> <p class="n">is</p> <p class="n">odd</p></pre></td></tr></tbody></table></code></pre></figure> <p>And that&#x2019;s true, e.g.: <code class="highlighter-rouge">4 == 8 - 4</code>. Any odd number for C (C usually means a constant/literal) will always be false for the expression:</p>
<figure class="aligncenter"> <img src="/images/instcombine/p3.png"> <figcaption>Foo2(int x) always returns false. LLVM doesn&apos;t have this optimization.</figcaption>
</figure> <h3 id="optimizations-vs-ieee754">Optimizations vs IEEE754</h3> <p>Lots of this type of optimizations work for different data types, e.g. <code class="highlighter-rouge">byte</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">unsigned</code>, <code class="highlighter-rouge">float</code>. The latter is a bit tricky e.g. you can&#x2019;t simplify <code class="highlighter-rouge">A - B - A</code> to <code class="highlighter-rouge">-B</code> for floats/doubles, even <code class="highlighter-rouge">(A * B) * C</code> is not equal to <code class="highlighter-rouge">A * (B * C)</code> due to the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754 specification</a>. However, C++ compilers have a special flag to let the optimizers be less strict around IEEE754, NaN and other FP corner cases and just apply all of the optimizations - it&#x2019;s usually called &#x201C;Fast Math&#x201D; (<code class="highlighter-rouge">-ffast-math</code> for clang and gcc, <code class="highlighter-rouge">/fp:fast</code> for MSVC). Btw, here you can find my feature request for .NET Core to introduce the &#x201C;Fast Math&#x201D; mode there: <a href="https://github.com/dotnet/coreclr/issues/24784">dotnet/coreclr#24784</a>).</p> <p>As you can see, two <code class="highlighter-rouge">vsubss</code> were eliminated in the <code class="highlighter-rouge">-ffast-math</code> mode:</p>
<figure class="aligncenter"> <img src="/images/instcombine/p5.png"> <figcaption></figcaption>
</figure> <p>The C++ optimizers also support <code class="highlighter-rouge">math.h</code> functions, e.g.:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">abs</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">*</p> <p class="n">abs</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">*</p> <p class="n">X</p></pre></td></tr></tbody></table></code></pre></figure> <p>The square root is always positive:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">&lt;</p> <p class="n">Y</p> <p class="o">=&gt;</p> <p class="nb">false</p><p class="p">,</p> <p class="k">if</p> <p class="n">Y</p> <p class="n">is</p> <p class="n">negative</p><p class="p">.</p>
<p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">&lt;</p> <p class="mi">0</p> <p class="o">=&gt;</p> <p class="nb">false</p></pre></td></tr></tbody></table></code></pre></figure> <p>Why should we calculate sqrt(X) if we can just calculate C^2 in compile time instead?:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">&gt;</p> <p class="n">C</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&gt;</p> <p class="n">C</p> <p class="o">*</p> <p class="n">C</p></pre></td></tr></tbody></table></code></pre></figure> <p> <figure class="aligncenter"> <img src="/images/instcombine/sqrt.png">
</figure>
</p><p>More sqrt optimizations:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">==</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">Y</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">==</p> <p class="n">Y</p>
<p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">*</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p>
<p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">*</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">Y</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">X</p> <p class="o">*</p> <p class="n">Y</p><p class="p">)</p>
<p class="n">logN</p><p class="p">(</p><p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">))</p> <p class="o">=&gt;</p> <p class="mi">0</p><p class="p">.</p><p class="mi">5</p> <p class="o">*</p> <p class="n">logN</p><p class="p">(</p><p class="n">X</p><p class="p">)</p></pre></td></tr></tbody></table></code></pre></figure> <p>or <code class="highlighter-rouge">exp</code>:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">exp</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">*</p> <p class="n">exp</p><p class="p">(</p><p class="n">Y</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">exp</p><p class="p">(</p><p class="n">X</p> <p class="o">+</p> <p class="n">Y</p><p class="p">)</p></pre></td></tr></tbody></table></code></pre></figure> <p>And my favorite one:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">sin</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">/</p> <p class="n">cos</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">tan</p><p class="p">(</p><p class="n">X</p><p class="p">)</p></pre></td></tr></tbody></table></code></pre></figure> <p> <figure class="aligncenter"> <img src="/images/instcombine/p6.png"> <figcaption></figcaption>
</figure> </p><p>There are lots of boring bit/bool patterns:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><p class="p">((</p><p class="n">a</p> <p class="o">^</p> <p class="n">b</p><p class="p">)</p> <p class="o">|</p> <p class="n">a</p><p class="p">)</p> <p class="o">-&gt;</p> <p class="p">(</p><p class="n">a</p> <p class="o">|</p> <p class="n">b</p><p class="p">)</p>
<p class="p">(</p><p class="n">a</p> <p class="o">&amp;</p> <p class="o">~</p><p class="n">b</p><p class="p">)</p> <p class="o">|</p> <p class="p">(</p><p class="n">a</p> <p class="o">^</p> <p class="n">b</p><p class="p">)</p> <p class="o">--&gt;</p> <p class="n">a</p> <p class="o">^</p> <p class="n">b</p>
<p class="p">((</p><p class="n">a</p> <p class="o">^</p> <p class="n">b</p><p class="p">)</p> <p class="o">|</p> <p class="n">a</p><p class="p">)</p> <p class="o">-&gt;</p> <p class="p">(</p><p class="n">a</p> <p class="o">|</p> <p class="n">b</p><p class="p">)</p>
<p class="p">(</p><p class="n">X</p> <p class="o">&amp;</p> <p class="o">~</p><p class="n">Y</p><p class="p">)</p> <p class="o">|^+</p> <p class="p">(</p><p class="o">~</p><p class="n">X</p> <p class="o">&amp;</p> <p class="n">Y</p><p class="p">)</p> <p class="o">-&gt;</p> <p class="n">X</p> <p class="o">^</p> <p class="n">Y</p>
<p class="n">A</p> <p class="o">-</p> <p class="p">(</p><p class="n">A</p> <p class="o">&amp;</p> <p class="n">B</p><p class="p">)</p> <p class="n">into</p> <p class="o">~</p><p class="n">B</p> <p class="o">&amp;</p> <p class="n">A</p>
<p class="n">X</p> <p class="o">&lt;=</p> <p class="n">Y</p> <p class="o">-</p> <p class="mi">1</p> <p class="n">equals</p> <p class="n">to</p> <p class="n">X</p> <p class="o">&lt;</p> <p class="n">Y</p>
<p class="n">A</p> <p class="o">&lt;</p> <p class="n">B</p> <p class="o">||</p> <p class="n">A</p> <p class="o">&gt;=</p> <p class="n">B</p> <p class="o">-&gt;</p> <p class="nb">true</p>
<p class="p">...</p> <p class="n">hundreds</p> <p class="n">of</p> <p class="n">them</p> <p class="p">...</p></pre></td></tr></tbody></table></code></pre></figure> <h3 id="machine-dependent-optimizations">Machine-dependent optimizations</h3> <p>Some operations may be faster or slower on different CPUs, e.g.:</p> <figure class="highlight"><pre><code class="language-c"></code></pre></figure> <p> <figure class="aligncenter"> <img src="/images/instcombine/p8.png"> <figcaption></figcaption>
</figure> </p><p><code class="highlighter-rouge">mulss</code>/<code class="highlighter-rouge">mulsd</code> usually have better both latency and throughput than <code class="highlighter-rouge">divss</code>/<code class="highlighter-rouge">divsd</code> for example, here is the spec for my Intel Haswell CPU:</p>
<figure class="aligncenter"> <img src="/images/instcombine/p7.png"> <figcaption></figcaption>
</figure> <p>We can replace <code class="highlighter-rouge">/ C</code> with <code class="highlighter-rouge">* 1/C</code> even in the non-&#x201C;Fast Math&#x201D; mode if <code class="highlighter-rouge">C</code> is a power of two. Btw, here is my PR for .NET Core for this optimization: <a href="https://github.com/dotnet/coreclr/pull/24584">dotnet/coreclr#24584</a>.</p> <p>The same rationale for:</p> <figure class="highlight"><pre><code class="language-cpp"></code></pre></figure> <p><code class="highlighter-rouge">test</code> is better than <code class="highlighter-rouge">cmp</code> (see my PR <a href="https://github.com/dotnet/coreclr/pull/25458">dotnet/coreclr#25458</a> for more details):</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><p class="n">X</p> <p class="o">&gt;=</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&gt;</p> <p class="mi">0</p>
<p class="n">X</p> <p class="o">&lt;</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&lt;=</p> <p class="mi">0</p>
<p class="n">X</p> <p class="o">&lt;=</p> <p class="o">-</p><p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&gt;=</p> <p class="mi">0</p>
<p class="n">X</p> <p class="o">&gt;</p> <p class="o">-</p><p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&gt;=</p> <p class="mi">0</p></pre></td></tr></tbody></table></code></pre></figure> <p>And what do you think about these ones?:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><p class="n">pow</p><p class="p">(</p><p class="n">X</p><p class="p">,</p> <p class="mf">0.5</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">x</p><p class="p">)</p>
<p class="n">pow</p><p class="p">(</p><p class="n">X</p><p class="p">,</p> <p class="mf">0.25</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">sqrt</p><p class="p">(</p><p class="n">sqrt</p><p class="p">(</p><p class="n">X</p><p class="p">))</p>
<p class="n">pow</p><p class="p">(</p><p class="n">X</p><p class="p">,</p> <p class="mi">2</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">*</p> <p class="n">X</p> <p class="p">;</p> <p class="mi">1</p> <p class="n">mul</p>
<p class="n">pow</p><p class="p">(</p><p class="n">X</p><p class="p">,</p> <p class="mi">3</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">*</p> <p class="n">X</p> <p class="o">*</p> <p class="n">X</p> <p class="p">;</p> <p class="mi">2</p> <p class="n">mul</p></pre></td></tr></tbody></table></code></pre></figure> <p> <figure class="aligncenter"> <img src="/images/instcombine/p9.png">
</figure> </p><p><br>
How many <code class="highlighter-rouge">mul</code> are needed to perform <code class="highlighter-rouge">pow(X, 4)</code> or <code class="highlighter-rouge">X * X * X * X</code>?</p>
<figure class="aligncenter"> <img src="/images/instcombine/pow4.png">
</figure>
<p>Just 2! Just like for <code class="highlighter-rouge">pow(X, 3)</code> and unlike <code class="highlighter-rouge">pow(X, 3)</code> we don&#x2019;t even use the <code class="highlighter-rouge">xmm1</code> register.</p> <p><br>
Modern CPUs support a special FMA instruction to perform <code class="highlighter-rouge">mul</code> and <code class="highlighter-rouge">add</code> in just one step without an intermediate rounding operation for <code class="highlighter-rouge">mul</code>:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">X</p> <p class="o">*</p> <p class="n">Y</p> <p class="o">+</p> <p class="n">Z</p> <p class="o">=&gt;</p> <p class="n">fmadd</p><p class="p">(</p><p class="n">X</p><p class="p">,</p> <p class="n">Y</p><p class="p">,</p> <p class="n">Z</p><p class="p">)</p></pre></td></tr></tbody></table></code></pre></figure> <p> <figure class="aligncenter"> <img src="/images/instcombine/p11.png">
</figure> </p><p><br>
Sometimes compilers are able to replace entire algorithms with just one CPU instruction, e.g.:</p>
<figure class="aligncenter"> <img src="/images/instcombine/p12.png">
</figure> <h3 id="traps-for-optimizations">Traps for optimizations</h3>
<p>We can&#x2019;t just find patterns &amp; optimize them:</p>
<ul> <li>There is a risk to break some code: there are always corner-cases, hidden side-effects. LLVM&#x2019;s bugzilla contains lots of InstCombine bugs.</li> <li>An expression or its parts we want to simplify might be used somewhere else.</li>
</ul> <p>I borrowed a nice example for the second issue from <a href="https://arxiv.org/pdf/1809.02161.pdf">&#x201C;Future Directions for Optimizing Compilers&#x201D;</a> article.<br>
Imagine we have a function:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><p class="kt">int</p> <p class="nf">Foo1</p><p class="p">(</p><p class="kt">int</p> <p class="n">a</p><p class="p">,</p> <p class="kt">int</p> <p class="n">b</p><p class="p">)</p> <p class="p">{</p> <p class="kt">int</p> <p class="n">na</p> <p class="o">=</p> <p class="o">-</p><p class="n">a</p><p class="p">;</p> <p class="kt">int</p> <p class="n">nb</p> <p class="o">=</p> <p class="o">-</p><p class="n">b</p><p class="p">;</p> <p class="k">return</p> <p class="n">na</p> <p class="o">+</p> <p class="n">nb</p><p class="p">;</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>We need to perform 3 operations here: <code class="highlighter-rouge">0 - a</code>, <code class="highlighter-rouge">0 - b</code>, &#x438; <code class="highlighter-rouge">na + nb</code>. LLVM simplifies it to just two operations: <code class="highlighter-rouge">return -(a + b)</code> - what a smart move, here is the IR:</p> <figure class="highlight"><pre><code class="language-llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><p class="k">define</p> <p class="err">dso_lo</p><p class="k">c</p><p class="err">al</p> <p class="kt">i32</p> <p class="vg">@_Z4Foo1ii</p><p class="p">(</p><p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">)</p> <p class="p">{</p> <p class="nv">%3</p> <p class="p">=</p> <p class="k">add</p> <p class="kt">i32</p> <p class="nv">%0</p><p class="p">,</p> <p class="nv">%1</p> <p class="c1">; a + b</p> <p class="nv">%4</p> <p class="p">=</p> <p class="k">sub</p> <p class="kt">i32</p> <p class="m">0</p><p class="p">,</p> <p class="nv">%3</p> <p class="c1">; 0 - %3</p> <p class="k">ret</p> <p class="kt">i32</p> <p class="nv">%4</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>Now imagine that we need to store values of <code class="highlighter-rouge">na</code> and <code class="highlighter-rouge">nb</code> in some global variables, e.g. <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>:</p> <figure class="highlight"><pre><code class="language-c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><p class="kt">int</p> <p class="n">x</p><p class="p">,</p> <p class="n">y</p><p class="p">;</p> <p class="kt">int</p> <p class="nf">Foo2</p><p class="p">(</p><p class="kt">int</p> <p class="n">a</p><p class="p">,</p> <p class="kt">int</p> <p class="n">b</p><p class="p">)</p> <p class="p">{</p> <p class="kt">int</p> <p class="n">na</p> <p class="o">=</p> <p class="o">-</p><p class="n">a</p><p class="p">;</p> <p class="kt">int</p> <p class="n">nb</p> <p class="o">=</p> <p class="o">-</p><p class="n">b</p><p class="p">;</p> <p class="n">x</p> <p class="o">=</p> <p class="n">na</p><p class="p">;</p> <p class="n">y</p> <p class="o">=</p> <p class="n">nb</p><p class="p">;</p> <p class="k">return</p> <p class="n">na</p> <p class="o">+</p> <p class="n">nb</p><p class="p">;</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>The optimizer still recognizes the pattern and simplifies it by removing redundant (from its point of view) <code class="highlighter-rouge">0 - a</code> and <code class="highlighter-rouge">0 - b</code> operations. But we do need them! We save them to the global variables! Thus, it leads to this:</p> <figure class="highlight"><pre><code class="language-llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><p class="k">define</p> <p class="err">dso_lo</p><p class="k">c</p><p class="err">al</p> <p class="kt">i32</p> <p class="vg">@_Z4Foo2ii</p><p class="p">(</p><p class="kt">i32</p><p class="p">,</p> <p class="kt">i32</p><p class="p">)</p> <p class="p">{</p> <p class="nv">%3</p> <p class="p">=</p> <p class="k">sub</p> <p class="k">nsw</p> <p class="kt">i32</p> <p class="m">0</p><p class="p">,</p> <p class="nv">%0</p> <p class="c1">; 0 - a </p> <p class="nv">%4</p> <p class="p">=</p> <p class="k">sub</p> <p class="k">nsw</p> <p class="kt">i32</p> <p class="m">0</p><p class="p">,</p> <p class="nv">%1</p> <p class="c1">; 0 - b</p> <p class="k">store</p> <p class="kt">i32</p> <p class="nv">%3</p><p class="p">,</p> <p class="kt">i32</p><p class="p">*</p> <p class="vg">@x</p><p class="p">,</p> <p class="k">align</p> <p class="m">4</p><p class="p">,</p> <p class="nv">!tbaa</p> <p class="nv">!2</p> <p class="k">store</p> <p class="kt">i32</p> <p class="nv">%4</p><p class="p">,</p> <p class="kt">i32</p><p class="p">*</p> <p class="vg">@y</p><p class="p">,</p> <p class="k">align</p> <p class="m">4</p><p class="p">,</p> <p class="nv">!tbaa</p> <p class="nv">!2</p> <p class="nv">%5</p> <p class="p">=</p> <p class="k">add</p> <p class="kt">i32</p> <p class="nv">%0</p><p class="p">,</p> <p class="nv">%1</p> <p class="c1">; a + b</p> <p class="nv">%6</p> <p class="p">=</p> <p class="k">sub</p> <p class="kt">i32</p> <p class="m">0</p><p class="p">,</p> <p class="nv">%5</p> <p class="c1">; 0 - %5</p> <p class="k">ret</p> <p class="kt">i32</p> <p class="nv">%6</p>
<p class="p">}</p></pre></td></tr></tbody></table></code></pre></figure> <p>4 math operations instead of 3! The optimizer has just made our code a bit slower.
Now let&#x2019;s see what C# RuyJIT generates for this case:</p> <figure class="aligncenter"> <img src="/images/instcombine/p10.png">
</figure> <p>RuyJIT doesn&#x2019;t have this optimization so the code contains only 3 operations :-) C# is faster than C++! :p</p> <h3 id="do-we-really-need-these-optimizations">Do we really need these optimizations?</h3>
<p>Well, you never know what the final code will look like after inlining, constant folding, copy propagation, CSE, etc.<br>
Also, both LLVM IR and .NET IL are not tied to a specific programming language and can&#x2019;t rely on quality of the IR it generates. And you can just run your app/lib with <code class="highlighter-rouge">InstCombine</code> pass on and off to measure the performance impact.</p> <h3 id="what-about-c">What about C#?</h3>
<p>As I said earlier, peephole optimizations are very limited in C# at the moment. However, when I say &#x201C;C#&#x201D; I mean the most popular C# runtime - CoreCLR with RuyJIT. But there are more, including those, using LLVM as a backend: Mono (see my <a href="https://twitter.com/EgorBo/status/1063468884257316865">tweet</a>), Unity Burst and LILLC - these runtimes basically use exactly the same optimizations as clang does. Unity guys are even considering <a href="https://lucasmeijer.com/posts/cpp_unity/">replacing C++ with C#</a> in their internal parts. By the way, since .NET 5 will include Mono as an optional built-in runtime - you will be able to use LLVM power for such cases.</p> <p>Back to CoreCLR - here are the peephole optimizations I managed to find in comments in <code class="highlighter-rouge">morph.cpp</code> (I am sure there are more):</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><p class="o">*</p><p class="p">(</p><p class="o">&amp;</p><p class="n">X</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="n">X</p>
<p class="n">X</p> <p class="o">%</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="mi">0</p>
<p class="n">X</p> <p class="o">/</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p>
<p class="n">X</p> <p class="o">%</p> <p class="n">Y</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">-</p> <p class="p">(</p><p class="n">X</p> <p class="o">/</p> <p class="n">Y</p><p class="p">)</p> <p class="o">*</p> <p class="n">Y</p>
<p class="n">X</p> <p class="o">^</p> <p class="o">-</p><p class="mi">1</p> <p class="o">=&gt;</p> <p class="o">~</p><p class="n">x</p>
<p class="n">X</p> <p class="o">&gt;=</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&gt;</p> <p class="mi">0</p> <p class="n">X</p> <p class="o">&lt;</p> <p class="mi">1</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">&lt;=</p> <p class="mi">0</p>
<p class="n">X</p> <p class="o">+</p> <p class="err">&#x421;</p><p class="mi">1</p> <p class="o">==</p> <p class="n">C2</p> <p class="o">=&gt;</p> <p class="n">X</p> <p class="o">==</p> <p class="n">C2</p> <p class="o">-</p> <p class="n">C1</p>
<p class="p">((</p><p class="n">X</p> <p class="o">+</p> <p class="n">C1</p><p class="p">)</p> <p class="o">+</p> <p class="n">C2</p><p class="p">)</p> <p class="o">=&gt;</p> <p class="p">(</p><p class="n">X</p> <p class="o">+</p> <p class="p">(</p><p class="n">C1</p> <p class="o">+</p> <p class="n">C2</p><p class="p">))</p>
<p class="p">((</p><p class="n">X</p> <p class="o">+</p> <p class="n">C1</p><p class="p">)</p> <p class="o">+</p> <p class="p">(</p><p class="n">Y</p> <p class="o">+</p> <p class="n">C2</p><p class="p">))</p> <p class="o">=&gt;</p> <p class="p">((</p><p class="n">X</p> <p class="o">+</p> <p class="n">Y</p><p class="p">)</p> <p class="o">+</p> <p class="p">(</p><p class="n">C1</p> <p class="o">+</p> <p class="n">C2</p><p class="p">))</p></pre></td></tr></tbody></table></code></pre></figure> <p>There are also some in <code class="highlighter-rouge">lowering.cpp</code> (machine-dependent ones) but in general RyuJIT obviously loses to &#x421;++ compilers here. RyuJIT just focuses more on different things and has a lot of requirements. The main one is - it should compile fast! it&#x2019;s called JIT after all. And it does it very well (unlike the C++ compilers - see <a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/">&#x201C;Modern&#x201D; C++ Lamentations</a>). It&#x2019;s also more important to de-virtualize calls, optimize out boxings, heap allocations (e.g. <a href="https://github.com/dotnet/coreclr/issues/20253">Object Stack Allocation</a>). However, since RyuJIT is now supporting tiers, who knows maybe there will be a place for peephole optimizations in future in the tier1 or even a separate tier2 ;-). Maybe with some sort of DSL to declare them, just read <a href="https://medium.com/@prathamesh1615/adding-peephole-optimization-to-gcc-89c329dd27b3">this</a> article where Prathamesh Kulkarni managed to declare an optimization for GCC in just a few lines of DSL:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><p class="p">(</p><p class="n">simplify</p> <p class="p">(</p><p class="n">plus</p> <p class="p">(</p><p class="n">mult</p> <p class="p">(</p><p class="n">SIN</p> <p class="err">@</p><p class="mi">0</p><p class="p">)</p> <p class="p">(</p><p class="n">SIN</p> <p class="err">@</p><p class="mi">0</p><p class="p">))</p> <p class="p">(</p><p class="n">mult</p> <p class="p">(</p><p class="n">COS</p> <p class="err">@</p><p class="mi">0</p><p class="p">)</p> <p class="p">(</p><p class="n">COS</p> <p class="err">@</p><p class="mi">0</p><p class="p">)))</p> <p class="p">(</p><p class="k">if</p> <p class="p">(</p><p class="n">flag_unsafe_math_optimizations</p><p class="p">)</p> <p class="p">{</p> <p class="n">build_one_cst</p> <p class="p">(</p><p class="n">TREE_TYPE</p> <p class="p">(</p><p class="err">@</p><p class="mi">0</p><p class="p">));</p> <p class="p">}))</p></pre></td></tr></tbody></table></code></pre></figure> <p>for the following pattern:</p> <figure class="highlight"><pre><code class="language-cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><p class="n">cos</p><p class="o">^</p><p class="mi">2</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="o">+</p> <p class="n">sin</p><p class="o">^</p><p class="mi">2</p><p class="p">(</p><p class="n">X</p><p class="p">)</p> <p class="n">equals</p> <p class="n">to</p> <p class="mi">1</p> </pre></td></tr></tbody></table></code></pre></figure> </body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>