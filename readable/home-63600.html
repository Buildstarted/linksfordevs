<!DOCTYPE html>
<html lang="en">
<head>
    <title>
home - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="home - linksfor.dev(s)"/>
    <meta property="og:description" content="Marco Bonvini&#x2019;s personal website."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://marcobonvini.com/modelica/2020/06/29/all-about-modelica.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - home</title>
<div class="readable">
        <h1>home</h1>
            <div>Reading time: 28-35 minutes</div>
        <div>Posted here: 01 Jul 2020</div>
        <p><a href="https://marcobonvini.com/modelica/2020/06/29/all-about-modelica.html">https://marcobonvini.com/modelica/2020/06/29/all-about-modelica.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    <div>
      <h2>All about Modelica</h2>
      <p>
	by <b>Marco Bonvini</b> on Monday June 29, 2020
      </p>
    <p>Early in my career, when ML and AI weren’t as cool, I fell in love with modeling and simulations.
As Joel Spolsky recently <a href="https://www.joelonsoftware.com/2020/06/18/hash-a-free-online-platform-for-modeling-the-world/">put it</a>,
sometimes you’re working on something that’s just too complicated to reason about with simple math, you can’t even begin to guess
how the inputs affect the outputs. In such cases, simulation models will help you understand better complex problems.<!--more--></p>

<p>While working with modeling and simulations, I discovered Modelica, a language for developing simulation models.
I worked <a href="https://marcobonvini.com/research">extensively</a> with Modelica, both during my Ph.D. as well as
in my first job at <a href="https://eta.lbl.gov/">Lawrence Berkeley National Laboratory</a>.
Modelica is a great tool for modeling <a href="https://en.wikipedia.org/wiki/Cyber-physical_system">cyber-physical systems</a>,
for example to study the fuel efficiency of an hybrid vehicle, or to evaluate the interactions between renewable energy sources
and the electrical grid.</p>

<p>In this post I will provide a general overview on Modelica, and I’ll showcase some of its main features.</p>

<h4 id="what-is-modelica">What is Modelica?</h4>

<p>Modelica, as the name suggests, is a modeling language.
Which type of models? Mathematical models.
Modelica does not focus on a particular application domain, and gives you the freedom
to model a variety of problems ranging from electro-mechanical systems for automotive
or aerospace applications, to financial models for banks.</p>

<p>You can use the language to create mathematical models using any combination of the
following formalisms</p>

<ul>
  <li>differential equations</li>
  <li>algebraic equations</li>
  <li>difference equations</li>
  <li>discrete event systems</li>
</ul>

<p>As you can imagine, this kind of flexibility makes it easier to tackle lots of
different and interesting engineering problems, including cyber-physical systems.
Typical examples of such systems are cars. Cars are characterized by mechanical components that interact
with electronics and hydraulic systems, all under the supervision of multiple control systems.
So if you want to know how a car is actually going to behave, you need to simulate the whole shebang.</p>

<p>Ignoring the interaction between components – a rookie mistake in the world of simulations –
would lead to a poor understanding of the system.</p>

<figure>
   <img src="https://marcobonvini.com/images/posts/hybrid-car-scheme.png" alt="A car, typical example of cyber-physical system.">
   <figcaption>
      A car, typical example of cyber-physical systems.
   </figcaption>
</figure>

<p>It’s not hard to find other examples of cyber-phyisical systems, they’re everywhere you look:</p>

<ul>
  <li>every private or public transportation vehicle – from airplanes to e-bikes</li>
  <li>the electrical grid that powers our houses</li>
  <li>data centers that process our data, etc.</li>
  <li>our homes, thanks to the increasing adoption of PV panels, batteries, EV cars, and IoT devices</li>
</ul>

<p>So, at this point you should be convinced that cyber-physical systems are a big part of
everyday life. Modelica allows engineers and scientists to model these systems accurately,
giving us a chance to improve their performance. <strong>This is why Modelica matters</strong>.</p>

<h4 id="modeling-the-real-world">Modeling the real world</h4>

<p>Ask any engineer, and they’ll tell you - “It’s tough to model the real world!”
Engineers perform a balancing act when they create models of complex
physical systems, building detailed simulations while at the same time struggling
against overwhelming complexity or irrelevant detail.</p>

<p>The Modelica modeling language has several features that make it the right choice for
modeling complex engineering systems. Modelica is not some abstract academic toy
disregarded by the modern industry.
In fact, in the last few years Modelica has been adopted by some of the world’s biggest
automotive companies – Audi, BMW, Daimler, Ford, Toyota, and VW. These companies
use Modelica to design energy efficient vehicles, improve air conditioning systems.
They Ferrari F1 team uses Modelica too for designing their racing cars!
And the automotive sector is just one of many that find this language effective.
The aerospace and energy industry are increasingly adopting Modelica, and the US Department
of Energy has been steadily investing in this technology for <a href="https://github.com/lbl-srg/modelica-buildings">modeling buildings</a>
and improving their energy efficiency.</p>

<h4 id="modelica---a-first-example">Modelica - A first example</h4>

<p>As described on the <a href="https://www.modelica.org/">Modelica association</a> website,
<em>Modelica is a non-proprietary, object-oriented, equation based language to conveniently model
complex physical systems including a variety of different aspects, including mechanical,
electrical, electronic, hydraulic, thermal, control, electric power or process-oriented subcomponents.</em></p>

<p>The following diagram shows the big picture behind any Modelica model</p>

<p><img src="https://marcobonvini.com/images/posts/modelica_toolchain.png" width="100%">
</p>


<p>The steps are the following:</p>

<ol>
  <li>an engineer/scientist writes a Modelica model that represents an idea as a series of equations,</li>
  <li>a Modelica tool analyzes the model and verifies its correctness – Does the model have the same number
 of variables and equations? Are there typos?</li>
  <li>the tool compiles the model and generates an executable</li>
  <li>run the executable to simulate the system and produce data.</li>
</ol>

<p>Before diving into some of Modelica’s core concepts let’s start with an example,
a kind of <strong>HelloWorld</strong> of differential equations. We’ll use the simplest
differential equation you can imagine</p>


<p>with initial condition </p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>HelloWorld</span>  <span>"The simplest differential equation ever"</span>
<span> 2 </span>  <span>// Define variables and parameters here...</span>
<span> 3 </span>  <span>Real</span> <span>x</span>
<span> 4 </span>    <span>"The unknown variable"</span><span>;</span>
<span> 5 </span>  <span>constant</span> <span>Real</span> <span>a</span> <span>=</span> <span>-</span><span>2.0</span>
<span> 6 </span>    <span>"Constant that characterizes the model"</span><span>;</span>
<span> 7 </span>  <span>parameter</span> <span>Real</span> <span>x_start</span> <span>=</span> <span>5.0</span>
<span> 8 </span>    <span>"Initial value of the variable x"</span><span>;</span>
<span> 9 </span><span>initial</span> <span>equation</span>
<span>10 </span>  <span>// Define initial conditions here...</span>
<span>11 </span>  <span>x</span> <span>=</span> <span>x_start</span><span>;</span>
<span>12 </span><span>equation</span>
<span>13 </span>  <span>// Write the equations here...</span>
<span>14 </span>  <span>der</span><span>(</span><span>x</span><span>)</span> <span>=</span> <span>a</span><span>*</span><span>x</span><span>;</span>
<span>15 </span><span>end</span> <span>HelloWorld</span><span>;</span></code></pre></figure>

</div>


<p>The keyword <code>model</code> defines the beginning of a model named <strong>HelloWorld</strong>.
The model is divided in three sections: declarations, initializations and equations.
The model starts by declaring variables, constants and parameters. <strong>Variables</strong> represent
quantities that are expected to change over time. <strong>Constants</strong>, meanwhile, are fixed
quantities that will never change. And finally <strong>parameters</strong> are quantities
that do not change over time but may change between simulations.
In this case parameter <code>x_start</code>, constant <code>a</code> and variable <code>x</code> have the same type,
<code>Real</code> type meaning a floating point number.</p>

<p>The keywords <code>initial equation</code> introduce the second part of our model.
Here we define the initial conditions of the system, for example the value of <code>x</code> at
the beginning of our model’s simulation time.</p>

<p>The keyword <code>equation</code> introduces the third and final part of our program,
where we finally get down to writing the equations of the system.
In this case there is one variable <code>x</code> and one differential equation <code>der(x) = a*x</code>.</p>

<p>One important thing to note is the <code>der(...)</code> operator that indicates the
time derivative of the expression inside the brackets.
The ability to express derivatives in such a clean and concise way is very helpful
when dealing with mathematical models.</p>

<h3 id="modelicas-key-principles">Modelica’s key principles</h3>

<p>So we’ve completed a simple example to get familiar with Modelica. Now, let’s look at
some of its most interesting features. As I mentioned at the beginning of the post,
Modelica is an object-oriented equation-based modeling language.
What exactly do those words mean? Let’s have a look, keeping in the context of
mathematical modeling.</p>

<h4 id="equation-based-modeling">Equation-based modeling</h4>

<p>Computer programs are nothing but clever set of instructions to let a computer solve a particular
problem for us (If this sounds familiar, bear with me. I’m going to make a distinction between
assignments and equations that you might not be familiar with).
Let’s consider the following problem: <em>given two numbers compute their sum</em>.
The following code snippet shows a solution to the problem implemented in C</p>

<div>

<figure><pre><code data-lang="c"><span></span><span>int</span> <span>main</span><span>(</span><span>void</span><span>){</span>
  <span>int</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>;</span>
  <span>a</span> <span>=</span> <span>4</span><span>;</span>
  <span>b</span> <span>=</span> <span>3</span><span>;</span>
  <span>c</span> <span>=</span> <span>a</span> <span>+</span> <span>b</span><span>;</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></pre></figure>

</div>


<p>What happens here when the program is executed is that the value 4 is inserted in the memory space
associated to variable <code>a</code>, the value 3 is inserted in the memory space
associated to variable <code>b</code> and then their sum is assigned to the memory space associated to variable <code>c</code>.</p>

<p>Given the initial problem, this program implements a particular solution to it. And, most of the
time when we write algorithms we are writing specific solutions to certain problems.
In this case the problem and its algorithmic solution were pretty straightforward!</p>

<p>Now here’s the kicker: when dealing with mathematical modeling the situation is quite different.
You typically start with a set of equations that describe the general understanding of the system
you want to model.</p>

<p>Then, you can collected data about that system, and feed it into those equations to start
generating some interesting answers to your questions. Often there are  multiple questions to answer,
so the model should be as general as possible so that it can be be easily manipulated to
answer all the questions.</p>

<p>Let’s get back to our problem: <em>given two numbers compute their sum</em>. The following
is an example of a Modelica model that solves it</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span>1 </span><span>model</span> <span>Sum</span>
<span>2 </span>   <span>Integer</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>;</span>
<span>3 </span><span>equation</span>
<span>4 </span>   <span>c</span> <span>-</span> <span>(</span><span>a</span> <span>+</span> <span>b</span><span>)</span> <span>=</span> <span>0</span><span>;</span>
<span>5 </span>   <span>a</span> <span>=</span> <span>4</span><span>;</span>
<span>6 </span>   <span>b</span> <span>-</span> <span>3</span> <span>=</span> <span>0</span><span>;</span>
<span>7 </span><span>end</span> <span>Sum</span><span>;</span></code></pre></figure>

</div>


<p>The content of line 4 is the essence of equation-based modeling. It all boils
down to two concepts:</p>

<ul>
  <li><code>c - (a + b) = 0</code> is an equation and <strong>equations are not assignment</strong> like the ones we’re used to
 write in C, Java, Python, etc.</li>
  <li><code>a = 4</code> and <code>b - 3 = 0</code> are located on lines 5 and 6. Both lines come after
 the first equation, and because <strong>equations are not assignment, their order does not matter</strong>.
 The only thing that matters is that the model has the same number of variables and equations.</li>
</ul>

<p>So it turns out that equation-based modeling is all about writing equations with code. The Modelica tool
of choice will know how to symbolically analyze the model, extract equations, substitute variables
in equations, sort them and apply the proper numerical methods to find the solution.</p>

<h4 id="working-with-causality">Working with Causality</h4>

<p>The equation-based paradigm opens the door to an interesting concept called a-causality.</p>

<p>Before focusing on the meaning and implications of a-causality let’s have a look at an example based
on Newton’s second law</p>



<blockquote>
  <p>
     The acceleration of an object as produced by a net force is directly
     proportional to the magnitude of the net force, in the same direction as
     the net force, and inversely proportional to the mass of the object.
  </p>
  <small><cite>Sir Isaac Newton</cite></small>
</blockquote>

<p>Newton’s second law describes a relationship between the following quantities: the forces acting on
a body, the mass of the body and its acceleration.</p>

<p>The example below shows a system where a body that can move only along one direction and two forces are acting on it</p>

<p><img src="https://marcobonvini.com/images/posts/newton.png" width="100%">
</p>


<p>Given this system, we can identify a number of problems to solve. Identifying a problem and
finding its solution requires us follow a specific  mental process:</p>

<ul>
  <li>identify the known variables,</li>
  <li>rewrite Newton’s second law to find the desired quantity (e.g., acceleration, force, mass, etc.)</li>
</ul>

<p>Here’s a small list of questions and their solutions presented with block diagrams;
each diagram visually describes how the information flows from the inputs (i.e., known variables) to the
output (i.e., answer to the question).</p>

<ul>
  <li>given the mass, and the two forces compute the acceleration of the body</li>
</ul>
<div>
  
  <div>
    <p><img src="https://marcobonvini.com/images/posts/bd1.png">
    </p>
  </div>
</div>

<ul>
  <li>given the mass, acceleration and one force compute the other force</li>
</ul>
<div>
  
  <div>
    <p><img src="https://marcobonvini.com/images/posts/bd2.png">
    </p>
  </div>
</div>

<ul>
  <li>given the two forces and the velocity of the body compute its mass</li>
</ul>
<div>
  
  <div>
    <p><img src="https://marcobonvini.com/images/posts/bd3.png">
    </p>
  </div>
</div>

<ul>
  <li>given the position of the body, the mass, and one force compute the other force</li>
</ul>
<div>
  
  <div>
    <p><img src="https://marcobonvini.com/images/posts/bd4.png">
    </p>
  </div>
</div>


<p>This process requires a person that looks at the problem and</p>

<ol>
  <li>identifies relationships between the things that are known and the results to be found,</li>
  <li>rearranges Newton’s second law in order to find a path that leads from one to the other.</li>
</ol>

<p>What we’ve just seen is the so called <strong>causal</strong> approach: explicitly describe cause-effect relationships between variables
and hard-code them in an algorithm that computes the solution. Even if the physical system is always the same,
a slightly different question about the system might require a complete rewrite of the algorithm that solves the problem.
The block diagrams above show this concept very well. Even if the underlying system is always the same, the type of operations
performed on the data and the order of those operations changes continuously.
This is rather inconvenient, especially when dealing with systems that are more complicated than a single body and a
couple of forces!</p>

<p>Moreover, designing complex systems is an iterative process. New questions come up as the process evolves.
Having an algorithm that can answer only one question and that needs
to be rewritten to answer a slightly different one is not very useful.</p>

<p>Modelica’s equation-based nature enables the so called <strong>a-causal</strong> modelling approach: build mathematical models without
imposing a priori cause-effect relationships between variables. Let’s try to model the same single body system in Modelica and see
what it looks like.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>SingleBodySystem</span>
<span> 2 </span>   <span>Real</span> <span>M</span> <span>"The mass of the body"</span><span>;</span>
<span> 3 </span>   <span>Real</span> <span>x</span> <span>"The position of the body"</span><span>;</span>
<span> 4 </span>   <span>Real</span> <span>v</span> <span>"The velocity of the body"</span><span>;</span>
<span> 5 </span>   <span>Real</span> <span>a</span> <span>"Acceleration of the body"</span><span>;</span>
<span> 6 </span>   <span>Real</span> <span>F1</span><span>,</span> <span>F2</span> <span>"Forces acting on the body"</span><span>;</span>
<span> 7 </span><span>initial</span> <span>equation</span>
<span> 8 </span>   <span>// Initial conditions</span>
<span> 9 </span>   <span>x</span> <span>=</span> <span>0</span> <span>"The position of the body is x=0 at time=0"</span><span>;</span>
<span>10 </span>   <span>v</span> <span>=</span> <span>0</span> <span>"The body is not moving when time=0"</span><span>;</span>
<span>11 </span><span>equation</span>
<span>12 </span>   <span>// The dynamic behaviour of the system</span>
<span>13 </span>   <span>v</span> <span>=</span> <span>der</span><span>(</span><span>x</span><span>);</span>
<span>14 </span>   <span>a</span> <span>=</span> <span>der</span><span>(</span><span>v</span><span>);</span>
<span>15 </span>   <span>M</span> <span>*</span> <span>a</span> <span>=</span> <span>F1</span> <span>-</span> <span>F2</span><span>;</span>
<span>16 </span>
<span>17 </span>   <span>// Other "boundary" conditions</span>
<span>18 </span>   <span>F1</span> <span>=</span> <span>1.2</span><span>;</span>
<span>19 </span>   <span>F2</span> <span>=</span> <span>2.0</span><span>;</span>
<span>20 </span>   <span>M</span>  <span>=</span> <span>5.0</span><span>;</span>
<span>21 </span><span>end</span> <span>SingleBodySystem</span><span>;</span></code></pre></figure>

</div>


<p>The equation section is divided in two parts. The first part describes Newton’s second law, i.e. the dynamic of the
system. This part is not going to change unless the body starts moving at the speed of light!</p>

<p>The second part contains other “boundary” conditions. These conditions are required to have a complete
picture of the system, and they can change from time to time depending on the question being
asked.</p>

<p>When such conditions change the Modelica tool does all the hard work to
finding causal relationships between the variables. Once the Modelica tools finds the
relationships between inputs and outputs it generates an executable that solves the problem.</p>

<p>Such an approach leverages a computer for doing the boring and error
prone job of rewriting and sorting equations. Computers are definitely better than humans at doing this!</p>

<p>A biproduct of a-causality is that models written in Modelica are more readable and maintainable.
The model contains a description of the system and its boundary conditions rather
than a solution to a specific problem. Most of the readers familiar with software engineering best practices
know this is very important, especially when dealing with complex and large models.</p>

<p>After this brief discussion on a-causality I hope you’re convinced that writing ad-hoc solution to problems
is similar to writing assembly code instead of using a higher level language and a compiler.</p>

<h4 id="variables-and-equations-have-units">Variables and equations have units</h4>

<p>As I already mentioned, Modelica variables can have types. Modelica gives the ability to
associate units to variables. This feature is pretty simple but has a remarkable impact on the quality
of the code.  Adding units to variables/parameters/constants increases the ability to spot
errors in the equations and makes the code more readable.
What is more clear <code>Real v</code> or <code>Modelica.SIunits.Volume v</code>?!</p>

<p>The Modelica Standard Library (<a href="https://github.com/modelica/Modelica">MSL</a> available on Github) provides an
extensive list of types that have units and extend the primitive type <code>Real</code>. This excerpt from the MSL shows
how the <code>ThermodynamicTemperature</code>, <code>Temperature</code>, and <code>SpecificHeatCapacity</code> types are defined.
Each type has a property called <code>unit</code> that is used to check the validty of the equations.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>type</span> <span>ThermodynamicTemperature</span> <span>=</span> <span>Real</span> <span>(</span>
<span> 2 </span>  <span>final</span> <span>quantity</span><span>=</span><span>"ThermodynamicTemperature"</span><span>,</span>
<span> 3 </span>  <span>final</span> <span>unit</span><span>=</span><span>"K"</span><span>,</span>
<span> 4 </span>  <span>min</span> <span>=</span> <span>0.0</span><span>,</span>
<span> 5 </span>  <span>start</span> <span>=</span> <span>288.15</span><span>,</span>
<span> 6 </span>  <span>nominal</span> <span>=</span> <span>300</span><span>,</span>
<span> 7 </span>  <span>displayUnit</span><span>=</span><span>"degC"</span>
<span> 8 </span><span>);</span>
<span> 9 </span>
<span>10 </span><span>type</span> <span>Temperature</span> <span>=</span> <span>ThermodynamicTemperature</span><span>;</span>
<span>11 </span>
<span>12 </span><span>type</span> <span>SpecificHeatCapacity</span> <span>=</span> <span>Real</span> <span>(</span>
<span>13 </span>  <span>final</span> <span>quantity</span><span>=</span><span>"SpecificHeatCapacity"</span><span>,</span>
<span>14 </span>  <span>final</span> <span>unit</span><span>=</span><span>"J/(kg.K)"</span>
<span>15 </span><span>);</span></code></pre></figure>

</div>


<p>Units can be simple like degrees <a href="https://en.wikipedia.org/wiki/Kelvin">Kelvin</a>, denoted by the string <code>K</code>, or
derived from others like the <a href="https://en.wikipedia.org/wiki/Heat_capacity">specific heat capacity</a>,
denoted by <code>J/(kg.K)</code>, that is the energy per unit of mass that causes a temperature change of one degree Kelvin.
The Modelica tool uses information about the type system and units to
check if the models are valid or not. For example the following model</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span>1 </span><span>model</span> <span>TestSIUnits</span>
<span>2 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Temperature</span> <span>T</span><span>;</span>
<span>3 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Energy</span> <span>E</span><span>;</span>
<span>4 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>SpecificHeatCapacity</span> <span>cp</span><span>=</span><span>1000</span><span>;</span>
<span>5 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Mass</span> <span>m</span><span>=</span><span>1</span><span>;</span>
<span>6 </span><span>equation</span>
<span>7 </span>  <span>T</span> <span>=</span> <span>300</span><span>;</span>
<span>8 </span>  <span>E</span> <span>=</span> <span>cp</span><span>*</span><span>T</span><span>;</span> <span>// Forgot to add m* ...</span>
<span>9 </span><span>end</span> <span>TestSIUnits</span><span>;</span></code></pre></figure>

</div>


<p>is not valid because the units in equation <code>E = cp*T</code> don’t match. The left side is energy
and its unit is Joule <code>J</code>, the right side’s unit is Joule per Kelvin <code>J/kg</code>. When the tool
parses and analyzes the model produces the following error
<code>Units error in equation E=cp*T, J != J/kg</code>. Such an error message makes it pretty easy to
understand that we forgot the mass, and the correct equation should have been <code>E = m*cp*T</code>.</p>

<h3 id="object-oriented-modeling">Object-Oriented modeling</h3>

<p>So far we’ve seen examples with few variables and simple equations. Real world systems
are way more complicated than this. A-causality and types help keep the code more readabile
and reduce bugs. This is just the tip of the iceberg, in order to model complex systems
we need some extra features.</p>

<p>This is the where object-oriented modeling shines and where software engineering meets mathematical modeling.</p>

<p>The next example is this electric circuit, the series connection of a voltage source, a resistor and a capacitor
(In case you’re not familiar with electrical circtuits bear with me, you’ll get the concepts anyway).</p>

<p><img src="https://marcobonvini.com/images/posts/electrical_network1.png">
</p>


<p>If we analyze the circuit using <a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_circuit_laws">Kirchhof’s circuit laws</a>
we end up writing a Modelica model with the following equations</p>





<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>RC_v1</span> <span>"RC model version 1.0"</span>
<span> 2 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>E</span>
<span> 3 </span>    <span>"Voltage source"</span><span>;</span>
<span> 4 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>Vc</span>
<span> 5 </span>    <span>"Voltage of the capacitor"</span><span>;</span>
<span> 6 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Current</span> <span>i</span>
<span> 7 </span>    <span>"Current flowing through the circuit"</span><span>;</span>
<span> 8 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Capacity</span> <span>C</span><span>=</span><span>1e-3</span>
<span> 9 </span>    <span>"Capacity"</span><span>;</span>
<span>10 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Resistance</span> <span>R</span><span>=</span><span>1e3</span>
<span>11 </span>    <span>"Resistance"</span><span>;</span>
<span>12 </span><span>initial</span> <span>equation</span>
<span>13 </span>  <span>Vc</span> <span>=</span> <span>0.0</span><span>;</span>
<span>14 </span><span>equation</span>
<span>15 </span>  <span>E</span> <span>=</span> <span>10.0</span><span>;</span>
<span>16 </span>  <span>C</span><span>*</span><span>der</span><span>(</span><span>Vc</span><span>)</span> <span>=</span> <span>i</span><span>;</span>
<span>17 </span>  <span>R</span><span>*</span><span>i</span> <span>=</span> <span>E</span> <span>-</span> <span>Vc</span><span>;</span>
<span>18 </span><span>end</span> <span>RC_v1</span><span>;</span></code></pre></figure>

</div>


<p>The model represents the physical system in a “flat” way, there’s no clear distinction between the
electrical components that are part of the circuit. We did not took advantage of the a-causality
provided by Modelica and we ended up with a Model that represents this specific circuit.</p>

<p>It’s more convenient to imagine the circuit as a network of components that are connected
to each other.</p>

<p><img src="https://marcobonvini.com/images/posts/electrical_network2.png">
</p>


<p>The image above shows an exploded view of the circuit and its components. Each component, enclosed
in a grey rectangle, represents an actual piece of hardware (e.g., resistors, capacitors, cables, etc.).</p>

<p>Wouldn’t be better to have a library of virtual electric components that can be connected
to generate all kinds of virtual circuits? Yes, and Modelica allows to create modular
models that can be assembled like construction blocks thanks to <strong>connectors</strong>.</p>

<h4 id="connectors-aka-interfaces">Connectors (aka Interfaces)</h4>

<p>Modelica connectors are a construct that allows to connect models
and let them exchange information. Connectors are inspired to real world physical interactions.
Let’s have a look how actual electrical components work to gain some insight.</p>

<p><img src="https://marcobonvini.com/images/posts/resistor.jpg">
</p>
<p><img src="https://marcobonvini.com/images/posts/capacitor.jpg">
</p>


<p>The pictures above show a resistor and a capacitor. They’re very different objects that behave according to
different laws, however they share a common trait: they both have two wires (also known as terminal pins).</p>

<p>Resistors and capacitors don’t care in which part of the circuit
are located, they behave in function of the voltages and currents provided to their terminals.
<strong>Resistors and capacitors see the world through their terminals</strong> – and they work just fine.</p>

<p>When an engineer designs a circuit in which resistors and capacitor interact with each other,
their terminals are welded. Welding electric terminals imposes two physical constraints, the voltage
at their junction becomes the same and the current leaving one component enters the other.</p>

<p><img src="https://marcobonvini.com/images/posts/connectRC.png">
</p>


<p>Modelica connectors are the equivalent of electic terminals as they define
boundary conditions for models.</p>

<p>In the electrical domain the boundary conditions that characterize the behaviour of
components such resistors or capacitors are voltages and currents.
This means that a Modelica connector for electrical components will look like</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span>1 </span><span>connector</span> <span>Terminal</span> <span>"Connector/Interface for electrical systems"</span>
<span>2 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>v</span>
<span>3 </span>    <span>"Voltage at the terminal"</span><span>;</span>
<span>4 </span>  <span>flow</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Current</span> <span>i</span>
<span>5 </span>    <span>"Current flowing through the terminal"</span>
<span>6 </span>    <span>"(positive entering the model)"</span><span>;</span>
<span>7 </span><span>end</span> <span>Terminal</span><span>;</span></code></pre></figure>

</div>


<p>The connector defines two variables, the voltage <code>v</code> and the current <code>i</code>.</p>

<h4 id="connectors-in-models">Connectors in Models</h4>

<p>So far we’ve seen that connectors can be used to define boundary conditions.
Now we’ll see how to use connectors for building a self contained model
representing a resistor.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>Resistor</span>
<span> 2 </span>  <span>Terminal</span> <span>A</span><span>,</span> <span>B</span><span>;</span>
<span> 3 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Resistance</span> <span>R</span> <span>=</span> <span>1e3</span>
<span> 4 </span>    <span>"Resistance"</span><span>;</span>
<span> 5 </span><span>equation</span>
<span> 6 </span>  <span>// Constraint between connector variables</span>
<span> 7 </span>  <span>// i.e. the current that enters</span>
<span> 8 </span>  <span>// connector A leaves connector B</span>
<span> 9 </span>  <span>A</span><span>.</span><span>i</span> <span>+</span> <span>B</span><span>.</span><span>i</span> <span>=</span> <span>0</span><span>;</span>
<span>10 </span>
<span>11 </span>  <span>// Ohm's law</span>
<span>12 </span>  <span>A</span><span>.</span><span>v</span> <span>-</span> <span>B</span><span>.</span><span>v</span> <span>=</span> <span>R</span><span>*</span><span>A</span><span>.</span><span>i</span><span>;</span>
<span>13 </span><span>end</span> <span>Resistor</span><span>;</span></code></pre></figure>

</div>


<p>The model has two electrical terminals <code>A</code>, <code>B</code>, and a parameter <code>R</code> (the value of the resistance).
The equations describe the behaviour of the component based on the boundary conditions provided by the
connectors.</p>

<p>Equation <code>A.v - B.v = R*A.i</code> states that the voltage difference between terminal A and B
is equal to the current entering from terminal A multiplied by the resistance R.</p>

<p>Equation <code>A.i + B.i = 0</code> states that the current entering from terminal A plus the current
entering from therminal B is equal to zero – i.e. the current entering from A leaves from B
(please note that currents are always measured as positive when entering the model).</p>

<p>In a similar way we can build component models for all of the remaining elements: source, capacitor
and ground reference.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>Source</span>
<span> 2 </span>  <span>Terminal</span> <span>A</span><span>,</span> <span>B</span><span>;</span>
<span> 3 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>E</span> <span>=</span> <span>10</span>
<span> 4 </span>    <span>"Constant voltage source"</span><span>;</span>
<span> 5 </span><span>equation</span>
<span> 6 </span>  <span>// Constraint between connector variables</span>
<span> 7 </span>  <span>// i.e. the same amount of current that enters from</span>
<span> 8 </span>  <span>// connector A leaves from connector B</span>
<span> 9 </span>  <span>A</span><span>.</span><span>i</span> <span>+</span> <span>B</span><span>.</span><span>i</span> <span>=</span> <span>0</span><span>;</span>
<span>10 </span>
<span>11 </span>  <span>// The source generates a voltage difference</span>
<span>12 </span>  <span>// between the two terminals</span>
<span>13 </span>  <span>A</span><span>.</span><span>v</span> <span>-</span> <span>B</span><span>.</span><span>v</span> <span>=</span> <span>E</span><span>;</span>
<span>14 </span><span>end</span> <span>Source</span><span>;</span>
<span>15 </span>
<span>16 </span><span>model</span> <span>Capacitor</span>
<span>17 </span>  <span>Terminal</span> <span>A</span><span>,</span> <span>B</span><span>;</span>
<span>18 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Capacitance</span> <span>C</span> <span>=</span> <span>1e-3</span>
<span>19 </span>    <span>"Capacitance"</span><span>;</span>
<span>20 </span>  <span>parameter</span> <span>ModelicA</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>Vc_start</span> <span>=</span> <span>0.0</span>
<span>21 </span>    <span>"Initial voltage of the capacitor"</span><span>;</span>
<span>22 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>Vc</span><span>;</span>
<span>23 </span><span>initial</span> <span>equation</span>
<span>24 </span>  <span>Vc</span> <span>=</span> <span>Vc_start</span><span>;</span>
<span>25 </span><span>equation</span>
<span>26 </span>  <span>// Constraint between connector variables</span>
<span>27 </span>  <span>// i.e. the same amount of current that enters from</span>
<span>28 </span>  <span>// connector A leaves from connector B</span>
<span>29 </span>  <span>A</span><span>.</span><span>i</span> <span>+</span> <span>B</span><span>.</span><span>i</span> <span>=</span> <span>0</span><span>;</span>
<span>30 </span>
<span>31 </span>  <span>// Change in the charge is equal to the current flow</span>
<span>32 </span>  <span>C</span><span>*</span><span>der</span><span>(</span><span>Vc</span><span>)</span> <span>=</span> <span>A</span><span>.</span><span>i</span><span>;</span>
<span>33 </span>  <span>Vc</span> <span>=</span> <span>A</span><span>.</span><span>v</span> <span>-</span> <span>B</span><span>.</span><span>v</span><span>;</span>
<span>34 </span>
<span>35 </span><span>end</span> <span>Capacitor</span><span>;</span>
<span>36 </span>
<span>37 </span><span>model</span> <span>Ground</span>
<span>38 </span>  <span>Terminal</span> <span>A</span><span>;</span>
<span>39 </span><span>equation</span>
<span>40 </span>  <span>// Boundary condition that fixes the voltage reference</span>
<span>41 </span>  <span>A</span><span>.</span><span>v</span> <span>=</span> <span>0.0</span><span>;</span>
<span>42 </span><span>end</span> <span>Ground</span><span>;</span></code></pre></figure>

</div>


<h4 id="connecting-models">Connecting Models</h4>

<p>At this point we have defined models of all the electrical components we need. Each
component has terminals and in order to build a circuit we have to connect them.
Modelica has a construct called <code>connect(.,.)</code> and it’s purpose is to connect connectors.</p>

<p>This is the new version of the Modelica model that represents the circuit.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>RC_v2</span> <span>"RC model version 2.0"</span>
<span> 2 </span>  <span>Source</span> <span>S</span><span>(</span><span>E</span><span>=</span><span>10</span><span>)</span>  <span>"Voltage source"</span><span>;</span>
<span> 3 </span>  <span>Capacitor</span> <span>C</span><span>(</span><span>Vc_start</span><span>=</span><span>0.0</span><span>,</span> <span>C</span><span>=</span><span>1e-3</span><span>)</span> <span>"Capacitor"</span><span>;</span>
<span> 4 </span>  <span>Resistor</span> <span>R</span><span>(</span><span>R</span><span>=</span><span>1e3</span><span>)</span> <span>"Resistance"</span><span>;</span>
<span> 5 </span>  <span>Ground</span> <span>ref</span> <span>"Ground reference"</span><span>;</span>
<span> 6 </span><span>equation</span>
<span> 7 </span>  <span>connect</span><span>(</span><span>S</span><span>.</span><span>A</span><span>,</span> <span>R</span><span>.</span><span>A</span><span>);</span>
<span> 8 </span>  <span>connect</span><span>(</span><span>S</span><span>.</span><span>B</span><span>,</span> <span>ref</span><span>.</span><span>A</span><span>);</span>
<span> 9 </span>  <span>connect</span><span>(</span><span>R</span><span>.</span><span>B</span><span>,</span> <span>C</span><span>.</span><span>A</span><span>);</span>
<span>10 </span>  <span>connect</span><span>(</span><span>C</span><span>.</span><span>B</span><span>,</span> <span>ref</span><span>.</span><span>A</span><span>);</span>
<span>11 </span><span>end</span> <span>RC_v2</span><span>;</span></code></pre></figure>

</div>


<p>This version of the model that uses components and connectors is more readable
than the flat representation we started with. The first part of the model
defines all the components we’re using while the second part defines how they
are connected. Nedless to say that this model is more maintainable than the previous
“flat” version. Modularity and reusability improve as well because each component
can be replaced and they are ready to be reused in other circuits without any effort.</p>

<h4 id="connects-magic">Connect’s magic</h4>

<p>The model we just wrote is very readable but what happened to all the equations we used
to write? And why is the connect statement included in the equation section?</p>

<p>Every time we connect two connectors with a <code>connect(., .)</code> operator
the Modelica tool that analyzes the code adds some equations for us.
The equations that are automatically added impose the constraints
that are enforced when welding terminal pins in the real world</p>

<ol>
  <li>voltages become equal,</li>
  <li>the current leaving one terminal enters the other.</li>
</ol>

<p>The image below shows two <code>Terminal</code> connectors named <code>A</code> and <code>B</code> and the equations that are
generated when they’re connected.</p>

<p><img src="https://marcobonvini.com/images/posts/connectors.png">
</p>


<p>Again, less tedious work for us to do and less opportunities to introduce
errors.</p>

<h4 id="partial-models--abstract-classes">Partial models = abstract classes</h4>

<p>At this point the software engineer in the room should stop me and tell
everyone “This is good, but I think we can do better than this”.</p>

<p>Creating mathematical models in Modelica (or Matlab, or whatever you like) is still software development.
Software engineering practices and well understood design patterns should be leveraged
when writing mathematical models.</p>

<p>This is particularly true for people who design Modelica libraries that are used by many and contain
houndreds of components. The pleople who design these libraries must have in mind a clear vision on how
the library should be structured, which connectors are needed, etc.</p>

<p>The createators of Modelica knew about SW engineering, and they baked into the language several features
that are mostly inspired to Object-Oriented programming. One of the most useful features is the
ability to create partial models.</p>

<p>For example <code>Source</code>, <code>Resistor</code>, and <code>Capacitor</code> share quite a bit of code.
Each model defines the connectors <code>A</code> and <code>B</code> as well the equation <code>A.i + B.i = 0</code>.
This is against the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> principle and fortunately
there’s a simple solution: <strong>partial models</strong>.</p>

<p>Partial models are models that allows to declare variables, parameters, and equations but don’t have to
be complete. This means that a partial model can have more variables than equations. The missing equations
will be provided by models that extend the partial model. In case you’re familiar with OO programming,
partial models are the Modelica version of abstract classes.
Let’s see how the models created so far can be refactored using this feature</p>

<p>The first step is to isolate the traits (parameters, connectors, equations, etc.) shared by
multiple models and collect them into a <code>partial</code> model. In this case the partial model
represents a bipole, i.e. a generic electric component with two terminals where the sum of
the currents entering and leaving is zero.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>partial</span> <span>model</span> <span>Bipole</span> <span>"Electrical model with two pins"</span>
<span> 2 </span>  <span>Terminal</span> <span>a</span><span>,</span> <span>b</span><span>;</span>
<span> 3 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>V</span>
<span> 4 </span>    <span>"Voltage drop"</span><span>;</span>
<span> 5 </span>  <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>current</span> <span>i</span>
<span> 6 </span>    <span>"Current entering terminal a"</span><span>;</span>
<span> 7 </span><span>equation</span>
<span> 8 </span>  <span>// Constraint between connector variables</span>
<span> 9 </span>  <span>// i.e. the same amount of current that enters from</span>
<span>10 </span>  <span>// connector a leaves from connector b</span>
<span>11 </span>  <span>A</span><span>.</span><span>i</span> <span>+</span> <span>B</span><span>.</span><span>i</span> <span>=</span> <span>0</span><span>;</span>
<span>12 </span>
<span>13 </span>  <span>// Definition of utility variables</span>
<span>14 </span>  <span>V</span> <span>=</span> <span>A</span><span>.</span><span>v</span> <span>-</span> <span>B</span><span>.</span><span>v</span><span>;</span>
<span>15 </span>  <span>i</span> <span>=</span> <span>A</span><span>.</span><span>i</span><span>;</span>
<span>16 </span>
<span>17 </span><span>end</span> <span>Bipole</span><span>;</span></code></pre></figure>

</div>


<p>The resistor, capacitor and source now become extensions of this basic model.</p>

<div>

<figure><pre><code data-lang="modelica"><span></span><span> 1 </span><span>model</span> <span>Resistor</span>
<span> 2 </span>  <span>extends</span> <span>Bipole</span><span>;</span>
<span> 3 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Resistance</span> <span>R</span> <span>=</span> <span>1e3</span>
<span> 4 </span>    <span>"Resistance"</span><span>;</span>
<span> 5 </span><span>equation</span>
<span> 6 </span>  <span>// Ohm's law</span>
<span> 7 </span>  <span>V</span> <span>=</span> <span>R</span><span>*</span><span>i</span><span>;</span>
<span> 8 </span><span>end</span> <span>Resistor</span><span>;</span>
<span> 9 </span>
<span>10 </span><span>model</span> <span>Source</span>
<span>11 </span>  <span>extends</span> <span>Bipole</span><span>;</span>
<span>12 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>E</span> <span>=</span> <span>10</span>
<span>13 </span>    <span>"Constant voltage source"</span><span>;</span>
<span>14 </span><span>equation</span>
<span>15 </span>  <span>// The source generates a voltage difference</span>
<span>16 </span>  <span>// between the two terminals</span>
<span>17 </span>  <span>V</span> <span>=</span> <span>E</span><span>;</span>
<span>18 </span><span>end</span> <span>Source</span><span>;</span>
<span>19 </span>
<span>20 </span><span>model</span> <span>Capacitor</span>
<span>21 </span>  <span>extends</span> <span>Bipole</span><span>;</span>
<span>22 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Capacitance</span> <span>C</span> <span>=</span> <span>1e-3</span>
<span>23 </span>    <span>"Capacitance"</span><span>;</span>
<span>24 </span>  <span>parameter</span> <span>Modelica</span><span>.</span><span>SIunits</span><span>.</span><span>Voltage</span> <span>V_start</span> <span>=</span> <span>0.0</span>
<span>25 </span>    <span>"Initial voltage of the capacitor"</span><span>;</span>
<span>26 </span><span>initial</span> <span>equation</span>
<span>27 </span>  <span>V</span> <span>=</span> <span>V_start</span><span>;</span>
<span>28 </span><span>equation</span>
<span>29 </span>  <span>// Change in the charge is equal to the current flow</span>
<span>30 </span>  <span>C</span><span>*</span><span>der</span><span>(</span><span>V</span><span>)</span> <span>=</span> <span>i</span><span>;</span>
<span>31 </span><span>end</span> <span>Capacitor</span><span>;</span></code></pre></figure>

</div>


<p>Again, readability and maintenability increases. Plus, if now we wish
to create a new model for an inductor or a variable resistor
there already is a partial model to extend that declares the basic structure.</p>

<h3 id="conclusions">Conclusions</h3>

<p>So, if you’ve made it this far, you should be convinced that cyber-physical systems are a big part of
everyday life, and Modelica helps engineers and scientists to model these systems accurately.</p>

<p>There’s a lot to be said about Modelica, and in this post we just scratched the surface. We have seen
that Modelica works directly with equations and that this leads to a-causal models. We also learned
that a-causal models are more readable and flexible, making then a good way to express complex engineering problems.
We also learned about some of the language features inspired by SW engineering: typed variables and object-oriented
features that promote encapsulation.</p>

<p>If after reading this post you’re even more interested in Modelica I suggest you to look
at the online book <a href="http://book.xogeny.com/">Modelica by examples</a> by Michael Tiller, otherwise
browse the website of the Modelica associations <a href="http://www.modelica.org/">www.modelica.org</a>.
Here you can freely access houndreds of papers that have been written over the years and presented
during the numerous Modelica conferences around the world.</p>

<p>If you’re interested in the work I’ve done with Modelica, you can look <a href="https://marcobonvini.com/research">here</a>.</p>

<h4 id="aknowledgments">Aknowledgments</h4>

<p>Special thanks to <a href="https://mcquilleninteractive.com/">Daniel McQuillen</a>
for proof reading this post and providing helpful suggestions, and to Daniel Gackle
for suggesting to combine my previous articles on this topic into a single one.</p>

    </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>