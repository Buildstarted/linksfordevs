<!DOCTYPE html>
<html lang="en">
<head>
    <title>
WinDbg&#x200A;&#x2014;&#x200A;the Fun Way: Part 2 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="WinDbg&#x200A;&#x2014;&#x200A;the Fun Way: Part 2 - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@yardenshafir2"/>
    <meta property="og:description" content="Welcome to part 2 of me trying to make you enjoy debugging on Windows (wow, I&#x2019;m a nerd)!"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@yardenshafir2/windbg-the-fun-way-part-2-7a904cba5435"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - WinDbg&#x200A;&#x2014;&#x200A;the Fun Way: Part 2</title>
<div class="readable">
        <h1>WinDbg&#x200A;&#x2014;&#x200A;the Fun Way: Part 2</h1>
            <div>by https://medium.com/@yardenshafir2</div>
            <div>Reading time: 39-49 minutes</div>
        <div>Posted here: 21 May 2020</div>
        <p><a href="https://medium.com/@yardenshafir2/windbg-the-fun-way-part-2-7a904cba5435">https://medium.com/@yardenshafir2/windbg-the-fun-way-part-2-7a904cba5435</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@yardenshafir2?source=post_page-----7a904cba5435----------------------"><img alt="Yarden Shafir" src="https://miro.medium.com/fit/c/96/96/1*zlXYBZfOf8yzpBnGc2ufIQ.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="6109" data-selectable-paragraph="">Welcome to part 2 of me trying to make you enjoy debugging on Windows (wow, I‚Äôm a nerd)!</p><p id="9e35" data-selectable-paragraph="">In the first part we got to know the basics of the new debugger data model ‚Äî Using the new objects, having custom registers, searching and filtering output, declaring anonymous types and parsing lists and arrays. In this part we will learn how to use legacy commands with <code>dx</code>, get to know the amazing new disassembler, create synthetic methods and types, see the fancy changes to breakpoints and use the filesystem from within the debugger.</p><p id="33a9" data-selectable-paragraph="">This sounds like a lot. Because it is. So let‚Äôs start!</p><p id="5981" data-selectable-paragraph="">This new data model completely changes the debugging experience. But sometimes you do need to use one of the old commands or extensions that we all got used to, and that don‚Äôt have a matching functionality under <code>dx</code>.</p><p id="5cb5" data-selectable-paragraph="">But we can still use these under <code>dx</code> with <code>Debugger.Utility.Control.ExecuteCommand</code>, which lets us run a legacy command as part of a <code>dx</code> query. For example, we can use the legacy <code>u</code> command to unassemble the address that is pointed to by RIP in our second stack frame.</p><p id="13f9" data-selectable-paragraph="">Since <code>dx</code> output is decimal by default and legacy commands only take hex input we first need to convert it to hex using <code>ToDisplayString("x")</code>:</p><pre><span id="0f52" data-selectable-paragraph=""><strong>dx Debugger.Utility.Control.ExecuteCommand("u " + @$curstack.Frames[1].Attributes.InstructionOffset.ToDisplayString("x"))</strong></span><span id="5ab0" data-selectable-paragraph="">Debugger.Utility.Control.ExecuteCommand("u " + @$curstack.Frames[1].Attributes.InstructionOffset.ToDisplayString("x"))                <br>    [0x0]     : kdnic!TXTransmitQueuedSends+0x125:<br>    [0x1]     : fffff807`52ad2b61 4883c430        add     rsp,30h<br>    [0x2]     : fffff807`52ad2b65 5b              pop     rbx<br>    [0x3]     : fffff807`52ad2b66 c3              ret<br>    [0x4]     : fffff807`52ad2b67 4c8d4370        lea     r8,[rbx+70h]<br>    [0x5]     : fffff807`52ad2b6b 488bd7          mov     rdx,rdi<br>    [0x6]     : fffff807`52ad2b6e 488d4b60        lea     rcx,[rbx+60h]<br>    [0x7]     : fffff807`52ad2b72 4c8b15d7350000  mov     r10,qword ptr [kdnic!_imp_ExInterlockedInsertTailList (fffff807`52ad6150)]<br>    [0x8]     : fffff807`52ad2b79 e8123af8fb      call    nt!ExInterlockedInsertTailList (fffff807`4ea56590)</span></pre><p id="af77" data-selectable-paragraph="">Another useful legacy command is <code>!irp</code>. This command supplies us with a lot of information about IRPs, so no need to work hard to recreate it with <code>dx</code>.</p><p id="ff02" data-selectable-paragraph="">So we will try to run <code>!irp</code> for all IRPs in lsass.exe process. Let‚Äôs walk through that:</p><p id="01b2" data-selectable-paragraph="">First, we need to find the process container for lsass.exe. We already know how to do that using <code>Where()</code>. Then we‚Äôll pick the first process returned. Usually there should only be one lsass anyway, unless there are server silos on the machine:</p><pre><span id="50d9" data-selectable-paragraph="">dx @$lsass = @$cursession.Processes.Where(p =&gt; p.Name == ‚Äúlsass.exe‚Äù).First()</span></pre><p id="dc30" data-selectable-paragraph="">Then we need to iterate over <code>IrpList</code> for each thread in the process and get the IRPs themselves. We can easily do that with <code>FromListEntry()</code> that we‚Äôve seen already. Then we only pick the threads that have IRPs in their list:</p><pre><span id="397f" data-selectable-paragraph=""><strong>dx -r4 @$irpThreads = @$lsass.Threads.Select(t =&gt; new {irp = Debugger.Utility.Collections.FromListEntry(t.KernelObject.IrpList, "nt!_IRP", "ThreadListEntry")}).Where(t =&gt; t.irp.Count() != 0)</strong></span><span id="a7c8" data-selectable-paragraph="">@$irpThreads = @$lsass.Threads.Select(t =&gt; new {irp = <br>Debugger.Utility.Collections.FromListEntry(t.KernelObject.IrpList, "nt!_IRP", "ThreadListEntry")}).Where(t =&gt; t.irp.Count() != 0)                <br>    [0x384]         <br>        irp             <br>            [0x0]            [Type: _IRP]<br>                [&lt;Raw View&gt;]     [Type: _IRP]<br>                IoStack          : Size = 12, Current IRP_MJ_DIRECTORY_CONTROL / 0x2 for Device for "\FileSystem\Ntfs"<br>                CurrentThread    : 0xffffb90a59477080 [Type: _ETHREAD *]<br>            [0x1]            [Type: _IRP]<br>                [&lt;Raw View&gt;]     [Type: _IRP]<br>                IoStack          : Size = 12, Current IRP_MJ_DIRECTORY_CONTROL / 0x2 for Device for "\FileSystem\Ntfs"<br>                CurrentThread    : 0xffffb90a59477080 [Type: _ETHREAD *]</span></pre><p id="a3fa" data-selectable-paragraph="">We can stop here for a moment, click on <code>IoStack</code> for one of the IRPs (or run with <code>-r5</code> to see all of them) and get the stack in a nice container we can work with:</p><pre><span id="f960" data-selectable-paragraph=""><strong>dx @$irpThreads.First().irp[0].IoStack</strong></span><span id="3a43" data-selectable-paragraph="">@$irpThreads.First().irp[0].IoStack                 : Size = 12, Current IRP_MJ_DIRECTORY_CONTROL / 0x2 for Device for "\FileSystem\Ntfs"<br>    [0]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [1]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [2]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [3]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [4]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [5]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [6]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [7]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [8]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [9]              : IRP_MJ_CREATE / 0x0 for {...} [Type: _IO_STACK_LOCATION]<br>    [10]             : IRP_MJ_DIRECTORY_CONTROL / 0x2 for Device for "\FileSystem\Ntfs" [Type: _IO_STACK_LOCATION]<br>    [11]             : IRP_MJ_DIRECTORY_CONTROL / 0x2 for Device for "\FileSystem\FltMgr" [Type: _IO_STACK_LOCATION]</span></pre><p id="1761" data-selectable-paragraph="">And as the final step we will iterate over every thread, and over every IRP in them, and <code>ExecuteCommand !irp &lt;irp address&gt;</code>. Here too we need casting and <code>ToDisplayString("x")</code> to match the format expected by legacy commands (the output of <code>!irp</code> is very long so we trimmed it down to focus on the interesting data):</p><pre><span id="3f64" data-selectable-paragraph=""><strong>dx -r3 @$irpThreads.Select(t =&gt; t.irp.Select(i =&gt; Debugger.Utility.Control.ExecuteCommand("!irp " + ((__int64)&amp;i).ToDisplayString("x"))))</strong></span><span id="d15e" data-selectable-paragraph="">@$irpThreads.Select(t =&gt; t.irp.Select(i =&gt; Debugger.Utility.Control.ExecuteCommand("!irp " + ((__int64)&amp;i).ToDisplayString("x"))))                <br>    [0x384]         <br>        [0x0]           <br>            [0x0]            : Irp is active with 12 stacks 11 is current (= 0xffffb90a5b8f4d40)<br>            [0x1]            :  No Mdl: No System Buffer: Thread ffffb90a59477080:  Irp stack trace.  <br>            [0x2]            :      cmd  flg cl Device   File     Completion-Context<br>            [0x3]            :  [N/A(0), N/A(0)]<br>            ...<br>            [0x34]           : Irp Extension present at 0xffffb90a5b8f4dd0:<br>        [0x1]           <br>            [0x0]            : Irp is active with 12 stacks 11 is current (= 0xffffb90a5bd24840)<br>            [0x1]            :  No Mdl: No System Buffer: Thread ffffb90a59477080:  Irp stack trace.  <br>            [0x2]            :      cmd  flg cl Device   File     Completion-Context<br>            [0x3]            :  [N/A(0), N/A(0)]<br>            ...<br>            [0x34]           : Irp Extension present at 0xffffb90a5bd248d0:</span></pre><p id="555e" data-selectable-paragraph="">Most of the information given to us by <code>!irp</code> we can get by parsing the IRPs with <code>dx</code> and dumping the <code>IoStack</code> for each. But there are a few things we might have a harder time to get but receive from the legacy command such as the existence and address of an <code>IrpExtension</code> and information about a possible Mdl linked to the Irp.</p><p id="cf1a" data-selectable-paragraph="">We used the <code>u</code> command as an example, though in this case there actually is functionality implementing this in <code>dx</code>, through <code>Debugger.Utility.Code.CreateDisassember</code> and <code>DisassembleBlock</code>, creating iterable and searchable disassembly:</p><pre><span id="c65b" data-selectable-paragraph=""><strong>dx -r3 Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(@$curstack.Frames[1].Attributes.InstructionOffset)</strong></span><span id="34f2" data-selectable-paragraph="">Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(@$curstack.Frames[1].Attributes.InstructionOffset)                <br>    [0xfffff80752ad2b61] : Basic Block [0xfffff80752ad2b61 - 0xfffff80752ad2b67)<br>        StartAddress     : 0xfffff80752ad2b61<br>        EndAddress       : 0xfffff80752ad2b67<br>        Instructions    <br>            [0xfffff80752ad2b61] : add         rsp,30h<br>            [0xfffff80752ad2b65] : pop         rbx<br>            [0xfffff80752ad2b66] : ret<br>    [0xfffff80752ad2b67] : Basic Block [0xfffff80752ad2b67 - 0xfffff80752ad2b7e)<br>        StartAddress     : 0xfffff80752ad2b67<br>        EndAddress       : 0xfffff80752ad2b7e<br>        Instructions    <br>            [0xfffff80752ad2b67] : lea         r8,[rbx+70h]<br>            [0xfffff80752ad2b6b] : mov         rdx,rdi<br>            [0xfffff80752ad2b6e] : lea         rcx,[rbx+60h]<br>            [0xfffff80752ad2b72] : mov         r10,qword ptr [kdnic!__imp_ExInterlockedInsertTailList (fffff80752ad6150)]<br>            [0xfffff80752ad2b79] : call        ntkrnlmp!ExInterlockedInsertTailList (fffff8074ea56590)<br>    [0xfffff80752ad2b7e] : Basic Block [0xfffff80752ad2b7e - 0xfffff80752ad2b80)<br>        StartAddress     : 0xfffff80752ad2b7e<br>        EndAddress       : 0xfffff80752ad2b80<br>        Instructions    <br>            [0xfffff80752ad2b7e] : jmp         kdnic!TXTransmitQueuedSends+0xd0 (fffff80752ad2b0c)<br>    [0xfffff80752ad2b80] : Basic Block [0xfffff80752ad2b80 - 0xfffff80752ad2b81)<br>        StartAddress     : 0xfffff80752ad2b80<br>        EndAddress       : 0xfffff80752ad2b81<br>        Instructions<br>   ...</span></pre><p id="baf9" data-selectable-paragraph="">And the cleaned-up version, picking only the instructions and flattening the tree:</p><pre><span id="3127" data-selectable-paragraph=""><strong>dx -r2 Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(@$curstack.Frames[1].Attributes.InstructionOffset).Select(b =&gt; b.Instructions).Flatten()</strong></span><span id="494f" data-selectable-paragraph="">Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(@$curstack.Frames[1].Attributes.InstructionOffset).Select(b =&gt; b.Instructions).Flatten()                <br>    [0x0]           <br>        [0xfffff80752ad2b61] : add         rsp,30h<br>        [0xfffff80752ad2b65] : pop         rbx<br>        [0xfffff80752ad2b66] : ret<br>    [0x1]           <br>        [0xfffff80752ad2b67] : lea         r8,[rbx+70h]<br>        [0xfffff80752ad2b6b] : mov         rdx,rdi<br>        [0xfffff80752ad2b6e] : lea         rcx,[rbx+60h]<br>        [0xfffff80752ad2b72] : mov         r10,qword ptr [kdnic!__imp_ExInterlockedInsertTailList (fffff80752ad6150)]<br>        [0xfffff80752ad2b79] : call        ntkrnlmp!ExInterlockedInsertTailList (fffff8074ea56590)<br>    [0x2]           <br>        [0xfffff80752ad2b7e] : jmp         kdnic!TXTransmitQueuedSends+0xd0 (fffff80752ad2b0c)<br>    [0x3]           <br>        [0xfffff80752ad2b80] : int         3<br>    [0x4]           <br>        [0xfffff80752ad2b81] : int         3<br>   ...</span></pre><p id="63b7" data-selectable-paragraph="">Another functionality that we get with this debugger data model is to create functions of our own and use them, with this syntax:</p><pre><span id="49a3" data-selectable-paragraph="">0: kd&gt; <strong>dx @$multiplyByThree = (x =&gt; x * 3)</strong></span><span id="0f7b" data-selectable-paragraph="">@$multiplyByThree = (x =&gt; x * 3)</span><span id="884b" data-selectable-paragraph="">0: kd&gt; <strong>dx @$multiplyByThree(5)</strong></span><span id="7ffc" data-selectable-paragraph="">@$multiplyByThree(5) : 15</span></pre><p id="4d35" data-selectable-paragraph="">Or we can have functions taking multiple arguments:</p><pre><span id="4036" data-selectable-paragraph="">0: kd&gt; <strong>dx @$add = ((x, y) =&gt; x + y)</strong></span><span id="c26a" data-selectable-paragraph="">@$add = ((x, y) =&gt; x + y)</span><span id="a1b6" data-selectable-paragraph="">0: kd&gt; <strong>dx @$add(5, 7)</strong></span><span id="3d0d" data-selectable-paragraph="">@$add(5, 7)      : 12</span></pre><p id="2370" data-selectable-paragraph="">Or if we want to really go a few levels up, we can apply these functions to the disassembly output we saw earlier to find all writes into memory in <code>ZwSetInformationProcess</code>. For that there are a few checks we need to apply to each instruction to know whether or not it‚Äôs a write into memory:</p><p id="bdeb" data-selectable-paragraph="">¬∑ Does it have at least 2 operands? <br> For example, <code>ret</code> will have zero and <code>jmp &lt;address&gt;</code> will have one. We only care about cases where one value is being written into some location, which will always require two operands. To verify that we will check for each instruction <code>Operands.Count() &gt; 1</code>.</p><p id="b906" data-selectable-paragraph="">¬∑ Is this a memory reference?<br> We are only interested in writes into memory and want to ignore instructions like <code>mon r10, rcx</code>. To do that, we will check for each instruction its <code>Operands[0].Attributes.IsMemoryReference == true</code>.<br> We check Operands[0] because that will be the destination. If we wanted to find memory reads we would have checked the source, which is in <code>Operands[1]</code>.</p><p id="8e2b" data-selectable-paragraph="">¬∑ Is the destination operand an output?<br> We want to filter out instructions where memory is referenced but not written into. To check that we will use <code>Operands[0].IsOutput == true</code>.</p><p id="26cb" data-selectable-paragraph="">¬∑ As our last filter we want to ignore memory writes into the stack, which will look like <code>mov [rsp+0x18], 1</code> or <code>mov [rbp-0x10], rdx</code>.<br> We will check the register of the first operand and make sure its index is not the rsp index (0x14) or rbp index (0x15).</p><p id="cce6" data-selectable-paragraph="">We will write a function, <code>@$isMemWrite</code>, that receives a block and only returns the instructions that contain a memory write, based in these checks. Then we can create a disassembler, disassemble our target function and only print the memory writes in it:</p><pre><span id="bd7f" data-selectable-paragraph=""><strong>dx -r0 @$rspId = 0x14</strong></span><span id="ae37" data-selectable-paragraph=""><strong>dx -r0 @$rbpId = 0x15</strong></span><span id="86fd" data-selectable-paragraph=""><strong>dx -r0 @$isMemWrite = (b =&gt; b.Instructions.Where(i =&gt; i.Operands.Count() &gt; 1 &amp;&amp; i.Operands[0].Attributes.IsOutput &amp;&amp; i.Operands[0].Registers[0].Id != @$rspId &amp;&amp; i.Operands[0].Registers[0].Id != @$rbpId &amp;&amp; i.Operands[0].Attributes.IsMemoryReference))</strong></span><span id="61e7" data-selectable-paragraph=""><strong>dx -r0 @$findMemWrite = (a =&gt; Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(a).Select(b =&gt; @$isMemWrite(b)))</strong></span><span id="af1f" data-selectable-paragraph=""><strong>dx -r2 @$findMemWrite(&amp;nt!ZwSetInformationProcess).Where(b =&gt; b.Count() != 0)</strong></span><span id="f9f2" data-selectable-paragraph="">@$findMemWrite(&amp;nt!ZwSetInformationProcess).Where(b =&gt; b.Count() != 0)                <br>    [0xfffff8074ebd23d4]<br>        [0xfffff8074ebd23e9] : mov         qword ptr [r10+80h],rax<br>        [0xfffff8074ebd23f5] : mov         qword ptr [r10+44h],rax<br>    [0xfffff8074ebd2415]<br>        [0xfffff8074ebd2421] : mov         qword ptr [r10+98h],r8<br>        [0xfffff8074ebd2428] : mov         qword ptr [r10+0F8h],r9<br>        [0xfffff8074ebd2433] : mov         byte ptr gs:[5D18h],al<br>    [0xfffff8074ebd25b2]<br>        [0xfffff8074ebd25c3] : mov         qword ptr [rcx],rax<br>        [0xfffff8074ebd25c9] : mov         qword ptr [rcx+8],rax<br>        [0xfffff8074ebd25d0] : mov         qword ptr [rcx+10h],rax<br>        [0xfffff8074ebd25d7] : mov         qword ptr [rcx+18h],rax<br>        [0xfffff8074ebd25df] : mov         qword ptr [rcx+0A0h],rax<br>    [0xfffff8074ebd263f]<br>        [0xfffff8074ebd264f] : and         byte ptr [rax+5],0FDh<br>    [0xfffff8074ebd26da]<br>        [0xfffff8074ebd26e3] : mov         qword ptr [rcx],rax<br>        [0xfffff8074ebd26e9] : mov         qword ptr [rcx+8],rax<br>        [0xfffff8074ebd26f0] : mov         qword ptr [rcx+10h],rax<br>        [0xfffff8074ebd26f7] : mov         qword ptr [rcx+18h],rax<br>        [0xfffff8074ebd26ff] : mov         qword ptr [rcx+0A0h],rax<br>        [0xfffff8074ebd2708] : mov         word ptr [rcx+72h],ax<br>     ...</span></pre><p id="2318" data-selectable-paragraph="">As another project combining almost everything mentioned here, we can try to create a version of <code>!apc</code> using <code>dx</code>. To simplify we will only look for kernel APCs. To do that, we have a few steps:</p><ul><li id="5995" data-selectable-paragraph="">Iterate over all the processes using <code>@$cursession.Processes</code> to find the ones containing threads where <code>KTHREAD.ApcState.KernelApcPending</code> is set to 1.</li><li id="1652" data-selectable-paragraph="">Make a container in the process with only the threads that have pending kernel APCs. Ignore the rest.</li><li id="825a" data-selectable-paragraph="">For each of these threads, iterate over <code>KTHREAD.ApcState.ApcListHead[0]</code> (contains the kernel APCs) and gather interesting information about them. We can do that with the <code>FromListHead()</code> method we‚Äôve seen earlier.<br>To make our container as similar as possible to <code>!apc</code>, we will only get <code>KernelRoutine</code> and <code>RundownRoutine</code>, though in your implementation you might find there are other fields that interest you as well.</li><li id="5f1a" data-selectable-paragraph="">To make the container easier to navigate, collect process name, ID and <code>EPROCESS</code> address, and thread ID and <code>ETHREAD</code> address.</li><li id="c60c" data-selectable-paragraph="">In our implementation we implemented a few helper functions:<br><strong>@$printLn</strong> ‚Äî runs the legacy command <code>ln</code> with the supplied address, to get information about the symbol<br><strong>@$extractBetween</strong> ‚Äî extract a string between two other strings, will be used for getting a substring from the output of <code>@$printLn</code><br><strong>@$printSymbol </strong>‚Äî Sends an address to <code>@$printLn</code> and extracts the symbol name only using <code>@$extractSymbol</code><br><strong>@$apcsForThread</strong> ‚Äî Finds all kernel APCs for a thread and creates a container with their <code>KernelRoutine</code> and <code>RundownRoutine</code>.</li></ul><p id="948a" data-selectable-paragraph="">We then got all the processes that have threads with pending kernel APCs and saved it into the <code>@$procWithKernelApcs</code> register, and then in a separate command got the APC information using <code>@$apcsForThread</code>. We also cast the <code>EPPROCESS</code> and <code>ETHREAD</code> pointers to <code>void*</code> so <code>dx</code> doesn‚Äôt print the whole structure when we print the final result.</p><p id="4323" data-selectable-paragraph="">This was our way of solving this problem, but there can be others, and yours doesn‚Äôt have to be identical to ours!</p><p id="06c2" data-selectable-paragraph="">The script we came up with is:</p><pre><span id="6ca1" data-selectable-paragraph="">dx -r0 @$printLn = (a =&gt; Debugger.Utility.Control.ExecuteCommand(‚Äúln ‚Äú+((__int64)a).ToDisplayString(‚Äúx‚Äù)))</span><span id="ce70" data-selectable-paragraph="">dx -r0 @$extractBetween = ((x,y,z) =&gt; x.Substring(x.IndexOf(y) + y.Length, x.IndexOf(z) ‚Äî x.IndexOf(y) ‚Äî y.Length))</span><span id="de9f" data-selectable-paragraph="">dx -r0 @$printSymbol = (a =&gt; @$extractBetween(@$printLn(a)[3], ‚Äú ‚Äú, ‚Äú|‚Äù))</span><span id="241b" data-selectable-paragraph="">dx -r0 @$apcsForThread = (t =&gt; new {TID = t.Id, Object = (void*)&amp;t.KernelObject, Apcs = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&amp;t.KernelObject.Tcb.ApcState.ApcListHead[0], ‚Äúnt!_KAPC‚Äù, ‚ÄúApcListEntry‚Äù).Select(a =&gt; new { Kernel = @$printSymbol(a.KernelRoutine), Rundown = @$printSymbol(a.RundownRoutine)})})</span><span id="e947" data-selectable-paragraph="">dx -r0 @$procWithKernelApc = @$cursession.Processes.Select(p =&gt; new {Name = p.Name, PID = p.Id, Object = (void*)&amp;p.KernelObject, ApcThreads = p.Threads.Where(t =&gt; t.KernelObject.Tcb.ApcState.KernelApcPending != 0)}).Where(p =&gt; p.ApcThreads.Count() != 0)</span><span id="e394" data-selectable-paragraph="">dx -r6 @$procWithKernelApc.Select(p =&gt; new { Name = p.Name, PID = p.PID, Object = p.Object, ApcThreads = p.ApcThreads.Select(t =&gt; @$apcsForThread(t))})</span></pre><p id="3abe" data-selectable-paragraph="">And it produces the following output:</p><pre><span id="7f6f" data-selectable-paragraph=""><strong>dx -r6 @$procWithKernelApc.Select(p =&gt; new { Name = p.Name, PID = p.PID, Object = p.Object, ApcThreads = p.ApcThreads.Select(t =&gt; @$apcsForThread(t))})</strong></span><span id="82a9" data-selectable-paragraph="">@$procWithKernelApc.Select(p =&gt; new { Name = p.Name, PID = p.PID, Object = p.Object, ApcThreads = p.ApcThreads.Select(t =&gt; @$apcsForThread(t))})                <br>    [0x15b8]        <br>        Name             : SearchUI.exe<br>            Length           : 0xc<br>        PID              : 0x15b8<br>        Object           : 0xffffb90a5b1300c0 [Type: void *]<br>        ApcThreads      <br>            [0x159c]        <br>                TID              : 0x159c<br>                Object           : 0xffffb90a5b14f080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x1528]        <br>                TID              : 0x1528<br>                Object           : 0xffffb90a5aa6b080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x16b4]        <br>                TID              : 0x16b4<br>                Object           : 0xffffb90a59f1e080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x16a0]        <br>                TID              : 0x16a0<br>                Object           : 0xffffb90a5b141080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x16b8]        <br>                TID              : 0x16b8<br>                Object           : 0xffffb90a5aab20c0 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x1740]        <br>                TID              : 0x1740<br>                Object           : 0xffffb90a5ab362c0 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x1780]        <br>                TID              : 0x1780<br>                Object           : 0xffffb90a5b468080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x1778]        <br>                TID              : 0x1778<br>                Object           : 0xffffb90a5b6f7080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x17d0]        <br>                TID              : 0x17d0<br>                Object           : 0xffffb90a5b1e8080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x17d4]        <br>                TID              : 0x17d4<br>                Object           : 0xffffb90a5b32f080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x17f8]        <br>                TID              : 0x17f8<br>                Object           : 0xffffb90a5b32e080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0xb28]         <br>                TID              : 0xb28<br>                Object           : 0xffffb90a5b065600 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList   <br>            [0x1850]        <br>                TID              : 0x1850<br>                Object           : 0xffffb90a5b6a5080 [Type: void *]<br>                Apcs            <br>                    [0x0]           <br>                        Kernel           :   nt!EmpCheckErrataList   <br>                        Rundown          :   nt!EmpCheckErrataList</span></pre><p id="8591" data-selectable-paragraph="">Not as pretty as <code>!apc</code>, but still pretty</p><p id="dfad" data-selectable-paragraph="">We can also print it as a table, receive information about the processes and be able to explore the APCs of each process separately:</p><pre><span id="cb9e" data-selectable-paragraph="">dx -g @$procWithKernelApc.Select(p =&gt; new { Name = p.Name, PID = p.PID, Object = p.Object, ApcThreads = p.ApcThreads.Select(t =&gt; @$apcsForThread(t))})</span></pre><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*gnZbSJV0WmU3_2tSA9N_Sw.png?q=20" width="1509" height="337" role="presentation"></p><p><img width="1509" height="337" srcset="https://miro.medium.com/max/552/1*gnZbSJV0WmU3_2tSA9N_Sw.png 276w, https://miro.medium.com/max/1104/1*gnZbSJV0WmU3_2tSA9N_Sw.png 552w, https://miro.medium.com/max/1280/1*gnZbSJV0WmU3_2tSA9N_Sw.png 640w, https://miro.medium.com/max/1400/1*gnZbSJV0WmU3_2tSA9N_Sw.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="b2fd" data-selectable-paragraph="">But wait, what are all these APCs with<code>nt!EmpCheckErrataList</code>? And why does <code>SearchUI.exe</code> have all of them? What does this process have to do with erratas?</p><p id="c312" data-selectable-paragraph="">The secret is that there are not actually APCs meant to call<code>nt!EmpCheckErrataList</code>. And no, the symbols are not wrong.</p><p id="dd08" data-selectable-paragraph="">The thing we see here is happening because the compiler is being smart ‚Äî when it sees a few different functions that have the same code, it makes them all point to the same piece of code, instead of duplicating this code multiple times. You might think that this is not a thing that would happen very often, but lets look at the disassembly for <code>nt!EmpCheckErrataList</code> (the old way this time):</p><pre><span id="f3a5" data-selectable-paragraph=""><strong>u EmpCheckErrataList</strong></span><span id="8595" data-selectable-paragraph="">nt!EmpCheckErrataList:<br>fffff807`4eb86010 c20000          ret     0<br>fffff807`4eb86013 cc              int     3<br>fffff807`4eb86014 cc              int     3<br>fffff807`4eb86015 cc              int     3<br>fffff807`4eb86016 cc              int     3</span></pre><p id="556a" data-selectable-paragraph="">This is actually just a stub. It might be a function that has not been implemented yet (probably the case for this one) or a function that is meant to be a stub for a good reason. The function that is the real <code>KernelRoutine/RundownRoutine</code> of these APCs is <code>nt!KiSchedulerApcNop</code>, and is meant to be a stub on purpose, and has been for many years. And we can see it has the same code and points to the same address:</p><pre><span id="708d" data-selectable-paragraph=""><strong>u nt!KiSchedulerApcNop</strong></span><span id="e6e1" data-selectable-paragraph="">nt!EmpCheckErrataList:<br>fffff807`4eb86010 c20000          ret     0<br>fffff807`4eb86013 cc              int     3<br>fffff807`4eb86014 cc              int     3<br>fffff807`4eb86015 cc              int     3<br>fffff807`4eb86016 cc              int     3</span></pre><p id="978a" data-selectable-paragraph="">So why do we see so many of these APCs?</p><p id="8096" data-selectable-paragraph="">When a thread is being suspended, the system creates a semaphore and queues an APC to the thread that will wait on that semaphore. The thread will be waiting until someone asks the resume it, and then the system will free the semaphore and the thread will stop waiting and will resume. The APC itself doesn‚Äôt need to do much, but it must have a <code>KernelRoutine</code> and a <code>RundownRoutine</code>, so the system places a stub there. In the symbols this stub receives the name of one of the functions that have this ‚Äúcode‚Äù, this time <code>nt!EmpCheckErrataList</code>, but it can be a different one in the next version.</p><p id="ba60" data-selectable-paragraph="">Anyone interested in the suspension mechanism can look at <a href="https://github.com/reactos/reactos/blob/7523a7b13880b47d21f2ef17761450e5893e6f49/ntoskrnl/ke/thrdobj.c#L610" target="_blank" rel="noopener nofollow">ReactOS</a>. The code for these functions changed a bit since, and the stub function was renamed from <code>KiSuspendNop</code> to <code>KiSchedulerApcNop</code>, but the general design stayed similar.</p><p id="b613" data-selectable-paragraph="">But I got distracted, this is not what this blog was supposed to be talking about. Let‚Äôs get back to WinDbg and synthetic functions:</p><p id="2135" data-selectable-paragraph="">After covering synthetic methods, we can also add our own named types and use them to parse data where the type is not available to us.</p><p id="fa92" data-selectable-paragraph="">For example, let‚Äôs try to print the <code>PspCreateProcessNotifyRoutine</code> array, which holds all the registered process notify routines ‚Äî function that are registered by drivers and will receive a notification whenever a process starts. But this array doesn‚Äôt contain pointers to the registered routines. Instead it contains pointers to the non-documented <code>EX_CALLBACK_ROUTINE_BLOCK</code> structure.</p><p id="2e25" data-selectable-paragraph="">So to parse this array, we need to make sure WinDbg knows this type ‚Äî to do that we use <a href="https://github.com/Microsoft/WinDbg-Samples/tree/master/SyntheticTypes" target="_blank" rel="noopener nofollow">Synthetic Types</a>. We start by creating a header file containing all the types we want to define (I used <code>c:\temp\header.h</code>). In this case it‚Äôs just <code>EX_CALLBACK_ROUTINE_BLOCK</code>, that we can find in <a href="https://github.com/reactos/reactos/blob/21362c8e86b39b8da2e36f31047b0ec45b56c9a8/sdk/include/ndk/extypes.h#L535" target="_blank" rel="noopener nofollow">ReactOS</a>:</p><pre><span id="ac5f" data-selectable-paragraph="">typedef struct _EX_CALLBACK_ROUTINE_BLOCK<br>{<br>    _EX_RUNDOWN_REF RundownProtect;<br>    void* Function;<br>    void* Context;<br>} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;</span></pre><p id="0837" data-selectable-paragraph="">Now we can ask WinDbg to load it and add the types to the nt module:</p><pre><span id="919a" data-selectable-paragraph=""><strong>dx Debugger.Utility.Analysis.SyntheticTypes.ReadHeader("c:\\temp\\header.h", "nt")</strong></span><span id="b676" data-selectable-paragraph="">Debugger.Utility.Analysis.SyntheticTypes.ReadHeader("c:\\temp\\header.h", "nt")                 : ntkrnlmp.exe(header.h)<br>    ReturnEnumsAsObjects : false<br>    RegisterSyntheticTypeModels : false<br>    Module           : ntkrnlmp.exe<br>    Header           : header.h<br>    Types</span></pre><p id="ea91" data-selectable-paragraph="">This gives us an object which lets us see all the types added to this module.<br> Now that we defined the type, we can use it with <code>CreateInstance</code>:</p><pre><span id="79f8" data-selectable-paragraph=""><strong>dx Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", *(__int64*)&amp;nt!PspCreateProcessNotifyRoutine)</strong></span><span id="a318" data-selectable-paragraph="">Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", *(__int64*)&amp;nt!PspCreateProcessNotifyRoutine)                <br>    RundownProtect   [Type: _EX_RUNDOWN_REF]<br>    Function         : 0xfffff8074cbdff50 [Type: void *]<br>    Context          : 0x6e496c4102031400 [Type: void *]</span></pre><p id="cf24" data-selectable-paragraph="">It‚Äôs important to notice that <code>CreateInstance</code> only takes <code>__int64</code> inputs so any other type has to be cast. It‚Äôs good to know this in advance because the error messages these modules return are not always easy to understand.</p><p id="24d7" data-selectable-paragraph="">Now, if we look at our output, and specifically at Context, something seems weird. And actually if we try to dump Function we will see it doesn‚Äôt point to any code:</p><pre><span id="4065" data-selectable-paragraph="">dq 0xfffff8074cbdff50<br>fffff807`4cbdff50  ????????`???????? ????????`????????<br>fffff807`4cbdff60  ????????`???????? ????????`????????<br>fffff807`4cbdff70  ????????`???????? ????????`????????<br>fffff807`4cbdff80  ????????`???????? ????????`????????<br>fffff807`4cbdff90  ????????`???????? ????????`????????</span></pre><p id="d10b" data-selectable-paragraph="">So what happened? <br> The problem is not our cast to <code>EX_CALLBACK_ROUTINE_BLOCK</code>, but the address we are casting. If we dump the values in <code>PspCreateProcessNotifyRoutine</code> we might see what it is:</p><pre><span id="b3d7" data-selectable-paragraph=""><strong>dx ((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0)</strong></span><span id="14d6" data-selectable-paragraph="">((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0)                <br>    [0]              : 0xffffb90a530504ef [Type: void * *]<br>    [1]              : 0xffffb90a532a512f [Type: void * *]<br>    [2]              : 0xffffb90a53da9d5f [Type: void * *]<br>    [3]              : 0xffffb90a53da9ccf [Type: void * *]<br>    [4]              : 0xffffb90a53e5d15f [Type: void * *]<br>    [5]              : 0xffffb90a571469ef [Type: void * *]<br>    [6]              : 0xffffb90a5714722f [Type: void * *]<br>    [7]              : 0xffffb90a571473df [Type: void * *]<br>    [8]              : 0xffffb90a597d989f [Type: void * *]</span></pre><p id="df09" data-selectable-paragraph="">The lower half-byte in all of these is 0xF, while we know that pointers in x64 machines are always aligned to 8 bytes, and usually to 0x10. This is because I oversimplified it earlier ‚Äî these are not pointers to <code>EX_CALLBACK_ROUTINE_BLOCK</code>, they are actually <code>EX_CALLBACK</code> structures (another type that is not in the public pdb), containing an <code>EX_RUNDOWN_REF</code>. But to make this example simpler we will treat them as simple pointers that have been ORed with 0xF, since this is good enough for our purposes. If you ever choose to write a driver that will handle <code>PspCreateProcessNotifyRoutine</code> please do not use this hack, look into ReactOS and do things properly. üòä<br> So to fix our command we just need to align the addresses to 0x10 before casting them. To do that we do:</p><pre><span id="642f" data-selectable-paragraph="">&lt;address&gt; &amp; 0xFFFFFFFFFFFFFFF0</span></pre><p id="a7fd" data-selectable-paragraph="">Or the nicer version:</p><pre><span id="957d" data-selectable-paragraph="">&lt;address&gt; &amp; ~0xF</span></pre><p id="3cb6" data-selectable-paragraph="">Let‚Äôs use that in our command:</p><pre><span id="4c4d" data-selectable-paragraph=""><strong>dx Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", (*(__int64*)&amp;nt!PspCreateProcessNotifyRoutine) &amp; ~0xf)</strong></span><span id="ceda" data-selectable-paragraph="">Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", (*(__int64*)&amp;nt!PspCreateProcessNotifyRoutine) &amp; ~0xf)                <br>    RundownProtect   [Type: _EX_RUNDOWN_REF]<br>    Function         : 0xfffff8074ea7f310 [Type: void *]<br>    Context          : 0x0 [Type: void *]</span></pre><p id="8baa" data-selectable-paragraph="">This looks better. Let‚Äôs check that Function actually points to a function this time:</p><pre><span id="d904" data-selectable-paragraph="">ln 0xfffff8074ea7f310<br>Browse module<br>Set bu breakpoint</span><span id="4e14" data-selectable-paragraph="">(fffff807`4ea7f310)   nt!ViCreateProcessCallback   |  (fffff807`4ea7f330)   nt!RtlStringCbLengthW<br>Exact matches:<br>    nt!ViCreateProcessCallback (void)</span></pre><p id="7115" data-selectable-paragraph="">Looks much better! Now we can get define this cast as a synthetic method and get the function addresses for all routines in the array:</p><pre><span id="e346" data-selectable-paragraph=""><strong>dx -r0 @$getCallbackRoutine = (a =&gt; Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", (__int64)(a &amp; ~0xf)))</strong></span><span id="6f0a" data-selectable-paragraph=""><strong>dx ((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0).Select(a =&gt; @$getCallbackRoutine(a).Function)</strong></span><span id="2686" data-selectable-paragraph="">((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0).Select(a =&gt; @$getCallbackRoutine(a).Function)                <br>    [0]              : 0xfffff8074ea7f310 [Type: void *]<br>    [1]              : 0xfffff8074ff97220 [Type: void *]<br>    [2]              : 0xfffff80750a41330 [Type: void *]<br>    [3]              : 0xfffff8074f8ab420 [Type: void *]<br>    [4]              : 0xfffff8075106d9f0 [Type: void *]<br>    [5]              : 0xfffff807516dd930 [Type: void *]<br>    [6]              : 0xfffff8074ff252c0 [Type: void *]<br>    [7]              : 0xfffff807520b6aa0 [Type: void *]<br>    [8]              : 0xfffff80753a63cf0 [Type: void *]</span></pre><p id="f7fe" data-selectable-paragraph="">But this will be more fun if we could see the symbols instead of the addresses. We already know how to get the symbols by executing the legacy command <code>ln</code>, but this time we will do it with <code>.printf</code>. First we will write a helper function <code>@$getsym</code> which will run the command <code>printf "%y", &lt;address&gt;</code>:</p><pre><span id="6af9" data-selectable-paragraph="">dx -r0 @$getsym = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf\"%y\", " + ((__int64)x).ToDisplayString("x"))[0])</span></pre><p id="85bd" data-selectable-paragraph="">Then we will send every function address to this method, to print the symbol:</p><pre><span id="fb1f" data-selectable-paragraph=""><strong>dx ((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0).Select(a =&gt; @$getsym(@$getCallbackRoutine(a).Function))</strong></span><span id="c2ba" data-selectable-paragraph="">((void**[0x40])&amp;nt!PspCreateProcessNotifyRoutine).Where(a =&gt; a != 0).Select(a =&gt; @$getsym(@$getCallbackRoutine(a).Function))                <br>    [0]              : nt!ViCreateProcessCallback (fffff807`4ea7f310)<br>    [1]              : cng!CngCreateProcessNotifyRoutine (fffff807`4ff97220)<br>    [2]              : WdFilter!MpCreateProcessNotifyRoutineEx (fffff807`50a41330)<br>    [3]              : ksecdd!KsecCreateProcessNotifyRoutine (fffff807`4f8ab420)<br>    [4]              : tcpip!CreateProcessNotifyRoutineEx (fffff807`5106d9f0)<br>    [5]              : iorate!IoRateProcessCreateNotify (fffff807`516dd930)<br>    [6]              : CI!I_PEProcessNotify (fffff807`4ff252c0)<br>    [7]              : dxgkrnl!DxgkProcessNotify (fffff807`520b6aa0)<br>    [8]              : peauth+0x43cf0 (fffff807`53a63cf0)</span></pre><p id="5caf" data-selectable-paragraph="">There, much nicer!</p><p id="73a9" data-selectable-paragraph="">Conditional breakpoints are a huge pain-point when debugging. And with the old MASM syntax they‚Äôre almost impossible to use. I spent hours trying to get them to work the way I wanted to, but the command turns out to be so awful that I can‚Äôt even understand what I was trying to do, not to mention why it doesn‚Äôt filter anything or how to fix it.</p><p id="a9df" data-selectable-paragraph="">Well, these days are over. We can now use <code>dx</code> queries for conditional breakpoints with the following syntax: <code>bp /w ‚Äúdx query" &lt;address&gt;</code>.</p><p id="0ecd" data-selectable-paragraph="">For example, let‚Äôs say we are trying to debug an issue involving file opens by Wow64 processes. The function <code>NtOpenProcess</code> is called all the time, but we only care about calls done by Wow64 processes, which are not the majority of processes on modern systems. So to avoid helplessly going through 100 debugger breaks until we get lucky or struggle with MASM-style conditional breakpoints, we can do this instead:</p><pre><span id="3e18" data-selectable-paragraph="">bp /w "@$curprocess.KernelObject.WoW64Process != 0" nt!NtOpenProcess</span></pre><p id="2351" data-selectable-paragraph="">We then let the machine run, and when the breakpoint is hit we can check if it worked:</p><pre><span id="a0a8" data-selectable-paragraph="">Breakpoint 3 hit<br>nt!NtOpenProcess:<br>fffff807`2e96b7e0 4883ec38        sub     rsp,38h</span><span id="0f2e" data-selectable-paragraph=""><strong>dx @$curprocess.KernelObject.WoW64Process</strong></span><span id="6f58" data-selectable-paragraph="">@$curprocess.KernelObject.WoW64Process                 : 0xffffc10f5163b390 [Type: _EWOW64PROCESS *]<br>    [+0x000] Peb              : 0xf88000 [Type: void *]<br>    [+0x008] Machine          : 0x14c [Type: unsigned short]<br>    [+0x00c] NtdllType        : PsWowX86SystemDll (1) [Type: _SYSTEM_DLL_TYPE]</span><span id="393a" data-selectable-paragraph=""><strong>dx @$curprocess.Name</strong></span><span id="3f43" data-selectable-paragraph="">@$curprocess.Name : IpOverUsbSvc.exe<br>    Length           : 0x10</span></pre><p id="4c32" data-selectable-paragraph="">The process that triggered our breakpoint is a WoW64 process!<br> For anyone who has ever tried using conditional breakpoints with MASM, this is a life-changing addition.</p><p id="b738" data-selectable-paragraph="">There are a few other interesting breakpoint options found under <code>Debugger.Utility.Control</code>:</p><ul><li id="c014" data-selectable-paragraph=""><code>SetBreakpointAtSourceLocation</code> ‚Äî allowing us to set a breakpoint in a module whose source file is available to us, with this syntax: <code>dx Debugger.Utility.Control.SetBreakpointAtSourceLocation("MyModule!myFile.cpp", ‚Äú172‚Äù)</code></li><li id="416e" data-selectable-paragraph=""><code>SetBreakpointAtOffset</code> ‚Äî sets a breakpoint at an offset inside a function ‚Äî <code>dx Debugger.Utility.Control.SetBreakpointAtOffset("NtOpenFile", 8, ‚Äúnt")</code></li><li id="8673" data-selectable-paragraph=""><code>SetBreakpointForReadWriteFile</code> ‚Äî similar to the legacy <code>ba</code> command but with more readable syntax, this lets us set a breakpoint to issue a debug break whenever anyone reads or writes to an address. It has default configuration of <code>type = Hardware Write</code> and <code>size = 1</code>.<br> For example, let‚Äôs try to break on every read of <code>Ci!g_CiOptions</code>, a variable whose size is 4 bytes:</li></ul><pre><span id="05ef" data-selectable-paragraph="">dx Debugger.Utility.Control.SetBreakpointForReadWrite(&amp;Ci!g_CiOptions, ‚ÄúHardware Read‚Äù, 0x4)</span></pre><p id="1070" data-selectable-paragraph="">We let the machine keep running and almost immediately our breakpoint is hit:</p><pre><span id="1038" data-selectable-paragraph="">0: kd&gt; g<br>Breakpoint 0 hit<br>CI!CiValidateImageHeader+0x51b:<br>fffff807`2f6fcb1b 740c je CI!CiValidateImageHeader+0x529 (fffff807`2f6fcb29)</span></pre><p id="ada2" data-selectable-paragraph=""><code>CI!CiValidateImageHeader</code> read this global variable when validating an image header. In this specific example, we will see reads of this variable very often and writes into it are the more interesting case, as it can show us an attempt to tamper with signature validation.</p><p id="a104" data-selectable-paragraph="">An interesting thing to notice about these commands in that they don‚Äôt just set a breakpoint, they actually return it as an object we can control, which has attributes like <code>IsEnabled</code>, <code>Condition</code> (allowing us to set a condition), <code>PassCount</code> (telling us how many times this breakpoint has been hit) and more.</p><p id="e4eb" data-selectable-paragraph="">Under Debugger.Utility we have the <code>FileSystem</code> module, letting us query and control the file system on the host machine (<em>not</em> the machine we are debugging) from within the debugger:</p><pre><span id="70bf" data-selectable-paragraph=""><strong>dx -r1 Debugger.Utility.FileSystem</strong></span><span id="6a93" data-selectable-paragraph="">Debugger.Utility.FileSystem</span><span id="5dd1" data-selectable-paragraph="">CreateFile       [CreateFile(path, [disposition]) - Creates a file at the specified path and returns a file object.  'disposition' can be one of 'CreateAlways' or 'CreateNew']</span><span id="2def" data-selectable-paragraph="">CreateTempFile   [CreateTempFile() - Creates a temporary file in the %TEMP% folder and returns a file object]</span><span id="13b2" data-selectable-paragraph="">CreateTextReader [CreateTextReader(file | path, [encoding]) - Creates a text reader over the specified file.  If a path is passed instead of a file, a file is opened at the specified path.  'encoding' can be 'Utf16', 'Utf8', or 'Ascii'.  'Ascii' is the default]</span><span id="c53e" data-selectable-paragraph="">CreateTextWriter [CreateTextWriter(file | path, [encoding]) - Creates a text writer over the specified file.  If a path is passed instead of a file, a file is created at the specified path.  'encoding' can be 'Utf16', 'Utf8', or 'Ascii'.  'Ascii' is the default]</span><span id="60c0" data-selectable-paragraph="">CurrentDirectory : C:\WINDOWS\system32</span><span id="220c" data-selectable-paragraph="">DeleteFile       [DeleteFile(path) - Deletes a file at the specified path]</span><span id="110e" data-selectable-paragraph="">FileExists       [FileExists(path) - Checks for the existance of a file at the specified path]</span><span id="6499" data-selectable-paragraph="">OpenFile         [OpenFile(path) - Opens a file read/write at the specified path]</span><span id="82b1" data-selectable-paragraph="">TempDirectory    : C:\Users\yshafir\AppData\Local\Temp</span></pre><p id="82ed" data-selectable-paragraph="">We can create files, open them, write into them, delete them or check if a file exists in a certain path. To see a simple example, let‚Äôs dump the contents of our current directory ‚Äî <code>C:\Windows\System32</code>:</p><pre><span id="2343" data-selectable-paragraph=""><strong>dx -r1 Debugger.Utility.FileSystem.CurrentDirectory.Files</strong></span><span id="4613" data-selectable-paragraph="">Debugger.Utility.FileSystem.CurrentDirectory.Files                <br>    [0x0]            : C:\WINDOWS\system32\07409496-a423-4a3e-b620-2cfb01a9318d_HyperV-ComputeNetwork.dll<br>    [0x1]            : C:\WINDOWS\system32\1<br>    [0x2]            : C:\WINDOWS\system32\103<br>    [0x3]            : C:\WINDOWS\system32\108<br>    [0x4]            : C:\WINDOWS\system32\11<br>    [0x5]            : C:\WINDOWS\system32\113<br>    ...<br>    [0x44]           : C:\WINDOWS\system32\93<br>    [0x45]           : C:\WINDOWS\system32\98<br>    [0x46]           : C:\WINDOWS\system32\@AppHelpToast.png<br>    [0x47]           : C:\WINDOWS\system32\@AudioToastIcon.png<br>    [0x48]           : C:\WINDOWS\system32\@BackgroundAccessToastIcon.png<br>    [0x49]           : C:\WINDOWS\system32\@bitlockertoastimage.png<br>    [0x4a]           : C:\WINDOWS\system32\@edptoastimage.png<br>    [0x4b]           : C:\WINDOWS\system32\@EnrollmentToastIcon.png<br>    [0x4c]           : C:\WINDOWS\system32\@language_notification_icon.png<br>    [0x4d]           : C:\WINDOWS\system32\@optionalfeatures.png<br>    [0x4e]           : C:\WINDOWS\system32\@VpnToastIcon.png<br>    [0x4f]           : C:\WINDOWS\system32\@WiFiNotificationIcon.png<br>    [0x50]           : C:\WINDOWS\system32\@windows-hello-V4.1.gif<br>    [0x51]           : C:\WINDOWS\system32\@WindowsHelloFaceToastIcon.png<br>    [0x52]           : C:\WINDOWS\system32\@WindowsUpdateToastIcon.contrast-black.png<br>    [0x53]           : C:\WINDOWS\system32\@WindowsUpdateToastIcon.contrast-white.png<br>    [0x54]           : C:\WINDOWS\system32\@WindowsUpdateToastIcon.png<br>    [0x55]           : C:\WINDOWS\system32\@WirelessDisplayToast.png<br>    [0x56]           : C:\WINDOWS\system32\@WwanNotificationIcon.png<br>    [0x57]           : C:\WINDOWS\system32\@WwanSimLockIcon.png<br>    [0x58]           : C:\WINDOWS\system32\aadauthhelper.dll<br>    [0x59]           : C:\WINDOWS\system32\aadcloudap.dll<br>    [0x5a]           : C:\WINDOWS\system32\aadjcsp.dll<br>    [0x5b]           : C:\WINDOWS\system32\aadtb.dll<br>    [0x5c]           : C:\WINDOWS\system32\aadWamExtension.dll<br>    [0x5d]           : C:\WINDOWS\system32\AboutSettingsHandlers.dll<br>    [0x5e]           : C:\WINDOWS\system32\AboveLockAppHost.dll<br>    [0x5f]           : C:\WINDOWS\system32\accessibilitycpl.dll<br>    [0x60]           : C:\WINDOWS\system32\accountaccessor.dll<br>    [0x61]           : C:\WINDOWS\system32\AccountsRt.dll<br>    [0x62]           : C:\WINDOWS\system32\AcGenral.dll<br>    ...</span></pre><p id="27da" data-selectable-paragraph="">We can choose to delete one of these files:</p><pre><span id="8f11" data-selectable-paragraph="">dx -r1 Debugger.Utility.FileSystem.CurrentDirectory.Files[1].Delete()</span></pre><p id="c929" data-selectable-paragraph="">Or delete it through <code>DeleteFile</code>:</p><pre><span id="e5ee" data-selectable-paragraph="">dx Debugger.Utility.FileSystem.DeleteFile(‚ÄúC:\\WINDOWS\\system32\\71‚Äù)</span></pre><p id="30b1" data-selectable-paragraph="">Notice that in this module paths have to have double backslash (‚Äú\\‚Äù), as they would if we had called the Win32 API ourselves.</p><p id="2775" data-selectable-paragraph="">As a last exercise we‚Äôll put together a few of the things we learned here ‚Äî we‚Äôre going to create a breakpoint on a kernel variable, get the symbol that accessed it from the stack and write the symbol the accessed it into a file on our host machine.</p><p id="913e" data-selectable-paragraph="">Let‚Äôs break it down into steps:</p><ul><li id="1a34" data-selectable-paragraph="">Open a file to write the results to.</li><li id="5dd8" data-selectable-paragraph="">Create a text writer, which we will use to write into the file.</li><li id="d686" data-selectable-paragraph="">Create a breakpoint for access into a variable. In this case we‚Äôll choose <code>nt!PsInitialSystemProcess</code> and set a breakpoint for read access. We will use the old MASM syntax to run a dx command every time the breakpoint is hit and move on: <code>ba r4 &lt;address&gt; "dx &lt;command&gt;; g"</code> <br>Our command will use <code>@$curstack</code> to get the address that accessed the variable, and then use the <code>@$getsym</code> helper function we wrote earlier to find the symbol for it. We‚Äôll use our text writer to write the result into the file.</li><li id="2ca3" data-selectable-paragraph="">Finally, we will close the file.</li></ul><p id="d333" data-selectable-paragraph="">Putting it all together:</p><pre><span id="6c67" data-selectable-paragraph="">dx -r0 @$getsym = (x =&gt; Debugger.Utility.Control.ExecuteCommand(".printf\"%y\", " + ((__int64)x).ToDisplayString("x"))[0])</span><span id="c9d0" data-selectable-paragraph="">dx @$tmpFile = Debugger.Utility.FileSystem.TempDirectory.OpenFile("log.txt")</span><span id="3240" data-selectable-paragraph="">dx @$txtWriter = Debugger.Utility.FileSystem.CreateTextWriter(@$tmpFile)</span><span id="5d26" data-selectable-paragraph="">ba r4 nt!PsInitialSystemProcess "dx @$txtWriter.WriteLine(@$getsym(@$curstack.Frames[0].Attributes.InstructionOffset)); g"</span></pre><p id="06d6" data-selectable-paragraph="">We let the machine run for as long as we want, and when we want to stop the logging we can disable or clear the breakpoint and close the file with <code>dx @$tmpFile.Close()</code>.</p><p id="282e" data-selectable-paragraph="">Now we can open our <code>@$tmpFile</code> and look at the results:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*baVE_kBwdqDQYv6t23Hxpg.png?q=20" width="1603" height="1474" role="presentation"></p><p><img width="1603" height="1474" srcset="https://miro.medium.com/max/552/1*baVE_kBwdqDQYv6t23Hxpg.png 276w, https://miro.medium.com/max/1104/1*baVE_kBwdqDQYv6t23Hxpg.png 552w, https://miro.medium.com/max/1280/1*baVE_kBwdqDQYv6t23Hxpg.png 640w, https://miro.medium.com/max/1400/1*baVE_kBwdqDQYv6t23Hxpg.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="fb9a" data-selectable-paragraph="">That‚Äôs it! What an amazingly easy way to log information about the debugger!</p><p id="a25b" data-selectable-paragraph="">So that‚Äôs the end of our WinDbg series! All the scripts in this series will be uploaded to a github repo, as well as some new ones not included here. I suggest you investigate this data model further, because we didn‚Äôt even cover all the different methods it contains. Write cool tools of your own and share them with the world :)</p><p id="6efc" data-selectable-paragraph="">And as long as this guide was, these are not even all the possible options in the new data model. And I didn‚Äôt even mention the new support for Javascript! You can get more information about using Javascript in WinDbg and the new and exciting support for TTD (time travel debugging) in this excellent <a href="https://doar-e.github.io/blog/2017/12/01/debugger-data-model/" target="_blank" rel="noopener nofollow">post</a>.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>