<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Tiered Compilation Preview in .NET Core 2.1 | .NET Blog -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Tiered Compilation Preview in .NET Core 2.1 | .NET Blog</h1>
    <div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/bdcd77a4ebc105ecb118c771f6757150?s=58&amp;d=mm&amp;r=g" width="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Noah</p></div></div></div><p>If you are a fan of .NET performance there has been a lot great news lately such as <a href="https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/">Performance Improvements in .NET Core 2.1</a> and <a href="https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/">Announcing .NET Core 2.1</a>, but we&#x2019;ve got more. Tiered compilation is a significant new performance feature that we are making available as a preview for anyone to try out, starting in .NET Core 2.1. In many scenarios that we have tested, applications start faster and run faster at steady state. All it needs from you is a smidgen of curiosity, a project that runs on .NET Core 2.1, and a trivial change to your environment variables or project file to enable it. In the rest of this post we&#x2019;ll cover what it is, how you use it, and why it is the hidden gem of the 2.1 release!</p><h2><a id="user-content-what-is-tiered-compilation" class="anchor" href="#what-is-tiered-compilation"></a>What is Tiered Compilation?</h2><p>Since the beginnings of .NET Framework, every method in your code was typically compiled once. However there are tradeoffs to be made when deciding how to do that compilation that will affect the performance of your application. For example the JIT could do very aggressive optimization and get great steady-state performance, but optimizing code well is not a quick endeavor so your application would start very slowly. Alternately the JIT could use very simple compilation algorithms that run quickly so your application starts fast, but the code quality would be much worse and steady-state application throughput would suffer. .NET has always tried to take a balanced approach that would do a reasonable job at both startup and steady-state performance, but using a single compilation means compromise was required.</p><p>The Tiered Compilation feature changes the premise by allowing .NET to have multiple compilations for the same method that can be hot-swapped at runtime. This separates the decision making so that we can pick a technique that is best for startup, pick a second technique that is best for steady-state and then deliver great performance on both. In .NET Core 2.1 this is what Tiered Compilation aims to do for your application if you opt-in:</p><ul><li><strong>Faster application startup time</strong> &#x2013; When an application starts it waits for some MSIL code to JIT. Tiered compilation asks the JIT to generate the initial compilation very quickly, sacrificing code quality optimization if needed. Afterwards, if the method is called frequently, more optimized code is generated on a background thread and the initial code is replaced to preserve the application&#x2019;s steady state performance.</li><li><strong>Faster steady-state performance</strong> &#x2013; For a typical .NET Core application most of the framework code will load from pre-compiled (<a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md">ReadyToRun</a>) images. This is great for startup, but the pre-compiled images have versioning constraints and CPU instruction constraints that prohibit some types of optimization. For any methods in these images that are called frequently Tiered Compilation requests the JIT to create optimized code on a background thread that will replace the pre-compiled version.</li></ul><h2><a id="user-content-faster-how-much-faster" class="anchor" href="#faster-how-much-faster"></a>Faster? How much faster?</h2><p>Part of reason we are releasing this as a preview is to learn how it performs for your apps, but below are some examples we have tested it on. Although very scenario dependent, we hope these results are typical of what you will see on similar workloads and that the results will continue to improve as the feature matures. The baseline is .NET Core 2.1 RTM running in a default configuration and all the numbers are scaled so that baseline always measures 1.0. In this first group we&#x2019;ve got a couple of Tech Empower tests and <a href="https://github.com/aspnet/musicstore">Music Store</a>, our frequent sample ASP.NET app.</p><p><a href="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/asp_net_startup.png"> <img class="aligncenter size-full wp-image-18565" src="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/asp_net_startup.png" alt width="1302"> </a></p><p><a href="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/asp_net_steady_state.png"> <img class="aligncenter size-full wp-image-18575" src="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/asp_net_steady_state.png" alt width="1302"> </a></p><p>Although a few of our ASP.NET benchmarks benefited particularly well (MvcPlaintext RPS up over 60% &#x2013; wow!), tiered compilation is in no way specific to ASP.NET. Here are some example .NET Core command line apps you might come across in daily development:</p><p><a href="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/console_app_performance.png"> <img class="aligncenter size-full wp-image-18585" src="https://devblogs.microsoft.com/wp-content/uploads/sites/10/2019/02/console_app_performance.png" alt width="1301"> </a></p><p>How will your apps fare? It is much easier to measure than to predict but we can offer a few broad rules of thumb.</p><ol><li>The startup improvements apply primarily to reduced time jitting managed code. You can use tools such as <a href="https://github.com/Microsoft/perfview">PerfView</a> to determine how much time your app spends doing this. In our testing time spent jitting would often decrease by about 35%.</li><li>The steady-state improvements apply primarily to applications that are CPU bound where some of the hot code is coming from the .NET or ASP.NET precompiled libraries. Profilers such as <a href="https://github.com/Microsoft/perfview">PerfView</a> can help you determine if your app is in this category.</li></ol><h2><a id="user-content-trying-it-out" class="anchor" href="#trying-it-out"></a>Trying it out</h2><p>A small disclaimer, the feature is still a preview. We&#x2019;ve done a lot of testing on it but haven&#x2019;t enabled the feature by default because we want to gather feedback and continue to make adjustments. Turning it on might not make your app faster or you might run into other rough edges we&#x2019;ve missed. We are here to help if you encounter issues and you can always disable it easily. You can turn this on in production if you like, but we strongly suggest testing it out beforehand.</p><p>There are several ways to opt-in, all of which have the same effect:</p><ul><li>If you build the application yourself using .NET 2.1 SDK &#x2013; Add the MSBuild property <strong>&lt;TieredCompilation&gt;true&lt;/TieredCompilation&gt;</strong> to the default property group in your project file. For example:</li></ul><ul><li>If you run an application that has already been built, edit runtimeconfig.json to add <strong>System.Runtime.TieredCompilation=true</strong> to the configProperties. For example:</li></ul><div id="crayon-5cfa954bc4bf5996076184" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate"><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums "></td><td class="crayon-code"><div class="crayon-pre"><div class="crayon-line" id="crayon-5cfa954bc4bf5996076184-4"><span class="crayon-h">&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;</span><span class="crayon-s">&quot;System.Runtime.TieredCompilation&quot;</span><span class="crayon-o">:</span><span class="crayon-h"> </span><span class="crayon-t">true</span></div></div></td></tr></table></div></div><p>If you run an application and don&#x2019;t want to modify any files, set the environment variable</p><div id="crayon-5cfa954bc4c11634954516" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate"><div class="crayon-main"><table class="crayon-table"><tr class="crayon-row"><td class="crayon-nums "></td><td class="crayon-code"><div class="crayon-pre"><div class="crayon-line" id="crayon-5cfa954bc4c11634954516-1"><span class="crayon-h"> </span><span class="crayon-v">COMPlus_TieredCompilation</span><span class="crayon-o">=</span><span class="crayon-cn">1</span></div></div></td></tr></table></div></div><p>For more details about trying it out and measuring performance, check out the <a href="https://github.com/aspnet/JitBench/blob/tiered_compilation_demo/README.md">Tiered Compilation Demo</a></p><h2><a id="user-content-getting-technical" class="anchor" href="#getting-technical"></a>Getting Technical</h2><p>Curious how it works? Fear not, understanding these internal details are not necessary to use tiered compilation and you can skip this section if you wish. At a glance the feature can be divided into four different parts:</p><ul><li>The JIT compiler which can be configured to generate assembly code of differing quality &#x2013; Surprisingly to many people, this has not been the focus in the feature so far. Going back to almost the beginning of .NET the JIT supported a default compilation mode and a no optimization compilation mode that is used for debugging. The normal mode produces better code quality and takes longer to compile whereas &#x2018;no optimization&#x2019; mode is the reverse. For Tiered Compilation we created new configuration names &#x2018;Tier0&#x2019; and &#x2018;Tier1&#x2019;, but the code these configurations generate is largely identical to the &#x2018;no optimization&#x2019; and &#x2018;normal&#x2019; modes we generated all along. Most of the JIT changes so far have involved making the JIT generate code faster when &#x2018;Tier0&#x2019; code is requested. We hope to continue improving Tier0 compilation speed in the future, as well as improve the code quality produced at Tier1.</li><li>The CodeVersionManager which keeps track of different compilations (versions) of code that exist for the same method &#x2013; At its most basic this is a big in-memory dictionary that stores the mapping between .NET methods in your application and a list of different assembly implementations the runtime has at its disposal to execute the method. We use a few tricks to optimize this data structure but if you want to dig in on this aspect of the project <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/code-versioning.md">our very nice spec</a> is available.</li><li>A mechanism to hot-swap at runtime between different assembly code compilations of the same method &#x2013; When method A calls method B, the call lands on a jmp instruction. By adjusting the target of the jmp instruction the runtime can control which implementation of B is executed.</li><li>A policy that decides what code versions to create and when to switch between them &#x2013; The runtime always creates Tier0 first which is either code loaded from a ReadyToRun image, or code jitted with minimal optimization. A call counter is used to determine which methods are run frequently and a timer is used to avoid the work of creating Tier1 too soon during startup. Once both the counter and timer are satisfied the method is queued and a background thread compiles the Tier1 version. For more details check out <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/tiered-compilation.md">the spec</a>.</li></ul><h2><a id="user-content-where-do-we-go-from-here" class="anchor" href="#where-do-we-go-from-here"></a>Where do we go from here?</h2><p>Tiered Compilation creates a variety of possibilities we could continue to capitalize on well into the future. Historically our JIT has been constrained to investing in techniques relatively near the middle ground positions of speed and code quality that .NET has always needed. Now that the runtime can capitalize on more extreme tradeoff positions we&#x2019;ve got the leeway and the incentive to push the boundaries, both to make compilation faster and to generate higher quality code. With runtime hot-swapping of code .NET could start doing more detailed profiling and then use the runtime feedback to do even better optimization (profile guided optimization). Such techniques can allow code generators to out-perform even the best static optimizers that don&#x2019;t have access to profile data. Or there are yet other options such as dynamic deoptimization for better diagnostics, collectible code to reduce memory usage, and hot patching for instrumentation or servicing. For now our most immediate goal remains a bit closer to the ground &#x2013; make sure the functionality in the preview works well, respond to your feedback, and finish this first iteration of the work.</p><h2><a id="user-content-wrapping-up" class="anchor" href="#wrapping-up"></a>Wrapping Up</h2><p>We hope Tiered Compilation gives your applications the same great improvements as our benchmarks and we know there is even more untapped potential yet to come. Please <a href="https://github.com/aspnet/JitBench/blob/tiered_compilation_demo/README.md">give it a try</a> and then <a href="https://github.com/dotnet/coreclr/issues/4331">come visit on github</a> to give us your feedback, discuss, ask questions, and maybe even contribute some code of your own. Thanks!</p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>