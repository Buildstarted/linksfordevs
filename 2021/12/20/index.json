[
  {
    "Title": "This is my Mum's 80th birthday present.",
    "Url": "http://fourlightyears.blogspot.com/2021/12/this-is-my-mums-80th-birthday-present.html",
    "Timestamp": "2021-12-20T10:01:58",
    "Domain": "fourlightyears.blogspot.com",
    "Description": " 20 Dec 2021 andrew.stuart@supercoders.com.au It's a rotary phone from the 1970's.  This is the sort of phone we had in the house when I was..."
  },
  {
    "Title": "Third-Party DI Container And Autofac - Code Maze",
    "Url": "https://code-maze.com/using-autofac-dotnet/",
    "Timestamp": "2021-12-20T09:02:33",
    "Domain": "code-maze.com",
    "Description": "Autofac is a popular and flexible third-party dependency injection container for .NET application development."
  },
  {
    "Title": "286: is not null",
    "Url": "https://www.mergeconflict.fm/285",
    "Timestamp": "2021-12-20T09:02:30",
    "Domain": "www.mergeconflict.fm",
    "Description": "More C# features coming at you! Ones that you totally need to know about!"
  },
  {
    "Title": "Use calendar, mailbox settings and Teams presence in ASP.NET Core hosted Blazor WASM with Microsoft Graph",
    "Url": "https://damienbod.com/2021/12/20/use-calendar-mailbox-settings-and-teams-presence-in-asp-net-core-hosted-blazor-wasm-with-microsoft-graph/",
    "Timestamp": "2021-12-20T09:02:29",
    "Domain": "damienbod.com",
    "Description": "This article shows how to use Microsoft Graph with delegated permissions in a Blazor WASM ASP.NET Core hosted application. The application uses Microsoft.Identity.Web and the BFF architecture to au…"
  },
  {
    "Title": ".NET Advent Calendar - .NET Advent Calendar 2021, Day 18",
    "Url": "https://dotnet.christmas/2021/18",
    "Timestamp": "2021-12-20T09:02:29",
    "Domain": "dotnet.christmas",
    "Description": "One blog post every day until Christmas."
  },
  {
    "Title": "TypeScript for Pythonistas",
    "Url": "https://medium.com/@Pilot-EPD-Blog/typescript-for-pythonistas-f90bbb297f0a",
    "Timestamp": "2021-12-20T06:02:25",
    "Domain": "medium.com",
    "Description": "Authored by Allison Kaptur"
  },
  {
    "Title": "Getting started with #DynamoDB in C#",
    "Url": "https://blog.dotnetframework.org/2021/12/14/getting-started-with-dynamodb-in-c/",
    "Timestamp": "2021-12-20T06:02:21",
    "Domain": "blog.dotnetframework.org",
    "Description": "DynamoDB is a good way to get started with NoSQL databases, and being hosted in AWS, means that you don’t have to worry about servers or backups. Now, a few assumptions before starting. I&#82…"
  },
  {
    "Title": "How to Upgrade a Codebase from .NET Framework to .NET 6",
    "Url": "https://christianfindlay.com/2021/12/12/upgrade-to-net-6/",
    "Timestamp": "2021-12-20T06:02:20",
    "Domain": "christianfindlay.com",
    "Description": "\nYou're probably here because your business has a legacy codebase, and you need to upgrade it. You're not alone, and almost every business goes through a similar thing at some stage. This post is part guide and part food for thought. Here, the focus is on upgrading a back-end from ASP.NET to ASP .NET Core, but you will find this helpful if you need to upgrade any code from Framework to .NET 6. You may want to break your architecture up into Microservices, or you may want to consolidate microservices back into a single service. You may want to upgrade your WPF app to WPF on .NET 6. Whatever your goal is, the process for upgrading to .NET 6 is going to be more or less the same.\n\n\n\nYour Codebase\n\n\n\nYou have a legacy system running on .NET Framework 4.x. It's probably a bit of a mess with some .NET Framework libraries, some .NET Standard or .NET Core libraries scattered around. Perhaps you share some code with Xamarin or UWP apps. Some of your code may be ready to come along for the ride, and some may not. You will go through a process involving sorting through the projects and determining what to upgrade, abandon, or rewrite.\n\n\n\nRefactor, Rewrite or Bifurcate?\n\n\n\nYou will need to look at each of your projects one by one and decide what to do with them. You may find that you can simply delete some old projects. But, you will need to decide what to do with important code.\n\n\n\nRefactoring involves upgrading the existing code to work in the new environment under .NET 6. It will probably also target .NET Framework with multi-targeting. This is the best-case scenario, and I'll explain why shortly.\n\n\n\nRewriting involves rewriting the code from scratch. The new code probably won't run on .NET Framework. It will only target .NET 6. This requires the most work.\n\n\n\nBifurcation means taking the old .NET Framework code, copying and pasting it into a new .NET 6 project, and getting it to run there. You should prefer refactoring to bifurcation, but you may not be able to do this in all scenarios. More on this soon.\n\n\n\nThe Roadmap\n\n\n\nAre you going to upgrade all the code in the background and then cut across to .NET 6 when you finish the process? Or, can you upgrade each project in the legacy codebase in a way that allows you to keep maintaining the legacy codebase while also targeting .NET 6?\n\n\n\nThe latter involves some risk because the upgrade process could disrupt the legacy system, but the risk may well be worth it, and here is why...\n\n\n\nAny code rewrites involve maintaining two sets of code: the legacy code and the new code. You will need to maintain both until you can delete the legacy code. If the legacy system is still running, you need to do bug fixes and potentially feature enhancements until you turn off the legacy system. If the code exists in two places, you need to apply the fixes and features to two codebases. Do not underestimate how much work this requires. Think about the maintenance of your current system. Is that onerous? Yes. Of course, it is. Now imagine doing that maintenance twice. You are doubling your workload. Not only do you have to fix the issue in the existing live system, but you also need to merge those changes into the new .NET 6 codebase. Nothing could be more frustrating and time-consuming for developers.\n\n\n\nThe good news is that .NET Framework code is mostly compatible with modern .NET Code. You can refactor at least part of the existing legacy system and take the benefits of those refactors into your new .NET 6 codebase. As mentioned, this adds a little risk to the legacy system, but it also means that improvements to your legacy system add value to your .NET 6 codebase. The key is multi-targeting. You can convert your existing .NET Framework projects to target newer formats such as .NET Standard or .NET 6. That code will run on .NET Framework in your legacy system and on .NET 6. It can also target platforms such as UWP or Xamarin.\n\n\n\nSo, your roadmap needs to include some multi-targeting. How much is up to you and your team, but the more you can multi-target, the less double maintenance you will require.\n\n\n\nChanging the Data Store(s)\n\n\n\nYou may be breaking up your data store for Microservices. Or, you may be consolidating multiple data stores. Either way, you should probably do this before or after the technology upgrade. Changing data stores in the middle of an upgrade will be far more difficult. These are ultimately different processes and you shouldn't confuse one with the other. Upgrading your code to .NET 6 will put you in a very good position to move to Microservices as the next step.\n\n\n\nStep 1 - Understand Your Dependencies\n\n\n\nYou should take some time to survey your projects and how they depend on one another. If you have a tool to generate a dependency diagram, this will be very helpful. It will also be helpful to survey external NuGet packages and so on that, your projects depend on. Do you use NuGet packages that don't exist in .NET 6?\n\n\n\nNDepend is a Visual Studio tool that generates amazing Dependency Diagrams\n\n\n\nStep 2 - Upgrade the Visual Studio Project (csproj) Format\n\n\n\nLegacy codebases tend to use the old csproj format. This format is overly verbose and requires a lot of explicit definitions. The newer format (SDK Style) requires minimal explicit configuration and enables you to compile the code (target) for .NET Framework and .NET 6 or .NET Standard. You should upgrade as many of your .NET Framework projects as you can. At the very least, you will find maintaining the newer project format more manageable, and you will see less Git history for your projects. Focus on projects you think you will need in the new .NET 6 system, but it's even better if you can upgrade all projects.\n\n\n\nYou can use the .NET Upgrade Assistant to help you. See this section on using the upgrade tool or migrating by hand, along with some preparation.\n\n\n\nStart the upgrade process on the lowest level libraries first - i.e., the libraries that other libraries depend on and work your way up the dependency graph. Leave the highest level projects like Web API or UI code until last. They are likely to change the most and require the most thought.\n\n\n\nA typical old style csproj\n\n\n\nStep 3 - Multi-target .NET Framework and .NET Standard or .NET 6\n\n\n\nFirstly, you should read through this documentation from Microsoft.\n\n\n\nWhen your projects use the SDK Style project format, you can attempt to compile to .NET 6 or .NET Standard. See this documentation on multi-targeting. You should see this chart if you need to target Xamarin or UWP. There is some further reading here. That might require you to target .NET Framework and .NET Standard 2.0 or 2.1 instead of .NET 6. If that's the case, the library will still run fine on .NET 6. But, if you don't need Xamarin or UWP, you can target .NET Framework and .NET 6.\n\n\n\n\nhttps://gist.github.com/MelbourneDeveloper/8f3d8b882f3554dfaa2780e92262182a\nThis is a modern multi-targeting csproj file. It covers .NET 4.5, UWP, Xamarin up to .NET 6\n\n\n\nStep 4 - Fix Code Issues\n\n\n\nTargeting the newer .NET version such as .NET 6 will cause some compilation and dependency issues. Some .NET Framework libraries may not have versions compatible with .NET 6. You need to fix all the code issues that appear. \n\n\n\nIf .NET 6 is missing a library that you use in .NET Framework, you will need to find an alternative or write the code yourself. The best thing is to find a more recent supported library and replace the existing code with code that uses the new library. Otherwise, you will need to use #if with different code paths for both targets.\n\n\n\nYou don't have to fix all compilation issues straight away. You can leave some targets in a non-compilational state while gradually fixing up each project. The main thing you need to do is ensure that the .NET Framework version still compiles. This ensures you can still release versions of your legacy system. You will need to create a process for creating builds without the .NET 6 targets until that code compiles. One approach might be to remove all the .NET 6 targets until it compiles.\n\n\n\nYou can take this opportunity to refactor your existing code and add unit tests, and so on. Or, you can choose to avoid risky refactors. The latter is sensible because refactors can break the legacy system. You should be able to upgrade all your projects without changing too much of the original code. Where .NET 6 is incompatible with legacy code, you can use #if so that the old code stays exactly the same.\n\n\n\nThere are some tools that you have at your disposal to help you. You can use partial classes so that the majority of the class exists in one file and then two other versions for the .NET 6 and .NET Framework specific code. You conditionally include/exclude files based on the target. You can do the same for NuGet packages. You don't have to keep the same dependency set for .NET Framework as you would with .NET 6.\n\n\n\nWork through all the code (except for the highest level projects) until you don't see any compilation issues.\n\n\n\nStep 5 - High-Level Projects\n\n\n\nBy now, your low-level dependency projects should be compiling for .NET 6 or .NET Standard, but you still need to convert the highest level code. For Web API back-ends, you will need to convert those from ASP .NET to ASP .NET Core. \n\n\n\nIf those projects have code that you can move to lower-level projects, you should do that. For example, you may have some DTO classes in your highest-level project. Most of those to a shared library so that the high-level .NET Framework and .NET 6 projects can access the shared code. These high-level projects should only include the specifics of the Web API. They should not contain logic. Web API projects should only include endpoint controllers, HTTP pipeline code, IoC composition, routing configuration, etc. \n\n\n\nYou will probably need to maintain two of the highest-level projects. For example, you may keep an ASP.NET MVC app and an ASP .NET Core Web API app. That means you can compile and run the original Web API and the new one from the same solution. You will probably need to rewrite large chunks of the highest-level projects. But, these projects will share most of the same project dependencies, and you can share code files by adding files as links. Try to minimize the amount of duplicate code. \n\n\n\nMy experience tells me that you can share a lot of code between ASP .NET MVC Web Apis and ASP.NET Core Web Apis. You should probably keep the endpoints exactly the same between the two versions because this allows you to run the same code side by side.\n\n\n\nStep 6 - Testing\n\n\n\nYou should already have unit tests and integration tests in your system. If you do, you should run them regularly to ensure that the new API works the same as the old API. If not, should add them where possible during the upgrade process. The good news is that ASP .NET Core has a good integration testing system, so you should implement this as early as possible in the upgrade process.\n\n\n\nIf you've been careful to keep the original .NET Framework code intact, you can now run both versions of the back-end side by side and theoretically run your front-end against the new back-end. Testing your front-end should be the final part of the process. You will find weird issues and this point and you will need to fix the code in an iterative process until the app behaves the same as the old version. You should also add more and more tests to make the codebase doesn't go backwards during this process. The performance of .NET 6 is leagues ahead of .NET Framework so the whole process will be worth it.\n\n\n\nDatabase Code\n\n\n\nThe code that you will probably find most difficult to upgrade will be database code. If you use Dapper, you probably won't find much difference between .NET Framework and .NET 6. However, Entity Framework is very different to Entity Framework Core. Some EF code will compile for EF Core but have different results and execute different SQL. This is why testing is important, and you should create a set of database tests that ensure that new database access code running on .NET 6 does the same thing as the .NET Framework code.\n\n\n\nShould We Do All This in a Separate Branch?\n\n\n\nInevitably you're going to need to decide whether you upgrade and retarget the .NET Framework projects one by one, and amongst normal development, or if you're going to branch for several months and then merge back. There are a variety of circumstances which will influence you here, but here is my two cents.\n\n\n\nUpgrade and retarget as many projects as you can before you start working on a separate branch. This introduces some risk but you want to minimize the time you are working on code that is not running in production. If you are squirreling code away in a branch for a long period of time, it becomes less and less like the production code and you will have to deal with more and more merge conflicts. \n\n\n\nTips\n\n\n\nKeep filenames the same during the whole process. If you move files in to new folders etc. you will have a lot of difficulty with merging\n\n\n\nDon't repeat yourself. Look for ways to avoid copying and pasting code. There are many and .NET Framework is not that different from .NET 6 so you can usually find a way to share code between the two\n\n\n\nBuilding up tests is your key to ensuring that both the old and new codebases continue to work. If you are worried about breaking something, it's because you need more tests.\n\n\n\nDon't get sidetracked with refactoring. You will feel the urge to refactor but you probably shouldn't unless you are confident that the old system has enough code coverage to stop you from breaking the system.\n\n\n\nWrap-Up\n\n\n\nUpgrading a codebase involves the same software development principles that you'd apply to anything else. If you're doing it well, you wil maximise the benefit of your changes to the legacy and new system. If you're doing it poorly, you will duplicate every line of code in the system. Everything about the decision making process will involve tradeoffs around risk and the amount of work you need to do. That becomes a business decision, but you have to adjust and communicate as a team to pull this off. There is no recipe for success but any team that does not communicate, understand the decisions being made and make the best guesses about the path will surely face a lot of pain.\n\n\n\n\n\n\n\nYou will probably have a crossover period where you need to run the legacy code and the new code side by side, but ultimately, your reward will be deleting the .NET Framework specific code, and turning off the old back-end and seeing those performance benefits.\n"
  },
  {
    "Title": "ASP.NET Core 6 – transparent WebSockets",
    "Url": "https://ingebrigtsen.blog/2021/12/17/asp-net-core-6-transparent-websockets/",
    "Timestamp": "2021-12-20T06:02:20",
    "Domain": "ingebrigtsen.blog",
    "Description": "Lets face it; I’m a framework builder. In the sense that I build stuff for other developers to use. The goal when doing so is that the developer using what’s built should feel empowered…"
  },
  {
    "Title": "Azure Container Apps, Bicep and GitHub Actions | I CAN MAKE THIS WORK",
    "Url": "https://blog.johnnyreilly.com/2021/12/19/azure-container-apps-bicep-and-github-actions/",
    "Timestamp": "2021-12-20T06:02:20",
    "Domain": "blog.johnnyreilly.com",
    "Description": "Azure Container Apps are an exciting way to deploy containers to Azure. This post shows how to deploy the infrastructure for an Azure Container App to Azure using Bicep and GitHub Actions. The Azure Container App documentation features quickstarts for deploying your first container app using both the Azure Portal and the Azure CLI. These are great, but there's a gap if you prefer to deploy using Bicep and you'd like to get your CI/CD setup right from the beginning. This post aims to fill that gap."
  },
  {
    "Title": "String Interpolation Trickery and Magic with C# 10 and .NET 6",
    "Url": "https://btburnett.com/csharp/2021/12/17/string-interpolation-trickery-and-magic-with-csharp-10-and-net-6",
    "Timestamp": "2021-12-20T06:02:20",
    "Domain": "btburnett.com",
    "Description": "This blog is one of The December 17th entries on the 2021 C# Advent Calendar. Thanks for having me again Matt!"
  },
  {
    "Title": "Akka for Advent",
    "Url": "https://backwardsincompatibilities.wordpress.com/2021/12/13/akka-for-advent/",
    "Timestamp": "2021-12-20T06:02:20",
    "Domain": "backwardsincompatibilities.wordpress.com",
    "Description": "I’ve been using Akka.Net quite a bit at work lately, so for this years F# advent calendar you’re getting a blog post about using Akka.Net and Akkling with F#. Before people start lookin…"
  },
  {
    "Title": "PagerDuty’s Security Training for Engineers",
    "Url": "https://www.codingblocks.net/podcast/pagerdutys-security-training-for-engineers/",
    "Timestamp": "2021-12-20T03:02:27",
    "Domain": "www.codingblocks.net",
    "Description": "We're taking our time as we discuss PagerDuty's Security Training presentations and what it means to \"roll the pepper\" while Michael is embarrassed in front of the whole Internet, Franklin Allen Underwood is on a full name basis, and don't talk to Joe about corn."
  },
  {
    "Title": "Document your .NET code with DocFX and GitHub Actions",
    "Url": "https://blog.taranissoftware.com/document-your-net-code-with-docfx-and-github-actions",
    "Timestamp": "2021-12-20T03:02:26",
    "Domain": "blog.taranissoftware.com",
    "Description": "In this article I show how to use XML doc comments, DocFX and GitHub Actions to automatically build and publish documentation for your .NET code."
  },
  {
    "Title": "The Big DevOps Misunderstanding",
    "Url": "https://wolfoliver.medium.com/the-big-devops-misunderstanding-8435a910a5fd",
    "Timestamp": "2021-12-20T02:02:26",
    "Domain": "wolfoliver.medium.com",
    "Description": "When the term DevOps came up it was all about a simple idea:"
  },
  {
    "Title": "exa · a modern replacement for ls",
    "Url": "https://the.exa.website/",
    "Timestamp": "2021-12-20T01:02:06",
    "Domain": "the.exa.website",
    "Description": "No — exa has, in my opinion, much saner defaults than ls, so while the available command-line options are similar, they are not exactly the same. Most of the common options will work consistently, though. For example, exa prints human-readable file sizes by default, so the -h option no longer applies."
  },
  {
    "Title": "Microsoft Visual Studio Offline Packages · Hossam Barakat",
    "Url": "https://www.hossambarakat.net/2020/06/24/fix-error-NU1101/",
    "Timestamp": "2021-12-20T01:02:05",
    "Domain": "www.hossambarakat.net",
    "Description": "I use Azure DevOps as my build pipelines for a lot of projects, I have faced the following error recently:"
  },
  {
    "Title": "The bulldozer vs vetocracy political axis",
    "Url": "https://vitalik.eth.limo/general/2021/12/19/bullveto.html",
    "Timestamp": "2021-12-20T00:02:29",
    "Domain": "vitalik.eth.limo",
    "Description": "2021 Dec 19 \nSee all posts"
  },
  {
    "Title": "Markus Captain Kaarlonen - Space Debris",
    "Url": "https://markuskaarlonen.com/space-debris",
    "Timestamp": "2021-12-20T00:02:29",
    "Domain": "markuskaarlonen.com",
    "Description": "Space Debris is an Amiga mod I composed back in 1991. This is a short story about how I made the song, and what it was like to make music on the Amiga. If you don't know what \"Amiga\" or \"mods\" are, no worries, just read on!"
  },
  {
    "Title": "A Step-By-Step Startup Guide For Bootstrappers",
    "Url": "https://mihaisplace.blog/2021/12/18/a-step-by-step-startup-guide-for-bootstrappers/",
    "Timestamp": "2021-12-20T00:02:29",
    "Domain": "mihaisplace.blog",
    "Description": "After reading various books, essays, and blog posts on what it takes to build a startup I've decided to create a step-by-step guide for it that is all-encompassing. Note that this content is heavily influenced by Lean Startup thinking and Running Lean by Ash Maurya, which in my opinion are the best books on succeeding with startup projects as a bootstrapper. A bootstrapper is someone who builds quickly themselves or with a small team and takes as little capital as they can in the early stages. I realize that there is some bias here as there are many other philosophies to building a startup in regards to investors, hard-tech, research projects, or geographical location. I believe that US-based tech founders who don't mind being technical, and funding their startup without taking too much initial capital will deeply resonate with this guide. For everyone else, I'm sure there is something for you here as well, though one or two of the steps may not apply to you or be relevant."
  },
  {
    "Title": "A mental model for decentralization",
    "Url": "https://jacobobryant.com/p/mental-model-decentralization/",
    "Timestamp": "2021-12-20T00:02:29",
    "Domain": "jacobobryant.com",
    "Description": "How much decentralization do we need? If there's too little, then software will stagnate from lack of competition; if there's too much, then it'll stagnate from lack of coordination."
  },
  {
    "Title": "COLODEBUG: a simple way to improve bash script debugging",
    "Url": "https://johannes.truschnigg.info/writing/2021-12_colodebug/",
    "Timestamp": "2021-12-20T00:02:28",
    "Domain": "johannes.truschnigg.info",
    "Description": "In this article, I will show you an easy-to-use, simple, and non-disruptive way to extend a GNU bash script by a few lines that can help make sense of its execution flow at runtime a fair bit easier. Using this method will also allow you to effortlessly add a “verbose” execution mode to scripts you create or extend. It also improves the usefulness of set -x aka xtrace mode. The method is compatible with zsh, and maybe also other advanced Bourne-style shells."
  },
  {
    "Title": "My Favorite Board Games and How I Play Them",
    "Url": "https://www.jimwestergren.com/favorite-board-games",
    "Timestamp": "2021-12-20T00:02:28",
    "Domain": "www.jimwestergren.com",
    "Description": "\"If we did all the things we are capable of, we would literally astound ourselves.\" - Thomas A. Edison"
  },
  {
    "Title": "I retired so I can focus on my open source project | Adama Language",
    "Url": "http://www.adama-lang.org/blog/retirement-going-all-in/",
    "Timestamp": "2021-12-20T00:02:28",
    "Domain": "www.adama-lang.org",
    "Description": "Adama is about to get a whole lot of love, and I intend to talk strategy today. As a side project, I could wander the desert for a while without much progress. It was easy to forgive as there was other shit distracting me, and my role as  principal engineer was already hard enough."
  },
  {
    "Title": "The Non-Productive Programmer (NPP)",
    "Url": "https://gerlacdt.github.io/posts/nonproductive-programmer/",
    "Timestamp": "2021-12-20T00:02:28",
    "Domain": "gerlacdt.github.io",
    "Description": "We all know them: programmers with long term experience stuck on a low-level of our craft not corresponding to their quantity of experience. Great programmers are creative workers and problem-solvers and one of their most important traits is: never stop learning &ndash; but getting stuck in its own comfort zone and becoming reluctant to change is deeply wired into human nature (Humans are hard-wired to follow the path of least resistance)."
  }
]