[
  {
    "Title": "Building a Critter Stack Application: Wolverine as Mediator",
    "Url": "https://jeremydmiller.com/2023/12/03/building-a-critter-stack-application-wolverine-as-mediator/",
    "Timestamp": "2023-12-03T23:02:53",
    "Domain": "jeremydmiller.com",
    "Description": "Hey, did you know that¬†JasperFx Software¬†is ready for¬†formal support plans¬†for¬†Marten¬†and¬†Wolverine? Not only are we trying to make the ‚ÄúCritter Stack‚Äù tools be viable long term options for your sh‚Ä¶",
    "Confidence": 0.9930595
  },
  {
    "Title": "jim-fx's | Plantarium",
    "Url": "https://plant.max-richter.dev/",
    "Timestamp": "2023-12-03T23:02:51",
    "Domain": "plant.max-richter.dev",
    "Description": "output",
    "Confidence": 0.98206306
  },
  {
    "Title": "LLM As A Function",
    "Url": "https://blog.vjeux.com/2023/analysis/llm-as-a-function.html",
    "Timestamp": "2023-12-03T22:03:09",
    "Domain": "blog.vjeux.com",
    "Description": "LLMs have seen a huge surge of popularity with ChatGPT by going from prompt to text for various use cases. But what's really exciting is that they are also extremely useful as ways to implement normal functions within a program. This is what I call LLM As A Function.",
    "Confidence": 0.99411505
  },
  {
    "Title": "Notion ‚Äì The all-in-one workspace for your notes, tasks, wikis, and databases.",
    "Url": "https://toiviainen.xyz/b5e0003c3f2e4b0db3bb0bb8b31d8bf5",
    "Timestamp": "2023-12-03T22:03:06",
    "Domain": "toiviainen.xyz",
    "Description": "Joose Toiviainen",
    "Confidence": 0.95960426
  },
  {
    "Title": "The Fork Bomb: What it is, how it works, and where it originated",
    "Url": "https://lunduke.locals.com/post/4949703/the-fork-bomb-what-it-is-how-it-works-and-where-it-originated",
    "Timestamp": "2023-12-03T22:03:06",
    "Domain": "lunduke.locals.com",
    "Description": "Connect with Lunduke and other members of Lunduke community",
    "Confidence": 0.96031964
  },
  {
    "Title": "I Started With Nix, NixOS, Home Manager and Flakes",
    "Url": "https://karl-voit.at/2023/09/12/nix/",
    "Timestamp": "2023-12-03T22:03:05",
    "Domain": "karl-voit.at",
    "Description": "I Started With Nix, NixOS, Home Manager and Flakes",
    "Confidence": 0.9944663
  },
  {
    "Title": "Now I Can Just Print That Video",
    "Url": "https://blog.forret.com/2023/12/01/printthatvideo/",
    "Timestamp": "2023-12-03T22:03:05",
    "Domain": "blog.forret.com",
    "Description": "It all started with Instagram Reels showing me too many yummy cooking videos. I wanted to try some recipes out myself. But I didn‚Äôt want to have to keep my phone in the kitchen, and I didn‚Äôt want to have to keep unlocking it to see the next step. I wanted to print the recipe out, and have it on the counter while I was cooking. Wouldn‚Äôt it be cool if I could just print that video?",
    "Confidence": 0.99600697
  },
  {
    "Title": "Recording and generating animated screencasts within the browser",
    "Url": "https://vigneshanand.com/recording-and-generating-animated-screencasts-within-the-browser/",
    "Timestamp": "2023-12-03T22:03:05",
    "Domain": "vigneshanand.com",
    "Description": "Blog",
    "Confidence": 0.95788723
  },
  {
    "Title": "Building your own bookmark launcher",
    "Url": "https://xenodium.com/building-your-own-bookmark-launcher/",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "xenodium.com",
    "Description": "‚ú®sponsor‚ú® this content",
    "Confidence": 0.99812764
  },
  {
    "Title": "Simplifying Complexity: The Journey from WebSockets to HTTP Streams",
    "Url": "https://blog.owulveryck.info/2023/12/02/simplifying-complexity-the-journey-from-websockets-to-http-streams.html",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "blog.owulveryck.info",
    "Description": "This article explores the transition from a WebSocket-based implementation to a simpler, more direct stream over HTTP in the context of capturing touch screen inputs on Linux.\nIt begins by introducing the main theme, encapsulated in the statement Everything is a file is a stream of byte. The need to capture finger positions on a touchscreen by reading /dev/input/events in Linux is initially discussed, followed by a dilemma of transferring this data to a JavaScript client in a browser.\nInitially, WebSockets are chosen, leading to a discussion on how frameworks often shape our technological choices and the challenges faced in debugging WebSocket connections. The article then introduces an alternative about sending a stream of bytes over HTTP, drawing a parallel to Linux‚Äôs approach to handling devices and files.\nSerialization, the process of encoding messages for this stream, is discussed next, highlighting the implementation specifics in GoLang and its native advantages. The final section covers how to receive and decode this stream in JavaScript within a worker thread, and then send the decoded messages to the main thread using post requests.\nThe article concludes by reflecting on the benefits of simplicity in technology, urging readers to reevaluate default choices and consider more straightforward solutions to complex problems.\n",
    "Confidence": 0.9949184
  },
  {
    "Title": "Own Your MX Record",
    "Url": "https://www.larrymyers.com/posts/own-your-mx-record/",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "www.larrymyers.com",
    "Description": "Your email address is the most important digital asset you have. Make sure you own and control it.",
    "Confidence": 0.9818337
  },
  {
    "Title": "On Pivoting",
    "Url": "https://rosslazer.com/posts/on-pivoting/",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "rosslazer.com",
    "Description": "A candid reflection of one tech startup's journey so far.",
    "Confidence": 0.95620775
  },
  {
    "Title": "Local LLMs as browser sidekicks",
    "Url": "https://kshreyas.dev/post/local-llms/",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "kshreyas.dev",
    "Description": "Introduction The rapidly evolving AI era presents new discoveries daily, particularly in software engineering, where AI assistants are now integral to our workflows. While these innovations have boosted productivity, they also bring challenges like:\nReliance on cloud-based services and closed models üõÖ Privacy and security concerns üîí Other barriers to entry üöß The Challenge of Cloud-Based and Proprietary Models According to the Chatbot arena leaderboard the top entries with high Elo ratings are all proprietary models.",
    "Confidence": 0.8946097
  },
  {
    "Title": "Look mom! I built a computer",
    "Url": "https://blog.ignaciobrasca.com/programming/2023/11/23/built-a-computer.html",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "blog.ignaciobrasca.com",
    "Description": "A journey through building a computer from scratch.",
    "Confidence": 0.95503896
  },
  {
    "Title": "RisingTone: A better way to learn Chinese tones",
    "Url": "http://joyfulmantis.github.io/posts/2023-12-03-risingtone.html",
    "Timestamp": "2023-12-03T22:03:04",
    "Domain": "joyfulmantis.github.io",
    "Description": "Posted on December  3, 2023",
    "Confidence": 0.83437425
  },
  {
    "Title": "Blazor WASM Lazy Loading",
    "Url": "https://ilovedotnet.org/blogs/blazor-wasm-lazy-loading/",
    "Timestamp": "2023-12-03T19:02:52",
    "Domain": "ilovedotnet.org",
    "Description": "In this post I will teach you how to lazy load assemblies in your Blazor applications. All with live working demo.",
    "Confidence": 0.9985737
  },
  {
    "Title": "How Uber Computes ETA at Half a Million Requests per Second",
    "Url": "https://newsletter.systemdesign.one/p/uber-eta",
    "Timestamp": "2023-12-03T18:02:26",
    "Domain": "newsletter.systemdesign.one",
    "Description": "#26: And How Online Maps Work Explained Like You‚Äôre Twelve (5 minutes)",
    "Confidence": 0.8890256
  },
  {
    "Title": "LLM Visualization",
    "Url": "https://bbycroft.net/llm",
    "Timestamp": "2023-12-03T18:02:25",
    "Domain": "bbycroft.net",
    "Description": "A 3D animated visualization of an LLM with a walkthrough.",
    "Confidence": 0.6469529
  },
  {
    "Title": "How to Take Advantage of CSharp Optional Parameters for Cleaner Code",
    "Url": "https://www.devleader.ca/2023/12/03/how-to-take-advantage-of-csharp-optional-parameters-for-cleaner-code/",
    "Timestamp": "2023-12-03T15:02:40",
    "Domain": "www.devleader.ca",
    "Description": "Learn how to make your code more readable, flexible, and maintainable with CSharp optional parameters. Check out these examples of optional parameters in C#!",
    "Confidence": 0.99510974
  },
  {
    "Title": "Not a real engineer - Richard Marmorstein",
    "Url": "https://twitchard.github.io/posts/2019-05-29-not-a-real-engineer.html",
    "Timestamp": "2023-12-03T11:02:56",
    "Domain": "twitchard.github.io",
    "Description": "Richard's Software Blog",
    "Confidence": 0.86230725
  },
  {
    "Title": "Captcha component for Blazor",
    "Url": "https://jinget.medium.com/captcha-component-for-blazor-41d86e239476",
    "Timestamp": "2023-12-03T10:02:36",
    "Domain": "jinget.medium.com",
    "Description": "Today, Jinget Blazor components are becoming open source. Jinget Blazor contains numerous useful components such as Captcha, Jalali‚Ä¶",
    "Confidence": 0.97824246
  },
  {
    "Title": "clang now makes binaries an original Pi B+ can't run",
    "Url": "https://rachelbythebay.com/w/2023/11/30/armv6/",
    "Timestamp": "2023-12-03T03:02:49",
    "Domain": "rachelbythebay.com",
    "Description": "I have a bunch of Raspberry Pi systems all over the place, goofy things \nthat they are.  They do dumb and annoying jobs in strange locations.  I \neven have one of the older models, which is called just the B+.  You can \nthink of it as the \"1B+\" but apparently it was never officially branded \nthe 1.",
    "Confidence": 0.99007446
  },
  {
    "Title": "How Are .NET APIs So Much Faster than Everything Else?",
    "Url": "https://youtube.com/watch?v=RNC422F-C4E&list=RDCMUCrkPsvLGln62OMZRO6K-llg",
    "Timestamp": "2023-12-03T01:02:36",
    "Domain": "youtube.com",
    "Description": "Use code REFAC20 and get 20% off the brand new \"Refactoring for C# Developers\" course on Dometrain: https://dometrain.com/course/from-zero-to-hero-refactorin...",
    "Confidence": 0.9538244
  },
  {
    "Title": "How to start a modern C++ project - Mikhail Svetkin - Meeting C++ 2023",
    "Url": "https://youtube.com/watch?v=UI_QayAb9U0&si=w--Lhzd6hBPUMhpv",
    "Timestamp": "2023-12-03T01:02:36",
    "Domain": "youtube.com",
    "Description": "C++ is a powerful language with a rich history and a wide range of applications. However, working with C++ can be challenging due to its complexity. Fortunat...",
    "Confidence": 0.9870455
  },
  {
    "Title": "Building a Smart Home - Part 14 Motion, Occupancy, and Presence | LINQ to Fail",
    "Url": "https://www.aaron-powell.com/posts/2023-12-03-building-a-smart-home---part-14-motion-occupancy-and-presence/",
    "Timestamp": "2023-12-03T01:02:34",
    "Domain": "www.aaron-powell.com",
    "Description": "Walking into a room, lights turning on, feels like magic.",
    "Confidence": 0.9949567
  },
  {
    "Title": "Containerizing .NET - Part 1",
    "Url": "https://chris-ayers.com/2023/12/03/containerizing-dotnet-part-1",
    "Timestamp": "2023-12-03T01:02:34",
    "Domain": "chris-ayers.com",
    "Description": "Containerizing .NET: Part 1 - A Guide to Containerizing .NET Applications     This article is part of C# Advent 2023. For more articles in the series by other authors, visit https://www.csadvent.christmas/.   This is the first in a series of articles on containerizing .NET applications. We‚Äôll explore how to containerize .NET applications using Dockerfiles and dotnet publish. Containers have become an essential part of the DevOps ecosystem, offering a lightweight, portable, and scalable solution for deploying applications. This process is crucial for developers looking to streamline app deployment in containerized environments, focusing on efficiency, security, compliance, and more.  What are Containers?  Containers are a lightweight, virtualized environment that provide an isolated space for running applications. Unlike traditional virtual machines that require a full-fledged operating system, containers share the host system‚Äôs kernel but encapsulate an application‚Äôs code, dependencies, and libraries in a self-contained unit. This encapsulation ensures uniform and consistent application performance across different computing environments.  Containers offer numerous benefits. They are efficient in terms of resource utilization, smaller in size, and require less overhead than virtual machines. Containers also enhance the portability of applications, enabling developers to easily move applications from local development machines to production servers. This portability, combined with their isolated nature, facilitates continuous integration and continuous deployment (CI/CD) practices, making containers a cornerstone of modern DevOps workflows. Moreover, containers help ensure software runs reliably when moved from one computing environment to another, mitigating the ‚Äúit works on my machine‚Äù problem.  Dotnet with a Dockerfile  Building and packaging dotnet applications into Docker images has been straightforward and well-documented. The dotnet documentation provides an excellent starting point. A simple Dockerfile can build a dotnet application and package it into a Docker image, using multi-stage builds to keep the final image size small.  FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build-env WORKDIR /App  # Copy everything COPY . ./ # Restore as distinct layers RUN dotnet restore # Build and publish a release RUN dotnet publish -c Release -o out  # Build runtime image FROM mcr.microsoft.com/dotnet/aspnet:8.0 WORKDIR /App COPY --from=build-env /App/out . ENTRYPOINT [\"dotnet\", \"DotNet.Docker.dll\"]   We can build this docker image by running the following command, where dotnet-docker is the name of the image.  docker build -t dotnet-docker .   I won‚Äôt go into all the details of a dockerfile or registries right now. We‚Äôll cover that in a future article. However, while this approach is great for those wanting full control over the image-building process, it can be daunting for newcomers to containers or those who prefer to focus on building applications rather than managing Docker images.  Containerizing .NET with dotnet publish  .NET has a built-in mechanism for building and packaging applications into Docker images. This approach is ideal for those who want to focus on application development rather than managing Docker images. We‚Äôll explore how to containerize .NET applications using dotnet publish. This method doesn‚Äôt require a Dockerfile. Instead, it uses a set of publish properties to build and package applications into Docker images.  Starting from scratch, we‚Äôll containerize a simple dotnet application using the dotnet CLI.     Create a new dotnet console application     dotnet new console -o hello-containers           Let‚Äôs add the required nuget package, Microsoft.NET.Build.Containers     dotnet add package Microsoft.NET.Build.Containers           Now we can build and package our application into a docker image     dotnet publish -t:PublishContainer            At this point you should see something like the following:  MSBuild version 17.8.3+195e7f5a3 for .NET   Determining projects to restore...   All projects are up-to-date for restore.   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/hello-containers.dll   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/publish/   Building image 'hello-containers' with tags 'latest' on top of base image 'mcr.microsoft.com/dotnet/runtime:8.0'.   Pushed image 'hello-containers:latest' to local registry via 'docker'.   Notice that we didn‚Äôt have to create a Dockerfile, we didn‚Äôt have to manage dependencies, and we didn‚Äôt have to package our application into a docker image. Let‚Äôs compare the docker image we just created with the one we created earlier. The following is the docker image we created earlier using a Dockerfile.  $ docker images REPOSITORY         TAG       IMAGE ID       CREATED          SIZE hello-containers   latest    83963b52892f   5 seconds ago    193MB dotnet-docker      latest    2d24bdc0b15d   57 seconds ago   217MB   Making it Smaller  To make our images smaller, we have a few options. The first is to choose a smaller base image. Popular choices include Alpine, a lightweight Linux distribution, and Ubuntu Chiseled, a lightweight version of Ubuntu. Using these base images can significantly reduce the final image size.  By introducing the -p:ContainerFamily parameter, we can specify the image family; And the -p:ContainerRepository parameter we can name our image. By leveraging image families like Alpine and Ubuntu Chiseled, we can significantly reduce the final image size without trimming or optimizing via Native AOT (Ahead of Time compilation). We‚Äôll cover those optimization techniques in a future article.  Alpine  Alpine Linux is a highly favored choice for container images, known for its lightweight nature and security-focused architecture. Its minimal footprint significantly enhances efficiency in resource usage, making it ideal for streamlined container images. This results in reduced overhead and improved performance in containerized applications. However, it‚Äôs important to consider certain aspects when using Alpine:     Resource Optimization: Alpine‚Äôs small size optimizes resource consumption.   Compliance: Minimal dependencies make it compliance-friendly.   Compatibility Note: Alpine uses musl libc instead of glibc, potentially leading to compatibility issues with glibc-dependent applications.   When using dotnet publish to containerize an application with Alpine, you can specify the container family as alpine to use this lightweight base image:  $ dotnet publish -t:PublishContainer -p:ContainerFamily=alpine -p:ContainerRepository=hello-containers-alpine MSBuild version 17.8.3+195e7f5a3 for .NET   Determining projects to restore...   All projects are up-to-date for restore.   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/hello-containers.dll   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/publish/   Building image 'hello-containers-alpine' with tags 'latest' on top of base image 'mcr.microsoft.com/dotnet/runtime:8.0-alpine'.   Pushed image 'hello-containers-alpine:latest' to local registry via 'docker'.   The resulting base image, mcr.microsoft.com/dotnet/runtime:8.0-alpine, is smaller compared to the standard mcr.microsoft.com/dotnet/runtime:8.0. Here‚Äôs a comparison of image sizes:  $ docker images REPOSITORY                TAG       IMAGE ID       CREATED          SIZE hello-containers-alpine   latest    60a63389d474   18 seconds ago   82.7MB hello-containers          latest    ae96d4d7ac36   23 seconds ago   193MB   This demonstrates that Alpine can significantly reduce image size, enhancing the efficiency of .NET containerized applications.  Ubuntu Chiseled  Ubuntu Chiseled is a lightweight, container-optimized version of the popular Ubuntu Linux distribution. Featuring ultra-small OCI images, it includes only the application and its runtime dependencies, leading to several key benefits:     Streamlined Design: The reduced footprint of Ubuntu Chiseled images enables lightweight maintenance and efficient resource utilization.   Enhanced Security: The focus on essential components minimizes security risks by reducing potential vulnerabilities.   Size Reduction: Compared to traditional Ubuntu images, Chiseled images are significantly smaller, comparable in size to Alpine, and offer glibc compatibility.   Fewer Components: With fewer components, there‚Äôs a reduced CVE exposure, aligning well with development and production environments.   Strong Support: Developed through a collaboration between Canonical and Microsoft, these images offer robust support, particularly suitable for .NET versions 6, 7, and 8.     The following example demonstrates containerizing a .NET application using Ubuntu Chiseled, showcasing the notable reduction in image size:  $ dotnet publish -t:PublishContainer -p:ContainerFamily=jammy-chiseled -p:ContainerRepository=hello-containers-chiseled MSBuild version 17.8.3+195e7f5a3 for .NET   Determining projects to restore...   All projects are up-to-date for restore.   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/hello-containers.dll   hello-containers -> /workspaces/dotnet-containers/hello-containers/bin/Release/net8.0/publish/   Building image 'hello-containers-chiseled' with tags 'latest' on top of base image 'mcr.microsoft.com/dotnet/runtime:8.0-jammy-chiseled'.   Pushed image 'hello-containers-chiseled:latest' to local registry via 'docker'.   Notice how the base image was changed from mcr.microsoft.com/dotnet/runtime:8.0 to mcr.microsoft.com/dotnet/runtime:8.0-jammy-chiseled. This is a smaller base image, which results in a smaller final image. Let‚Äôs take a look at the size difference between the images.  $ docker images REPOSITORY                  TAG       IMAGE ID       CREATED          SIZE hello-containers-chiseled   latest    bfdb924079ab   6 seconds ago    85.7MB hello-containers-alpine     latest    cde2172a1f17   6 minutes ago    82.7MB hello-containers            latest    83963b52892f   16 minutes ago   193MB dotnet-docker               latest    2d24bdc0b15d   17 minutes ago   217MB   The comparison illustrates how Ubuntu Chiseled effectively reduces the container image size, making it an efficient choice for cloud and containerized environments.  Streamlining with Project File Properties  Streamlining the deployment process in .NET can be achieved by integrating publish properties directly into the project file. This approach enhances compliance and security while reducing the likelihood of errors. Consider a typical .csproj file:  <Project Sdk=\"Microsoft.NET.Sdk\">    <PropertyGroup>     <OutputType>Exe</OutputType>     <TargetFramework>net8.0</TargetFramework>     <ImplicitUsings>enable</ImplicitUsings>     <Nullable>enable</Nullable>   </PropertyGroup>    <ItemGroup>     <PackageReference Include=\"Microsoft.NET.Build.Containers\" Version=\"8.0.100\" />   </ItemGroup>  </Project>   To streamline, we add container-specific properties directly into the .csproj:  <PropertyGroup>   <!-- Existing properties -->   <ContainerFamily>jammy-chiseled</ContainerFamily>   <ContainerRepository>hello-containers-chiseled</ContainerRepository> </PropertyGroup>   Our final csproj file looks like this:  <Project Sdk=\"Microsoft.NET.Sdk\">    <PropertyGroup>     <OutputType>Exe</OutputType>     <TargetFramework>net8.0</TargetFramework>     <ImplicitUsings>enable</ImplicitUsings>     <Nullable>enable</Nullable>     <ContainerFamily>jammy-chiseled</ContainerFamily>     <ContainerRepository>hello-containers-chiseled</ContainerRepository>   </PropertyGroup>    <ItemGroup>     <PackageReference Include=\"Microsoft.NET.Build.Containers\" Version=\"8.0.100\" />   </ItemGroup>   With these additions, the deployment command simplifies to:  dotnet publish -t:PublishContainer   This method eliminates the need to specify publish properties each time, as they are already defined in the project file. It ensures a consistent and repeatable process, making deployments smoother and more efficient.  Conclusion  Publishing .NET console apps as container images offers a range of options, like targeting specific Linux distributions or families. Each method has unique benefits in terms of size, security, compliance, composability, compatibility, and support. This approach signifies a move towards more specialized, purpose-built container images, shaping the future of cloud applications.  Thank you for joining me on this exploration of .NET and containers. Stay tuned for more insights and guides on containerizing .NET!  Resources     https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8#containers   https://learn.microsoft.com/en-us/dotnet/core/docker/build-container   https://learn.microsoft.com/en-us/dotnet/core/docker/publish-as-container   https://devblogs.microsoft.com/dotnet/announcing-dotnet-chiseled-containers/   https://canonical.com/blog/chiselled-ubuntu-ga   https://ubuntu.com/containers/chiselled/dotnet",
    "Confidence": 0.99440545
  }
]