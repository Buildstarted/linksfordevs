[
  {
    "Title": "What‚Äôs Next in C#? - Mads Torgersen - Copenhagen DevFest 2023",
    "Url": "https://youtube.com/watch?v=gGzfAJwoH5A?si=1e6N2dZR4CG1Z4Zf",
    "Timestamp": "2023-10-14T19:02:24",
    "Domain": "youtube.com",
    "Description": "Join Mads on a tour of upcoming language features in C#. While still very much in the works, C# 12 is starting to take shape. We touch on some of the ways, b...",
    "Confidence": 0.5365872
  },
  {
    "Title": "Grumpy Website",
    "Url": "https://grumpy.website/1389",
    "Timestamp": "2023-10-14T19:02:22",
    "Domain": "grumpy.website",
    "Description": "Why is nobody excited about these ‚Äúyesterday‚Äù/‚Äú2 days ago‚Äù/‚Äúa week ago‚Äù labels?",
    "Confidence": 0.945623
  },
  {
    "Title": "Michael Tsai - Blog - Relative Time Labels",
    "Url": "https://mjtsai.com/blog/2023/10/13/relative-time-labels/",
    "Timestamp": "2023-10-14T18:02:45",
    "Domain": "mjtsai.com",
    "Description": "Nikita Prokopov:",
    "Confidence": 0.9779751
  },
  {
    "Title": "Undermining Democracy: The European Commission's Controversial Push for Digital Surveillance ‚Äì Danny Mekiƒá",
    "Url": "https://dannymekic.com/202310/undermining-democracy-the-european-commissions-controversial-push-for-digital-surveillance",
    "Timestamp": "2023-10-14T17:02:35",
    "Domain": "dannymekic.com",
    "Description": "The European Commission wants to turn digital communication apps, such as WhatsApp, iMessage, Instagram, TikTok and X, into mass surveillance tools so that digital communications of all EU citizens, including their live conversations, photos and videos, can be automatically scanned for criminal offences.[1] Even of citizens who are not suspected of any crime. This proposal [‚Ä¶]",
    "Confidence": 0.85473865
  },
  {
    "Title": "Can open source be saved from the EU's Cyber Resilience Act?",
    "Url": "https://www.theregister.com/2023/10/13/can_open_source_be_saved/",
    "Timestamp": "2023-10-14T16:04:04",
    "Domain": "www.theregister.com",
    "Description": "The road to Hell is paved with good intentions, and for open source this is a well meaning cluster fudge",
    "Confidence": 0.94894886
  },
  {
    "Title": "ChatGPT-AutoExpert/System Prompts.md at main ¬∑ spdustin/ChatGPT-AutoExpert",
    "Url": "https://github.com/spdustin/ChatGPT-AutoExpert/blob/main/System%20Prompts.md",
    "Timestamp": "2023-10-14T14:04:11",
    "Domain": "github.com",
    "Description": "üöÄüß†üí¨ Supercharged Custom Instructions for ChatGPT (non-coding) and ChatGPT Advanced Data Analysis (coding).  - spdustin/ChatGPT-AutoExpert",
    "Confidence": 0.97575444
  },
  {
    "Title": "First Look at The Brand New Polly V8 API #shorts",
    "Url": "https://youtube.com/watch?v=OvSqmmJxFDM",
    "Timestamp": "2023-10-14T13:04:55",
    "Domain": "youtube.com",
    "Description": "üìå Check out my Pragmatic Clean Architecture course: https://bit.ly/3Zn41BKüöÄ Support me on Patreon to access the source code: https://www.patreon.com/milanj...",
    "Confidence": 0.9861501
  },
  {
    "Title": "A bug in MySQL, or working as intended? You decide",
    "Url": "https://www.dolthub.com/blog/2023-10-13-fixing-mysql-bugs-in-dolt/",
    "Timestamp": "2023-10-14T13:04:54",
    "Domain": "www.dolthub.com",
    "Description": "Fixing a bug in Dolt that MySQL still has and will not fix",
    "Confidence": 0.9852968
  },
  {
    "Title": "How to cook ground meat perfectly every time! - The Blind Kitchen",
    "Url": "https://theblindkitchen.com/how-to-cook-ground-meat-perfectly-every-time/",
    "Timestamp": "2023-10-14T11:02:27",
    "Domain": "theblindkitchen.com",
    "Description": "Cook ground meat perfectly using these steps to make sure it is not over or under done. Directions are accessible for vision impaired cooks.",
    "Confidence": 0.8956786
  },
  {
    "Title": "GitHub - CherniakYura/tccurl: Implement include header files over https",
    "Url": "https://github.com/CherniakYura/tccurl",
    "Timestamp": "2023-10-14T09:04:46",
    "Domain": "github.com",
    "Description": "Implement include header files over https. Contribute to CherniakYura/tccurl development by creating an account on GitHub.",
    "Confidence": 0.99716
  },
  {
    "Title": "Beware: URLs are Pointers to Mutable Entities",
    "Url": "https://textslashplain.com/2023/10/13/beware-urls-are-pointers-to-mutable-entities/",
    "Timestamp": "2023-10-14T06:02:28",
    "Domain": "textslashplain.com",
    "Description": "Folks often like to think of URLs as an entity that can be evaluated: ‚ÄúIs it harmless, or is it malicious?‚Äù In particular, vendors of security products tend to lump URLs in with other I‚Ä¶",
    "Confidence": 0.9881231
  },
  {
    "Title": "Sign Combo",
    "Url": "https://xkcd.com/2841/",
    "Timestamp": "2023-10-14T03:02:37",
    "Domain": "xkcd.com",
    "Description": "",
    "Confidence": 0.98151064
  },
  {
    "Title": "TimeGPT-1",
    "Url": "https://arxiv.org/abs/2310.03589",
    "Timestamp": "2023-10-14T02:02:35",
    "Domain": "arxiv.org",
    "Description": "In this paper, we introduce TimeGPT, the first foundation model for time series, capable of generating accurate predictions for diverse datasets not seen during training. We evaluate our pre-trained model against established statistical, machine learning, and deep learning methods, demonstrating that TimeGPT zero-shot inference excels in performance, efficiency, and simplicity. Our study provides compelling evidence that insights from other domains of artificial intelligence can be effectively applied to time series analysis. We conclude that large-scale time series models offer an exciting opportunity to democratize access to precise predictions and reduce uncertainty by leveraging the capabilities of contemporary advancements in deep learning.",
    "Confidence": 0.8634697
  },
  {
    "Title": "Improving ASP.NET Core Dependency Injection With Scrutor",
    "Url": "https://www.milanjovanovic.tech/blog/improving-aspnetcore-dependency-injection-with-scrutor",
    "Timestamp": "2023-10-14T01:04:19",
    "Domain": "www.milanjovanovic.tech",
    "Description": "Dependency injection (DI) is one of the most exciting features of ASP.NET Core. It helps us build more testable and maintainable applications. However, ASP.NET Core's built-in DI system sometimes needs a little help to achieve more advanced scenarios.\nSo I want to introduce you to a powerful library for enhancing your ASP.NET Core DI - Scrutor.",
    "Confidence": 0.99753255
  },
  {
    "Title": "Grants on the web",
    "Url": "https://gow.epsrc.ukri.org/NGBOViewGrant.aspx?GrantRef=EP%2FY022904%2F1",
    "Timestamp": "2023-10-14T00:03:00",
    "Domain": "gow.epsrc.ukri.org",
    "Description": "Grants on the web",
    "Confidence": 0.93890965
  },
  {
    "Title": "Mads Torgersen on C# 12",
    "Url": "https://jesseliberty.com/2023/10/13/mads-torgersen-on-c-12/",
    "Timestamp": "2023-10-13T23:02:18",
    "Domain": "jesseliberty.com",
    "Description": "Super excited and proud to have Mads (lead designer of C#) back to talk about C# 12",
    "Confidence": 0.94221115
  },
  {
    "Title": "Reverse engineering SBF file format",
    "Url": "http://knmw.link/posts/dfbhd_sbf.html",
    "Timestamp": "2023-10-13T22:03:52",
    "Domain": "knmw.link",
    "Description": "Describes the SBF assets used to store music in DFBHD",
    "Confidence": 0.98617506
  },
  {
    "Title": "brick",
    "Url": "https://meskhetian.com/brick/",
    "Timestamp": "2023-10-13T22:03:52",
    "Domain": "meskhetian.com",
    "Description": "If your life is a wall, each day is a brick in that wall.\nIf your days are full of anxiety and stress, your wall will not look good when it's complete",
    "Confidence": 0.9603055
  },
  {
    "Title": "How to compare signed and unsigned integers in C++20?",
    "Url": "https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities",
    "Timestamp": "2023-10-13T22:03:52",
    "Domain": "www.sandordargo.com",
    "Description": "Comparing two numbers should be easy right? Maybe it should, yet it‚Äôs not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you‚Äôll spend quite some time scratching your head about what just happened. It‚Äôs also possible that it will not work according to your expectation but it will go unnoticed. Another option is that you get a compiler warning either by specifically turning on -Wsign-compare or -Wextra. If it‚Äôs combined with -Werror, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons. Let‚Äôs start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution. The problem of comparing a signed with an unsigned What are integral types in C++? There are quite a few of them: bool, char, char8_t, char16_t, char32_t, short, int, long, long long, and the unsigned versions of them. Let‚Äôs put aside that we can also cv qualify them and that there are a big bunch of implementation-defined types such as uint32_t et al. Even though these are all integrals, bool and char types are not meant to store numbers. We are limiting our focus to short, int, long, long long and their unsigned versions. If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a short and an unsigned short will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an unsigned short is from 0 to 2**16-1. The bitwise representations of -1 and 4294967295 are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on. On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two‚Äôs complement form. The most significant bit represents the sign (0 for positive, 1 for negative numbers) To convert a positive value to its negative counterpart, you invert all the bits and then add 1 But what does this mean in practice? If you try to interpret -1 as an unsigned int - assuming a 4-byte size - the result will be something big, in this case 4294967295. -1 is represented as 111111111‚Äô111111111‚Äô111111111‚Äô111111111 in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1. But if 111111111'111111111'111111111'111111111 is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits. This also means that big enough unsigned numbers cannot be represented in 2‚Äôs complement form given that the size of the variable stays the same. It‚Äôs straightforward given that there is one bit reserved to store the sign of the stored number. This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other. To put in code the above, unless you use -Werror the below will compile. If you don‚Äôt use -Wextra or -Wsign-compare you won‚Äôt even get a warning. 1 2 3 4 5 6 7 8 9 int main() { static_assert(static_cast<unsigned int>(-1) > 42); constexpr int n = -1; constexpr size_t m = 42; static_assert(n > m); return 0; } The modern solution C++20 introduced the so-called ‚Äúintcmp‚Äù functions in the <utility> header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat -1 smaller than any non-negative number. First, let‚Äôs see what are the available functions and what are their meaning: Function Meaning std::cmp_equal(n, m) n == m std::cmp_not_equal(n, m) n != m std::cmp_less(n, m) n < m std::cmp_greater(n, m) n > m std::cmp_less_equal(n, m) n <= m std::cmp_greater_equal(n, m) n >= m This means that when reading out the function name the relation such as ‚Äúless‚Äù is always compared to the first first parameter. The first parameter is less than or greater than the second. While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough. Let me first put here the code and then let‚Äôs go through it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions */ template<class T, class U> constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v<T> == std::is_signed_v<U>) return t == u; else if constexpr (std::is_signed_v<T>) return t >= 0 && std::make_unsigned_t<T>(t) == u; else return u >= 0 && std::make_unsigned_t<U>(u) == t; } template<class T, class U> constexpr bool cmp_not_equal(T t, U u) noexcept { return !cmp_equal(t, u); } template<class T, class U> constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v<T> == std::is_signed_v<U>) return t < u; else if constexpr (std::is_signed_v<T>) return t < 0 || std::make_unsigned_t<T>(t) < u; else return u >= 0 && t < std::make_unsigned_t<U>(u); } template<class T, class U> constexpr bool cmp_greater(T t, U u) noexcept { return cmp_less(u, t); } template<class T, class U> constexpr bool cmp_less_equal(T t, U u) noexcept { return !cmp_less(u, t); } template<class T, class U> constexpr bool cmp_greater_equal(T t, U u) noexcept { return !cmp_less(t, u); } We only have to understand cmp_equal and cmp_less as the rest is implemented with the help of these two. cmp_equal Let‚Äôs repeat the reference implementation of cmp_equal: 1 2 3 4 5 6 7 8 9 10 template<class T, class U> constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v<T> == std::is_signed_v<U>) return t == u; else if constexpr (std::is_signed_v<T>) return t >= 0 && std::make_unsigned_t<T>(t) == u; else return u >= 0 && std::make_unsigned_t<U>(u) == t; } What we first see when we look at the function is that we use type traits to decide how to perform a comparison: if both numbers are signed or both are unsigned, then we simply check if they are equal or not if only the first parameter is a signed number then we check if it‚Äôs non-negative and by casting it to an unsigned type does that equal to the second value if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters. Let‚Äôs play with these a bit, what do they mean in practice? Let‚Äôs ignore the case when we pass two numbers with the same signedness. If we compare int{-5} and unsigned int{5}, we go to the second branch and we fail on the first condition as t is a negative number. What happens if we pass int{5} and unsigned int {5}. We go to the second branch and the first condition evaluates to true. If we cast int{5} to unsigned int, it will keep its value and we can safely check if they are equal. If we swap the two parameters, we could observe the same set of events. Let‚Äôs go to cmp_less, it‚Äôs probably more interesting. cmp_less Let‚Äôs put here the reference implementation as a reminder: 1 2 3 4 5 6 7 8 9 10 template<class T, class U> constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v<T> == std::is_signed_v<U>) return t < u; else if constexpr (std::is_signed_v<T>) return t < 0 || std::make_unsigned_t<T>(t) < u; else return u >= 0 && t < std::make_unsigned_t<U>(u); } Again, at first glance, we can see that we have three compile-time if branches based on the signedness of the two parameters. If both are signed or if both are unsigned, we do a simple comparison If only the first one is signed, we check whether it‚Äôs a negative number or(!) if we cast it to the unsigned version, is it smaller than u If only the second parameter is signed, then we check whether it‚Äôs positive and if it is, then we cast it to unsigned and check if it‚Äôs bigger than t This implementation is interesting because the second and third branches follow a different logic. Let‚Äôs go through them step by step. If we compare int{-5} and unsigned int{5}, we go to the second branch. t‚Äôs type is signed and its value is negative, so we know that it must be smaller than any u as it‚Äôs an unsigned value, it cannot be negative. We can stop there, we know that t < u. If we compare int{5} and unsigned int {5}, we still go to the second branch, but as t is non-negative, we can safely cast to its unsigned type and compare it to u. If we compare unsigned int{5} to int{-5}, we go to the third branch. We check if u is non-negative, but it‚Äôs not, so we can stop there because we know that t which is unsigned in that case, must be greater. If we compare unsigned int{5} and int {5}, we go again to the second branch. As u is positive, we can safely cast it to its unsigned type and compare it to t. This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it‚Äôs also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you‚Äôll make some mistakes so it‚Äôs better to use the standard version now that we have one. Conclusion In this article, we saw why it‚Äôs error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20‚Äôs intcmp utilities solve this issue and we also had a deep dive into the implementation of these new utility functions. Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I‚Äôll share with you what are the most common and most horrendous violations I‚Äôve seen so far while I was trying to remove such warnings over the last few years. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let‚Äôs connect on Twitter!",
    "Confidence": 0.9954241
  },
  {
    "Title": "When a 33% Success Rate Outperforms 99.999%",
    "Url": "https://shermanonsoftware.com/2023/10/12/when-a-33-success-rate-outperforms-99-999/",
    "Timestamp": "2023-10-13T22:03:51",
    "Domain": "shermanonsoftware.com",
    "Description": "",
    "Confidence": 0.8759421
  },
  {
    "Title": "Adventures in network repair ‚Äì JRS Systems: the blog",
    "Url": "https://jrs-s.net/2023/09/30/adventures-in-network-repair/",
    "Timestamp": "2023-10-13T22:03:51",
    "Domain": "jrs-s.net",
    "Description": "Recently, I acquired a new client with a massive load of technical debt (in other words: a new client). The facility internet connection appeared to go down for an hour or two every day, typically in the mid-afternoon.",
    "Confidence": 0.935137
  },
  {
    "Title": "Drivechains: A Detailed Analysis",
    "Url": "https://petertodd.org/2023/drivechains",
    "Timestamp": "2023-10-13T22:03:51",
    "Domain": "petertodd.org",
    "Description": "Drivechains is a controversial proposal aiming to allow for the creation ofsidechains containing coins meant to be pegged 1:1 to Bitcoin. Here we willanalyze...",
    "Confidence": 0.98314583
  },
  {
    "Title": "Fast(er) JavaScript on WebAssembly: Portable Baseline Interpreter and Future Plans",
    "Url": "https://cfallin.org/blog/2023/10/11/spidermonkey-pbl/",
    "Timestamp": "2023-10-13T22:03:50",
    "Domain": "cfallin.org",
    "Description": "For the past year, I have been hard at work trying to improve the\nperformance of the SpiderMonkey\nJavaScript engine when compiled as a\nWebAssembly module. For server-side\napplications that use WebAssembly (and WASI, its\n‚Äúsystem‚Äù layer) as a software distribution and sandboxing technology\nwith significant exciting\npotential,\nthis is an important enabling technology: it allows existing software\nwritten in JavaScript to be run within the sandboxed environment and\nto interact with other Wasm modules.",
    "Confidence": 0.9924757
  },
  {
    "Title": "overcoming the fear of forgetting what you read",
    "Url": "https://www.mahdikarimi.com/blog/being-afraid-about-losing-knowledge",
    "Timestamp": "2023-10-13T22:03:50",
    "Domain": "www.mahdikarimi.com",
    "Description": "‚ÄúI cannot remember the books I've read any more than the meals I have eaten; even so, they have made me.‚Äù -Ralph Waldo Emerson",
    "Confidence": 0.901398
  },
  {
    "Title": "On Organizing Bookmarks",
    "Url": "https://joshleeb.com/posts/organizing-bookmarks.html",
    "Timestamp": "2023-10-13T22:03:50",
    "Domain": "joshleeb.com",
    "Description": "Published on\n2023-10-11\nto joshleeb's blog",
    "Confidence": 0.960971
  },
  {
    "Title": "OpenAI-Specific Code Nixed from Semantic Kernel AI SDK -- Visual Studio Magazine",
    "Url": "https://visualstudiomagazine.com/articles/2023/10/13/semantic-kernel-beta.aspx",
    "Timestamp": "2023-10-13T21:02:40",
    "Domain": "visualstudiomagazine.com",
    "Description": "  Microsoft shipped the first beta of its Semantic Kernel SDK for AI development, in the process making it service-agnostic by removing OpenAI-specific code.\n",
    "Confidence": 0.7375442
  }
]