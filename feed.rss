<?xml version="1.0" encoding="utf-16"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <atom:link rel="self" type="application/rss+xml" href="https://linksfor.dev/" />
    <title>linksfor.dev(s)</title>
    <link>https://linksfor.dev/</link>
    <description>Curated links for devs</description>
    <language>en</language>
    <item>
      <title>Workplace advice for Programmers (Q&amp;amp;A)</title>
      <link>https://youtube.com/watch?v=2V5zRHSN5PE</link>
      <description>Advice for programmers on how to face problems in the workplace.The Clean Coder:Extreme Ownership: Jocko Podcast: Support my Work  &amp;#129309; https://www.patreon.com...</description>
      <author> (@sus-the-engineer
            
          
        
        
        
        1 hour ago)</author>
      <guid>https://youtube.com/watch?v=2V5zRHSN5PE</guid>
      <pubDate>Sun, 30 Jul 2023 13:03:22 GMT</pubDate>
    </item>
    <item>
      <title>The best 5&amp;#160;.NET and ASP.NET courses for eCommerce developers</title>
      <link>https://medium.com/@mwaseemzakir/the-best-5-net-and-asp-net-courses-for-ecommerce-developers-196be4ebd1fb</link>
      <description>To help eCommerce developers with their careers, we reviewed significant training courses and added free resources for ASP.NET development.</description>
      <author> (https://medium.com/@mwaseemzakir)</author>
      <guid>https://medium.com/@mwaseemzakir/the-best-5-net-and-asp-net-courses-for-ecommerce-developers-196be4ebd1fb</guid>
      <pubDate>Sun, 30 Jul 2023 12:02:27 GMT</pubDate>
    </item>
    <item>
      <title>Weird Things You Can Do In C#: True &amp;amp; False Operators #shorts</title>
      <link>https://youtube.com/watch?v=uuSOlTrFLrg</link>
      <description>&amp;#128640; Support me on Patreon to access the source code: https://www.patreon.com/milanjovanovicJoin my weekly .NET newsletter:https://www.milanjovanovic.techRead ...</description>
      <author> (Milan Jovanović
  
  
  
    Milan Jovanović
  






    •)</author>
      <guid>https://youtube.com/watch?v=uuSOlTrFLrg</guid>
      <pubDate>Sun, 30 Jul 2023 12:02:27 GMT</pubDate>
    </item>
    <item>
      <title>Libreboot – GNU Boot</title>
      <link>https://libreboot.org/news/gnuboot.html#gnu-boot-cease-and-desist-email</link>
      <description>Libreboot – GNU Boot</description>
      <author> (Leah Rowe)</author>
      <guid>https://libreboot.org/news/gnuboot.html#gnu-boot-cease-and-desist-email</guid>
      <pubDate>Sun, 30 Jul 2023 12:02:25 GMT</pubDate>
    </item>
    <item>
      <title>Functions are Vectors</title>
      <link>https://thenumb.at/Functions-are-Vectors/</link>
      <description>Conceptualizing functions as infinite-dimensional vectors lets us apply the tools of linear algebra to a vast landscape of new problems, from image and geometry processing to curve fitting, light transport, and machine learning.

Prerequisites: introductory linear algebra, introductory calculus, introductory differential equations.


  Functions as Vectors
    
      Vector Spaces
      Linear Operators
      Diagonalization
      Inner Product Spaces
      The Spectral Theorem
    
  
  Applications
    
      Fourier Series
      Image Compression
      Geometry Processing
      Further Reading
    
  




Functions as Vectors

Vectors are often first introduced as lists of real numbers—i.e. the familiar notation we use for points, directions, and more.



$$ \mathbf{v} = \begin{bmatrix}x\\y\\z\end{bmatrix} $$






You may recall that this representation is only one example of an abstract vector space.
There are many other types of vectors, such as lists of complex numbers, graph cycles, and even magic squares.

However, all of these vector spaces have one thing in common: a finite number of dimensions.
That is, each kind of vector can be represented as a collection of \(N\) numbers, though the definition of “number” varies.

If any \(N\)-dimensional vector is essentially a length-\(N\) list, we could also consider a vector to be a mapping from an index to a value.

\[\begin{align*}
\mathbf{v}_1 &amp;amp;= x\\
\mathbf{v}_2 &amp;amp;= y\\
\mathbf{v}_3 &amp;amp;= z
\end{align*}\ \iff\ \mathbf{v} = \begin{bmatrix}x \\ y \\ z\end{bmatrix}\]

What does this perspective hint at as we increase the number of dimensions?




    Dimensions
    




In higher dimensions, vectors start to look more like functions!

Countably Infinite Indices

Of course, a finite-length vector only specifies a value at a limited number of indices.
Could we instead define a vector that contains infinitely many values?

Writing down a vector representing a function on the natural numbers (\(\mathbb{N}\))—or any other countably infinite domain—is straightforward: just extend the list indefinitely.



$$ \begin{align*}\mathbf{v}_1 &amp;amp;= 1\\\mathbf{v}_2 &amp;amp;= 2\\ &amp;amp;\vdots \\ \mathbf{v}_i &amp;amp;= i\end{align*}\ \iff\ \mathbf{v} = \begin{bmatrix}1 \\ 2 \\ 3 \\ \vdots \end{bmatrix} $$






This vector could represent the function \(f(x) = x\), where \(x \in \mathbb{N}\).1

Uncountably Infinite Indices

Many interesting functions are defined on the real numbers (\(\mathbb{R}\)), so may not be representable as a countably infinite vector.
Therefore, we will have to make a larger conceptual leap: not only will our set of indices be infinite, it will be uncountably infinite.

That means we can’t write down vectors as lists at all—it is impossible to assign an integer index to each element of an uncountable set.
So, how can we write down a vector mapping a real index to a certain value?

Now, a vector really is just an arbitrary function:



$$ \mathbf{v}_{x} = x^2\ \iff\ \mathbf{v} = \begin{bmatrix} x \mapsto x^2 \end{bmatrix} $$






Precisely defining how and why we can represent functions as infinite-dimensional vectors is the purview of functional analysis.
In this post, we won’t attempt to prove our results in infinite dimensions: we will focus on building intuition via analogies to finite-dimensional linear algebra.



Vector Spaces


  Review: Abstract vector spaces | Chapter 16, Essence of linear algebra.


Formally, a vector space is defined by choosing a set of vectors \(\mathcal{V}\), a scalar field \(\mathbb{F}\), and a zero vector \(\mathbf{0}\).
The field \(\mathbb{F}\) is often the real numbers (\(\mathbb{R}\)), complex numbers (\(\mathbb{C}\)), or a finite field such as the integers modulo a prime (\(\mathbb{Z}_p\)).

Additionally, we must specify how to add two vectors and how to multiply a vector by a scalar.

\[\begin{align*}
(+)\ &amp;amp;:\ \mathcal{V}\times\mathcal{V}\mapsto\mathcal{V}\\
(\cdot)\ &amp;amp;:\ \mathbb{F}\times\mathcal{V} \mapsto \mathcal{V}
\end{align*}\]

To describe a vector space, our definitions must entail several vector space axioms.

A Functional Vector Space

In the following sections, we’ll work with the vector space of real functions.
To avoid ambiguity, square brackets are used to denote function application.


  The scalar field \(\mathbb{F}\) is the real numbers \(\mathbb{R}\).
  The set of vectors \(\mathcal{V}\) contains functions from \(\mathbb{R}\) to \(\mathbb{R}\).2
  \(\mathbf{0}\) is the zero function, i.e. \(\mathbf{0}[x] = 0\).


Adding functions corresponds to applying the functions separately and summing the results.


$$ (f + g)[x] = f[x] + g[x] $$






This definition generalizes the typical element-wise addition rule—it’s like adding the two values at each index.

\[f+g = \begin{bmatrix}f_1 + g_1 \\ f_2 + g_2 \\ \vdots \end{bmatrix}\]

Multiplying a function by a scalar corresponds to applying the function and scaling the result.



$$ (\alpha f)[x] = \alpha f[x] $$






This rule similarly generalizes element-wise multiplication—it’s like scaling the value at each index.

\[\alpha f = \begin{bmatrix}\alpha f_1 \\ \alpha f_2 \\ \vdots \end{bmatrix}\]

Proofs

Given these definitions, we can now prove all necessary vector space axioms.
We will illustrate the analog of each property in \(\mathbb{R}^2\), the familiar vector space of two-dimensional arrows.


  
    Vector Addition is Commutative
  
  
  
For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$:



$$\mathbf{u} + \mathbf{v} = \mathbf{v} + \mathbf{u}$$






Since real addition is commutative, this property follows directly from our definition of vector addition:

$$\begin{align*}
(f + g)[x] &amp;amp;= f[x] + g[x]\\
&amp;amp;= g[x] + f[x]\\
&amp;amp;= (g + f)[x]
\end{align*}$$
  
  



  
    Vector Addition is Associative
  
  
  
For all vectors $$\mathbf{u}, \mathbf{v}, \mathbf{w} \in \mathcal{V}$$:



$$(\mathbf{u} + \mathbf{v}) + \mathbf{w} = \mathbf{u} + (\mathbf{v} + \mathbf{w})$$






This property also follows from our definition of vector addition:

$$\begin{align*}
((f + g) + h)[x] &amp;amp;= (f + g)[x] + h[x]\\
&amp;amp;= f[x] + g[x] + h[x]\\
&amp;amp;= f[x] + (g[x] + h[x])\\
&amp;amp;= f[x] + (g + h)[x]\\
&amp;amp;= (f + (g + h))[x]
\end{align*}$$

  
  



  
    $$\mathbf{0}$$ is an Additive Identity
  
  
  
For all vectors $$\mathbf{u} \in \mathcal{V}$$:



$$\mathbf{0} + \mathbf{u} = \mathbf{u} $$






This one is easy:

$$\begin{align*}
(\mathbf{0} + f)[x] &amp;amp;= \mathbf{0}[x] + f[x]\\
&amp;amp;= 0 + f[x]\\
&amp;amp;= f[x]
\end{align*}$$

  
  



  
    Additive Inverses Exist
  
  
  
For all vectors $$\mathbf{u} \in \mathcal{V}$$, there exists a vector $$-\mathbf{u} \in \mathcal{V}$$ such that:



$$\mathbf{u} + (-\mathbf{u}) = \mathbf{0}$$






Negation is defined as applying $$f$$ and negating the result: $$(-f)[x] = -f[x]$$.
Clearly, $$-f$$ is also in $$\mathcal{V}$$.

$$\begin{align*}
(f + (-f))[x] &amp;amp;= f[x] + (-f)[x]\\
&amp;amp;= f[x] - f[x]\\
&amp;amp;= 0\\
&amp;amp;= \mathbf{0}[x]
\end{align*}$$

  
  



  
    $$1$$ is a Multiplicative Identity
  
  
  
For all vectors $$\mathbf{u} \in \mathcal{V}$$:



$$1\mathbf{u} = \mathbf{u}$$






Note that $$1$$ is specified by the choice of $$\mathbb{F}$$.
In our case, it is simply the real number $$1$$.

$$\begin{align*}
(1 f)[x] &amp;amp;= 1 f[x]\\
&amp;amp;= f[x]
\end{align*}$$

  
  



  
    Scalar Multiplication is Associative
  
  
  
For all vectors $$\mathbf{u} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$:



$$(\alpha \beta)\mathbf{u} = \alpha(\beta\mathbf{u})$$






This property follows from our definition of scalar multiplication:

$$\begin{align*}
((\alpha\beta) f)[x] &amp;amp;= (\alpha\beta)f[x]\\
&amp;amp;= \alpha(\beta f[x])\\
&amp;amp;= \alpha(\beta f)[x]
\end{align*}$$

  
  



  
    Scalar Multiplication Distributes Over Vector Addition
  
  
  
For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$ and scalars $$\alpha \in \mathbb{F}$$:



$$\alpha(\mathbf{u} + \mathbf{v}) = \alpha\mathbf{u} + \alpha\mathbf{v}$$






Again using our definitions of vector addition and scalar multiplication:

$$\begin{align*}
(\alpha (f + g))[x] &amp;amp;= \alpha(f + g)[x]\\
&amp;amp;= \alpha(f[x] + g[x])\\
&amp;amp;= \alpha f[x] + \alpha g[x]\\
&amp;amp;= (\alpha f)[x] + (\alpha g)[x]\\
&amp;amp;= (\alpha f + \alpha g)[x]
\end{align*}$$

  
  



  
    Scalar Multiplication Distributes Over Scalar Addition
  
  
  
For all vectors $$\mathbf{u} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$:



 $$(\alpha + \beta)\mathbf{u} = \alpha\mathbf{u} + \beta\mathbf{u}$$






Again using our definitions of vector addition and scalar multiplication:

$$\begin{align*}
((\alpha + \beta)f)[x] &amp;amp;= (\alpha + \beta)f[x]\\
&amp;amp;= \alpha f[x] + \beta f[x] \\
&amp;amp;= (\alpha f)[x] + (\beta f)[x]
\end{align*}$$

  
  


Therefore, we’ve built a vector space of functions!3
It may not be immediately obvious why this result is useful, but bear with us through a few more definitions—we will spend the rest of this post exploring powerful techniques arising from this perspective.

A Standard Basis for Functions


  Review: Linear combinations, span, and basis vectors | Chapter 2, Essence of linear algebra.


Unless specified otherwise, vectors are written down with respect to the standard basis.
In \(\mathbb{R}^2\), the standard basis consists of the two coordinate axes.



$$ \mathbf{e}_1 = \begin{bmatrix}1 \\ 0\end{bmatrix},\,\, \mathbf{e}_2 = \begin{bmatrix}0 \\ 1\end{bmatrix} $$






Hence, vector notation is shorthand for a linear combination of the standard basis vectors.



$$ \mathbf{u} = \begin{bmatrix}\alpha \\ \beta\end{bmatrix} = \alpha\mathbf{e}_1 + \beta\mathbf{e}_2 $$






Above, we represented functions as vectors by assuming each dimension of an infinite-length vector contains the function’s result for that index.
This construction points to a natural generalization of the standard basis.

Just like the coordinate axes, each standard basis function contains a \(1\) at one index and \(0\) everywhere else.
More precisely, for every \(\alpha \in \mathbb{R}\),


\[\mathbf{e}_\alpha[x] = \begin{cases} 1 &amp;amp; \text{if } x = \alpha \\ 0 &amp;amp; \text{otherwise} \end{cases}\]



We can then express any real function \(f\) as a linear combination of these basis functions:

\[\begin{align*} f[x] &amp;amp;= f[\alpha]\mathbf{e}_\alpha[x] \\ &amp;amp;= f[1]\mathbf{e}_1[x] + f[2]\mathbf{e}_2[x] + f[\pi]\mathbf{e}_\pi[x] + \dots \end{align*}\]

If you evaluate this sum at \(x\), you’ll find that all terms are zero—except \(\mathbf{e}_x\), making the result \(f[x]\).



Linear Operators


  Review: Change of basis | Chapter 13, Essence of linear algebra.


Now that we can manipulate functions as vectors, let’s start transferring the tools of linear algebra to the functional perspective.

One ubiquitous operation on finite-dimensional vectors is transforming them with matrices.
A matrix \(\mathbf{A}\) encodes a linear transformation, meaning multiplication preserves linear combinations.

\[\mathbf{A}(\alpha \mathbf{x} + \beta \mathbf{y}) = \alpha \mathbf{A}\mathbf{x} + \beta \mathbf{A}\mathbf{y}\]

Multiplying a vector by a matrix can be intuitively interpreted as defining a new set of coordinate axes from the matrix’s column vectors.
The result is a linear combination of the columns:






\[\mathbf{Ax} = \begin{bmatrix} \vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u} &amp;amp; \mathbf{v} &amp;amp; \mathbf{w} \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix} \begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix} = x_1\mathbf{u} + x_2\mathbf{v} + x_3\mathbf{w}\]

    


\[\begin{align*}
\mathbf{Ax} &amp;amp;= \begin{bmatrix} \vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u} &amp;amp; \mathbf{v} &amp;amp; \mathbf{w} \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix} \begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix} \\ &amp;amp;= x_1\mathbf{u} + x_2\mathbf{v} + x_3\mathbf{w}
\end{align*}\]

    







When all vectors can be expressed as a linear combination of \(\mathbf{u}\), \(\mathbf{v}\), and \(\mathbf{w}\), the columns form a basis for the underlying vector space.
Here, the matrix \(\mathbf{A}\) transforms a vector from the \(\mathbf{uvw}\) basis into the standard basis.

Since functions are vectors, we could imagine transforming a function by a matrix.
Such a matrix would be infinite-dimensional, so we will instead call it a linear operator and denote it with \(\mathcal{L}\).



\[\mathcal{L}f = \begin{bmatrix} \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \\ \mathbf{f} &amp;amp; \mathbf{g} &amp;amp; \mathbf{h} &amp;amp; \cdots \\ \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \end{bmatrix} \begin{bmatrix}f_1\\ f_2 \\ f_3\\ \vdots\end{bmatrix} = f_1\mathbf{f} + f_2\mathbf{g} + f_3\mathbf{h} + \cdots\]




\[\begin{align*}
\mathcal{L}f &amp;amp;= \begin{bmatrix} \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \\ \mathbf{f} &amp;amp; \mathbf{g} &amp;amp; \mathbf{h} &amp;amp; \cdots \\ \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \end{bmatrix} \begin{bmatrix}f_1\\ f_2\\ f_3 \\ \vdots\end{bmatrix} \\ &amp;amp;= f_1\mathbf{f} + f_2\mathbf{g} + f_3\mathbf{h} + \cdots
\end{align*}\]



This visualization isn’t very accurate—we’re dealing with uncountably infinite-dimensional vectors, so we can’t actually write out an operator in matrix form.
Nonetheless, the structure is suggestive: each “column” of the operator describes a new basis function for our functional vector space.
Just like we saw with finite-dimensional vectors, \(\mathcal{L}\) represents a change of basis.

Differentiation


  Review: Derivative formulas through geometry | Chapter 3, Essence of calculus.


So, what’s an example of a linear operator on functions?
You might recall that differentiation is linear:

\[\frac{\partial}{\partial x} \left(\alpha f[x] + \beta g[x]\right) = \alpha\frac{\partial f}{\partial x} + \beta\frac{\partial g}{\partial x}\]

It’s hard to visualize differentiation on general functions, but it’s feasible for the subspace of polynomials, \(\mathcal{P}\).
Let’s take a slight detour to examine this smaller space of functions.

\[\mathcal{P} = \{ p[x] = a + bx + cx^2 + dx^3 + \cdots \}\]

We typically write down polynomials as a sequence of powers, i.e. \(1, x, x^2, x^3\), etc.
All polynomials are linear combinations of the functions \(\mathbf{e}_i[x] = x^i\), so they constitute a countably infinite basis for \(\mathcal{P}\).4

This basis provides a convenient vector notation:



\[\begin{align*} p[x] &amp;amp;= a + bx + cx^2 + dx^3 + \cdots \\ &amp;amp;= a\mathbf{e}_0 + b\mathbf{e}_1 + c \mathbf{e}_2 + d\mathbf{e}_3 + \dots \end{align*}\ \iff\ \mathbf{p} = \begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix}\]




\[\begin{align*} p[x] &amp;amp;= a + bx + cx^2 + dx^3 + \cdots \\ &amp;amp;= a\mathbf{e}_0 + b\mathbf{e}_1 + c \mathbf{e}_2 + d\mathbf{e}_3 + \dots \\&amp;amp; \iff\ \mathbf{p} = \begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix} \end{align*}\]



Since differentiation is linear, we’re able to apply the rule \(\frac{\partial}{\partial x} x^n = nx^{n-1}\) to each term.



\[\begin{align*}\frac{\partial}{\partial x}p[x] &amp;amp;= \vphantom{\Bigg\vert}a\frac{\partial}{\partial x}1 + b\frac{\partial}{\partial x}x + c\frac{\partial}{\partial x}x^2 + d\frac{\partial}{\partial x}x^3 + \dots \\ &amp;amp;= b + 2cx + 3dx^2 + \cdots\\ &amp;amp;= b\mathbf{e}_0 + 2c\mathbf{e}_1 + 3d\mathbf{e}_2 + \dots\end{align*}  \ \iff\ \frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\]




\[\begin{align*}\frac{\partial}{\partial x}p[x] &amp;amp;= \vphantom{\Bigg\vert}a\frac{\partial}{\partial x}1 + b\frac{\partial}{\partial x}x + c\frac{\partial}{\partial x}x^2\, +\\ &amp;amp; \phantom{=} d\frac{\partial}{\partial x}x^3 + \dots \\ &amp;amp;= b + 2cx + 3dx^2 + \cdots\\ &amp;amp;= b\mathbf{e}_0 + 2c\mathbf{e}_1 + 3d\mathbf{e}_2 + \dots  \\ &amp;amp;\iff\ \frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\end{align*}\]



We’ve performed a linear transformation on the coefficients, so we can represent differentiation as a matrix!

\[\frac{\partial}{\partial x}\mathbf{p} = \begin{bmatrix}0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots\\ 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; \cdots\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; \cdots\\ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots \end{bmatrix}\begin{bmatrix}a\\ b\\ c\\ d\\ \vdots\end{bmatrix} = \begin{bmatrix}b\\ 2c\\ 3d\\ \vdots\end{bmatrix}\]

Each column of the differentiation operator is itself a polynomial, so this matrix represents a change of basis.

\[\frac{\partial}{\partial x} = \begin{bmatrix} \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \vert &amp;amp;  \\ 0 &amp;amp; 1 &amp;amp; 2x &amp;amp; 3x^2 &amp;amp; 4x^3 &amp;amp; \cdots \\ \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \vert &amp;amp; \vert &amp;amp;  \end{bmatrix}\]

As we can see, the differentiation operator simply maps each basis function to its derivative.

This result also applies to the larger space of analytic real functions, which includes polynomials, exponential functions, trigonometric functions, logarithms, and other familiar names.
By definition, an analytic function can be expressed as a Taylor series about \(0\):

\[f[x] = \sum_{n=0}^\infty \frac{f^{(n)}[0]}{n!}x^n = \sum_{n=0}^\infty \alpha_n x^n\]

Which is a linear combination of our polynomial basis functions.
That means a Taylor expansion is essentially a change of basis into the sequence of powers, where our differentiation operator is quite simple.5



Diagonalization


  Review: Eigenvectors and eigenvalues | Chapter 14, Essence of linear algebra.


Matrix decompositions are arguably the crowning achievement of linear algebra.
To get started, let’s review what diagonalization means for a \(3\times3\) real matrix \(\mathbf{A}\).

Eigenvectors

A vector \(\mathbf{u}\) is an eigenvector of the matrix \(\mathbf{A}\) when the following condition holds:



$$ \mathbf{Au} = \lambda \mathbf{u} $$






The eigenvalue \(\lambda\) may be computed by solving the characteristic polynomial of \(\mathbf{A}\).
Eigenvalues may be real or complex.

The matrix \(\mathbf{A}\) is diagonalizable when it admits three linearly independent eigenvectors, each with a corresponding real eigenvalue.
This set of eigenvectors constitutes an eigenbasis for the underlying vector space, indicating that we can express any vector \(\mathbf{x}\) via their linear combination.



$$ \mathbf{x} = \alpha\mathbf{u}_1 + \beta\mathbf{u}_2 + \gamma\mathbf{u}_3 $$






To multiply \(\mathbf{x}\) by \(\mathbf{A}\), we just have to scale each component by its corresponding eigenvalue.



$$ \begin{align*} \mathbf{Ax} &amp;amp;= \alpha\mathbf{A}\mathbf{u}_1 + \beta\mathbf{A}\mathbf{u}_2 + \gamma\mathbf{A}\mathbf{u}_3 \\
&amp;amp;= \alpha\lambda_1\mathbf{u}_1 + \beta\lambda_2\mathbf{u}_2 + \gamma\lambda_3\mathbf{u}_3 \end{align*} $$






Finally, re-combining the eigenvectors expresses the result in the standard basis.



Intuitively, we’ve shown that multiplying by \(\mathbf{A}\) is equivalent to a change of basis, a scaling, and a change back.
That means we can write \(\mathbf{A}\) as the product of an invertible matrix \(\mathbf{U}\) and a diagonal matrix \(\mathbf{\Lambda}\).



\[\begin{align*} \mathbf{A} &amp;amp;= \mathbf{U\Lambda U^{-1}} \\
 &amp;amp;= \begin{bmatrix}\vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u}_1 &amp;amp; \mathbf{u}_2 &amp;amp; \mathbf{u}_3 \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix}
 \begin{bmatrix}\lambda_1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; \lambda_2 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \lambda_3 \end{bmatrix}
 \begin{bmatrix}\vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u}_1 &amp;amp; \mathbf{u}_2 &amp;amp; \mathbf{u}_3 \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix}^{-1}
\end{align*}\]




\[\begin{align*} \mathbf{A} &amp;amp;= \mathbf{U\Lambda U^{-1}} \\
 &amp;amp;= \begin{bmatrix}\vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u}_1 &amp;amp; \mathbf{u}_2 &amp;amp; \mathbf{u}_3 \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix}
 \\ &amp;amp; \phantom{=} \begin{bmatrix}\lambda_1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; \lambda_2 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \lambda_3 \end{bmatrix}
 \\ &amp;amp; \phantom{=} \begin{bmatrix}\vert &amp;amp; \vert &amp;amp; \vert \\ \mathbf{u}_1 &amp;amp; \mathbf{u}_2 &amp;amp; \mathbf{u}_3 \\ \vert &amp;amp; \vert &amp;amp; \vert \end{bmatrix}^{-1}
\end{align*}\]



Note that \(\mathbf{U}\) is invertible because its columns (the eigenvectors) form a basis for \(\mathbb{R}^3\).
When multiplying by \(\mathbf{x}\), \(\mathbf{U}^{-1}\) converts \(\mathbf{x}\) to the eigenbasis, \(\mathbf{\Lambda}\) scales by the corresponding eigenvalues, and \(\mathbf{U}\) takes us back to the standard basis.

In the presence of complex eigenvalues, \(\mathbf{A}\) may still be diagonalizable if we allow \(\mathbf{U}\) and \(\mathbf{\Lambda}\) to include complex entires.
In this case, the decomposition as a whole still maps real vectors to real vectors, but the intermediate values become complex.

Eigenfunctions


  Review: What’s so special about Euler’s number e? | Chapter 5, Essence of calculus.


So, what does diagonalization mean in a vector space of functions?
Given a linear operator \(\mathcal{L}\), you might imagine a corresponding definition for eigenfunctions:

\[\mathcal{L}f = \psi f\]

The scalar \(\psi\) is again known as an eigenvalue.
Since \(\mathcal{L}\) is infinite-dimensional, it doesn’t have a characteristic polynomial—there’s not a straightforward method for computing \(\psi\).

Nevertheless, let’s attempt to diagonalize differentiation on analytic functions.
The first step is to find the eigenfunctions.
Start by applying the above condition to our differentiation operator in the power basis:

\[\begin{align*}
&amp;amp;&amp;amp; \frac{\partial}{\partial x}\mathbf{p} = \psi \mathbf{p} \vphantom{\Big|}&amp;amp; \\
&amp;amp;\iff&amp;amp; \begin{bmatrix}0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots\\ 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; \cdots\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 3 &amp;amp; \cdots\\ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots \end{bmatrix}\begin{bmatrix}p_0\\ p_1\\ p_2\\ p_3\\ \vdots\end{bmatrix}
&amp;amp;= \begin{bmatrix}\psi p_0\\ \psi p_1 \\ \psi p_2 \\ \psi p_3 \\ \vdots \end{bmatrix} \\
&amp;amp;\iff&amp;amp; \begin{cases} p_1 &amp;amp;= \psi p_0 \\ p_2 &amp;amp;= \frac{\psi}{2} p_1 \\ p_3 &amp;amp;= \frac{\psi}{3} p_2 \\ &amp;amp;\dots \end{cases} &amp;amp;
\end{align*}\]

This system of equations implies that all coefficients are determined solely by our choice of constants \(p_0\) and \(\psi\).
We can explicitly write down their relationship as \(p_i = \frac{\psi^i}{i!}p_0\).

Now, let’s see what this class of polynomials actually looks like.



\[p[x] = p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2 + p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots\]




\[\begin{align*}
p[x] &amp;amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2\, +\\ &amp;amp;\phantom{=} p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots
\end{align*}\]



Differentiation shows that this function is, in fact, an eigenfunction for the eigenvalue \(\psi\).



\[\begin{align*} \frac{\partial}{\partial x} p[x] &amp;amp;= 0 + p_0\psi + p_0 \psi^2 x + p_0\frac{\psi^3}{2}x^2 + p_0\frac{\psi^4}{6}x^3 + \dots \\
&amp;amp;= \psi p[x] \end{align*}\]




\[\begin{align*}
\frac{\partial}{\partial x} p[x] &amp;amp;= 0 + p_0\psi + p_0 \psi^2 x\, +\\ &amp;amp;\phantom{=} p_0\frac{\psi^3}{2}x^2 + p_0\frac{\psi^4}{6}x^3 + \dots \\
&amp;amp;= \psi p[x]
\end{align*}\]



With a bit of algebraic manipulation, the definition of \(e^{x}\) pops out:



\[\begin{align*} p[x] &amp;amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2 + p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots \\
&amp;amp;= p_0\left((\psi x) + \frac{1}{2!}(\psi x)^2 + \frac{1}{3!}(\psi x)^3 + \frac{1}{4!}(\psi x)^4 + \dots\right) \\
&amp;amp;= p_0 e^{\psi x} \end{align*}\]




\[\begin{align*}
p[x] &amp;amp;= p_0 + p_0\psi x + p_0\frac{\psi^2}{2}x^2\, +\\ &amp;amp;\phantom{=} p_0\frac{\psi^3}{6}x^3 + p_0\frac{\psi^4}{24}x^4 + \dots \\
&amp;amp;= p_0\Big((\psi x) + \frac{1}{2!}(\psi x)^2\, +\\ &amp;amp;\phantom{=p_0\Big((} \frac{1}{3!}(\psi x)^3 + \frac{1}{4!}(\psi x)^4 + \dots\Big) \\
&amp;amp;= p_0 e^{\psi x}
\end{align*}\]



Therefore, functions of the form \(p_0e^{\psi x}\) are eigenfunctions for the eigenvalue \(\psi\), including when \(\psi=0\).

Diagonalizing Differentiation

We’ve found the eigenfunctions of the derivative operator, but can we diagonalize it?
Ideally, we would express differentiation as the combination of an invertible operator \(\mathcal{L}\) and a diagonal operator \(\mathcal{D}\).



\[\begin{align*} \frac{\partial}{\partial x} &amp;amp;= \mathcal{L} \mathcal{D} \mathcal{L}^{-1}  \\
&amp;amp;=
\begin{bmatrix} \vert &amp;amp; \vert &amp;amp;  &amp;amp; \\ \alpha e^{\psi_1 x} &amp;amp; \beta e^{\psi_2 x} &amp;amp; \dots \\ \vert &amp;amp; \vert &amp;amp;  \end{bmatrix}
\begin{bmatrix} \psi_1 &amp;amp; 0 &amp;amp; \dots \\ 0 &amp;amp; \psi_2 &amp;amp; \dots \\ \vdots &amp;amp; \vdots &amp;amp; \ddots \end{bmatrix}
{\color{red} \begin{bmatrix} \vert &amp;amp; \vert &amp;amp;  &amp;amp; \\ \alpha e^{\psi_1 x} &amp;amp; \beta e^{\psi_2 x} &amp;amp; \dots \\ \vert &amp;amp; \vert &amp;amp;  \end{bmatrix}^{-1} }
\end{align*}\]




\[\begin{align*} \frac{\partial}{\partial x} &amp;amp;= \mathcal{L} \mathcal{D} \mathcal{L}^{-1}  \\
&amp;amp;=
\begin{bmatrix} \vert &amp;amp; \vert &amp;amp;  &amp;amp; \\ \alpha e^{\psi_1 x} &amp;amp; \beta e^{\psi_2 x} &amp;amp; \dots \\ \vert &amp;amp; \vert &amp;amp;  \end{bmatrix}
\\ &amp;amp; \phantom{=} \begin{bmatrix} \psi_1 &amp;amp; 0 &amp;amp; \dots \\ 0 &amp;amp; \psi_2 &amp;amp; \dots \\ \vdots &amp;amp; \vdots &amp;amp; \ddots \end{bmatrix}
\\ &amp;amp; \phantom{=} {\color{red} \begin{bmatrix} \vert &amp;amp; \vert &amp;amp;  &amp;amp; \\ \alpha e^{\psi_1 x} &amp;amp; \beta e^{\psi_2 x} &amp;amp; \dots \\ \vert &amp;amp; \vert &amp;amp;  \end{bmatrix}^{-1} }
\end{align*}\]



Diagonalization is only possible when our eigenfunctions form a basis.
This would be true if all analytic functions are expressible as a linear combination of exponentials.
However…


  
    Counterexample: $$f[x] = x$$
  
  
    
      First assume that \(f[x] = x\) can be represented as a linear combination of exponentials.
Since analytic functions have countably infinite dimensionality, we should only need a countably infinite sum:

\[f[x] = x = \sum_{n=0}^\infty \alpha_n e^{\psi_n x}\]

      Differentiating both sides:

\[\begin{align*} f^{\prime}[x] &amp;amp;= 1 = \sum_{n=0}^\infty \psi_n\alpha_n e^{\psi_n x} \\
 f^{\prime\prime}[x] &amp;amp;= 0 = \sum_{n=0}^\infty \psi_n^2\alpha_n e^{\psi_n x} \end{align*}\]

      Since \(e^{\psi_n x}\) and \(e^{\psi_m x}\) are linearly independent when \(n\neq m\), the final equation implies that all \(\alpha = 0\), except possibly the \(\alpha_\xi\) corresponding to \(\psi_\xi = 0\).
Therefore:

\[\begin{align*}
1 &amp;amp;= \sum_{n=0}^\infty \psi_n\alpha_n e^{\psi_n x}\\
&amp;amp;= \psi_\xi \alpha_\xi + \sum_{n\neq \xi} 0\psi_n e^{\psi_n x} \\
&amp;amp;= 0
\end{align*}\]

      That’s a contradiction—the linear combination representing \(f[x] = x\) does not exist.

      A similar argument shows that we can’t represent any non-constant function whose \(n\)th derivative is zero, nor periodic functions like sine and cosine.
    
  


Real exponentials don’t constitute a basis, so we cannot construct an invertible \(\mathcal{L}\).

The Laplace Transform

We previously mentioned that more matrices can be diagonalized if we allow the decomposition to contain complex numbers.
Analogously, more linear operators are diagonalizable in the larger vector space of functions from \(\mathbb{R}\) to \(\mathbb{C}\).

Differentiation works the same way in this space; we’ll still find that its eigenfunctions are exponential.

\[\frac{\partial}{\partial x} e^{(a+bi)x} = (a+bi)e^{(a+bi)x}\]

However, the new eigenfunctions have complex eigenvalues, so we still can’t diagonalize.
We’ll need to consider the still larger space of functions from \(\mathbb{C}\) to \(\mathbb{C}\).

\[\frac{\partial}{\partial x} : (\mathbb{C}\mapsto\mathbb{C}) \mapsto (\mathbb{C}\mapsto\mathbb{C})\]

In this space, differentiation can be diagonalized via the Laplace transform.
Although useful for solving differential equations, the Laplace transform is non-trivial to invert, so we won’t discuss it further.
In the following sections, we’ll delve into an operator that can be easily diagonalized in \(\mathbb{R}\mapsto\mathbb{C}\): the Laplacian.



Inner Product Spaces


  Review: Dot products and duality | Chapter 9, Essence of linear algebra.


Before we get to the spectral theorem, we’ll need to understand one more topic: inner products.
You’re likely already familiar with one example of an inner product—the Euclidean dot product.

\[\begin{bmatrix}x\\ y\\ z\end{bmatrix} \cdot \begin{bmatrix}a\\ b\\ c\end{bmatrix} = ax + by + cz\]

An inner product describes how to measure a vector along another vector.
For example, \(\mathbf{u}\cdot\mathbf{v}\) is proportional to the length of the projection of \(\mathbf{u}\) onto \(\mathbf{v}\).



$$ \mathbf{u} \cdot \mathbf{v} =\|\mathbf{u}\|\|\mathbf{v}\|\cos[\theta] $$






With a bit of trigonometry, we can show that the dot product is equivalent to multiplying the vectors’ lengths with the cosine of their angle.
This relationship suggests that the product of a vector with itself produces the square of its length.

\[\begin{align*} \mathbf{u}\cdot\mathbf{u} &amp;amp;= \|\mathbf{u}\|\|\mathbf{u}\|\cos[0] \\
&amp;amp;= \|\mathbf{u}\|^2
\end{align*}\]

Similarly, when two vectors form a right angle (are orthogonal), their dot product is zero.



$$ \begin{align*}  \mathbf{u} \cdot \mathbf{v} &amp;amp;= \|\mathbf{u}\|\|\mathbf{v}\|\cos[90^\circ] \\ &amp;amp;= 0 \end{align*} $$






Of course, the Euclidean dot product is only one example of an inner product.
In more general spaces, the inner product is denoted using angle brackets, such as \(\langle \mathbf{u}, \mathbf{v} \rangle\).


  The length (also known as the norm) of a vector is defined as \(\|\mathbf{u}\| = \sqrt{\langle \mathbf{u}, \mathbf{u} \rangle}\).
  Two vectors are orthogonal if their inner product is zero: \(\ \mathbf{u} \perp \mathbf{v}\ \iff\ \langle \mathbf{u}, \mathbf{v} \rangle = 0\).


A vector space augmented with an inner product is known as an inner product space.

A Functional Inner Product

We can’t directly apply the Euclidean dot product to our space of real functions, but its \(N\)-dimensional generalization is suggestive.

\[\begin{align*} \mathbf{u} \cdot \mathbf{v} &amp;amp;= u_1v_1 + u_2v_2 + \dots + u_Nv_N \\ &amp;amp;= \sum_{i=1}^N u_iv_i \end{align*}\]

Given countable indices, we simply match up the values, multiply them, and add the results.
When indices are uncountable, we can convert the discrete sum to its continuous analog: an integral!

\[\langle f, g \rangle = \int_a^b f[x]g[x] \, dx\]

When \(f\) and \(g\) are similar, multiplying them produces a larger function; when they’re different, they cancel out.
Integration measures their product over some domain to produce a scalar result.










Of course, not all functions can be integrated.
Our inner product space will only contain functions that are square integrable over the domain \([a, b]\), which may be \([-\infty, \infty]\).
Luckily, the important properties of our inner product do not depend on the choice of integration domain.

Proofs

Below, we’ll briefly cover functions from \(\mathbb{R}\) to \(\mathbb{C}\).
In this space, our intuitive notion of similarity still applies, but we’ll use a slightly more general inner product:

\[\langle f,g \rangle = \int_a^b f[x]\overline{g[x]}\, dx\]

Where \(\overline{x}\) denotes conjugation, i.e. \(\overline{a + bi} = a - bi\).

Like other vector space operations, an inner product must satisfy several axioms:


  
    Conjugate Symmetry
  
  
  
  For all vectors $$\mathbf{u}, \mathbf{v} \in \mathcal{V}$$:

  $$\langle \mathbf{u}, \mathbf{v} \rangle = \overline{\langle \mathbf{v}, \mathbf{u} \rangle}$$

  Conjugation may be taken outside the integral, making this one easy:

  $$\begin{align*} \langle f, g \rangle &amp;amp;= \int_a^b f[x]\overline{g[x]} \, dx \\
  &amp;amp;= \int_a^b \overline{g[x]\overline{f[x]}} \, dx \\
  &amp;amp;= \overline{\int_a^b g[x]\overline{f[x]} \, dx} \\
  &amp;amp;= \overline{\langle g, f \rangle}
  \end{align*}$$

  Note that we require conjugate symmetry because it implies $$\langle\mathbf{u}, \mathbf{u}\rangle = \overline{\langle\mathbf{u}, \mathbf{u}\rangle}$$, i.e. the inner product of a vector with itself is real.
  
  



  
    Linearity in the First Argument
  
  
  
  For all vectors $$\mathbf{u}, \mathbf{v}, \mathbf{w} \in \mathcal{V}$$ and scalars $$\alpha, \beta \in \mathbb{F}$$:

  $$\langle \alpha \mathbf{u} + \beta \mathbf{v}, \mathbf{w} \rangle = \alpha\langle \mathbf{u}, \mathbf{w} \rangle + \beta\langle \mathbf{v}, \mathbf{w} \rangle $$

  The proof follows from linearity of integration, as well as our vector space axioms:



\[\begin{align*} \langle \alpha f + \beta g, h \rangle &amp;amp;= \int_a^b (\alpha f + \beta g)[x]\overline{h[x]} \, dx \\
&amp;amp;= \int_a^b (\alpha f[x] + \beta g[x])\overline{h[x]} \, dx \\
&amp;amp;= \int_a^b \alpha f[x]\overline{h[x]} + \beta g[x]\overline{h[x]} \, dx \\
&amp;amp;= \alpha\int_a^b f[x]\overline{h[x]}\, dx + \beta\int_a^b g[x]\overline{h[x]} \, dx \\
&amp;amp;= \alpha\langle f, h \rangle + \beta\langle g, h \rangle
\end{align*}\]

      


\[\begin{align*} &amp;amp;\langle \alpha f + \beta g, h \rangle\\ &amp;amp;= \int_a^b (\alpha f + \beta g)[x]\overline{h[x]} \, dx \\
&amp;amp;= \int_a^b (\alpha f[x] + \beta g[x])\overline{h[x]} \, dx \\
&amp;amp;= \int_a^b \alpha f[x]\overline{h[x]} + \beta g[x]\overline{h[x]} \, dx \\
&amp;amp;= \alpha\int_a^b f[x]\overline{h[x]}\, dx\, +\\&amp;amp;\hphantom{==} \beta\int_a^b g[x]\overline{h[x]} \, dx \\
&amp;amp;= \alpha\langle f, h \rangle + \beta\langle g, h \rangle
\end{align*}\]

      

  Given conjugate symmetry, an inner product is also antilinear in the second argument.
  
  



  
    Positive-Definiteness
  
  
  
  For all $$\mathbf{u} \in \mathcal{V}$$:

  $$ \begin{cases} \langle \mathbf{u}, \mathbf{u} \rangle = 0 &amp;amp; \text{if } \mathbf{u} = \mathbf{0} \\ \langle \mathbf{u}, \mathbf{u} \rangle &amp;gt; 0 &amp;amp; \text{otherwise} \end{cases} $$

  By conjugate symmetry, we know $$\langle f, f \rangle$$ is real, so we can compare it with zero.
  
  However, rigorously proving this result requires measure-theoretic concepts beyond the scope of this post.
  In brief, we redefine $$\mathbf{0}$$ not as specifically $$\mathbf{0}[x] = 0$$, but as an equivalence class of functions that are zero </description>
      <author> (Max Slater)</author>
      <guid>https://thenumb.at/Functions-are-Vectors/</guid>
      <pubDate>Sun, 30 Jul 2023 11:03:15 GMT</pubDate>
    </item>
    <item>
      <title>How to benchmark different .NET versions</title>
      <link>https://steven-giesel.com/blogPost/59cfb6f8-8b87-4707-a99e-e372541b696a</link>
      <description>With the famous BenchmarkDotNet library you can benchmark a lot - but it doesn&amp;#39;t stop with a single .NET version. You can benchmark multiple versions of the same code that targets different runtimes!</description>
      <author> ()</author>
      <guid>https://steven-giesel.com/blogPost/59cfb6f8-8b87-4707-a99e-e372541b696a</guid>
      <pubDate>Sun, 30 Jul 2023 09:02:25 GMT</pubDate>
    </item>
    <item>
      <title>GitHub - AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI</title>
      <link>https://github.com/automatic1111/stable-diffusion-webui</link>
      <description>Stable Diffusion web UI. Contribute to AUTOMATIC1111/stable-diffusion-webui development by creating an account on GitHub.</description>
      <author> (AUTOMATIC1111)</author>
      <guid>https://github.com/automatic1111/stable-diffusion-webui</guid>
      <pubDate>Sun, 30 Jul 2023 06:03:22 GMT</pubDate>
    </item>
    <item>
      <title>Four ways to shoot yourself in the foot with Redis</title>
      <link>https://philbooth.me/blog/four-ways-to-shoot-yourself-in-the-foot-with-redis</link>
      <description>Production outages are great
at teaching you how not to cause production outages.
I&amp;#39;ve caused plenty and hope that by sharing them publicly,
it might help some people bypass part one
of the production outage learning syllabus.
Previously I discussed ways I&amp;#39;ve broken prod
with PostgreSQL
and with healthchecks.
Now I&amp;#39;ll show you how I&amp;#39;ve done it with Redis too.</description>
      <author> ()</author>
      <guid>https://philbooth.me/blog/four-ways-to-shoot-yourself-in-the-foot-with-redis</guid>
      <pubDate>Sun, 30 Jul 2023 06:03:21 GMT</pubDate>
    </item>
    <item>
      <title>How critical theory is radicalizing high school debate</title>
      <link>https://www.slowboring.com/p/how-critical-theory-is-radicalizing</link>
      <description>New rhetorical tactics are creating a generation of nihilists</description>
      <author> (Maya Bodnick)</author>
      <guid>https://www.slowboring.com/p/how-critical-theory-is-radicalizing</guid>
      <pubDate>Sun, 30 Jul 2023 05:05:31 GMT</pubDate>
    </item>
    <item>
      <title>Grand Kadooment 2023 - Biggest Carnival Event of Barbados</title>
      <link>https://www.visitbarbados.org/grand-kadooment</link>
      <description>Celebrate Grand Kadooment 2023 to experience the grand finale of the Crop Over festival. An event showcasing masquerade bands make their way to the Grynner Highway.</description>
      <author> ()</author>
      <guid>https://www.visitbarbados.org/grand-kadooment</guid>
      <pubDate>Sun, 30 Jul 2023 02:03:17 GMT</pubDate>
    </item>
    <item>
      <title>Error</title>
      <link>https://nt.vern.cc/cards/18ce54bi3fv/1rc3n</link>
      <description></description>
      <author> ()</author>
      <guid>https://nt.vern.cc/cards/18ce54bi3fv/1rc3n</guid>
      <pubDate>Sun, 30 Jul 2023 01:01:56 GMT</pubDate>
    </item>
    <item>
      <title>Codifying a ChatGPT workflow into a malleable GUI</title>
      <link>https://www.geoffreylitt.com/2023/07/25/building-personal-tools-on-the-fly-with-llms.html</link>
      <description>Wouldn&amp;#39;t it be neat if you could use LLMs to create little personal utility apps as the need arises? Here&amp;#39;s a story where I did just that...</description>
      <author> ()</author>
      <guid>https://www.geoffreylitt.com/2023/07/25/building-personal-tools-on-the-fly-with-llms.html</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:03 GMT</pubDate>
    </item>
    <item>
      <title>The transformer model, explained clearly - DeriveIt</title>
      <link>https://www.deriveit.org/notes/119</link>
      <description>In this note, we&amp;#39;ll come up with GPT and the TRANSFORMER architecture, from scratch.


</description>
      <author> ()</author>
      <guid>https://www.deriveit.org/notes/119</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:03 GMT</pubDate>
    </item>
    <item>
      <title>How to read inference rules</title>
      <link>https://cohost.org/prophet/post/2248211-how-to-read-inferenc</link>
      <description>The notation used is probably one of the largest barriers of entry to type inference papers, but it is rarely explained explicitly, so... I&amp;#39;m going to do just that!

For starters, inference rules are really nothing more than implications. The inference rule

AB(Name)

really just means &amp;quot;if A then B&amp;quot;. These are usually given a name (in this case, creatively, Name) to make it easier to refer to them in the rest of the paper.

Now, even though these are technically just implications, it&amp;#39;s usually not a great idea to read them from top to bottom. Inference rules denote relations, but it usually usually makes more sense to read them as (possibly non-deterministic) functions.
For example, a judgement for typing function application might look like this. (where Γ⊢e:τ means &amp;quot;In a context Γ, the type of an expression e is infered to τ&amp;quot;)

Γ⊢e1  :  τ1→τ2      Γ⊢e2  :  τ1Γ⊢e1(e2)  :  τ2(App)

Naively, one might read this as

&amp;gt; If e1 has type τ1→τ2 in a context Γ and e2 has type τ1 in Γ, then e1(e2) has type τ2 in Γ

but a much better way to read it, that is much closer to an actual implementation, would be

&amp;gt; In order to infer a type for e1(e2) in a context Γ, one first needs to infer a type for e1 with shape τ1→τ2 in Γ. Now e2 also needs to infer to type τ1 in Γ, so that the result (i.e. the type of e1(e2)) is τ2.

Read this way, the inference rule maps very closely onto an actual implementation! Seriously, compare the corresponding pseudocode to that second description

infer Γ (App e1 e2) =
    let (τ1 -&amp;gt; τ2) = infer Γ e1
    let τ3 = infer Γ e2
    unify τ1 τ3
    return τ2


The only major difference between this code (which skips error handling, just like inference rules) and the inference rule is that the fact that the type of e2 needs to be equal to τ1 is explicit in the code (unify τ1 τ3).

Reading off the algorithm like this is possible if the inference rules are syntax directed, i.e. if there is only ever a single rule that might match on a given expression. This is not always the case, so sometimes it&amp;#39;s better to imagine non-deterministically choosing the correct rule to apply, rather than just pattern matching.

And that&amp;#39;s... pretty much all you need to know to read inference rules!

There are a few common conventions in type systems that might be a bit surprising, so let&amp;#39;s go over those as well


ENVIRONMENTS AND EXTENSION

Type inference needs an environment to keep track of the types of variables. This is usually called Γ and extended as Γ,x  :  τ.

For example, this inference rule for (annotated) let bindings checks e2 under the environment Γ, extended with the binding x  :  τ1.

Γ⊢e1  :  τ1      Γ,x  :  τ1⊢e2  :  τ2Γ⊢let&amp;#160;x  :  τ1=e1&amp;#160;in&amp;#160;e2  :  τ2Let

Extracting information from the environment is achieved through &amp;quot;pattern matching&amp;quot; on the environment, for example in this inference rule for variables.

Γ,x  :  τ⊢x  :  τVar


UNIFICATION VARIABLES

Unification variables [https://cohost.org/prophet/post/2220730-if-there-is-one-piec] don&amp;#39;t exist in theoretical type systems, but they still map very directly onto a similar concept. Instead of generating a fresh unification variable, inference rules just &amp;quot;guess&amp;quot; a new type (they&amp;#39;re relations, remember?).

For example, this typing rule for (unannotated) lambdas just pulls the type τ out of thin air.

Γ,x  :  τ⊢e  :  τ1Γ⊢λx→e  :  τ→τ1Lambda


LISTS

Something you will see pretty often in papers by Simon Peyton Jones are lists that are represented by an overline. E.g. the syntax for uncurried function application might be e1(e‾), where e‾ consists of 0 or more expressions.


SKOLEMS

Similarly, skolems don&amp;#39;t exist as a separate concept. Instead, &amp;quot;unbound&amp;quot; type variables are treated as skolems, although these obviously cannot conflict with any other type variables in scope!
In an implementation, this would be achieved by generating a fresh skolem, but in inference rules, this is expressed by the side condition that the type variable should not occur &amp;quot;free in the environment&amp;quot;, written a∉ftv(Γ), where ftv denotes the set of free type variables (= skolems) in Γ.

For example, a rule for let bindings with polymorphic types (that need to be skolemized) might look like this

Γ⊢e1  :  τ1      a‾∉ftv(Γ)      Γ,x  :  ∀a‾.τ1⊢e2  :  τ2Γ⊢let&amp;#160;x  :  ∀a‾.τ1=e1&amp;#160;in&amp;#160;e2  :  τ2


WHERE TO GO FROM HERE

Great, with a little practice, you should be able to read inference rules now! I would recommend you read Practical type inference for higher rank types [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf], which is a great, relatively beginner friendly paper about type inference that even contains a full implementation at the end! (And despite the name, is not just about higher rank types).</description>
      <author> (https://cohost.org/prophet)</author>
      <guid>https://cohost.org/prophet/post/2248211-how-to-read-inferenc</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:02 GMT</pubDate>
    </item>
    <item>
      <title>Sampling at scale with OpenTelemetry</title>
      <link>https://www.gouthamve.dev/sampling-at-scale-with-opentelemetry/</link>
      <description>Thoughts on different sampling strategies at scale when using OpenTelemetry. With experience running tracing at scale at Grafana Labs.</description>
      <author> ()</author>
      <guid>https://www.gouthamve.dev/sampling-at-scale-with-opentelemetry/</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:02 GMT</pubDate>
    </item>
    <item>
      <title>Hamel’s Blog - Optimizing LLM latency</title>
      <link>https://hamel.dev/notes/llm/03_inference.html</link>
      <description>An exploration of inference tools for open source LLMs focused on latency.</description>
      <author> ()</author>
      <guid>https://hamel.dev/notes/llm/03_inference.html</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:02 GMT</pubDate>
    </item>
    <item>
      <title>Building a BitTorrent client in Elixir</title>
      <link>https://kochika.me/posts/torrent/</link>
      <description>
In this post, we delve headfirst into the BitTorrent protocol, understanding the process of downloading a torrent by building a minimal torrent client from scratch.</description>
      <author> (Mayank)</author>
      <guid>https://kochika.me/posts/torrent/</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:01 GMT</pubDate>
    </item>
    <item>
      <title>The Illustrated Transformer</title>
      <link>https://jalammar.github.io/illustrated-transformer/</link>
      <description>Discussions:
Hacker News (65 points, 4 comments), Reddit r/MachineLearning (29 points, 3 comments)


Translations: Arabic, Chinese (Simplified) 1, Chinese (Simplified) 2, French 1, French 2, Italian, Japanese, Korean, Persian, Russian, Spanish 1, Spanish 2, Vietnamese

Watch: MIT’s Deep Learning State of the Art lecture referencing this post

In the previous post, we looked at Attention – a ubiquitous method in modern deep learning models. Attention is a concept that helped improve the performance of neural machine translation applications. In this post, we will look at The Transformer – a model that uses attention to boost the speed with which these models can be trained. The Transformer outperforms the Google Neural Machine Translation model in specific tasks. The biggest benefit, however, comes from how The Transformer lends itself to parallelization. It is in fact Google Cloud’s recommendation to use The Transformer as a reference model to use their Cloud TPU offering. So let’s try to break the model apart and look at how it functions.

The Transformer was proposed in the paper Attention is All You Need. A TensorFlow implementation of it is available as a part of the Tensor2Tensor package. Harvard’s NLP group created a guide annotating the paper with PyTorch implementation. In this post, we will attempt to oversimplify things a bit and introduce the concepts one by one to hopefully make it easier to understand to people without in-depth knowledge of the subject matter.

2020 Update: I’ve created a “Narrated Transformer” video which is a gentler approach to the topic:




A High-Level Look
Let’s begin by looking at the model as a single black box. In a machine translation application, it would take a sentence in one language, and output its translation in another.


  


</description>
      <author> (Jay Alammar)</author>
      <guid>https://jalammar.github.io/illustrated-transformer/</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:01 GMT</pubDate>
    </item>
    <item>
      <title>GPT-4 Code Interpreter and Pillow</title>
      <link>https://metastable.org/pillow.html</link>
      <description>Getting ChatGPT to draw whether it wants to or not!</description>
      <author> (By Philip Winston |
		
		Thursday, July 27, 2023)</author>
      <guid>https://metastable.org/pillow.html</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:01 GMT</pubDate>
    </item>
    <item>
      <title>Digital Bum: Finding a Home/lessness on the Internet</title>
      <link>https://aartaka.me/blog/digital-bum</link>
      <description>Internet grew out of a non-commercial academic network with free resources for everyone. Can one get back to this dream of free Internet and build a lifestyle out of it? Well yeah I guess so, kinda worked for me.</description>
      <author> (Artyom Bologov)</author>
      <guid>https://aartaka.me/blog/digital-bum</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:01 GMT</pubDate>
    </item>
    <item>
      <title>Defcon: Preventing Overload with Graceful Feature Degradation</title>
      <link>https://www.micahlerner.com/2023/07/23/defcon-preventing-overload-with-graceful-feature-degradation.html</link>
      <description>Defcon: Preventing Overload with Graceful Feature Degradation</description>
      <author> ()</author>
      <guid>https://www.micahlerner.com/2023/07/23/defcon-preventing-overload-with-graceful-feature-degradation.html</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:01 GMT</pubDate>
    </item>
    <item>
      <title>LN 035: The Messy Desktop</title>
      <link>https://alexanderobenauer.com/labnotes/035/</link>
      <description>When I got to college, I learned a lot about computing fairly quickly, before I even stepped into my first computer science course.</description>
      <author> ()</author>
      <guid>https://alexanderobenauer.com/labnotes/035/</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:00 GMT</pubDate>
    </item>
    <item>
      <title>A Lock-Free Vector</title>
      <link>https://ibraheem.ca/posts/a-lock-free-vector/</link>
      <description>Designing a fast, lock-free vector.</description>
      <author> (Ibraheem Ahmed)</author>
      <guid>https://ibraheem.ca/posts/a-lock-free-vector/</guid>
      <pubDate>Sun, 30 Jul 2023 00:03:00 GMT</pubDate>
    </item>
    <item>
      <title>Git says I am adding &amp;#39;^M&amp;#39; but core.autocrlf is true</title>
      <link>https://stackoverflow.com/questions/34729978/git-says-i-am-adding-m-but-core-autocrlf-is-true</link>
      <description>The problem is simple enough. Git is saying I&amp;#39;ve added CR (^M) to a file,

me@myComp MINGW64 /c/workspace/service (develop)
$ git diff --check
engine/src/main/java/someFile.java:18: trailing whites...</description>
      <author> (Captain Man)</author>
      <guid>https://stackoverflow.com/questions/34729978/git-says-i-am-adding-m-but-core-autocrlf-is-true</guid>
      <pubDate>Sat, 29 Jul 2023 22:04:07 GMT</pubDate>
    </item>
    <item>
      <title>If We Want a Shift to Walking, We Need to Prioritize Dignity</title>
      <link>https://streets.mn/2023/07/19/if-we-want-a-shift-to-walking-we-need-to-prioritize-dignity/</link>
      <description>To make walking and rolling a desirable, everyday activity, we need facilities that are compliant, safe and dignified.</description>
      <author> (View all posts by Sean Hayford Oleary →)</author>
      <guid>https://streets.mn/2023/07/19/if-we-want-a-shift-to-walking-we-need-to-prioritize-dignity/</guid>
      <pubDate>Sat, 29 Jul 2023 21:03:30 GMT</pubDate>
    </item>
    <item>
      <title>So you want to build your own open source chatbot… – Mozilla Hacks - the Web developer blog</title>
      <link>https://hacks.mozilla.org/2023/07/so-you-want-to-build-your-own-open-source-chatbot/</link>
      <description>A small team within Mozilla’s innovation group recently undertook a hackathon to build a trustworthy internal chatbot prototype.</description>
      <author> (By
                                        Stephen Hood)</author>
      <guid>https://hacks.mozilla.org/2023/07/so-you-want-to-build-your-own-open-source-chatbot/</guid>
      <pubDate>Sat, 29 Jul 2023 21:03:30 GMT</pubDate>
    </item>
    <item>
      <title>A spectacular superconductor claim is making news. Here’s why experts are doubtful</title>
      <link>https://www.science.org/content/article/spectacular-superconductor-claim-making-news-here-s-why-experts-are-doubtful</link>
      <description>Skepticism abounds for claim that lead-based material perfectly conducts electricity at room temperature and pressure</description>
      <author> (Adrian Cho
			
				mail
			
		
	
		
			Author
		
	
		
			Staff Writer
		
		View more)</author>
      <guid>https://www.science.org/content/article/spectacular-superconductor-claim-making-news-here-s-why-experts-are-doubtful</guid>
      <pubDate>Sat, 29 Jul 2023 16:03:27 GMT</pubDate>
    </item>
  </channel>
</rss>