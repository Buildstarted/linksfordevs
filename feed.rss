<?xml version="1.0" encoding="utf-16"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <atom:link rel="self" type="application/rss+xml" href="https://linksfor.dev/" />
    <title>linksfor.dev(s)</title>
    <link>https://linksfor.dev/</link>
    <description>Curated links for devs</description>
    <language>en</language>
    <item>
      <title>Undermining Democracy: The European Commission&amp;#39;s Controversial Push for Digital Surveillance – Danny Mekić</title>
      <link>https://dannymekic.com/202310/undermining-democracy-the-european-commissions-controversial-push-for-digital-surveillance</link>
      <description>The European Commission wants to turn digital communication apps, such as WhatsApp, iMessage, Instagram, TikTok and X, into mass surveillance tools so that digital communications of all EU citizens, including their live conversations, photos and videos, can be automatically scanned for criminal offences.[1] Even of citizens who are not suspected of any crime. This proposal […]</description>
      <author> (Danny Mekić)</author>
      <guid>https://dannymekic.com/202310/undermining-democracy-the-european-commissions-controversial-push-for-digital-surveillance</guid>
      <pubDate>Sat, 14 Oct 2023 17:02:35 GMT</pubDate>
    </item>
    <item>
      <title>Can open source be saved from the EU&amp;#39;s Cyber Resilience Act?</title>
      <link>https://www.theregister.com/2023/10/13/can_open_source_be_saved/</link>
      <description>The road to Hell is paved with good intentions, and for open source this is a well meaning cluster fudge</description>
      <author> ()</author>
      <guid>https://www.theregister.com/2023/10/13/can_open_source_be_saved/</guid>
      <pubDate>Sat, 14 Oct 2023 16:04:04 GMT</pubDate>
    </item>
    <item>
      <title>ChatGPT-AutoExpert/System Prompts.md at main &amp;#183; spdustin/ChatGPT-AutoExpert</title>
      <link>https://github.com/spdustin/ChatGPT-AutoExpert/blob/main/System%20Prompts.md</link>
      <description>&amp;#128640;&amp;#129504;&amp;#128172; Supercharged Custom Instructions for ChatGPT (non-coding) and ChatGPT Advanced Data Analysis (coding).  - spdustin/ChatGPT-AutoExpert</description>
      <author> ()</author>
      <guid>https://github.com/spdustin/ChatGPT-AutoExpert/blob/main/System%20Prompts.md</guid>
      <pubDate>Sat, 14 Oct 2023 14:04:11 GMT</pubDate>
    </item>
    <item>
      <title>First Look at The Brand New Polly V8 API #shorts</title>
      <link>https://youtube.com/watch?v=OvSqmmJxFDM</link>
      <description>&amp;#128204; Check out my Pragmatic Clean Architecture course: https://bit.ly/3Zn41BK&amp;#128640; Support me on Patreon to access the source code: https://www.patreon.com/milanj...</description>
      <author> (Milan Jovanović
  
  
  
    Milan Jovanović
  






    •)</author>
      <guid>https://youtube.com/watch?v=OvSqmmJxFDM</guid>
      <pubDate>Sat, 14 Oct 2023 13:04:55 GMT</pubDate>
    </item>
    <item>
      <title>A bug in MySQL, or working as intended? You decide</title>
      <link>https://www.dolthub.com/blog/2023-10-13-fixing-mysql-bugs-in-dolt/</link>
      <description>Fixing a bug in Dolt that MySQL still has and will not fix</description>
      <author> (Zach Musgrave)</author>
      <guid>https://www.dolthub.com/blog/2023-10-13-fixing-mysql-bugs-in-dolt/</guid>
      <pubDate>Sat, 14 Oct 2023 13:04:54 GMT</pubDate>
    </item>
    <item>
      <title>How to cook ground meat perfectly every time! - The Blind Kitchen</title>
      <link>https://theblindkitchen.com/how-to-cook-ground-meat-perfectly-every-time/</link>
      <description>Cook ground meat perfectly using these steps to make sure it is not over or under done. Directions are accessible for vision impaired cooks.</description>
      <author> (Chef Debra Erickson)</author>
      <guid>https://theblindkitchen.com/how-to-cook-ground-meat-perfectly-every-time/</guid>
      <pubDate>Sat, 14 Oct 2023 11:02:27 GMT</pubDate>
    </item>
    <item>
      <title>GitHub - CherniakYura/tccurl: Implement include header files over https</title>
      <link>https://github.com/CherniakYura/tccurl</link>
      <description>Implement include header files over https. Contribute to CherniakYura/tccurl development by creating an account on GitHub.</description>
      <author> (CherniakYura)</author>
      <guid>https://github.com/CherniakYura/tccurl</guid>
      <pubDate>Sat, 14 Oct 2023 09:04:46 GMT</pubDate>
    </item>
    <item>
      <title>Beware: URLs are Pointers to Mutable Entities</title>
      <link>https://textslashplain.com/2023/10/13/beware-urls-are-pointers-to-mutable-entities/</link>
      <description>Folks often like to think of URLs as an entity that can be evaluated: “Is it harmless, or is it malicious?” In particular, vendors of security products tend to lump URLs in with other I…</description>
      <author> (Published by ericlaw)</author>
      <guid>https://textslashplain.com/2023/10/13/beware-urls-are-pointers-to-mutable-entities/</guid>
      <pubDate>Sat, 14 Oct 2023 06:02:28 GMT</pubDate>
    </item>
    <item>
      <title>Sign Combo</title>
      <link>https://xkcd.com/2841/</link>
      <description></description>
      <author> (About)</author>
      <guid>https://xkcd.com/2841/</guid>
      <pubDate>Sat, 14 Oct 2023 03:02:37 GMT</pubDate>
    </item>
    <item>
      <title>TimeGPT-1</title>
      <link>https://arxiv.org/abs/2310.03589</link>
      <description>In this paper, we introduce TimeGPT, the first foundation model for time series, capable of generating accurate predictions for diverse datasets not seen during training. We evaluate our pre-trained model against established statistical, machine learning, and deep learning methods, demonstrating that TimeGPT zero-shot inference excels in performance, efficiency, and simplicity. Our study provides compelling evidence that insights from other domains of artificial intelligence can be effectively applied to time series analysis. We conclude that large-scale time series models offer an exciting opportunity to democratize access to precise predictions and reduce uncertainty by leveraging the capabilities of contemporary advancements in deep learning.</description>
      <author> ([Submitted on 5 Oct 2023])</author>
      <guid>https://arxiv.org/abs/2310.03589</guid>
      <pubDate>Sat, 14 Oct 2023 02:02:35 GMT</pubDate>
    </item>
    <item>
      <title>Improving ASP.NET Core Dependency Injection With Scrutor</title>
      <link>https://www.milanjovanovic.tech/blog/improving-aspnetcore-dependency-injection-with-scrutor</link>
      <description>Dependency injection (DI) is one of the most exciting features of ASP.NET Core. It helps us build more testable and maintainable applications. However, ASP.NET Core&amp;#39;s built-in DI system sometimes needs a little help to achieve more advanced scenarios.
So I want to introduce you to a powerful library for enhancing your ASP.NET Core DI - Scrutor.</description>
      <author> (Milan Jovanović)</author>
      <guid>https://www.milanjovanovic.tech/blog/improving-aspnetcore-dependency-injection-with-scrutor</guid>
      <pubDate>Sat, 14 Oct 2023 01:04:19 GMT</pubDate>
    </item>
    <item>
      <title>Grants on the web</title>
      <link>https://gow.epsrc.ukri.org/NGBOViewGrant.aspx?GrantRef=EP%2FY022904%2F1</link>
      <description>Grants on the web</description>
      <author> (EPSRC author)</author>
      <guid>https://gow.epsrc.ukri.org/NGBOViewGrant.aspx?GrantRef=EP%2FY022904%2F1</guid>
      <pubDate>Sat, 14 Oct 2023 00:03:00 GMT</pubDate>
    </item>
    <item>
      <title>Mads Torgersen on C# 12</title>
      <link>https://jesseliberty.com/2023/10/13/mads-torgersen-on-c-12/</link>
      <description>Super excited and proud to have Mads (lead designer of C#) back to talk about C# 12</description>
      <author> (Posted on)</author>
      <guid>https://jesseliberty.com/2023/10/13/mads-torgersen-on-c-12/</guid>
      <pubDate>Fri, 13 Oct 2023 23:02:18 GMT</pubDate>
    </item>
    <item>
      <title>Reverse engineering SBF file format</title>
      <link>http://knmw.link/posts/dfbhd_sbf.html</link>
      <description>Describes the SBF assets used to store music in DFBHD</description>
      <author> ()</author>
      <guid>http://knmw.link/posts/dfbhd_sbf.html</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:52 GMT</pubDate>
    </item>
    <item>
      <title>brick</title>
      <link>https://meskhetian.com/brick/</link>
      <description>If your life is a wall, each day is a brick in that wall.
If your days are full of anxiety and stress, your wall will not look good when it&amp;#39;s complete</description>
      <author> ()</author>
      <guid>https://meskhetian.com/brick/</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:52 GMT</pubDate>
    </item>
    <item>
      <title>How to compare signed and unsigned integers in C++20?</title>
      <link>https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities</link>
      <description>Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you’ll spend quite some time scratching your head about what just happened. It’s also possible that it will not work according to your expectation but it will go unnoticed. Another option is that you get a compiler warning either by specifically turning on -Wsign-compare or -Wextra. If it’s combined with -Werror, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons. Let’s start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution. The problem of comparing a signed with an unsigned What are integral types in C++? There are quite a few of them: bool, char, char8_t, char16_t, char32_t, short, int, long, long long, and the unsigned versions of them. Let’s put aside that we can also cv qualify them and that there are a big bunch of implementation-defined types such as uint32_t et al. Even though these are all integrals, bool and char types are not meant to store numbers. We are limiting our focus to short, int, long, long long and their unsigned versions. If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a short and an unsigned short will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an unsigned short is from 0 to 2**16-1. The bitwise representations of -1 and 4294967295 are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on. On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two’s complement form. The most significant bit represents the sign (0 for positive, 1 for negative numbers) To convert a positive value to its negative counterpart, you invert all the bits and then add 1 But what does this mean in practice? If you try to interpret -1 as an unsigned int - assuming a 4-byte size - the result will be something big, in this case 4294967295. -1 is represented as 111111111’111111111’111111111’111111111 in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1. But if 111111111&amp;#39;111111111&amp;#39;111111111&amp;#39;111111111 is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits. This also means that big enough unsigned numbers cannot be represented in 2’s complement form given that the size of the variable stays the same. It’s straightforward given that there is one bit reserved to store the sign of the stored number. This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other. To put in code the above, unless you use -Werror the below will compile. If you don’t use -Wextra or -Wsign-compare you won’t even get a warning. 1 2 3 4 5 6 7 8 9 int main() { static_assert(static_cast&amp;lt;unsigned int&amp;gt;(-1) &amp;gt; 42); constexpr int n = -1; constexpr size_t m = 42; static_assert(n &amp;gt; m); return 0; } The modern solution C++20 introduced the so-called “intcmp” functions in the &amp;lt;utility&amp;gt; header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat -1 smaller than any non-negative number. First, let’s see what are the available functions and what are their meaning: Function Meaning std::cmp_equal(n, m) n == m std::cmp_not_equal(n, m) n != m std::cmp_less(n, m) n &amp;lt; m std::cmp_greater(n, m) n &amp;gt; m std::cmp_less_equal(n, m) n &amp;lt;= m std::cmp_greater_equal(n, m) n &amp;gt;= m This means that when reading out the function name the relation such as “less” is always compared to the first first parameter. The first parameter is less than or greater than the second. While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough. Let me first put here the code and then let’s go through it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions */ template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&amp;lt;T&amp;gt; == std::is_signed_v&amp;lt;U&amp;gt;) return t == u; else if constexpr (std::is_signed_v&amp;lt;T&amp;gt;) return t &amp;gt;= 0 &amp;amp;&amp;amp; std::make_unsigned_t&amp;lt;T&amp;gt;(t) == u; else return u &amp;gt;= 0 &amp;amp;&amp;amp; std::make_unsigned_t&amp;lt;U&amp;gt;(u) == t; } template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_not_equal(T t, U u) noexcept { return !cmp_equal(t, u); } template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&amp;lt;T&amp;gt; == std::is_signed_v&amp;lt;U&amp;gt;) return t &amp;lt; u; else if constexpr (std::is_signed_v&amp;lt;T&amp;gt;) return t &amp;lt; 0 || std::make_unsigned_t&amp;lt;T&amp;gt;(t) &amp;lt; u; else return u &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt; std::make_unsigned_t&amp;lt;U&amp;gt;(u); } template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_greater(T t, U u) noexcept { return cmp_less(u, t); } template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_less_equal(T t, U u) noexcept { return !cmp_less(u, t); } template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_greater_equal(T t, U u) noexcept { return !cmp_less(t, u); } We only have to understand cmp_equal and cmp_less as the rest is implemented with the help of these two. cmp_equal Let’s repeat the reference implementation of cmp_equal: 1 2 3 4 5 6 7 8 9 10 template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&amp;lt;T&amp;gt; == std::is_signed_v&amp;lt;U&amp;gt;) return t == u; else if constexpr (std::is_signed_v&amp;lt;T&amp;gt;) return t &amp;gt;= 0 &amp;amp;&amp;amp; std::make_unsigned_t&amp;lt;T&amp;gt;(t) == u; else return u &amp;gt;= 0 &amp;amp;&amp;amp; std::make_unsigned_t&amp;lt;U&amp;gt;(u) == t; } What we first see when we look at the function is that we use type traits to decide how to perform a comparison: if both numbers are signed or both are unsigned, then we simply check if they are equal or not if only the first parameter is a signed number then we check if it’s non-negative and by casting it to an unsigned type does that equal to the second value if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters. Let’s play with these a bit, what do they mean in practice? Let’s ignore the case when we pass two numbers with the same signedness. If we compare int{-5} and unsigned int{5}, we go to the second branch and we fail on the first condition as t is a negative number. What happens if we pass int{5} and unsigned int {5}. We go to the second branch and the first condition evaluates to true. If we cast int{5} to unsigned int, it will keep its value and we can safely check if they are equal. If we swap the two parameters, we could observe the same set of events. Let’s go to cmp_less, it’s probably more interesting. cmp_less Let’s put here the reference implementation as a reminder: 1 2 3 4 5 6 7 8 9 10 template&amp;lt;class T, class U&amp;gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&amp;lt;T&amp;gt; == std::is_signed_v&amp;lt;U&amp;gt;) return t &amp;lt; u; else if constexpr (std::is_signed_v&amp;lt;T&amp;gt;) return t &amp;lt; 0 || std::make_unsigned_t&amp;lt;T&amp;gt;(t) &amp;lt; u; else return u &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt; std::make_unsigned_t&amp;lt;U&amp;gt;(u); } Again, at first glance, we can see that we have three compile-time if branches based on the signedness of the two parameters. If both are signed or if both are unsigned, we do a simple comparison If only the first one is signed, we check whether it’s a negative number or(!) if we cast it to the unsigned version, is it smaller than u If only the second parameter is signed, then we check whether it’s positive and if it is, then we cast it to unsigned and check if it’s bigger than t This implementation is interesting because the second and third branches follow a different logic. Let’s go through them step by step. If we compare int{-5} and unsigned int{5}, we go to the second branch. t’s type is signed and its value is negative, so we know that it must be smaller than any u as it’s an unsigned value, it cannot be negative. We can stop there, we know that t &amp;lt; u. If we compare int{5} and unsigned int {5}, we still go to the second branch, but as t is non-negative, we can safely cast to its unsigned type and compare it to u. If we compare unsigned int{5} to int{-5}, we go to the third branch. We check if u is non-negative, but it’s not, so we can stop there because we know that t which is unsigned in that case, must be greater. If we compare unsigned int{5} and int {5}, we go again to the second branch. As u is positive, we can safely cast it to its unsigned type and compare it to t. This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it’s also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you’ll make some mistakes so it’s better to use the standard version now that we have one. Conclusion In this article, we saw why it’s error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20’s intcmp utilities solve this issue and we also had a deep dive into the implementation of these new utility functions. Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I’ll share with you what are the most common and most horrendous violations I’ve seen so far while I was trying to remove such warnings over the last few years. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!</description>
      <author> ()</author>
      <guid>https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:52 GMT</pubDate>
    </item>
    <item>
      <title>When a 33% Success Rate Outperforms 99.999%</title>
      <link>https://shermanonsoftware.com/2023/10/12/when-a-33-success-rate-outperforms-99-999/</link>
      <description></description>
      <author> (jeffpsherman)</author>
      <guid>https://shermanonsoftware.com/2023/10/12/when-a-33-success-rate-outperforms-99-999/</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:51 GMT</pubDate>
    </item>
    <item>
      <title>Adventures in network repair – JRS Systems: the blog</title>
      <link>https://jrs-s.net/2023/09/30/adventures-in-network-repair/</link>
      <description>Recently, I acquired a new client with a massive load of technical debt (in other words: a new client). The facility internet connection appeared to go down for an hour or two every day, typically in the mid-afternoon.</description>
      <author> (Published by)</author>
      <guid>https://jrs-s.net/2023/09/30/adventures-in-network-repair/</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:51 GMT</pubDate>
    </item>
    <item>
      <title>Drivechains: A Detailed Analysis</title>
      <link>https://petertodd.org/2023/drivechains</link>
      <description>Drivechains is a controversial proposal aiming to allow for the creation ofsidechains containing coins meant to be pegged 1:1 to Bitcoin. Here we willanalyze...</description>
      <author> ()</author>
      <guid>https://petertodd.org/2023/drivechains</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:51 GMT</pubDate>
    </item>
    <item>
      <title>Fast(er) JavaScript on WebAssembly: Portable Baseline Interpreter and Future Plans</title>
      <link>https://cfallin.org/blog/2023/10/11/spidermonkey-pbl/</link>
      <description>For the past year, I have been hard at work trying to improve the
performance of the SpiderMonkey
JavaScript engine when compiled as a
WebAssembly module. For server-side
applications that use WebAssembly (and WASI, its
“system” layer) as a software distribution and sandboxing technology
with significant exciting
potential,
this is an important enabling technology: it allows existing software
written in JavaScript to be run within the sandboxed environment and
to interact with other Wasm modules.</description>
      <author> ()</author>
      <guid>https://cfallin.org/blog/2023/10/11/spidermonkey-pbl/</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:50 GMT</pubDate>
    </item>
    <item>
      <title>overcoming the fear of forgetting what you read</title>
      <link>https://www.mahdikarimi.com/blog/being-afraid-about-losing-knowledge</link>
      <description>“I cannot remember the books I&amp;#39;ve read any more than the meals I have eaten; even so, they have made me.” -Ralph Waldo Emerson</description>
      <author> ()</author>
      <guid>https://www.mahdikarimi.com/blog/being-afraid-about-losing-knowledge</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:50 GMT</pubDate>
    </item>
    <item>
      <title>On Organizing Bookmarks</title>
      <link>https://joshleeb.com/posts/organizing-bookmarks.html</link>
      <description>Published on
2023-10-11
to joshleeb&amp;#39;s blog</description>
      <author> ()</author>
      <guid>https://joshleeb.com/posts/organizing-bookmarks.html</guid>
      <pubDate>Fri, 13 Oct 2023 22:03:50 GMT</pubDate>
    </item>
    <item>
      <title>OpenAI-Specific Code Nixed from Semantic Kernel AI SDK -- Visual Studio Magazine</title>
      <link>https://visualstudiomagazine.com/articles/2023/10/13/semantic-kernel-beta.aspx</link>
      <description>  Microsoft shipped the first beta of its Semantic Kernel SDK for AI development, in the process making it service-agnostic by removing OpenAI-specific code.
</description>
      <author> (By David Ramel10/13/2023)</author>
      <guid>https://visualstudiomagazine.com/articles/2023/10/13/semantic-kernel-beta.aspx</guid>
      <pubDate>Fri, 13 Oct 2023 21:02:40 GMT</pubDate>
    </item>
    <item>
      <title>.NET Framework October 2023 Security and Quality Rollup Updates - .NET Blog</title>
      <link>https://devblogs.microsoft.com/dotnet/dotnet-framework-october-2023-security-and-quality-rollup-updates/</link>
      <description>A recap of the latest Security and Quality Rollup for .NET Framework for October 2023.</description>
      <author> (Salini Agarwal)</author>
      <guid>https://devblogs.microsoft.com/dotnet/dotnet-framework-october-2023-security-and-quality-rollup-updates/</guid>
      <pubDate>Fri, 13 Oct 2023 19:02:24 GMT</pubDate>
    </item>
    <item>
      <title>The Interface of Kai Krause&amp;#39;s Software @mprove</title>
      <link>https://mprove.de/script/99/kai/</link>
      <description>mprove ideas + interaction + design</description>
      <author> ()</author>
      <guid>https://mprove.de/script/99/kai/</guid>
      <pubDate>Fri, 13 Oct 2023 18:04:01 GMT</pubDate>
    </item>
  </channel>
</rss>